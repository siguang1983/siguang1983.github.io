<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/金融类/">金融类</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/金融类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/金融/">金融</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="M0、M1、M2"><a href="#M0、M1、M2" class="headerlink" title="M0、M1、M2"></a>M0、M1、M2</h2><h2 id="什么是金融、金融体系"><a href="#什么是金融、金融体系" class="headerlink" title="什么是金融、金融体系"></a>什么是金融、金融体系</h2><h2 id="赤字"><a href="#赤字" class="headerlink" title="赤字"></a>赤字</h2><h2 id="金融危机和次贷危机"><a href="#金融危机和次贷危机" class="headerlink" title="金融危机和次贷危机"></a>金融危机和次贷危机</h2><pre><code>低利率照成所有人去银行进行贷款，然后使用杠杆

杠杆是用借贷来扩大交易收益的手段

杠杆的操作 - 例 A用1万美元买一个箱子，在以1.1万美元卖给B，在中间赚了1千美元，这属于正常操作，

        如果用杠杆就是 A有1万美元，又去借了99万美元，这样手里有100万美元，去买了100个箱子，赚取110万，还了99万借款和1万的利息，赚了9万美元

次贷危机 - 通过这种杠杆会使大面积的贷款短贷导金融系统破崩溃
</code></pre><h2 id="刚性兑付"><a href="#刚性兑付" class="headerlink" title="刚性兑付"></a>刚性兑付</h2><pre><code>就是投资、理财的项目，无论赔了赚了都有平台或银行兜底，打破刚性兑付就是将打掉这种模式，平台和银行不在兜底，赔与赚要看借款方的企业
</code></pre><h2 id="投资类型"><a href="#投资类型" class="headerlink" title="投资类型"></a>投资类型</h2><pre><code>股票

基金

p2p借贷

股权投资
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>只要政府低利率加上超发货币，资产一定会上涨
</code></pre><p><a href="https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=340s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=340s</a><br><a href="https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=342s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=342s</a></p>
<p><a href="https://www.youtube.com/watch?v=eY_Y_w_95JY&amp;list=PLuoaTfw_1lYwyxS-RQ7_Hwsd_gcAdVJtV" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eY_Y_w_95JY&amp;list=PLuoaTfw_1lYwyxS-RQ7_Hwsd_gcAdVJtV</a>  金融学</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/Linux命令/">Linux命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/Linux命令/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Linux/">Linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>[root@localhost~]  root 管理员    localhost 主机名    ~ 用户的目录 $ 为普通用户 # root用户

1、命令 [选项] [参数]        选项可简化  -a 等于 --all

2、Linux中 .xxx文件 是隐藏文件

3、命令补全: 输入一个开头字母，按Tab会将当前目录下所有的相关文件显示

4、sudo 使用超级使用者权限

nginx 目录: /usr/local/openresty/nginx 9092

启动 sudo /usr/local/openresty/nginx/sbin/nginx

重启 /usr/local/openresty/nginx/sbin/nginx -s reload
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>使用 SecureCRT 工具

1、exit 或 logout 退出登录

2、文件上传和下载 到服务器

    $ sz 要下载的文件或目录   在secureCRT中设置 options -&gt; session options -&gt; x/z/zmodem 中设置的下载目录 

    $ rz 上传的文件            上传相同名文件，不会被替换，不能上传目录，可以直接发压缩gzip包在传


3、查看日志  使用tail 或 cat来查看文件内容

    $ tail -fn  显示行数  服务器的日志文件

    tail -fn 100  /opt/server/apache-tomcat-6.0.41_8084/logs/catalina.2016-01-21.log    56服务器8084端口


4、解决secureCRT 中文编码问题

    options -&gt;    session options  -&gt; terminal 下的 appearance  将 character encodeing 改成 utf-8


5、清理服务器缓存

    进入到apache-tomcat服务中的works中清楚loaclhost目录 

    $ cd /opt/server/apache-tomcat-6.0.41_8084/works/Catalina

    $ rm -rf  localhost

    8084：网站  apache-tomcat-6.0.41_8084

    8086：H5   apache-tomcat-7.0.47_8086


6、open 打开目录

7、clear 清除当前屏    cmd+k 清除所有

8、tree 打印出目录树

    mac下没有tree命令  brew install tree  安装

    $ tree -a   显示所有的文件和目录

    $ tree -L 1 -a  只显示一个层级的目录和文件(包括隐藏文件)

    $ tree -L 1 -d
</code></pre><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><pre><code>Example: 

-rw-r--r--@   1 apple  staff   8196  5 15 19:26 .gitignore.js

一、第一个字符为文件类型 -

    剩下每三位一组

        rw- u所有者    r-- g所属组    r-- o其它人

    r 读        w 写        x 执行


一、文件类型

    1、- 文件    如果第一个符号为&apos;-&apos;就是一个普通文件

    2、d 目录 

    3、l 软链接文件
</code></pre><h4 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h4><pre><code>1、cd 切换到指定目录

    cd 与 cd ~  回到apple目录, 也就是 /Users/apple

    cd -   回到上次操作所在的目录

    cd ..  进入到上一级目录


2、mkdir [-p]  dirname 创建目录 

    -p 递归创建  mkdir -p parent/child    可以直接创建多个目录，如果不加就只能创建一个目录


3、pwd 显示当前路径

4、rm 删除文件或目录   rm -rf [文件或目录]

    -r  删除目录 如果删除目录必须要加 -r, 删除文件不需要

    -f  强制


5、cp 复制目录或文件   cp [选项][原文件或目录][目标目录]

    -r 复制目录

    -p 连带文件属性复制 一些类似文件创建日期等

    -d 如果源文件是链接文件，则复制链接属性

    -a 相当于 -pdr


6、mv 移动目录或文件    mv [源文件或目录] [目标目录]

    mv dir1 dir2 将文件或目录移动到指定目录中  

    mv a.js b.js 修改文件或目录名  


7、chown目录权限

    1、命令格式：

        chown [选项]... [所有者][:[组]] 文件...

    2．命令功能：

        通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。

    3．命令参数：

        必要参数:

        -c 显示更改的部分的信息

        -f 忽略错误信息

        -h 修复符号链接

        -R 处理指定目录以及其子目录下的所有文件

        -v 显示详细的处理信息

        -deference 作用于符号链接的指向，而不是链接文件本身

        选择参数:

        --reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组

        --from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变

        --help 显示帮助信息

        --version 显示版本信息

    4．使用实例：

        实例1：改变拥有者和群组

        命令：

        chown mail:mail log2012.log
</code></pre><h4 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h4><pre><code>1、touch .gitignore  创建文件

2、ls 显示文件

    # 显示详细列表
    $ ls -l  显示详细信息
    # 
    $ ll 是ls -l的简写
    # 
    $ ls -a 显示所有文件，包含隐藏文件（以. 起头的文件名）
    # 
    $ ls -R 显示文件及所有子目录
    $ 
    $ ls -F 显示文件（后跟*）和目录（后跟/）
    # 
    $ ls -d 与l选项合用，显示目录名而非其内容
    #
    $ ls -h 显示文件大小
    #
    $ ls -i 显示文件的id号    30988816 README.md


3、cat 显示文件内容

    cat package.json


4、echo 输出内容

5、ln 文件名   将文件的内容输出带行号

    $ ln package.json


6、wc 文件名  统计指定文件中的字节数、字数、行数，并将统计结果显示输出

    -c 统计字节数。

    -l 统计行数。

    -m 统计字符数。这个标志不能与 -c 标志一起使用。

    -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。

    -L 打印最长行的长度。
</code></pre><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><pre><code>一、find [搜索范围] [搜索条件]  避免大范围搜索，耗费系统资源

    通配符: * 匹配任意内容      ? 匹配任意一个字符      [] 匹配任意一个中括号内的字符

    按文件名搜索    $find / -name person.js     从根目录开始搜索person.js文件

    1、-name   搜索文件名   

    2、-iname  搜索的文件名不区分大小写

    3、-user   按所有者文件

    4、-nouser  没有所有者文件


    按时间搜索   $ find /var/log/ -mtime +10    搜索10天前修改的文件   +10 十天前     10 十天当天修改    -10  十天内修改文件

    5、-mtime  修改文件内容

    6、-atime  文件访问时间

    7、-ctime  改变文件属性


    按文件大小搜索   $ find . -size 25k  查找文件大小是25K的文件  -25k 小于25k   +25k 大于25k   25k 等于25k

        注意: M 是大写   k 用小写

    8、-size  查找文件大小

    9、-inum  通过 i 节点个数来查看   ls -i 查看当前目录下的文件带id   29560848 Bluetooth    31587257 opendirectoryd.log.0  31745680 system.log.4.gz

        find /var/log/ -inum  29560848   // 返回 Bluetooth

        逻辑运算符  -a 逻辑与    -o 逻辑或

        example   find /var/log -size +20K  -a  -size -50K    查找大于20K并小于50K

    10、-exec ... {} \;  将搜索的内容交给第二条命令来处理

         find /var/log -size +20k -a -size -500M  -exec ls -l -a {} \;


二、grep 在文件中匹配符合条件的字符串   grep [选项]  字符串   文件名

    -i 忽略大小写

    -v 排除指定字符串    

    $ grep -i 丝绸之路 package.json 


三、whereis 和 which  搜索系统命令

    whereis vim        // 输出 /usr/bin/vim 可以

    which 指令会在环境变量$PATH设置的目录里查找符合条件的文件。

        which mongod        // 返回当前mongod命令所在的目录 /usr/local/bin/mongod


四、locate 文件名   在后台数据库中按文件名搜索，搜索速度快

    locate不是在文件中搜索，而是在 /var/lib/mlocat 只在后台数据库搜索

    updatedb  更新数据库
</code></pre><h4 id="ln-链接命令-ln-s-原文件或目录-目录文件"><a href="#ln-链接命令-ln-s-原文件或目录-目录文件" class="headerlink" title="ln 链接命令   ln -s [原文件或目录] [目录文件]"></a>ln 链接命令   ln -s [原文件或目录] [目录文件]</h4><pre><code>硬链接: 硬链接看做是文件或目录的副本，两个i节点和存储，可以看成是同一个文件

软链接: 软连接看做是文件或目录的快捷方式

选项:

-s 创建软链接    

    注意软链接要写绝对路径 ln -s /Users/apple/siguang.liu/linux/catalogB   /Users/apple/siguang.liu/linux/lnDir

    appledeMacBook-Pro-2:lnDir apple$ ls -il
    31874703 lrwxr-xr-x  1 apple  staff  39  5 16 18:54 catalogB -&gt; /Users/apple/siguang.liu/linux/catalogB    这种 -&gt; 就是指的软链接 或者 lrwxr第一个类型为『l』

删除软连接就去目标目录直接把软链接的目录直接删掉
</code></pre><h4 id="压缩文件、目录"><a href="#压缩文件、目录" class="headerlink" title="压缩文件、目录"></a>压缩文件、目录</h4><pre><code>一、zip压缩文件、目录

    1、压缩文件     zip 压缩文件名  源文件        // 注意这里压缩zip，原文件不会被删除，而gzip会删除源文件

    2、压缩目录  zip -r 压缩文件名.zip   要压缩的目录       // 最好先进入要指定压缩的目录，如果写成a/b/c，这样就会将所有目录一层一层压缩，如果要压缩的目录在aa下面，而且你当前就在aa目录下面不用从指定根目录，否则解压后会一层一层的 

    3、解压缩    unzip 解压的文件


二、gzip压缩

    压缩后的扩展为 .gz  

    1、gzip 源文件      压缩为.gz文件，源文件会消失

    2、gzip -c 源文件 &gt; 压缩 文件     压缩为.gz文件，保留源文件

    3、gzip -r 目录     压缩目录下所有子文件，但不压缩目录

    2、gunzip             解压文件名


三、tar压缩目录

    通过tar来对目录进行打包，然后通过gzip进行压缩

    $ 格式: tar -cvf  打包文件名  源文件

    1、打包成 .tar文件

        1) tar -cvf  压缩后的目录  要压缩的目录 

        2) tar -xcvf  打包的文件名


    2、打包成 .tar.gz格式

        1) tar -zcvf  压缩后的目录  要压缩的目录 

        2) tar -zxcvf  打包的文件名

        -c: 产生.tar打包文件

        -v: 显示详细信息

        -f: 指定压缩后缀名

        -z: 打包同时压缩


    3、当包解压到当前目录

        tar zxf  nginx-1.12.2.tar.gz
</code></pre><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><pre><code>所有程序只要运行就会产生一个进程，客户端网页访问服务器就会产生一个进程

一、查看进程

    1、ps aux  系统所有进程

        ps -ef|grep nginx 查看nginx服务的进程

            a 显示所有进程，包括会话引线

            u 显示进程的归属用户及内存使用情况

            x 显示没有控制终端进程

            -l 长格式显示 显示更详细信息

            -e 显示所有进程，和-A作用一致

    2、pstree [选项]

        -p 显示进程PID

        -u 显示进程用户

    3、top  每3秒查看一下系统的健康，有cpu和内存的数据和所有进程


二、杀死进程

    kill -1 进程ID    重启进程

    kill -9 进程ID    强制杀死进程
</code></pre><h4 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h4><pre><code>https://www.cnblogs.com/duhuo/p/5695256.html
</code></pre><h4 id="环境变量和host的修改"><a href="#环境变量和host的修改" class="headerlink" title="环境变量和host的修改"></a>环境变量和host的修改</h4><pre><code>一、host目录

    etc/hosts

二、环境变量、export 设置或显示环境变量  export [-fnp][变量名称]=[变量设置值]

    -f 　代表[变量名称]中为函数名称。 

    -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 

    -p 　列出所有的shell赋予程序的环境变量。


    $ export   查看环境变量


    设置环境变量有两种: 

        1、使用export命令 这种方法只是临时设置，重启终端就

            $ export PATH=$PATH:/opt/au1200_rm/build_tools/bin

        2、修改profile文件 或者设置到 source ~/.bash_profile 

            $ vi ~/.profile

              export PATH=$PATH:/usr/local/zend/mysql/bin/:/usr/local/zend/bin     // 设置$PATH 扩展一下加一下

            $ source ~/.profile    立即执行

    注意两个环境变量使用 “：”来分割


三、通过环境变量来设置命令快捷键

    $ vi ~/.profile

        alias ll=&quot;ls -a&quot;
        alias ..=&quot;cd ..&quot;
        alias ...=&quot;cd ../../&quot;
        alias ....=&quot;cd ../../../&quot;
        alias .....=&quot;cd ../../../../&quot;
        alias ......=&quot;cd ../../../../../&quot;
</code></pre><h4 id="man-–help-帮助"><a href="#man-–help-帮助" class="headerlink" title="man  –help  帮助"></a>man  –help  帮助</h4><pre><code>一、man ls  查看帮助信息

二、ls --help   
</code></pre><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><pre><code>一、日期

    date 日期时间

    cal  显示当前日历

二、关机重启系统

    1、shutdown [选项] 时间   来进行重启和关机

        shutdown -r now    立即重启  -h 立即关机

        shutdown -r 18:00  定时在18点的时候重启

        -c: 取消前一个关机命令

        -h: 关机

        -r: 重启

    2、halt  回车  直接关机

    3、poweroff  回车  直接关机

    4、init 0 回车  直接关机

    5、reboot 回车  直接重启

三、查询与自动挂载

    1、mount
</code></pre><h4 id="linux根目录"><a href="#linux根目录" class="headerlink" title="linux根目录"></a>linux根目录</h4><pre><code>Linux的目录

    根目录下的 bin目录不允许操作， usr下的 sbin目录是可以操作的

    /bin 传统unix命令的存放目录，如ls，rm，mv等。
    /sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。
    /tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。
    /usr 第三方程序安装目录。
        /usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）.
    /etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。        
    /var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。


OS X系统中，除了标准的unix目录外，还增加了特有的目录。

    /Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；
    /Library 系统的数据文件、帮助文件、文档等等；
    /Network 网络节点存放目录；
    /System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。
    /Users 存放用户的个人资料和配置。每个用户有自己的单独目录。
    /Volumes 文件系统挂载点存放目录。
    /cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。
    /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。


/bin是系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。

/sbin一般是指超级用户指令。主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。

/usr/bin　是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等。

/usr/sbin   放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。

/usr/bin用于分发包管理器（如Ubuntu apt等）存放它所管理的应用的路径, /usr/sbin与/usr/bin的关系类似与/bin和/sbin的关系

/usr/local/bin用于存放用户自己的程序（如自己编译出来的包等），不受分发包管理器的控制。如果用户把自己的程序放在/usr/bin下，则有可能在未来被包管理器给修改或删除了。
</code></pre><h4 id="vim-编辑器"><a href="#vim-编辑器" class="headerlink" title="vim 编辑器"></a>vim 编辑器</h4><pre><code>vi  文件名    或vim 文件名

命令状态：

H 左  L 右   K 上  J 下

0（零） 行首     $（shift+5） 行尾       G（shift+G） 文件尾

i 插入命令

dd  删除当前行    pp 复制并粘贴当前行    x: 删除光标处字符

control+f 后翻页        control+b前翻页

u 取消上次操作)


a,A:追加命令，a 在当前光标后追加，A 在行末追加

o,O:打开命令，o 在当前行下打开一行，O在当前行上插入一行

r,R :替换命令，r 替换当前光标处字符，R从光标处开始替换

数字s: 替换指定数量字符

d0: 删除光标前半行

d$: 删除光标后半行

/string 查找字符串

n 继续查找

N 反向继续查找

% 查找对应括号

ex命令状态

    ：0 文件首

    ：1,5 copy 7 块拷贝

    ：1，5 del 块删除

    ：1，5 move 7 块移动

    ：1，$s/string1/string2/g 全文件查找string1并替换为string2

    ：wq! 存盘退出

保存命令

    按ESC键 跳到命令模式，然后：

    :w   保存文件但不退出vi

    :w file 将修改另外保存到file中，不退出vi

    :w!  强制保存，不推出vi

    :wq  保存文件并退出vi

    :wq! 强制保存文件，并退出vi

    q:   不保存文件，退出vi

    :q!  不保存文件，强制退出vi

    :e!  放弃所有修改，从上次保存文件开始再编辑
</code></pre><h4 id="Mac终端下的快捷键"><a href="#Mac终端下的快捷键" class="headerlink" title="Mac终端下的快捷键"></a>Mac终端下的快捷键</h4><pre><code>cmd + A 移到行首
cmd + E 移到行尾

cmd + L 清除上一次操作的内容
cmd + K 清除所有内容

cmd + option + H 将所有窗口隐藏到应用程序图标
cmd + H  将当前窗口隐藏到图标中
cmd + M  将当前窗口最小化到

control + U 清除当前行命令

cmd + shift + .  显示/隐藏当前文件的隐藏文件

traceroute -n 125.35.51.162        // 查看当前网络访问到这个ip都通过哪些途径

mac 打开iphone界面  iphone与mac连接，打开QuickTime，文件 -&gt; 新建录制影片
</code></pre><p>| <a href="http://www.cnblogs.com/webzhangnan/p/3221410.html" target="_blank" rel="noopener">http://www.cnblogs.com/webzhangnan/p/3221410.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/JS作用域和整理经验/">JS作用域和整理经验</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/JS作用域和整理经验/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><pre><code>一、示例

    console.log(str);        // 输出undefined  因为读取的是解析器预先存储的str，还没有被赋值
    var str = 1;         


二、示例2

    alert(a);        // 弹出的是function a(){ alert(&quot;2&quot;)}
    var a = 1;
    function a(){
        alert(&quot;2&quot;)
    }

    预解析会保存a = undefinded，和 a = function a(){alert(&quot;2&quot;)}，
    因为函数与变量重名，函数后最执行所以保留函数，结果输出的就是函数


三、示例3

    var a = 1;
    function a(){
        alert(&quot;2&quot;);
    }

    // 报错，因为a被定义成变量，typeof a 返回的是number，如果 var a;不能定义值那么a()是成功的
    a();


四、示例4

    var a = 1;
    function fn1(){
        alert(a);
        // 注意这里因为是使用var声明所以执行数预解析器才会把它单独存储起来，
        // 如果将var去掉，a=2改成了赋值这样会改变外部的a的值，下面输出的就是1，2
        var a = 2;
    }

    fn1();                        // undefined
    console.log(a);        // 1


五、示例5

    function foo(){
        return fn1;

        function fn1(){};
        var fn1 = 10;
    }

    var f = foo();

    // 输出 function fn1(){};    因为调用foo函数时，return  fn1因为变量还未定义所以 直接调用的函数
    alert(f);                


六、示例6

    var  myname = &quot;global&quot;; // 全局变量
    function func() {

        // &quot;undefined&quot;，如果函数内不在定义myname就会找全局的变量，但函数本身已经定义了，预编译会先将变量定义成undefined
        alert(myname);                 
        var myname = &quot;local&quot;;
        alert(myname);                 // &quot;local&quot;
    }
    func();


七、示例7

    &lt;script&gt;
        window.name = &apos;globalName&apos;;

        var getName = function(){
            return this.name;
        }

        getName();         // &apos;globalName&apos;
    &lt;/script&gt;


八、示例8

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var callback = function(){
                return this.id;        // divA
            }
            callback();            // window
        }
    &lt;/script&gt;


 九、示例9

    1、Example
        var getName;
        console.log(getName)    // undefined

        getName()                // Uncaught TypeError: getName is not a function

        var getName = function() {
            console.log(&apos;wscat&apos;)
        }

    2、Example
        var getName;
        console.log(getName)    // function getName() {console.log(&apos;oaoafly&apos;)}

        getName()                // oaoafly

        function getName() {
            console.log(&apos;oaoafly&apos;)
        }


十、bind()

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var obj = {
                id: &apos;objId&apos;,
                callback: function(){
                    return this.id;         // &apos;divA&apos;
                }.bind(window)                // 通过bind来将callback内的this指向window
            }

            console.log(obj.callback());    // &apos;window&apos;
        }
    &lt;/script&gt;


十一、严格模式下的this

    &lt;script&gt;
        &apos;use strict&apos;

        function fun(){
            alert(this);        // 返回 &apos;undefined&apos;, strict模式下this不会指向全局
        }

        fun();
    &lt;/script&gt;


十二、箭头函数下的this指向

    // 箭头函数没有this
    const Template = {
        test(){
            console.log(this);        // this指向Template

            document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                // 如果非箭头函数this应该指向 #showThis
                // 这里箭头函数不是指向调用者，所以指向了 Template
                console.log(this);    
            }
        }
    }

    Template.test();
</code></pre><h3 id="JS作用域和常用方法"><a href="#JS作用域和常用方法" class="headerlink" title="JS作用域和常用方法"></a>JS作用域和常用方法</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code>1、函数本身是对象也是构造函数

2、直接挂载到函数下的叫对象的属性和方法

    function Foo(){};  

    Foo.username = &apos;111&apos;;     // 注意这里Foo的属性不能为name因为被name被函数的名所占用
    Foo.getName = function(){ console.log(this.username) };

    // 调用
    Foo.getName();        // 111


3、写到构造函数内部的叫构造函数的属性和方法

    function Foo() {
        this.username = &apos;111&apos;
    }

    Foo.username = &apos;222&apos;;

    // 调用
    console.log(new Foo().username);    // 111


&lt;script&gt;
    function Foo() {
        getName = function() {
            console.log(this);
            console.log(1);
        }

        console.log(this);
        return this;
    }
    Foo.getName = function() { // 这里只是Foo对象的方法，而不是构造函数的方法，
        console.log(2);
    }

    // Foo.prototype.getName = function() {
    //     console.log(3);
    // }

    var getName = function() {
        console.log(4)
    }

    function getName() {
        console.log(5)
    }


    Foo.getName(); // 2    Foo.getName=function(){}  是存到Foo下的方法，Foo.getName()可以取到

    getName(); // 4     如果一个作用域下有var的变量名与函数名相当，var的作用域提升高于function

    Foo().getName(); // 1    因为Foo()被调用，定义中加了return this，Foo指向的是window全局，getName没有var升明，所以为全局，所以相当于window.getName()，Foo中如果不加return this那么就会报错，因为Foo没有链式调用，所以this断了

    getName(); // 1   因为上面已经将Foo内的getName()提升成全局，所以会赋盖掉var getName、function getName定义的全局方法

    // var ofo = new Foo;
    // ofo.getName();   // 3



    // Foo既是一个对象也是一个构造函数

    new Foo.getName(); // 2    先执行Foo.getName()，因为&quot;.&quot;运算符优先于new运算符，所以这时候Foo只是一个对象并不是构造函数的实例，所以会调用对象下的方法

    new Foo().getName(); // 3     先执行new Foo()构造函数，然后在构造函数下去找getName方法，Foo构造函数方法没有getName()所以到prototype下去找

    new new Foo().getName(); // 3   与上面相同
&lt;/script&gt;
</code></pre><h4 id="将对象拷贝并不引用指针"><a href="#将对象拷贝并不引用指针" class="headerlink" title="将对象拷贝并不引用指针"></a>将对象拷贝并不引用指针</h4><pre><code>有两种方法，一是使用for...in将一个对象拷贝到另一个对象

另一种方法是使用Object.assign()

let objA = {
    name: &apos;siguang&apos;,
    age: 30
}
let objB = Object.assign({}, objA);
objB.name = &apos;lulu&apos;;         // lulu
console.log(objA.name);     // siguang
</code></pre><h4 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h4><pre><code>浅拷贝就是还存在对象的引用关系，深拷贝就是两个对象之间没有引用关系

一、浅拷贝

    const a = {t: 1, p: &apos;gg&apos;};
    const b = a;
    b.t = 3;
    console.log(a);     // {t: 3, p: &apos;gg&apos;}
    console.log(b);     // {t: 3, p: &apos;gg&apos;}

二 、深拷贝

    1、Object.assign()

        assign()方法是将两个对象合并，并返回一个新对象

        const c = {t: 1, p: &apos;gg&apos;};
        const d = Object.assign({}, c);
        d.t = 3;
        console.log(c);     // {t: 1, p: &apos;gg&apos;}
        console.log(d);     // {t: 3, p: &apos;gg&apos;}

    2、Object.create()

        将拷贝的内容入到prototype下，对象和数组都适用

        对象:

            var oA = {
                name: &apos;sg&apos;,
                age: 33
            }
            var oB = {};
            oB = Object.create(oA);

            oB.eat = &apos;bread&apos;;

        数组:

            var oA = [1,2]
            var oB = [];
            oB = Object.create(oA);

            oB.push(3);            // oB.length;   3


    3、jQuery.extend()

        let oa = {a: 1, b: 2}; let ob = {};  
        $.extend(ob, oa); 
        ob.b = 3; 
        console.log(oa, ob);        // oa: {a: 1, b: 2}、 ob: {a: 1, b: 3}
</code></pre><h4 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h4><pre><code>一、concat()方法

    var arrA = [1,2,3];
    var arrB = arrA.concat();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

二、slice()方法

    var arrA = [1,2,3];
    var arrB = arrA.slice();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

两种方法都是回返一个不带指向的新数组
</code></pre><h4 id="对象处理"><a href="#对象处理" class="headerlink" title="对象处理"></a>对象处理</h4><pre><code>一、查看是否是一个空对象

    // 使用keys来查看对象中所有的kyes并返回一个数组，如果数组为度为0则对象为空
    var obj = {}; 
    var Len = Object.keys(obj);         
    console.log(Len.length);

二、查看对象中属性是否存在

    var obj = {
        a: 1,
        b: 2
    }
    console.log(obj.c);        // undefined
</code></pre><h4 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h4><pre><code>一、数据去重

    1、普通方法

        function clearRepeat(arr){
            var newArr = [], obj = {};
            for(var i=0; i&lt;arr.length; i++){
                if(!obj[arr[i]]){
                    obj[arr[i]] = &apos;&apos;;        // 对象属性相同会直接覆盖
                    newArr.push(key);        
                }
            }
            return newArr;
        }

        let retArray = clearRepeat([3,2,3,4,5,5,2,2,13,3]);


    2、使用ES6的set()方法，set方法就是不允许数组内有重复的值

        let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
        console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
        let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    http://www.jb51.net/article/46154.htm


二、数组排序

    1、使用sort方法

        var arr = [6,7,5,8,4,2342342,23,234,2,34];
        arr.sort(function(v1, v2){
            return v1 - v2        // 正序
        })
        console.log(arr);
</code></pre><h4 id="编写组件并兼容AMD、ES6写法"><a href="#编写组件并兼容AMD、ES6写法" class="headerlink" title="编写组件并兼容AMD、ES6写法"></a>编写组件并兼容AMD、ES6写法</h4><pre><code>;(function(root, factory){

    // 判断使用的支持定义模块的方式
    if(typeof define === &apos;function&apos; &amp;&amp; define.amd){
        define(factory)
    }
    else if(typeof exports === &apos;object&apos;){
        module.exports = factory();
    }
    else{
        root.NProgress = factory();
    }

})(this, function(){
    console.log(`输出内容`);
})
</code></pre><p>| 参考<br>| <a href="https://juejin.im/entry/58db95eaac502e0058f8472e" target="_blank" rel="noopener">https://juejin.im/entry/58db95eaac502e0058f8472e</a><br>| <a href="http://www.iamaddy.net/2015/04/front-end-engineering/" target="_blank" rel="noopener">http://www.iamaddy.net/2015/04/front-end-engineering/</a>       // 前端的发展</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之组件篇/">React Native之组件篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之组件篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h5 id="组件列表"><a href="#组件列表" class="headerlink" title="组件列表"></a>组件列表</h5><pre><code>ListView - 用于展示数据列表

ScrollView - 带滚动条的容器

Fetch - 请求网络接口数据

TarBarIOS - 切换菜单

TouchableHighlight - 封装视图，可以将一些内容放到这个容器中方便处理点击


View - 窗口，相当于div

Image - 加载图片

Text - 展示文本

TextInput - 文本输入框

Button - 按钮
</code></pre><h4 id="根据ios、android不同系统"><a href="#根据ios、android不同系统" class="headerlink" title="根据ios、android不同系统"></a>根据ios、android不同系统</h4><pre><code>定义一个兼容组件:
    var Component = Platform.select({
        ios: () =&gt; require(&apos;ComponentIOS&apos;),
        android: () =&gt; require(&apos;ComponentAndroid&apos;),
    })();

调用组件
    &lt;Component /&gt;


样式兼容:
    import { Platform, StyleSheet } from &apos;react-native&apos;;
    var styles = StyleSheet.create({
        height: (Platform.OS === &apos;ios&apos;) ? 200 : 100,
    });

    import { Platform, StyleSheet } from &apos;react-native&apos;;
    var styles = StyleSheet.create({
        container: {
            flex: 1,
            ...Platform.select({
            ios: {
                backgroundColor: &apos;red&apos;,
            },
            android: {
                backgroundColor: &apos;blue&apos;,
            },
            }),
        },
    });
</code></pre><h4 id="react-native-内置组件"><a href="#react-native-内置组件" class="headerlink" title="react-native 内置组件"></a>react-native 内置组件</h4><pre><code>需要在react-native对象进行解构 

import {View, TextInput, Text} from &apos;react-native&apos;
</code></pre><h4 id="View-用来布局的组件"><a href="#View-用来布局的组件" class="headerlink" title="View 用来布局的组件"></a>View 用来布局的组件</h4><pre><code>&lt;View style={{ flex: 1; justifyContent: 'center', alignItems: 'center}}&gt;
    &lt;Text&gt;xxxxx&lt;/Text&gt;
&lt;/View&gt;
</code></pre><h4 id="Text-显示文本内容"><a href="#Text-显示文本内容" class="headerlink" title="Text 显示文本内容"></a>Text 显示文本内容</h4><pre><code>&lt;Text&gt;Component A&lt;/Text&gt;
</code></pre><h4 id="TextInput-文本输入框"><a href="#TextInput-文本输入框" class="headerlink" title="TextInput 文本输入框"></a>TextInput 文本输入框</h4><pre><code>属性: 

    autoCapitalize - 枚举类型，可选值有none,sentences,words,characters.当用户输入时，用于提示。

    placeholder - 占位符，在输入前显示的文本内容。

    value - 文本输入框的默认值。

    placeholdertTextColor - 占位符文本颜色。

    password - 如果为ture ， 则是密码输入框，文本显示为＊＊＊。

    multiline - 如果为true ， 则是多行输入。

    editable - 如果为false ， 文本框不可输入。其默认值事true。

    autoFocus - 如果为true， 将自动聚焦。

    clearButtonMode - 枚举类型，可选值有never，while－enditing , unless-editing,always.用于显示清除按钮。

    maxLength - 能够输入的最长字符数。

    enablesReturnKeyAutomatically : 如果值为true，表示没有文本时键盘是不能有返回键的。其默认值为false。

    returnKeyType - 枚举类型，可选值有default,go,google,join,next,route,search,send,yahoo,done,emergency-call。表示软键盘返回键显示的字符串。

事件:

    onChangeText - 当文本输入框的内容发生变化时，调用该函数。onChangeText接收一个文本的参数对象。

    onChange - 当文本变化时，调用该函数。

    onEndEditing - 当结束编辑时，调用该函数。

    onBlur - 失去焦点出发事件。

    onFocus - 获得焦点出发事件。

    onSubmitEditing : 当结束编辑后，点击键盘的提交按钮出发该事件。


&lt;TextInput
    style={styles.inp}
    placeholder=&quot;none&quot;
    autoCapitalize=&quot;none&quot; /&gt;
</code></pre><h4 id="Keyboard-控制-键盘的"><a href="#Keyboard-控制-键盘的" class="headerlink" title="Keyboard 控制 键盘的"></a>Keyboard 控制 键盘的</h4><h4 id="KeyboardAvoidingView-键盘"><a href="#KeyboardAvoidingView-键盘" class="headerlink" title="KeyboardAvoidingView  键盘"></a>KeyboardAvoidingView  键盘</h4><pre><code>用于解决手机上弹出键盘挡住视图，本组件可以自动根据键盘的位置，调整自身的position
</code></pre><h4 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h4><pre><code>color: 颜色       disabel: 是否可用       onPress: 点击事件       title: 按钮文本

&lt;Button
    onPress={onPressLearnMore}
    title=&quot;Learn More&quot;
    color=&quot;#841584&quot;
    accessibilityLabel=&quot;Learn more about this purple button&quot; /&gt;
</code></pre><h4 id="Image-图片-加载的两种方式"><a href="#Image-图片-加载的两种方式" class="headerlink" title="Image 图片 加载的两种方式"></a>Image 图片 加载的两种方式</h4><pre><code>onLayout: 元素挂载或布局中改变调用      onLoad: 加载成功完成调用        onLoadEnd: 加载结束后，无论成功失败都调用

resizeMode:  cover:等比拉伸      strech:保持原有大小       contain:图片拉伸  充满空间

source: 图片的资源地址


1、require引用  使用静态图片资源

    &lt;Image source={require(&apos;./components/images/i1.png&apos;)} style={{width: 100, height: 100}} resizeMode={&apos;cover&apos;} /&gt;

    注: 使用require静态资源，不允许拼接url &lt;Image source={require(&apos;./img/my_icon&apos;+&apos;.png&apos;)} /&gt;


2、uri  使用网络图片资源

    &lt;Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} style={{width: 400, height: 400}} /&gt;


3、使用原生图片资源(ios中的图片)

    打开xCode 在工程 打开images xcassets目录，将图片vue-banner.jpg拖入到appicon下进行导入

    加载 &lt;Image source={{uri: 'vue-banner'}} style={styles.imgStyle2} resizeMode=&quot;cover&quot; /&gt;  重启项目


4、使用本地文件系统中的资源(相册里的图片)
</code></pre><h4 id="TarBarIOS-选项卡插件-只能在根元素不能被任何元素包裹"><a href="#TarBarIOS-选项卡插件-只能在根元素不能被任何元素包裹" class="headerlink" title="TarBarIOS  选项卡插件 只能在根元素不能被任何元素包裹"></a>TarBarIOS  选项卡插件 只能在根元素不能被任何元素包裹</h4><pre><code>TabBarIOS 属性

    barTintColor 标签栏背景色 

    tintColor 当前选中的标签颜色 

    translucent Boolean  是否标签栏半透明

    &lt;TabBarIOS barTintColor=&quot;#ccc&quot; tintColor=&quot;#fff&quot;&gt;
        &lt;TabBarIOS.Item&gt; ... &lt;/TabBarIOS.Item&gt;
    &lt;/TabBarIOS&gt;


TabBarIOS.Item 属性

    title: 图标下面的标题文字

    badge: 右上角显示一个红色气泡 提示气泡

    icon: 显示的图标  

        icon={require(&apos;../images/i4.png&apos;)} 加载本地

        icon={{uri: base64Icon, scale: 3}} 加载其它 并且带缩放

    selectedIcon: 选中的图标

    selected: 是否为选中状态 selected: {this.state.selectName = &apos;blue&apos;}

    onPress(): 按下
</code></pre><h4 id="Fetch-网络请求"><a href="#Fetch-网络请求" class="headerlink" title="Fetch 网络请求"></a>Fetch 网络请求</h4><pre><code>获取接口数据, 处理get或post的请求

Example:

    1、Get

    onPressLearnMore(){
        let that = this;
        const REQUEST_URL = &apos;http://goucai.diyicai.com/lottery/hisnumber.action?lotteryId=001&amp;issueLen=20&amp;d=1496242956216&apos;;

        fetch(REQUEST_URL)
            .then((response) =&gt; {
                return response.json();  //把response转为json
            })
            .then((responseData) =&gt; {   // 接收上面的转好的json
                debugger;
                let data = responseData[0].ernieDate;
                that.setState({lotter: data})
                console.log(data);
            })
            .catch((error) =&gt; {
                this.setState({
                    error: true,
                    errorInfo: error
                })
            })
            .done();
    }

    2、post:

    fetch(&apos;https://mywebsite.com/endpoint/&apos;, {
        method: &apos;POST&apos;,
        headers: {
            &apos;Accept&apos;: &apos;application/json&apos;,
            &apos;Content-Type&apos;: &apos;application/json&apos;,
        },
        body: JSON.stringify({
            firstParam: &apos;yourValue&apos;,
            secondParam: &apos;yourOtherValue&apos;,
        })
    })
</code></pre><h4 id="FlatList-加载网络数据"><a href="#FlatList-加载网络数据" class="headerlink" title="FlatList 加载网络数据"></a>FlatList 加载网络数据</h4><h4 id="SectionList-分组的列表组件"><a href="#SectionList-分组的列表组件" class="headerlink" title="SectionList 分组的列表组件"></a>SectionList 分组的列表组件</h4><pre><code>不需要分组可以使用FlatList, 如果需要分组使用SectionList
</code></pre><h4 id="TouchableHighlight-封装视图-把一部分内容放到一个容器中可以方便处理"><a href="#TouchableHighlight-封装视图-把一部分内容放到一个容器中可以方便处理" class="headerlink" title="TouchableHighlight  封装视图 把一部分内容放到一个容器中可以方便处理"></a>TouchableHighlight  封装视图 把一部分内容放到一个容器中可以方便处理</h4><pre><code>render: function () {
    return (
        &lt;TouchableHighlight onPress={this._onPressButton} style={styles.mt40}&gt;
            &lt;View&gt;
                &lt;Text&gt;{this.state.userName}&lt;/Text&gt;
                &lt;Image
                    style={styles.mt40}
                    source={require(&apos;./src/images/1.jpg&apos;)}
                /&gt;
            &lt;/View&gt;                    
        &lt;/TouchableHighlight&gt;
    );
}
</code></pre><h4 id="Dimensions-获取设备屏幕的宽高"><a href="#Dimensions-获取设备屏幕的宽高" class="headerlink" title="Dimensions  获取设备屏幕的宽高"></a>Dimensions  获取设备屏幕的宽高</h4><pre><code>let winWidth = Dimensions.get(&apos;window&apos;).width;
let winHeight = Dimensions.get(&apos;window&apos;).height;
</code></pre><h4 id="DatePickerIOS-日期选择器"><a href="#DatePickerIOS-日期选择器" class="headerlink" title="DatePickerIOS  日期选择器"></a>DatePickerIOS  日期选择器</h4><pre><code>date: 当前被选中的日期      mode: 选择器模式       onDateChange: 选中事件

maximumdDate: 可选的最大日期       minimumDate: 可选的最小日期        

minuteInterval: 可选的最小分钟     timeZoneOffsetInMinutes: 时区差，单位分钟
</code></pre><h4 id="TimePickerAndroid-Android时间选择器的对话框"><a href="#TimePickerAndroid-Android时间选择器的对话框" class="headerlink" title="TimePickerAndroid Android时间选择器的对话框"></a>TimePickerAndroid Android时间选择器的对话框</h4><h4 id="ActivityIndicator-loading加载图标"><a href="#ActivityIndicator-loading加载图标" class="headerlink" title="ActivityIndicator  loading加载图标"></a>ActivityIndicator  loading加载图标</h4><pre><code>animating: 是否显示 true false

color: 图片颜色

size: 大小  small large
</code></pre><h4 id="Modal-弹层"><a href="#Modal-弹层" class="headerlink" title="Modal  弹层"></a>Modal  弹层</h4><pre><code>不是弹窗，而是整弹个层

animationType: 展示层的动画效果  slide 滑动   fade 淡入淡出    none 无

onRequestClose: 
</code></pre><h4 id="alert、AlertIOS-对话框"><a href="#alert、AlertIOS-对话框" class="headerlink" title="alert、AlertIOS  对话框"></a>alert、AlertIOS  对话框</h4><pre><code>Alert.alert(标题，内容，[{确定按钮和}]

&lt;Text onPress={() =&gt; Alert.alert(
    &apos;这里是弹层的标题&apos;,
    &apos;这里是内容&apos;,
    [
        {text: &apos;取消&apos;, onPress: () =&gt; console.log(&apos;Cancel Pressed!&apos;)},    // 显示的按钮和回调函数
        {text: &apos;确定&apos;, onPress: () =&gt; console.log(&apos;OK Pressed!&apos;)},
    ]
)}&gt;点击显示弹窗&lt;/Text&gt;
</code></pre><h4 id="Navigator-NavigatorIOS-导航"><a href="#Navigator-NavigatorIOS-导航" class="headerlink" title="Navigator NavigatorIOS  导航"></a>Navigator NavigatorIOS  导航</h4><h4 id="StatusBar-状态栏组件"><a href="#StatusBar-状态栏组件" class="headerlink" title="StatusBar 状态栏组件"></a>StatusBar 状态栏组件</h4><pre><code>控制顶部运营商、电量位置的

属性: 

    animated bool   进行设置当状态栏的状态发生变化的时候是否需要加入动画。当前该动画支持backgroundColor,barStyle和hidden属性

    hidden  bool  进行设置状态栏是否隐藏（最顶部的那条栏）

    backgroundColor   color类型，仅支持Android设备，设置状态栏的背景颜色

    translucent bool类型，仅支持Android设备, 进行设置状态栏是否为透明。当状态栏的值为true的时候，应用将会在状态栏下面进行绘制显示。这样在Android平台上面就是沉浸式的效果，可以达到Android和iOS应用一致性效果。该值常常配置半透明效果的状态栏颜色一起使用

    barStyle  enum(&apos;default&apos;,&apos;light-content&apos;)  枚举类型，仅支持iOS设备。进行设置状态栏文字的颜色

    networkActivityIndicatorVisible   bool类型，仅支持iOS设备。设置状态栏上面的网络进度加载器是否进行显示

    showHideTransition   enum(&apos;fade&apos;,&apos;slide&apos;) 枚举类型，仅支持iOS设备。进行设置当隐藏或者显示状态栏的时候的动画效果。默认值为&apos;fade&apos;
</code></pre><h4 id="Picker-PickerIOS-象select的选择菜单"><a href="#Picker-PickerIOS-象select的选择菜单" class="headerlink" title="Picker PickerIOS  象select的选择菜单"></a>Picker PickerIOS  象select的选择菜单</h4><pre><code>1、selectedValue: 选中后的值

2、onValueChange: 触发事件

3、PickerIOS.Item: 定义菜单的先项

&lt;PickerIOS
    style={{width:200}}
    selectedValue={this.state.language}
    onValueChange={(lang) =&gt; this.setState({language: lang})}&gt;
    &lt;PickerIOS.Item label=&quot;Java&quot; value=&quot;java&quot; /&gt;
    &lt;PickerIOS.Item label=&quot;JavaScript&quot; value=&quot;js&quot; /&gt;
&lt;/PickerIOS&gt;
&lt;Text&gt;当前选择的是:{this.state.language}&lt;/Text&gt;
</code></pre><h4 id="Slider-选择一个范围的组件-滑块"><a href="#Slider-选择一个范围的组件-滑块" class="headerlink" title="Slider  选择一个范围的组件, 滑块"></a>Slider  选择一个范围的组件, 滑块</h4><pre><code>属性:

    disabled    bool    如果为true，用户无法移动这个滑动条。默认值为false

    maximumValue    number    滑动条最大值。默认为1

    minimumValue    number    滑动条最小值，默认为0

    onSlidingComplete    function    当用户完成值的改变被回调的方法

    onValueChange    function    当用户正在滑动滑动条持续回调的方法

    step    number    滑动条的最小单位。这个值应该在0到最大值-最小值之间。默认为0

    testID    string    

    value    number    滑动条选择的值。这个值应该在最小值和最大值之间，它们的默认值分别为0和1。默认值为0
</code></pre><h4 id="Switch-开关滑块组件"><a href="#Switch-开关滑块组件" class="headerlink" title="Switch  开关滑块组件"></a>Switch  开关滑块组件</h4><pre><code>disabled 是否禁用

onValueChange 当值改变时回调

value 开关是否打开，默认false

onTintColor: 开启状态背景颜色

tintColor: 关闭状态时边框颜色或背景色

thumbTintColor: 开关上按钮的颜色     

testID
</code></pre><h4 id="ScrollView-可滚动的容器，可以放多个组件和视图"><a href="#ScrollView-可滚动的容器，可以放多个组件和视图" class="headerlink" title="ScrollView  可滚动的容器，可以放多个组件和视图"></a>ScrollView  可滚动的容器，可以放多个组件和视图</h4><h4 id="ListView-用于垂直滚动列表，用于元素之间结构近似而仅数据不同-listView不立即渲染所有元素-优先渲染屏幕可见元素"><a href="#ListView-用于垂直滚动列表，用于元素之间结构近似而仅数据不同-listView不立即渲染所有元素-优先渲染屏幕可见元素" class="headerlink" title="ListView  用于垂直滚动列表，用于元素之间结构近似而仅数据不同, listView不立即渲染所有元素, 优先渲染屏幕可见元素"></a>ListView  用于垂直滚动列表，用于元素之间结构近似而仅数据不同, listView不立即渲染所有元素, 优先渲染屏幕可见元素</h4><pre><code>ListView继承了ScrollView所以有ScrollView下所有的属性

ListView属性:

    dataSource - 列表数据源

    renderRow - 解析每一条的数据的展示结构样式

    rowHasChanged - 函数也是ListView的必需属性。这里我们只是简单的比较两行数据是否是同一个数据（===符号只比较基本类型数据的值，和引用类型的地址）来判断某行数据是否变化了。

    scrollView - automaticallyAdjustContentInsets={false} 如果不设置这个属性顶部会一个块留白

ListView方法:

    ListView.DataSource - 用于比对两条数据是否相同，如果不相同进行渲染


Example:

    class DemoComponent extends Component {
        constructor(props){
            super(props);
            const ds = new ListView.DataSource({
                rowHasChanged: (r1, r2) =&gt; r1 !== r2
            });

            this.state = {
                dataSource: ds.cloneWithRows([
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    },
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    },
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    }               
                ])
            }
        }

        // 返回每一条数据的结构
        carRenderRow(rowData){
            return (
                &lt;View style={styles.carList}&gt;
                    &lt;Image source={rowData.img} style={styles.carPicture} /&gt;
                    &lt;Text style={styles.carFont1}&gt;{rowData.title}&lt;/Text&gt;                  
                &lt;/View&gt;
            )
        }

        render(){
            return (
                &lt;View style={{flex: 1, marginBottom: 60}}&gt;
                    &lt;ListView
                        dataSource={this.state.dataSource}
                        renderRow={this.carRenderRow} /&gt;             
                &lt;/View&gt;
            )
        }
    }
</code></pre><h4 id="RefreshControl-下拉刷新"><a href="#RefreshControl-下拉刷新" class="headerlink" title="RefreshControl  下拉刷新"></a>RefreshControl  下拉刷新</h4><pre><code>PullToRefreshAndroidView 也是实现下拉刷新的组件

属性方法

    onRefresh  function方法 当视图开始刷新的时候调用

    refreshing  bool  决定加载进去指示器是否为活跃状态，也表名当前是否在刷新中

    colors [ColorPropType]   android平台适用  进行设置加载进去指示器的颜色，至少设置一种，最好可以设置4种

    enabled  bool   android平台适用   用来设置下拉刷新功能是否可用

    progressBackgroundColor ColorPropType  设置加载进度指示器的背景颜色

    size RefreshLayoutConsts.SIZE.DEFAULT  android平台适用  加载进度指示器的尺寸大小 ，具体可以查看RefreshControl.SIZE(详细点击进入)

    tintColor ColorPropType   iOS平台适用  设置加载进度指示器的颜色

    title string iOS平台适用  设置加载进度指示器下面的标题文本信息
</code></pre><h4 id="AppState、AppStateIOS-获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你"><a href="#AppState、AppStateIOS-获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你" class="headerlink" title="AppState、AppStateIOS  获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你"></a>AppState、AppStateIOS  获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你</h4><pre><code>AppState.currentState 返回的值:

    active - 表示当前App在前台运行

    background - 应用正在后台运行。用户既可能在别的应用中，也可能在桌面。

    inactive - 该状态我们可以暂时不考虑，因为该状态不会出现在现在React Native App中。
</code></pre><h4 id="AppRegistry-运行RN的入口"><a href="#AppRegistry-运行RN的入口" class="headerlink" title="AppRegistry 运行RN的入口"></a>AppRegistry 运行RN的入口</h4><pre><code>AppRegistry.registerComponent(&apos;exampleApp&apos;, () =&gt; exampleApp);
</code></pre><h4 id="AsyncStorage-简单的、未加密的、异步的、持久化的Key-Value存储系统"><a href="#AsyncStorage-简单的、未加密的、异步的、持久化的Key-Value存储系统" class="headerlink" title="AsyncStorage  简单的、未加密的、异步的、持久化的Key-Value存储系统"></a>AsyncStorage  简单的、未加密的、异步的、持久化的Key-Value存储系统</h4><pre><code>一、方法: anyncStroage每个方法返回的都是一个Promise

    getItem(key, callback) - 获取数据

    setItem(key, value, callback) - 存储数据

    removeItem(key, callback) - 删除数据

    mergeItem(key, value, callback) - 合并两值

    clear() - 删除全部

    getAllKeys(callback) - 获取所有可访问到的数据

    flushGetRequest() - 清除所有进行中的查询操作

    multiGet(keys &lt;Array&gt;, callback) - 获取keys所包含所有的字段值

        AsyncStroage.multiGet([&apos;user&apos;, &apos;enter&apos;])
            .then((data) =&gt; {
                // 这里可以取到本地存储中的user和enter的值
                /*
                * data返回的是一个二维数组
                * [
                *   [&quot;key1&quot;, &quot;aaa&quot;],
                *   [&quot;key2&quot;, &quot;bbb&quot;]
                * ]
                */

                let user = JSON.parse(data);
            })
</code></pre><h4 id="ProgressBarAndroid-ProgressViewIOS-加载进度"><a href="#ProgressBarAndroid-ProgressViewIOS-加载进度" class="headerlink" title="ProgressBarAndroid ProgressViewIOS 加载进度"></a>ProgressBarAndroid ProgressViewIOS 加载进度</h4><pre><code>属性:

    View 相关属性样式全部继承(例如:宽和高,背景颜色,边距等相关属性样式)

    progress number  设置进度值 (范围在0-1之间)

    progressTintColor  string  设置进度条本身的颜色

    progressViewStyle   enum(&apos;default&apos;,&apos;bar&apos;)  加载进度的风格   枚举类型 默认风格和Bar条类型

    trackImage   Image.propTypes.source    设置一个可以拉伸的图片，设置进度条剩下部分进度的图片

    trackTintColor  string   进度条的颜色(已经有进度的情况)
</code></pre><h4 id="DrawerLayoutAndroid-抽屉-安卓"><a href="#DrawerLayoutAndroid-抽屉-安卓" class="headerlink" title="DrawerLayoutAndroid   抽屉 安卓"></a>DrawerLayoutAndroid   抽屉 安卓</h4><p>SegmentedControlIOS<br>ToolbarAndroid<br>TouchableNativeFeedback<br>TouchableOpacity<br>TouchableWithoutFeedback<br>ViewPagerAndroid<br>VirtualizedList<br>WebView</p>
<p>API<br>ActionSheetIOS<br>AdSupportIOS<br>Animated<br>BackAndroid<br>BackHandler     后退<br>CameraRoll      访问本地相册<br>Clipboard       读写剪贴板的内容<br>DatePickerAndroid  Android日期选择器的对话框<br>Easing<br>Geolocation     地理位置<br>ImageEditor     根据URI剪裁对应的图片<br>ImagePickerIOS<br>ImageStore<br>InteractionManager<br>LayoutAnimation 当布局变化时，自动将视图运动到它们新的位置上<br>Linking         传入和传出的App链接进行交互<br>NativeMethodsMixin<br>NetInfo         获取设备联网或离线的状态信息<br>PanResponder    多点触摸操作协调成一个手势<br>PermissionsAndroid<br>PixelRatio      获取设备的像素密度的方法<br>PushNotificationIOS 处理应用的推送通知<br>Share           打开一个对话框来共享文本内容<br>StyleSheet      定义css样式<br>Systrace<br>ToastAndroid<br>Vibration       控制设备震动<br>布局样式属性<br>阴影样式属性</p>
<hr>
<h4 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h4><pre><code>rnpm介绍 下载完第三方组件不能直接用，需要通过rnpm 直接组件的内容挂载到工程中去，需要执行$ rnpm link 模块名 ，与react-native link 相同

    安装rnpm  $ npm i rnpm -g

    link的原因：以下组件都是原生开发，wrapper了一层js，因此需要link .a到project中

$ react-native-elements   基础组件    https://github.com/react-native-community/react-native-elements#buttons


$ lodash 

$ query-string 

$ sha1      加密模块

$ react-native-button

$ react-native-audio      音频

$ react-native-video      视频  https://github.com/react-native-community/react-native-video

$ react-native-image-picker  摄像头和本地相册  https://github.com/marcshilling/react-native-image-picker

$ react-native-progress   进度条

$ react-native-storage    存储  https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md

$ react-native-sk-countdown  倒计时

$ react-native-swiper     轮播 https://github.com/leecade/react-native-swiper

$ react-native-barcodescanner 扫二维码 Android   https://github.com/ideacreation/react-native-barcodescanner
                                      http://blog.csdn.net/liu__520/article/details/52889950

$ react-native-animatable  动画   https://github.com/oblador/react-native-animatable

$ react-native-device-info 设备信息  https://github.com/rebeccahughes/react-native-device-info
                                    http://www.ncloud.hk/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/react-native-acquisition-device-information-component-react-native-device-info/


Geolocation  内置的地理位置 


http://www.jianshu.com/p/53ff78168acc       整理的插件
https://yq.aliyun.com/articles/78154?utm_campaign=wenzhang&amp;utm_medium=article&amp;utm_source=QQ-qun&amp;201759&amp;utm_content=m_20152
http://www.jianshu.com/p/e30feb098ef2
</code></pre><h4 id="react-native-vector-icons-图标类"><a href="#react-native-vector-icons-图标类" class="headerlink" title="react-native-vector-icons 图标类"></a>react-native-vector-icons 图标类</h4><pre><code>1、安装 npm i react-native-vector-icons --save &amp;&amp; react-native link react-native-vector-icons

2、引用

    import FontAwesome from &apos;react-native-vector-icons/FontAwesome&apos;;        // 引用的FontAwesome文件
    /* 图标文件名
        Entypo
        EvilIcons 
        FontAwesome 
        Foundation 
        Ionicons 
        MaterialIcons
        MaterialCommunityIcons 
        Octicons 
        Zocial 
        SimpleLineIcons 
    */

    class myfirst extends Component {
        render() {
            return (
                &lt;View style={styles.container}&gt;
                    &lt;FontAwesome name=&quot;address-book&quot; size={20} color=&quot;#4F8EF7&quot; /&gt;
                &lt;/View&gt;
            )
        }
    }

3、注意: 这里icon对一些组件封装

    import Icon from &apos;react-native-vector-icons/Ionicons&apos;;
    return (
        &lt;TabBarIOS&gt;
            &lt;Icon.TabBarItem        // 这里对TabBarItem进行了封装  或者ToolbarAndroid
                title=&quot;Home&quot;
                iconName=&quot;ios-home-outline&quot;     // 这里属性名为 iconName 而不是 icon
                selectedIconName=&quot;ios-home&quot;&gt;    // 选中的
                &lt;View style={styles.tabContent}&gt;&lt;Text&gt;Home Tab&lt;/Text&gt;&lt;/View&gt;
            &lt;/Icon.TabBarItem&gt;
        &lt;/TabBarIOS&gt;
    );

https://github.com/oblador/react-native-vector-icons
http://ionicons.com/  图标官网
http://blog.csdn.net/uuq/article/details/53150841  使用方法  
https://github.com/oblador/react-native-vector-icons#installation   图标对应的name值 
</code></pre><h4 id="mockjs"><a href="#mockjs" class="headerlink" title="mockjs"></a>mockjs</h4><pre><code>npm i mockjs --save

import Mock from &apos;mockjs&apos;
</code></pre><p>| 参考资料<br>| react.parts/native   // 第三方组件列表 <strong><em><br>|<br>| <a href="http://www.lcode.org/react-native/" target="_blank" rel="noopener">http://www.lcode.org/react-native/</a><br>| <a href="http://blog.csdn.net/hsbirenjie/article/category/6307126/3" target="_blank" rel="noopener">http://blog.csdn.net/hsbirenjie/article/category/6307126/3</a><br>| <a href="http://blog.csdn.net/jiangqq781931404/article/category/6055594/2" target="_blank" rel="noopener">http://blog.csdn.net/jiangqq781931404/article/category/6055594/2</a><br>| <a href="http://www.hangge.com/blog/cache/category_76_1.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/category_76_1.html</a>       </em></strong><br>| <a href="http://blog.csdn.net/mengks1987/article/category/6850683" target="_blank" rel="noopener">http://blog.csdn.net/mengks1987/article/category/6850683</a><br>| <a href="http://blog.csdn.net/yuanguozhengjust/article/category/6058018" target="_blank" rel="noopener">http://blog.csdn.net/yuanguozhengjust/article/category/6058018</a><br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/经济类/">经济学</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/经济类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/经济学/">经济学</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是经济"><a href="#什么是经济" class="headerlink" title="什么是经济"></a>什么是经济</h2><pre><code>经济 - 管理一个家庭的人

稀缺性 - 社会资源的有限性

经济学 - 研究社会如休管理自己的稀缺资源
</code></pre><h2 id="经济学的十大原理"><a href="#经济学的十大原理" class="headerlink" title="经济学的十大原理"></a>经济学的十大原理</h2><pre><code>一、人们面临权衡取舍 - 要知道做一件事情得到了什么，又舍去了什么，什么都想要最后确什么都没有
</code></pre><h2 id="绝对优势、比较优势"><a href="#绝对优势、比较优势" class="headerlink" title="绝对优势、比较优势"></a>绝对优势、比较优势</h2><pre><code>比较优势说明每种物品应该由生产这种物品成本较低的国家生产
</code></pre><h2 id="进口、出口"><a href="#进口、出口" class="headerlink" title="进口、出口"></a>进口、出口</h2><pre><code>进口: 在国外生产在国内销售的物品叫进口

出口: 在国内生产而在国外销售的物品称出口
</code></pre><h2 id="成本机会"><a href="#成本机会" class="headerlink" title="成本机会"></a>成本机会</h2><h2 id="供给与需求"><a href="#供给与需求" class="headerlink" title="供给与需求"></a>供给与需求</h2><pre><code>供给量是卖者愿意并且能够出售该物品的数量

供给定理是一种物品价格上升，该物品供给量增加，物品价格下降，物品供给量减少
</code></pre><h2 id="过剩、短缺"><a href="#过剩、短缺" class="headerlink" title="过剩、短缺"></a>过剩、短缺</h2><pre><code>过剩 - 当价格下降，供给者不能卖出他们想卖的所有物品

短缺 - 当前价格下，需求者不能买到他们想买的物品
</code></pre><h2 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h2><pre><code>市场是由某种物品或服务的买者或卖者组成的一个群体，买者作为一个群体决定了一种产品的需求，而卖者作为一个群体决定了一个产品的代给
</code></pre><h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><pre><code>竞争市场有许多买者与卖者并且每
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/Git/">Git</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/Git/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Git/">Git</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><pre><code>版本控制分为 集成式版本控制 和 分布式开发

    1、集成式开发（svn）：需要一台中央服务器，客户端需要连接到中央服务器进行更新、提交代码文件等

    2、分布式开发（Git）：每台机器都有自己版本库不需要中央服务器

分布式的好处：

    1、不需要连接中央服务器来提交和更新文件

    2、通过不同的版本来做不同阶段开发，不同的版本文件可以随时切换回之前的版本

    3、分支管理上要比svn方便很多


[master +0 ~0 -0 !1]: + 增加  ~修改  -删除  !有冲突

Git的配置文件：vi ~/.gitconfig
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>1、将远端的库克隆到本地:  git clone 远程代码库

2、创建分支并切换到创建的新分支:  git checkout -b   新建本地分支名  origin/远端分支名

3、从远端拉取拉取代码:  git pull 远端分支名

4、将文件添加到暂存区:  git add 文件名         git add .  添加所有工作区文件到暂存区

5、提交文件:  git commit -m &apos;提交版本内容说明&apos;

6、将本地代码提交到远端库:  git push origin/develop_web  本地分支名

7、查看当前文件状态:  git status 

8、查看当前所在的分支:  git branch

9、切换分支:  git checkout

10、临时保存:  git stash   git stash pop

11、从主分支上merge代码:  git merge origin/dev_crm2.6_base

12、将本地分支提交到主分支:  pull resquest

13、删除本地分支:  git branch -d dev_crm2.8_base

14、删除远端分支:  git push origin :PublicAdmin_V1.0.0_liusiguang        或  git branch -r -d origin/PublicAdmin_V1.0.0_liusiguang

15、从远端单独拉取一个文件:  git checkout origin/master -- path/to/file

16、撤消最后一次commit提交：git reset --hard HEAD^

17、chenkout一个分支后，pull的时候想在app_master下切换，使用下面命令进行转换

    git branch --set-upstream 当前分支名 远端分支名

18、git branch --track branch 名称 远端branch 建立一个 tracking 远端 branch 的 branch，这样以后 push/pull都会直接对应到该远端的branch。
    git branch --set-upstream branch 远端branch 将一个已存在的 branch 设定成 tracking 远端的branch。
</code></pre><h4 id="版本库介绍"><a href="#版本库介绍" class="headerlink" title="版本库介绍"></a>版本库介绍</h4><pre><code>工作区（文件）      暂存区（过度）     版本库      |       远端（服务器版本）    

1、工作区:  开发的区域

2、暂存区: 将工作区的文件执行 git add &apos;文件名&apos; 命令会使文件添加到暂存区，工作区的文件如果删除了就没有了

    git add &apos;文件名&apos;


3、版本库: 通过commit来提交到版本库， 暂存区需要先提交到版本库才能最后提交远端

    git commit -m &apos;提交说明内容&apos;

    add 和 commit 连着的写法
    git commit -a -m &apos;提交注释&apos;        // 这样可以省略add的步骤


4、提交到远端: 通过push来提交到远端

    git push origin develop_web_2.5.1_siguang            // 提交到远端
</code></pre><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><pre><code>1、设置贡献者

    设置用户名:     git config  --global user.name “username”

    设置Email-id:  git config  --global user.email “email”


2、设置避免PULLING提交合并:   git config --global branch.autosetuprebase always

3、颜色高亮

    git config --global color.ui true

    git config --global color.status auto

    git config --global color.branch auto


4、设置默认编辑器:  git config --global core.editor vim        Git的使用系统默认取自VISUAL或EDITOR环境变量的编辑器

5、设置默认的合并工具:  git config --global merge.tool vimdiff

6、查看设置命令:  git config --list
</code></pre><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><pre><code>1、git init 库名： 创建一个git仓库 

2、git remote add origin git@xbc.me:wordpress.git:    添加远程版本库origin

3、git remote:   显示所有远端主机

    git remote  -v:        查看远程仓库地址

    git remote show &lt;主机名&gt;:     查看远端主机的详细信息

    git remote add &lt;主机名&gt; &lt;网址&gt;:    添加远程主机

    git remote rm &lt;主机名&gt;:    删除远端主机

    git remote rename &lt;原主机名&gt; &lt;新主机名&gt;:    对无端主机进行改名

     在clone完成之后，Git 会自动为你将此远程仓库命名为origin，origin只相当于一个别名，运行git remote –v可以看到下载的版本路径。


克隆项目地址:    git clone 远程版本库地址
</code></pre><h4 id="文件操作（查看、添加、提交、删除、恢复，撤消）"><a href="#文件操作（查看、添加、提交、删除、恢复，撤消）" class="headerlink" title="文件操作（查看、添加、提交、删除、恢复，撤消）"></a>文件操作（查看、添加、提交、删除、恢复，撤消）</h4><pre><code>查看:

    1、git help:  显示help的命令功能

    2、git show 提交ID:  显示某次提交的内容，先通过git log来查看提交的ID

        commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e         // 提交的ID

    3、git log:  显示所有的版本记录


添加: 添加到缓存区

    1、git add 文件名:  将工作文件修改提交到本地暂存区            add只是刷新了git的跟踪信息，并未发到版本库中

    2、git add --all:  将所有修改过的文件提交到暂存区


提交: 提交到版本库

    1、git commit -m &apos;注释提交理由&apos;:  代码提交

        git commit --amend:  使用最后一次提交的注释在提交

    2、git push origin master:  将刚commit的版本推送到远程服务器


删除：

    1、git rm &apos;main.js&apos;:     删除暂存区的main.js文件

    2、git rm -f &apos;main.js&apos;:  删除工作区和暂存区的main.js文件

    3、git rm --cached &apos;main.js&apos;:  如果工作区和暂存区都有main.js，只删除暂存区文件


恢复：

    如果把工作区的文件删除了，想从版本库中恢复回来的方法:

    1、恢复文件

        先 git log 来查看commit 提交的历史版本，获取到commitId

        commit d5d9357319a4ef536b30f2d906bb71700beaa899
        Author: liusiugang &lt;liusiguang@renrendai.com&gt;
        Date:   Thu Nov 3 15:19:00 2016 +0800

            修改邻趣配送时间接口加merchantId参数+

        git checkout  [commitId] [要恢复的文件名]

        // 这样就将版本库中的common.coffee.js恢复到了工作区
        git checkout d5d9357319a4ef536b30f2d906bb71700beaa899  common.coffee.js   


    2、恢复版本

        1）git reset --hard  [commitId]    恢复到指定提交的版本的内容，通过commitId来指定版本

        2）git reset --hard HEAD^    恢复向后一个版本

        3）git reflog    显示所有的操作记录


撤消：

    1、git reset &lt;file&gt;：    从暂存区恢复到工作文件

    2、git reset --：        从暂存区恢复到工作文件

    3、git reset --hard：    恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改

    4、git reset HEAD b：    现在你只想提交a文件，不想提交b文件，应该这样

    5、git revert &lt;$id&gt;：    恢复某次提交的状态，恢复动作本身也创建了一次提交对象

    6、git revert HEAD：    恢复最后一次提交的状态

        git checkout -- filname  撤回远端版本或指定文件

        git commit --amend    重新合并一个提交方案


文件重命名：

    1、git mv reademe.txt 新文件名


查看当前库状态: git status

    显示
    On branch master        // master分支
    Your branch is up-to-date with &apos;origin/master&apos;.        // 你的分支是最新的 master
    nothing to commit, working directory clean            // 无提交，工作目录干净
</code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code>1、查看分支

    查看本地分支:  git branch

    查看远端分支:  git branch -r

    查看本地和远端分支:  git branch -a

    查看各分支最后提交的信息:  git branch -v


2、创建分支 

    git branch 分支名称


3、把分支提交到远端分支

    # 如果在本地创建一个分支，与团队其它人一起开发，需要将这个分支push到远端仓库，不然这个分支只是存在你本地，其它人看不到，每次commit完代码就需要提交到远端

    git push origin 本地分支名

    Example:

        appledeMacBook-Pro:what apple$ git push origin dev_1.1_lulu           // 将dev_1.1_lulu分支提交到远端
        Username for &apos;https://github.com&apos;: siguang1983            // 输入远程的用户名
        Password for &apos;https://siguang1983@github.com&apos;:             // 输入远端的密码
        Counting objects: 4, done.                                // 成功


4、删除分支: 

    git branch -d &lt;branch&gt;        删除某个分支

    git branch -D &lt;branch&gt;        强制删除某个分支 (未被合并的分支被删除的时候需要强制)


5、切换分支:

    git checkout [要切换的分支]        本地切换分支

    git checkout -b [新创建分支名]  [远端地址分支]            创建并且直接切换到这个新分支


6、合并分支: git morge  分支名

    git merge master develop        # 将develop分支合并到master上


7、分支的更新与合并

    # 将本地仓库更新到最新版本，直接更新自动合并冲突，如果执行fetch提示哪些冲突需要手动更新
    git pull origin 分支名

    # 执行一下合并，并且手动去去解决冲突
    git merge [branch]

    # 将这个冲突文件重新提交 
    git add &lt;filename&gt;

    # 查看一下冲突的文件
    git diff 确定分支  目标分支

    # 冲突处理完后就可以commit
    git commit -m &apos;fix conflict&apos;


8、删除远程版本:  git push origin :br-1.0.0

9、查看分支提交的记录:  git whatchanged

    commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e            // 提交的状态码
    Author: apple &lt;apple@appledeMacBook-Pro.local&gt;            // 提交人
    Date:   Mon May 2 17:24:16 2016 +0800                    // 日期

        siguang add index.js                // 提交文件

    :100644 100644 e69de29... 50b777e... M  js/index.js
</code></pre><h4 id="拉取远端代码-和-提交远端代码"><a href="#拉取远端代码-和-提交远端代码" class="headerlink" title="拉取远端代码 和 提交远端代码"></a>拉取远端代码 和 提交远端代码</h4><pre><code>1、pull、fetch 两种都是拉取代码功能，有一些小的差别

    git pull : 拉取远端代码，直接合并        // Already up-to-date. 已更新

    git fetch: 拉取远端代码，并不合并，查看哪些冲突，来进行手动merge合并


2、版本库提交到远端

    git push origin/dev_crm2.9_base


3、pull request：将代码提交到远端版本中的一个请求，在merge就可以直接合到远端仓库中
</code></pre><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><pre><code>拉取完代码git pull 或 git fetch 拉取远程某个分支的代码，再与本地的指定分支合并（包括fetch和merge）

git pull origin/dev_crm2.5_base 

git merge origin/dev_crm2.5_base

    有时候pull的时候会提示：git branch --set-upstream master origin/next  

    Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）

    如果有冲突 常见提示：
        Auto-merging addCacke.html            // 自动合并了这个文件
        CONFLICT (content): Merge conflict in addCacke.html            // 有冲突在 addCacke.html文件中合并冲突
        Automatic merge failed; fix conflicts and then commit the result.        // 自动合并失败解决冲突
</code></pre><h4 id="查看文件之间区别-diff"><a href="#查看文件之间区别-diff" class="headerlink" title="查看文件之间区别 diff"></a>查看文件之间区别 diff</h4><pre><code>1、git diff &lt;file&gt;:        是工作区与暂存区的

2、git diff &lt;$id1&gt; &lt;$id2&gt;:    比较两次提交之间的差异

3、git diff &lt;branch1&gt;..&lt;branch2&gt;:    在两个分支之间比较

4、git diff --staged:    比较暂存区和版本库差异

5、git diff --cached:    暂存区和版本区差异

6、git diff --stat:         仅仅比较统计信息
</code></pre><h4 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h4><pre><code>1、git log:  显示提交的所有记录

    commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e         // 提交的ID
    Author: apple &lt;apple@appledeMacBook-Pro.local&gt;         // 提交用户
    Date:   Mon May 2 17:24:16 2016 +0800                 // 提交日期

        siguang add index.js            // 提交文件

2、git log &lt;file&gt;:        查看该文件每次提交记录

3、git log -p &lt;file&gt; :    查看每次详细修改内容的diff

4、git log -p -2:        查看最近两次详细修改内容的diff

5、git log --status:     查看提交统计信息
</code></pre><h4 id="sourceTree-使用"><a href="#sourceTree-使用" class="headerlink" title="sourceTree 使用"></a>sourceTree 使用</h4><pre><code>一、设置拉取、推送默认密码

    仓库 -&gt; 远程仓库 -&gt; 将路径配置成 http://用户名:密码@172.16.x.xx:7990/scm/ibg/ibg.git
</code></pre><blockquote>
<p>参考资料：</p>
<p>可视化工具：SourceTree<br>远端：stash</p>
<p><a href="http://iissnan.com/progit/" target="_blank" rel="noopener">http://iissnan.com/progit/</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</a><br><a href="http://www.yiibai.com/git/git_update_operation.html" target="_blank" rel="noopener">http://www.yiibai.com/git/git_update_operation.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/函数式编程/">函数式编程</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/函数式编程/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/函数式编程/">函数式编程</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="纯函数式"><a href="#纯函数式" class="headerlink" title="纯函数式"></a>纯函数式</h4><pre><code>一、非纯净的

    let number = 1;

    const increment = () =&gt; number += 1;

    increment();  // 2


二、纯净的

    const increment = n =&gt; n + 1;

    increment(1);
</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><pre><code>把函数当做其它函数的参数来传递

let sum = (x, y) =&gt; x+y;

let calculate = (fn, x, y) =&gt; fn(x,y);

calculate(sum, 1, 2)
</code></pre><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><pre><code>柯里化就是将多参函数转换成单参函数

// 一个多参函数 
var add = (a, b) =&gt; a + b;
add(1, 2); // =&gt; 3

// 柯里化
var add = a =&gt; b =&gt; a+b;
add(1)(2);


Example:

    var say = function(title) {
        return function(type){
            return title + &quot; is &quot; + type;
        }
    }

    var sayFP = say(&quot;Functional Programming&quot;);
    var sayOther = say(&quot;Other Programming&quot;);

    sayFP(&quot;good&quot;); // =&gt; Functional Programming is good
    sayOther(&quot;bad&quot;); // =&gt; Other Programming is good
</code></pre><h4 id="compose-函数组合"><a href="#compose-函数组合" class="headerlink" title="compose 函数组合"></a>compose 函数组合</h4><pre><code>将多个函数组合成一个函数

Example:

    var compose = function(fn1, fn2) {
        return function(arg){
            return fn1(fn2(arg));
        }
    }

    var a = arg =&gt; arg + &apos;a&apos;;
    var b = arg =&gt; arg + &apos;b&apos;;

    var c = compose(a, b); // 将a,b函数进行组合
    console.log(c(&apos;c&apos;));  // =&gt; cba
</code></pre><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><pre><code>function isDataType(type){
    var typeName = &apos;&apos;;

    switch(toString.call(type)){
        case &apos;[object String]&apos;:
            return &apos;string&apos;;
            break;

        case &apos;[object Number]&apos;:
            if(type.toString().indexOf(&apos;.&apos;) != -1){
                return &apos;float&apos;;
            }
            else{
                return &apos;number&apos;;
            }
            break;

        case &apos;[object Array]&apos;:
            return &apos;array&apos;;
            break;

        case &apos;[object Object]&apos;:
            return &apos;object&apos;;
            break;

        case &apos;[object Undefined]&apos;:
            return &apos;undefined&apos;;
            break;

        case &apos;[object Null]&apos;:
            return &apos;null&apos;;
            break;    

        default: break;
    }

    return typeName;
}
</code></pre><p>| <a href="http://www.alloyteam.com/2016/09/talk-about-functional-programming/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/09/talk-about-functional-programming/</a><br>| <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/NPM/">NPM 常用命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/NPM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/npm/">npm</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么"></a>npm是什么</h4><pre><code>资源包的管理器，安装NodeJS时会直接安装NPM
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>$ 下载并安装node.js也就将npm直接安装

$ npm install npm@latest -g        // 更新npm

$ npm i [package_name]         // 安装包，将在当前目录创建一个node_modules目录，将下载的包保存到这个目录

$ npm update     // 获取最新的包并更新

$ npm uninstall [package_name]    // 卸载包，命令是将node_modules目录将包的文件删除

$ npm uninstall --save [package_name]    // 卸载包，将从package.json文件中删除依赖, 如果--save-dev安装就需要换成--save-dev

# npm i -g [package_name]    // 全局安装包，两种安装本地和全局安装，如果遇到acces错误权限问题，需要在前面加sudo，安装在/usr/local/lib/node_modules/中

$ npm update -g [package_name]    // 更新全局包

$ npm uninstall -g [package_name]    // 卸载全局包
</code></pre><h4 id="package-json参数介绍"><a href="#package-json参数介绍" class="headerlink" title="package.json参数介绍"></a>package.json参数介绍</h4><pre><code>name - 包名

version - 包的版本号

description - 包的描述

homepage - 包的官网 url 

author - 包的作者姓名

contributors - 包的其他贡献者姓名

dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下

repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上

main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(&quot;express&quot;)

keywords - 关键字
</code></pre><h4 id="npm-install-安装模块"><a href="#npm-install-安装模块" class="headerlink" title="npm install 安装模块"></a>npm install 安装模块</h4><pre><code>npm i [package_name] --save-dev

1、-S, --save 安装包添加到dependencies（项目依赖)中

    npm i 包名 --save

    当发布时可以不会将node_module目录发布出去，可以将package.json发布出去，其它项目的人，可以通过npm install 下载dependenciess中的所有包内容.

    例：
        npm install gulp --save 或 npm install gulp -S

        &quot;dependencies&quot;: {
            &quot;gulp&quot;: &quot;^1.0.0&quot;
        }

2、-D, --save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它

    npm install gulp --save-dev 或 npm install gulp -D

    &quot;devDependencies&quot;: {
        &quot;gulp&quot;: &quot;^1.0.0&quot;
    }


3、-O, --save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）

    npm install gulp --save-optional 或 npm install gulp -O

    &quot;optionalDependencies&quot;: {
        &quot;gulp&quot;: &quot;^1.0.0&quot;
    }


4、-E, --save-exact 精确安装指定模块版本

    npm install gulp --save-exact 或 npm install gulp -E

    输入命令npm install gulp -ES，留意package.json 文件的 dependencies 字段，以看出版本号中的^消失了

    &quot;dependencies&quot;: {
        &quot;gulp&quot;: &quot;3.9.1&quot;
    }
</code></pre><h4 id="npm-i-选项–global，–save，–save-dev"><a href="#npm-i-选项–global，–save，–save-dev" class="headerlink" title="npm i 选项–global，–save，–save-dev"></a>npm i 选项–global，–save，–save-dev</h4><pre><code>-global: 简写 -g

-save: 简写 -S, 作用是在package.json的dependencies字段增加或修改安装包和版本号

-save-dev: 简写 -D, 是修改devDependencies, 这样就不用安装了某个包之后手动修改package.json
</code></pre><h4 id="与-版本"><a href="#与-版本" class="headerlink" title="~ 与 ^ 版本"></a>~ 与 ^ 版本</h4><pre><code>版本分为: 主版本号、次版本号、补丁版本号

&quot;devDependencies&quot;: {
    &quot;vue&quot;: &quot;~2.2.2&quot;,            // 匹配最近小版本，如，会匹配所有的2.2.x版本，但最高不会匹配2.3.0
    &quot;vue-router&quot;: &quot;^2.2.0&quot;        // 最近的一个大版本，所有 2.x.x但不不包括3.0.0，相当于 2.0.0 &lt;= version &lt; 3.0.0
}
</code></pre><h4 id="npm-ls-查看安装的模块"><a href="#npm-ls-查看安装的模块" class="headerlink" title="npm ls 查看安装的模块"></a>npm ls 查看安装的模块</h4><pre><code>查看安装模块及依赖：npm ls -g
</code></pre><h4 id="发布模块"><a href="#发布模块" class="headerlink" title="发布模块"></a>发布模块</h4><pre><code>使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：

$ npm adduser
Username: mcmohd
Password:
Email: (this IS public) xxxxxx@qq.com

来发布模块命令: $ npm publish
</code></pre><h4 id="script属性"><a href="#script属性" class="headerlink" title="script属性"></a>script属性</h4><pre><code>1、npm start 启动模块

    该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序

    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;gulp -ws&quot;
    }

2、npm stop 停止模块

3、npm restart 重新启动模块
</code></pre><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><pre><code>一、npm使用过程中遇到的 Cannot find module &apos;internal/fs&apos;，错误场景 gulp中执行任务报错，的确amd-optimize插件中的graceful-fs与gulp中graceful-fs的版本问题，

    解决:
        删除插件 npm uninstall graceful-fs
        安装  npm i graceful-fs --save

二、$ npm view react version    查看npm中指定包的版本号

三、$ npm i vue@2.0.0 --save    安装指定版本
</code></pre><p>| 参考资料<br>| <a href="https://www.npmjs.com.cn/" target="_blank" rel="noopener">https://www.npmjs.com.cn/</a><br>| <a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/master-npm/</a><br>| <a href="https://github.com/ericdum/mujiang.info/issues/6/" target="_blank" rel="noopener">https://github.com/ericdum/mujiang.info/issues/6/</a><br>| <a href="http://www.luckyonecn.com/blog/difference_between_dependencies_and_devdependencies_in_npm/" target="_blank" rel="noopener">http://www.luckyonecn.com/blog/difference_between_dependencies_and_devdependencies_in_npm/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/MySQL/">MySQL</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/MySQL/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/数据库/">数据库</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>知识索引</p>
<p>数据类型: 字符型、整型、浮点型、日期时间型<br>操作符: 算术运算符、比较运算符、逻辑运算符、位运算符<br>属性: 自动编号<br>约束: 主键、外键、表关连、索引<br>库操作: 创建库、修改库、删除库、<br>表操作: 创建表、删除表、查看表结构、查看库中所有表<br>列操作: 添加列、删除列、修改列<br>记录操作: 插入记录、更新记录（单表、多表更新）、删除记录、查询记录（多列查询、分组、指定查询范围、使用别名）<br>子查询语句、例约束、<br>运算符与函数: 字符函数、数值运算符、比较运算符、日期时间函数、信息函数、聚合函数、加密函数、自定义函数<br>存储过程: 创建（参数:IN、OUT、INOUT）、调用<br>其它概念: 存储引擎、并发控制(锁、锁颗粒)、事务、</p>
</blockquote>
<h3 id="一、MySQL基础"><a href="#一、MySQL基础" class="headerlink" title="一、MySQL基础"></a>一、MySQL基础</h3><pre><code>1、MySQL介绍

    1）MySQL是关系型数据库

    2）安装后的有4个默认库

        1）information_schem: 

        2) performance_schema: 

        3) test: 

        4) mysql:     

    3）Mysql 端口号 3306

    4）mac下Mysql的配置文件 /usr/local/mysql-5.6.24-osx10.9-x86_64/my.cnf


2、MySQL 目录结构 

    mysql安装后的路径 /usr/local/mysql

    1）bin: 存储可执行文件

    2）data: 存储数据文件

    3）docs: 文档

    4）include: 存储包含头文件

    5）lib: 存储库文件

    6）share: 错误消息和字符集文件


3、停止和启动mysql服务

    关闭mysql服务    查看进程：ps -ef|grep mysql         杀进程和子进程：sudo kill -9 239 746

    启动mysql服务    sudo /usr/local/mysql-5.6.24-osx10.9-x86_64/bin/mysqld_safe

    系统偏好设置 -&gt; mysql   启动


4、登录、退出mysql

    1）登录

        mysql -uroot -pssssss -h127.0.0.1          

        -u 用户名    -p 密码       -P 端口号       -h 数据库地址 

        隐藏密码输入 mysql -uroot -h127.0.0.1 -p    回车后在输入密码


    2）退出: exit;


5、语法规范

    1）关键字和函数名全部大写

    2）数据库名称、表名称、字段字都小写

    3）SQL语句必须以&quot;;&quot;分号结束

        修改结束符  DELIMITER  //        以 // 为结束


6、数据库概念

    1）库: 一些关联表的集合

    2）表: 行和列组成, 行一条数据

    3）主键: 可以唯一标识不会有重复, 可以通过主键来查询数据

    4）外键: 外键可以引用主键数据，用于关联


7、安装mysql

    1）安装 homebrew      http://brew.sh/

    2）brew install mysql
</code></pre><h3 id="二、库服务命令"><a href="#二、库服务命令" class="headerlink" title="二、库服务命令"></a>二、库服务命令</h3><pre><code>1、启动和停止MySQL服务

    service stop mysql

    service start mysql

2、登录: mysql -uroot -p123456 -h127.0.0.1

3、退出: \q 、 exit、 quit
</code></pre><p>—————————– 语句 —————————–</p>
<pre><code>关键字与函数名全部大写

数据库名称表名字段名全部小写

SQL语句必须以分号结尾
</code></pre><h3 id="三、库操作语句"><a href="#三、库操作语句" class="headerlink" title="三、库操作语句"></a>三、库操作语句</h3><pre><code>1、创建数据库       CREATE DATABASE 库名;

        创建一个指定字符集的数据库         CREATE DATABASE 库名 CHARACTER SET utf8;

2、修改数据库       ALTER  DATABASE 库名 CHARACTER SET = uft-8;   // 将库编码改成utf8

3、删除数据库     DROP database 库名;

4、查看所有数据库     SHOW databases;

5、打开数据库        USE 库名;

6、查看当前所在的数据库   SELECT database();

7、查看库的编码: SHOW CREATE DATABASE 库名;
</code></pre><h3 id="四、操作表语句"><a href="#四、操作表语句" class="headerlink" title="四、操作表语句"></a>四、操作表语句</h3><pre><code>1、创建表        CREATE TABLE  表名(字段名 数据类型, 字段名 数据类型);

            CREATE TABLE  表名(字段 数据类型  primary key,  username VARCHAR(20));        // 加主键 primary key 

2、查看库中所有表  SHOW TABLES [db_name] [where expr];

3、查看表结构    SHOW COLUMNS FROM 表名;         // 与 desc 表名;   相同

4、删除表        DROP TABLE 表名;

5、ALTER 列操作: 

    1）添加列: ALTER TABLE 表名 ADD 列名 varchar(20);

    2）删除列: ALTER TABLE 表名 DROP 列名;

    3）修改列的类型信息

        ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称（这里可以用和原来列同名即可）】 BIGINT NOT NULL  COMMENT &apos;注释说明&apos;

    4）重命名列

        ALTER TABLE 【表名】 CHANGE 【列名称】【新列名称】 BIGINT NOT NULL  COMMENT &apos;注释说明&apos;

    5）重命名表

        ALTER TABLE 【表名字】 RENAME 【表新名字】

    6）删除表中主键

        Alter TABLE 【表名字】 drop primary key

    7）添加主键

        ALTER TABLE sj_resource_charges ADD CONSTRAINT PK_SJ_RESOURCE_CHARGES PRIMARY KEY (resid,resfromid)

    8）添加索引

        ALTER TABLE sj_resource_charges add index INDEX_NAME (name);

    9）添加唯一限制条件索引

        ALTER TABLE sj_resource_charges add unique emp_name2(cardnumber);

    10）删除索引

        ALTER TABLE [表名] index emp_name;
</code></pre><h3 id="五、记录操作语句"><a href="#五、记录操作语句" class="headerlink" title="五、记录操作语句"></a>五、记录操作语句</h3><pre><code>1、插入记录     

    1) INFO 插入指定字段值:     INSERT INTO 表名(name, age) VALUES (name值, age值);

    2) SET  插入指定字段值:     INSERT 表名 SET name=&quot;sssss&quot;, age=&quot;lll&quot;;

    3）插入所有字段值:        INSERT 表名 VALUES (NULL, name值, age值)；        // 1、没有INFO  2、如果id为主键、自增涨，需要给一个默认传入NULL 或 DEFAULT

    4）INSERT ... SELECT 将查询结果写入数据表

        INSERT [INTO] 表名 FROM 列名   SELECT 

        // 将查询出restaurant表中的type进行分组内容，插入到rest_type表中的type字段中

        INSERT rest_type(type) SELECT type FROM restaurant GROUP BY type;    


2、更新数据     

    单表更新:  UPDATE 表名 SET 要更新字段名=新值, 要更新字段名=新值  WHERE  条件        // 如果省略where条件，将修改表中的所有记录

    多表更新:  

        UPDATE 表1  [JOIN | CROSS JOIN | INNER JOIN] 表2

        表连接类型，JOIN、CROSS JOIN、INNER JOIN

                   LEFT [OUTER] JOIN 左外连接

                   RIGHT [OUTER] JOIN 右外连接


3、删除记录     

    单表删除:  DELETE FROM  表名 WHERE id=2

    多表删除:  



4、查询记录    

    查询所有列: SELECT * FROM 表名;        // 查询所有列

    查询多列:   SELECT username, age, sex FROM 表名;

    条件查询:   SELECT * FROM 表名  WHERE  条件表达式(id&lt;100);        // 查询表中的id小于100的所有记录

    查询结果分组 GROUP BY: 返回一个列中所有不相同的类别

        SELECT * FROM 表名  GROUP BY  列名 [ASC | DESC];             // 分组以哪列进行返回 ASC | DESC 正、倒序

                例: SELECT * FROM users GROUP BY sex;            # 返回sex列的分组内容，结果为两类: &apos;男&apos; 和 &apos;女&apos;


    HAVING 分组条件: SELECT * FROM 表名  GROUP BY  列名  HAVING  version &lt; 100;   // 分组后进行过滤

    LIMIT 指定查询范围: SELECT * FROM 表名 LIMIT  5, 10;        // 从第5条数据开始，查找出10条数据，也就是查询出第5-15条数据

    AS 给予别名: 当名子太长可以定义一个名，输出的时候就是定义的名字

            SELECT person AS ps, username AS un FORM users;


    --------------- select 其它  ---------------

    SELECT COUNT(*) FROM 表名 WHERE (条件)         // 返回记录的总数，如果不加条件返回整个表的总记录

    SELECT AVG(price) FROM 表名;                    // AVG()来求一个字段的平均值

    SELECT ROUND(AVG(price), 2) FROM 表名;        // ROUND() 对数值进行四舍五入


小技巧:

    1、SELECT * FROM users\G;        // 加\G 以网格形势展示查询，格式化了数据方便来看


设置空值

    例 UPDATE tag SET label=&apos;折&apos; WHERE label=NULL;        // 将label列中所有空值更新成&apos;折&apos;，失效不会被

    MySQL: null值需要通过几种方式

    1、is null、is not null: UPDATE tag SET label=&apos;折&apos; WHERE label is null;

    2、ISNULL(): 与上面一样 UPDATE tag SET label=&apos;折&apos; WHERE ISNULL(label);
</code></pre><h3 id="六、子查询语句"><a href="#六、子查询语句" class="headerlink" title="六、子查询语句"></a>六、子查询语句</h3><pre><code>子查询指嵌套在查询内部，且必须始终出现在圆括号内

子查询包含关键字或条件: DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等

子查询外层查询可以是: SELECT、INSERT、UPDATE、SET、DO

1、按返回结果集分类

    http://www.cnblogs.com/herry52/p/5643986.html

    分为4种：表子查询，行子查询，列子查询和标量子查询

    1) 表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。

        示例: 获取编号小于10的男性球员的号码

        SELECT playerno FROM (SELECT playerno, sex FROM players WHERE playerno &lt; 10) AS players10 WHERE sex=&apos;M&apos;;

        分析: 

        // 查询players中playerno小于10的两个字段的记录，并起别名为player10
        SELECT playerno, sex FROM players WHERE playerno &lt; 10 AS players10;    

        // 显示playerno字段内容，条件是子表中的sex=&apos;M&apos;
        SELECT playerno FROM 查询出的内容 WHERE sex=&apos;M&apos;


    2) 行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。

        示例: players表中获取与100号球员性别相同并且居住在同一城市的球员号码。

        SELECT playerno, sex, town FROM players WHERE (sex, town) = (select sex, town FROM players where playerno = 100);


    3) 列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）

        列子查询可以使用 IN、ANY、SOME、ALL

        1、修饰的比较运算符: ANY、SOME、ALL

            如果子查询返回：Subquery returns more than 1 row   多于一行记录，使用上面运算符

            ANY和SOME是等价的意思只符合一个就可以

            ALL 需要符合全部


        2、IN、NOT IN 子查询



    4) 标量子查询：可以指定一个标量表达式的任何地方，几乎都可以使用一个标量子查询

        示例: 获取和27号球员出生在同一年的球员的号码

        SELECT playerno, name, birth_date FROM players WHERE YEAR(birth_date) = (SELECT YEAR(birth_date) FROM players WHERE playerno=100) AND playerno != 100;
</code></pre><p>—————————– 运算符与函数 —————————–</p>
<h3 id="七、字符函数"><a href="#七、字符函数" class="headerlink" title="七、字符函数"></a>七、字符函数</h3><pre><code>1、CONCAT(): 字符连接    SELECT CONCAT(&apos;user&apos;, &apos;-&apos;, &apos;name&apos;);

    // 将tag表中value和label字段的值连接，并通过AS来返回一个别列名为tagName
    SELECT CONCAT(value, &apos;_&apos;, label) AS tagName FROM tag;


2、CONCAT_WS(): 使用指定的分隔符进行字符连接

    SELECT CONCAT_WS(&apos;|&apos;, name, user, id);        以&quot;|&quot;进行分隔


3、FORMAT(): 数据格式化

    SELECT FORMAT(132.34234, 2);        // 132.34


4、LOWER(): 将字符转成小写

5、UPPER(): 将字符转成大写

6、LEFT()、RIGHT(): 获取从左、右侧字符的几位

    SELECT LEFT(&apos;what are you doing.&apos;, 7);         // what ar

7、LENGTH(): 获取字符串长度

8、LTRIM()、RTRIM()、TRIM(): 删除前空格、删除后空格、删除前后空格

9、SUBSTRING(): 字符串的截取 substring();

        SELECT SUBSTRING(&apos;what are you doing.&apos;, 3, 7);        // at are

10、RESPLACE(): 字符替换 

        SELECT REPLACE(&apos;what are you doing.&apos;, &apos; &apos;, &apos;&apos;);      // whatareyoudoing.

11、LIKE(): 模式匹配

        %: 为任意字符            _: 任意一个字符

        ESCAPE: 使用哪个字符后的百分号

        SELECT * FROM sys_user WHERE username LIKE &apos;%@renrendai.com%&apos;\G;    // sys_user表中username字段匹配出 带有@renrendai.com的字符

        SELECT * FROM sys_user WHERE username LIKE &apos;%renren%%&apos; ESCAPE &apos;renren&apos;\G;    // 匹配出 renren%
</code></pre><h3 id="八、数值运算符"><a href="#八、数值运算符" class="headerlink" title="八、数值运算符"></a>八、数值运算符</h3><pre><code>1、CEIL(): 向上取整    SELECT CEIL(4.9);        // 5     SELECT CEIL(log) FROM office;

2、FLOOR(): 向下取整    SELECT FLOOR(4.2);        // 4

3、DIV(): 整数除法     SELECT 20 DIV 3;        // 6

4、MOD(): 取模

5、POWER(): 幂运算

6、ROUND(): 四舍五入        SELECT ROUND(2.3464, 2);    // 2.35

7、TEUNCATE(): 数字截取
</code></pre><h3 id="九、比较运算符"><a href="#九、比较运算符" class="headerlink" title="九、比较运算符"></a>九、比较运算符</h3><pre><code>1、[NOT] BETWEEN ... AND ... :  在不在一个范围内

        // 查找出fruit表中fruit_price字段（价格）10元至30无之间的数据
        SELECT fruit_id, fruit_desc, fruit_price FROM  fruit WHERE fruit_price BETWEEN 10 AND 30;


2、[NOT] IN(): 在不在几个值的内

        SELECT 10 IN (5, 20, 40);        // 返回0

        SELECT 10 IN (2, 10, 30, 49);    // 返回1


3、IS [NOT] NULL: 返回为空， IS NOT NULL 返回不为空

    // 返回 fruit_dim_three 内容为空的值
    SELECT fruit_product_name, fruit_price,fruit_dim_three FROM fruit WHERE fruit_dim_three IS NULL;  
</code></pre><h3 id="十、函数"><a href="#十、函数" class="headerlink" title="十、函数"></a>十、函数</h3><pre><code>1、日期时间函数

    1）NOW(): 返回一个当前日期和时间

    2）CURDATE(): 当前日期

    3）CURTIME(): 当前时间

    4）DATE_ADD(): 在一个时间内添加多少时间

            SELECT DATE_ADD(&apos;2016-12-12&apos;, INTERVAL 365 DAY);        // 返回 2017-12-12 , -365就是减365天

    5）DATEDIFF(date1, date2): 两个日期的差值

            SELECT DATEDIFF(&apos;2018-12-12&apos;, NOW());        // 2018-12-12与今天相差多少天

    6）DATE_FORMAT(): 日期格式化

            SELECT DATE_FORMAT(&apos;2016-12-10&apos;, &apos;%Y/%m/%d&apos;);        // 转换成 2016/12/10 

            SELECT DATE_FORMAT(NOW(), &apos;%Y年-%m月-%d日 %H时:%i分:%s秒&apos;);


2、信息函数

    1）CONNECTION_ID(): 连接的ID（线程的ID）

    2）DATABASE(): 查看当前数据库     SELECT DATABASE();

    3）LAST_INSERT_ID(): 最后插入记录

    4）USER(): 当前用户

    5）VERSION(): 版本信息


3、聚合函数

    1）AVG(): 平均值的计算

            SELECT AVG(fruit_price) FROM fruit;        // 将水果的价格字段平均值返回

    2）COUNT(): 返回条件的行数

            SELECT COUNT(列名) FROM 表名;        // 返回数目(NULL 不计)

            SELECT COUNT(*) FROM 表名;        // 返回所有的记录数

    3）MAX(): 最大值

    4）MIN(): 最小值

    5）SUM(): 返回和


4、加密函数

    1）MD5(): 信息摘要算法

            MD5(&apos;adf234sdf2=-a1%af123#$&apos;);        // 16f7709af2898dd3c9f116d56ea93c82

    2）PASSWORD(): 密码算法

            PASSWORD(&apos;adf234sdf2=-a1%af123#$&apos;);    // *6D3B0C079BFF7DAD315D9AF131F0868939A74A8D
</code></pre><h3 id="十一、自定义函数"><a href="#十一、自定义函数" class="headerlink" title="十一、自定义函数"></a>十一、自定义函数</h3><pre><code>1、创建自定函数:

    CREATE FUNCTION 函数名 RETURNS {STRING | INTERGER | REAL | DECIMAL} routine_body

    创建     函数      名    返回                    类型                     函数体          


    函数体: 由合法的SQL语句构成，可以是简单的SELECT 或 INSERT语句

    示例1 无参数:

        // 创建一个返回当前格式化的日期
        CREATE FUNCTION newDate() RETURNS VARCHAR(30) 

            RETURN  DATE_FORMAT(NOW(), &apos;%Y年-%m月-%d日 %H时:%i分:%s秒&apos;);

        // 调用
        SELECT newDate();        // 2016年-12月-12日 11时:31分:55秒


    示例2 有参数:

        CREATE FUNCTION fun2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) 

            RETURNS FLOAT(10,2) UNSIGNED  

            RETURN (num1+num2)/2;


        SELECT fun2(20, 30);        // 25.00


    示例3 返回语句

        # 需要修改结束符 “;”

        // 定义一个向users表中的username字段插入值

        DELIMITER //;

        CREATE FUNCTION addUser(username VARCHAR(20))

            RETURNS INT UNSIGNED

            BEGIN

            INSERT users(username) VALUES(username);

            RETURN LAST_INSERT_ID();

            END//


2、删除自定义函数: DROP FUNCTION 函数名;



ROW_COUNT(): 用于返回被 update, insert, delete 实际修改的行数

FOUND_ROWS(): 返回上一条执行语句，影响的行数
</code></pre><p>—————————– 数据类型 —————————–</p>
<h3 id="十二、数据类型："><a href="#十二、数据类型：" class="headerlink" title="十二、数据类型："></a>十二、数据类型：</h3><pre><code>1、int: 整型

2、浮点

    1）float: 单精度

    2）double: 双精度浮点

3、日期

    1）datetime: 日期

    2）timestamp: 日期

    3) year、month、date

4、字符型

    1）char: 定长字符类型

    2) varchar: 不定长字符

    3) tinytext:

    4) text: 

    5) medinmtext:

    6) longtext:

    7) enum: 

    8) set: 
</code></pre><h3 id="十三、操作符"><a href="#十三、操作符" class="headerlink" title="十三、操作符"></a>十三、操作符</h3><pre><code>1、算术运算符

    +     加   SET var1=2+2;       4
    -     减   SET var2=3-2;       1
    *     乘   SET var3=3*2;       6
    /     除   SET var4=10/3;      3.3333
    DIV   整除 SET var5=10 DIV 3;  3
    %     取模 SET var6=10%3 ;     1


2、比较运算符

    &gt;            大于 1&gt;2 False
    &lt;            小于 2&lt;1 False
    &lt;=           小于等于 2&lt;=2 True
    &gt;=           大于等于 3&gt;=2 True
    BETWEEN      在两值之间 5 BETWEEN 1 AND 10 True
    NOT BETWEEN  不在两值之间 5 NOT BETWEEN 1 AND 10 False
    IN           在集合中 5 IN (1,2,3,4) False
    NOT IN       不在集合中 5 NOT IN (1,2,3,4) True
    =            等于 2=3 False
    &lt;&gt;, !=       不等于 2&lt;&gt;3 False
    &lt;=&gt;          严格比较两个NULL值是否相等 NULL&lt;=&gt;NULL True
    LIKE         简单模式匹配 &quot;Guy Harrison&quot; LIKE &quot;Guy%&quot; True
    REGEXP       正则式匹配 &quot;Guy Harrison&quot; REGEXP &quot;[Gg]reg&quot; False
    IS NULL      为空 0 IS NULL False
    IS NOT NULL  不为空 0 IS NOT NULL True


3、逻辑运算符

    与(AND) &amp;&amp;       或（OR）||        非（NOT）！


4、位运算符

    |   位或
    &amp;   位与
    &lt;&lt;  左移位
    &gt;&gt;  右移位
    ~   位非(单目运算，按位取反)
</code></pre><h3 id="十四、属性"><a href="#十四、属性" class="headerlink" title="十四、属性"></a>十四、属性</h3><pre><code>1、AUTO_INCREMENT: 自动编号，必须与主键组合使用，起始值为1，每次增加1

2、primary key         主键约束 每张表只能存在一个主键，主键保证记录的唯一性, 主键自动为 NOT NULL

3、foreign            外键约束 保持数据的一致性, 实现一对一或一对多的关系约束
</code></pre><h3 id="十五、约束"><a href="#十五、约束" class="headerlink" title="十五、约束"></a>十五、约束</h3><pre><code>2、PRIMARY KEY（主键约束）: 每张表只能存在一个主键，保证记录的唯一性，主键自动为NOT NULL

3、UNIQUE KEY（唯一约束）: 可以保证记录的唯一性，字段可以为空值（NULL），每张数据表可以存在多个唯一约束

4、DEFAULT（默认约束）: 默认值，插入记录时没有赋值，自动赋予默认值

    创建表时的性别字段，有三个值1，2，3 =&gt; 男，女，不男不女  如果insert插入未写入值，默认加入3
    sex ENUM(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;) DEFAULT &apos;3&apos;        

5、FOREIGN KEY（外键约束）: 保证数据一致性和完整性，实现一对一 或 一对多关系

5、NOT NULL（非空约束） 不能为空，必须写值要不报错

6、NULL 可以为空


# 约束分为表级约束 和 列级约束

    约束只针对一个字段来约束，叫列级约束

    约束针对两个或以上字段来约束，叫表级约束


# 外键约束的要求

    1、父表和子表必须使用相同的存储引擎，禁止使用临时表

    2、数据表存储只能为InnoDB

    3、外键列和参照必须有相似的数据类型，



CURRENT_TIMESTAMP
</code></pre><p>—————————– 存储过程 —————————–</p>
<h3 id="十六、MySQL命令执行过程"><a href="#十六、MySQL命令执行过程" class="headerlink" title="十六、MySQL命令执行过程"></a>十六、MySQL命令执行过程</h3><pre><code>SQL命令 -&gt; MySQL引擎 -&gt; 语法正确 -&gt; 可识别命令 -&gt; 执行结果 -&gt; 返回客户端

需要这一套流程才能跑完，如果使用存储过程会节省中间的一些步骤，可以节省性能.
</code></pre><h3 id="十七、什么是存储过程"><a href="#十七、什么是存储过程" class="headerlink" title="十七、什么是存储过程"></a>十七、什么是存储过程</h3><pre><code>存储过程: 是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理

存储过程存储在数据库内，可以通过应用程序调用和输出

存储过程的优点:

    1、增强SQL语句的功能和灵活性

    2、实现较快的执行速度

        存储过程是不需要语法解析等操作，预编译，所以速度上要快

    3、减少网络流量

        后端应用程序与数据库通信，需要传SQL语句，如果有存储过程就直接告诉执行哪个存储过程就可以了
</code></pre><h3 id="十八、存储过程的使用"><a href="#十八、存储过程的使用" class="headerlink" title="十八、存储过程的使用"></a>十八、存储过程的使用</h3><pre><code>1、创建存储过程

    CREATE 

    [DEFINER = {user | CURRENT_USER}]         // 如果省略就是默认走的当前登录客户端的用户

    PROCEDURE 存储过程名(参数)


    参数：

        1) IN: 表示该参数值必须在调用存储过程时指定，这个值不能返回只能进不能出

        2）OUT: 表示该参数值可以审美观点存储过程改变，并且可以返回，

        3）INOUT: 表示该参数调用时指定，并且可以被改变和返回


    过程体

        1）由合法的SQL语句构成

        2）可以是做任意的SQL语句

        3）复合结构则使用BEGIN...END语句，与函数相同，如果执行两个或两个以上语句需要使用BEGIN...END

        4）复合结构可以包含声明、循环、控制结构



    示例1: 无参数

        // 定义一个返回客户端信息的存储过程
        CREATE PROCEDURE sp1() SELEECT VERSION();

        // 调用存储过程
        CALL sp1();                // 如果没有参数可以去掉小括号  CALL sp1;


    示例2: 带参数 IN

        DELIMITER //

        CREATE PROCEDURE removeUserId(IN uid INT UNSIGNED)

        BEGIN

        DELETE FROM users WHERE id=uid;                    // 通过传入的id来删除users表中的一条记录

        END //

        // 调用存储过程
        CALL removeUserId(5);    


    示例3: OUT

        DELIMITER ;;

        CREATE PROCEDURE removeIdAndReturnUserCount(IN pid INT UNSIGNED, OUT userCount INT UNSIGNED)         // OUT 定义输出的变量

        BEGIN 

        DELETE FROM users WHERE id = pid;                      // 删除指定的记录

        SELECT count(id) FROM users INTO userCount;         // 查询id字段所有的记录数，并返回userCount变量中，注意结果返回使用INTO

        END;;


        // 调用
        CALL removeIdAndReturnUserCount(3, @count);        // 执行删除并返回记录数，存储在count变量中

        SELECT @count;                // 显示变量的值



2、删除存储过程: DROP PROCEDURE 存储过程名;
</code></pre><p>—————————– 概念 —————————–</p>
<h3 id="十九、常用概念"><a href="#十九、常用概念" class="headerlink" title="十九、常用概念"></a>十九、常用概念</h3><pre><code>1、什么是存储引擎

    MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。

    每种存储引擎使用不同的存储机制、索引技术、锁定水平，最终提供广泛且不同的功能。


2、并发控制

    当多个连接对记录进行修改时保证数据的一致性和完整性

        例: 一个用户删除id=22的操作，另一个用户要读取id=22的操作，这样读取id=22就会报错

            解决这个问题就是使用并发，当迸发读或写时系统会使用锁系统，来控制读写


    1、锁

        共享锁（读锁）: 在同一时间段内，多个用户读取同一个资源，读取过程中数据不会发生任何变化.

        排他锁（写锁）: 在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其它的读锁或写锁操作.


    2、锁颗粒

        表锁: 开锁最小的锁策略

        行锁: 开锁最大的锁策略


3、事务

    事务的主要作用就是保证数据的完整性



4、外键

    保证数据一致性的策略



5、索引

    是对数据表中一列或多列进行排序的一种结构
</code></pre><h3 id="二十、Navicat工具"><a href="#二十、Navicat工具" class="headerlink" title="二十、Navicat工具"></a>二十、Navicat工具</h3><pre><code>1、导入、导出表数据

    1）导出，选择要导出的表右键 Dump SQL File 

    2）导入，选中Table右键 import Wizard...
</code></pre><blockquote>
<p>使用工具</p>
<p>Navicat</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-第三方插件收集/">Egg.js</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-第三方插件收集/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/EggJS/">EggJS</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| egg-validate POST参数规则校验  <a href="https://github.com/eggjs/egg-validate" target="_blank" rel="noopener">https://github.com/eggjs/egg-validate</a><br>| egg-mongoose Mongoose        <a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a></p>
<h4 id="egg-validate"><a href="#egg-validate" class="headerlink" title="egg-validate"></a>egg-validate</h4><pre><code>验证 Request Body的参数

$ npm i egg-validate --save  安装

// {app_root}/config/plugin.js
exports.validate = {
    package: &apos;egg-validate&apos;,
};

// 校验规则 post
async fromRule(){
    const {ctx, app} = this;

    // Request 参数规则
    const paramRule = {
        username: {type: &apos;string&apos;},
        password: {type: &apos;string&apos;},
        rememberMe: {type: &apos;boolean&apos;, required: false},
    };
    const paramErrors = app.validator.validate(paramRule, ctx.request.body);

    if(paramErrors){    // 如果为真说明校验不通过
        ctx.body = `校验失败`;
    }   
    else{
        ctx.body = `校验成功, ${ctx.request.body.username}`;
    }
}
</code></pre><h4 id="ejs-后端模板"><a href="#ejs-后端模板" class="headerlink" title="ejs 后端模板"></a>ejs 后端模板</h4><pre><code>$ npm install ejs

https://segmentfault.com/a/1190000004286562
http://www.360doc.com/content/16/0115/10/597197_528136785.shtml
https://github.com/tj/ejs
</code></pre><h4 id="nunjucks-后端模板"><a href="#nunjucks-后端模板" class="headerlink" title="nunjucks 后端模板"></a>nunjucks 后端模板</h4><pre><code>http://mozilla.github.io/nunjucks/cn/templating.html
https://github.com/eggjs/examples/tree/master/hackernews/app/view/news
</code></pre><h4 id="其它收集插件"><a href="#其它收集插件" class="headerlink" title="其它收集插件"></a>其它收集插件</h4><pre><code>1、ms返回时间 - https://github.com/zeit/ms       // ms用来返回一个时间  ms(&apos;2h&apos;) 返回 7200000  

2、MD5加密 - https://github.com/jkiss/crypto-js      npm i crypto-js --save  引用 const MD5 = require(&apos;crypto-js/md5&apos;);

3、文件上传 - https://github.com/node-modules/formstream

4、JSON串和对象互转 - https://github.com/ljharb/qs  // 可以根据key来进行排序 

5、验证码 - https://github.com/lemonce/svg-captcha/blob/master/README_CN.md
</code></pre><p>| 参考资料<br>| <a href="https://github.com/eggjs" target="_blank" rel="noopener">https://github.com/eggjs</a><br>|</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
