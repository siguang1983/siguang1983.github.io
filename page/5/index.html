<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Mot-clés</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/正则表达式/">正则表达式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/正则表达式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="特殊字符和转义序列"><a href="#特殊字符和转义序列" class="headerlink" title="特殊字符和转义序列"></a>特殊字符和转义序列</h4><pre><code>1、[...] 位于括号内的任意字符            

    /[abcde]/.test(&apos;aboot&apos;);     // 只要含有任意一个字符返回 true

    /a[bo]t/.test(&apos;abot&apos;);        // false 中间只能含有其中一个字符，匹配&apos;abt&apos;或&apos;aot&apos;

2、[^...] 不在括号中之中的任意字符

    /a[^bo]t/.test(&apos;ast&apos;);        // true a|t之间不含有b、o期中一个字符

*3、. 除了换行和Unicode行止符之外的任意字符

    /a.t/.test(&apos;a*t&apos;);        // true , &apos;a\nt&apos;换行false，使用 \.来进行转义

4、\w 任何ASCII字符,等于[a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // true, 不含有其它字符

5、\W 任何非ASCII字符单字字符，等于[^a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // false, 至少需要有一个特殊字符

6、\s 任何空格

    /\s/.test(&apos;I think&apos;);    // true

7、\S 不包含空格

    /\s/.test(&apos;I think&apos;);    // false, 非空格为true

8、\d 任何数字，等于[0-9]

9、\D 除了数字之外的任意字符

10、\b 单词边界

    例: 匹配 hi 这个词，如果写成 /hi/ 这样 &apos;wordhibiry are you&apos; 也会匹配，如果加\b会单词的分界空格处来匹配， /hi\b/.test(&apos;word hi biry are you&apos;);  true

11、\B 非单词边界 
</code></pre><h4 id="指定匹配的位置"><a href="#指定匹配的位置" class="headerlink" title="指定匹配的位置"></a>指定匹配的位置</h4><pre><code>1、^ 匹配字符串的开头

    /^ab/.test(&apos;absolute&apos;);        // true 以ab开头

2、$ 匹配字符串的结尾

    /te$/.test(&apos;absolute&apos;);        // true 以te结尾

* 3、? ! 一个反前向声明者，含义与反前向声明相反
</code></pre><h4 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h4><pre><code>1、| 用于分隔选择的字符，相当于或

    /oa|on|op/.test(&apos;option&apos;);    // true，只要带有oa、on、op都匹配

2、(...) 分组，相当于并且

    /(\d+&amp;)([a-zA-Z]+%)/.test(&apos;1234&amp;abcde%&apos;);        // true, 必须包含数据+&amp;，并且还包含英文字母+%

* 3、(?...) 只组合，把项组合到一个单元，但不记忆与该组匹配的字符

    (?:):

    (?!):

    (?&lt;=):

    (?&lt;!):
</code></pre><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><pre><code>1、{ } 匹配一个字符的重复  **** 注意{3,10} 逗号后不能有空格, 如{3, 10}        

    /^\d{1,3}$/: 最少2个数字，最多4个数字

    /^\d{4,}$/: 最少有4个数字

    /^\d{4}$/: 只能有4个数字

2、* 表示0次或多次重复,等价于{0, }    /^\d*$/

3、？最少0次, 最多1次重复，等价于{0,1}   

4、+ 表示最少出现1次，等价于{1,}

5、\1、\2 重复的子项

    var reg = /(a)(b)(c)\1/;
    var str = &quot;abca&quot;;

    // 返回 true： \1是重复第一个子项(a)，相当于/(a)(b)(c)(a)/.     \2就是第二项(b)
    console.log(reg.test(str));
</code></pre><h4 id="修饰符，高级匹配"><a href="#修饰符，高级匹配" class="headerlink" title="修饰符，高级匹配"></a>修饰符，高级匹配</h4><pre><code>1、g 匹配的是全局，检索字符串的所有匹配

    如果不加g只匹配第一个后就退出

    let reg = /你妈的|去你妈|傻逼/g;
    let content = &apos;你妈的房子傻逼是用来住的你妈的不是用来炒的去你妈的吧&apos;;
    content = content.replace(reg, &apos;***&apos;);
    console.log(content)            // ***房子***是用来住的***不是用来炒的***的吧

2、i 匹配忽略大小写

    /java/i.test(&apos;JavdaScript&apos;);        // true

3、m 进行多行匹配
</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>1、match(reg) 将匹配结果返回一个数组

    var arr = &apos;123kasdo34kk234k234234k&apos;.match(/\d+/g);        // 如果不加g，只返回第一个
    console.log(arr);        // [&quot;123&quot;, &quot;34&quot;, &quot;234&quot;, &quot;234234&quot;]

2、test() 如果没有匹配返回false否则返回true

3、search(reg) 查找并返回所在的位置，如果没有匹配的返回-1

    var result = &apos;房地产行业究竟是白银时代还是钻石时代&apos;.search(/钻石/); 
    console.log(result);        // 返回 8

4、content.replace(reg, str) 用于执行检索和替换操作

5、exec() [ɪɡ&apos;zek] 如果找到返回一个数组并存放匹配的结果，如果没有找到返回null

    var result = /白银|钻石/g.exec(&apos;房地产行业究竟是白银时代还是钻石时代&apos;); 
    console.log(result);        // [&apos;&apos;]
</code></pre><h4 id="整理经验"><a href="#整理经验" class="headerlink" title="整理经验"></a>整理经验</h4><pre><code>1、如果检查全部需要前后加匹配

    /\d+/  只对字符中存在数字就匹配

    /^\d+$/  对字符中全部为数字的进行匹配


2、test()、exec()是对每一个字符串进行匹配，如果为true就不会往下执行，并返回true

    例如: 匹配字符中不能带有.字符
    /[^\.]/.test(&apos;123123.&apos;);    // 返回true，因为第一个字符就不是.返回true不在往下执行

    /[\.]/.test(&apos;23412.34&apos;);    // 如果存在就返回true
    或者
    /^[^\.]$/g.test(&apos;asdfa.sdf&apos;) // 返回true

3、| 或符号只能用到()中，不能在[]中使用
</code></pre><h4 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h4><pre><code>1、密码强度

    // 弱密码 - 纯数字、纯字母或纯特殊字符
    /^(?:\d+|[a-zA-Z]+|[!@#$%^&amp;*]+)$/

    // 中密码 - 字母+数字，字母+特殊字符，数字+特殊字符
    /^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$/

    // 强密码 - 必须有数字、小写字母、大写字母和特殊字符
    /^(?=.*((?=[!@#$%^&amp;*_]+)[^A-Za-z0-9]))(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[^\u4e00-\u9fa5]{8,16}$/


2、手机号码验证

    /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139|186|185|170|156|155|130|131|132|189|180|170|153|133)(\d){8}$/.test(&apos;13012345678&apos;)

    移动号段: /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139)(\d){8}$/;     

    联通号段: /^(186|185|170|156|155|130|131|132)(\d){8}$/

    电信号段: /^(189|180|170|153|133)(\d){8}$/


3、验证Email - /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/

4、验证中文 - /^[\u4e00-\u9fa5]+$/

5、域名验证 - /^(http(s)?:\/\/)(www)?\.\w+\.(com|cn|net|org)$/

6、手机号前带86或是+86 - /^((\+86)|(86))?(13)\d{9}$/

7、电话号码与手机号码同时验证 - /(^(\d{3,4}-)?\d{7,8})$|(13[0-9]{9})/

8、验证IP地址 - /^((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)$/;    //  匹配0-255, 匹配&apos;255.255.255.255&apos;

9、邮政编码 - /[1-9]{1}(\d+){5}/

10、身份证号码 - /\d{18}|\d{15}/

11、双字节字符串(汉字) - /[^\x00-\xff]*/

12、去除两端空格 - /^\s*|\s*$/

数字正则

    /^\d+$/ - 非负整数（正整数 + 0)

    /^[1-9](\d)+$/ - 正整数(不可以以0开头)  

    /^-(\d)+$/ - 非正整数（负整数 + 0） 

    /^-[1-9]?(\d){0,}$/ - 负整数(-12345), 不可以-012312

    /^[1-9]?(\d)+\.(\d)+$/ - 浮点数   

    /^[+-]?\d+(\.\d{1,2})?$/ - 可以是整数 或 浮点数，并且小数点只能后两位

    ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$    //正浮点数   
    ^((-\\d+(　　//非正浮点数（负浮点数 + 0）   
    ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$  //负浮点数  

    /^[A-Za-z]+$/ - 由26个英文字母组成的字符串   

    /^[A-Z]+$/ - 由26个英文字母的大写组成的字符串   

    /^[a-z]+$/ - 由26个英文字母的小写组成的字符串  

    /^[A-Za-z0-9]+$/ - 由数字和26个英文字母组成的字符串   

    /^\w+$/ - 由数字、26个英文字母或者下划线组成的字符串
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/DOM/">DOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/DOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h4><pre><code>DOM 文档对象模型     D - Document      O - Object      M - Model
</code></pre><h4 id="Node-对象属性"><a href="#Node-对象属性" class="headerlink" title="Node 对象属性"></a>Node 对象属性</h4><pre><code>1、nodeType: 节点类型

    e.target.nodeType 来获取节点的类别

    1、Element 1

    2、Attr  2

    3、Text  3

    4、注释  8

    5、Document 9


2、nodeName: 节点名称   返回的是大写 &apos;DIV&apos;

3、nodeValue: 节点的类型

    元素节点的 nodeValue 是 undefined 或 null
    文本节点的 nodeValue 是文本本身
    属性节点的 nodeValue 是属性值

    &lt;p&gt;dfsdfsdf&lt;/p&gt;

    let oP = document.querySelector(&apos;p&apos;);   
    // 这里注意oP是元素如果直接写成oP.nodeValue返回是null，写成oP下的第一个节点才找到文本元素
    oP.firstChild.nodeValue;            

4、parentNode: 返回当前节点的父节点   e.target.parentNode.nodeName

    document.querySelector(&apos;ul&apos;).parentNode     // &lt;div class=&quot;box&quot;&gt;...&lt;/box&gt;

5、childNodes、children: 返回所有子节点元素，不包括孙节点

    &lt;ul id=&quot;list&quot;&gt;
        &lt;li&gt;111&lt;/li&gt;
        &lt;li&gt;222&lt;/li&gt;
        &lt;li&gt;
            &lt;ul&gt;
                &lt;li&gt;333&lt;/li&gt;
                &lt;li&gt;444&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;

    let oList = document.querySelector(&quot;#list&quot;);
    let lis = oList.children;
    for(let i=0; i&lt;lis.length; i++){
        console.log(lis[i].nodeName);   // output LI LI LI
    }

    ** childeNodes与children区别 ** 

        childeNodes: 包括空行的文本节点, 如果是空行的节点返回是一个text节点
        children: 不包括空行之类的节点

6、hasChildNodes(): 判断是否有子节点，返回Booleanw值

7、firstChild、lastChild: 返回子节点的第一个节点、最后一个节点

    firstChild 相当于 children[0]

    lastChilde 相当于 children[node.children.length-1]

    &lt;div id=&quot;car&quot;&gt;&lt;p&gt;aaa&lt;/p&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;/div&gt;

    let oCars = document.querySelector(&quot;#car&quot;);
    console.log(oCars.firstNode, oCars.lastNode);   //&lt;p&gt;aaa&lt;/p&gt; 、 &lt;span&gt;ccc&lt;/span&gt;

8、previousSibling、nextSibling: 当前节点的前一个节点、后一个节点

    注意: 如果是空行返回的是 text

9、innerHTML: 获取或修改HTML元素内容

    Element.innerHTML = &apos;&lt;div&gt;xxxxx&lt;div&gt;&apos;;

10、innerText: 获取或修改的是除去html的文本

11、outerHTML、outerText: 与innerHTML、innerText相当，不同的是它包含当前节点元素，inner只包含子节点元素

12、offsetParent: 获取当前元素定位的父元素  找到基于设置position的父元素

     document.querySelector(&apos;ul&apos;).offsetParent
</code></pre><h4 id="Node-对象的方法"><a href="#Node-对象的方法" class="headerlink" title="Node 对象的方法"></a>Node 对象的方法</h4><pre><code>一、节点操作方法

    1、getElementById(): 获取指定ID的元素

    2、getElementsByTagName(): 获取指定标签名称的所有元素

    3、getElementsByClassName(): 获取指定类名的元素

    4、appendChild(): 追加子节点  注意这里插入的是一个节点，而不是HTML的字符串 parent.appendChild(children);

    5、removeChild(): 删除子节点，不能删除孙子节点    (removeNode 只支持IE)

        删除节点 并返回删除的节点
        let oSubCar = document.querSelector(&apos;#subCar&apos;);
        document.querySelector(&apos;body&apos;).removeChild(oSubCar);        // &lt;div id=&quot;subCar&quot;&gt;...&lt;/div&gt;

    6、cloneNode(Boolean): 复制节点  如果参数为true复制指定节点下包括所有子节点，如果不写只复制当前节点不手包子节点

        &lt;div class=&quot;car&quot;&gt;
            &lt;ul id=&quot;box&quot;&gt;
                &lt;li&gt;aaa&lt;/li&gt;
                &lt;li&gt;bbb&lt;/li&gt;
                &lt;li&gt;ccc&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div id=&quot;subCar&quot;&gt;&lt;/div&gt;

        &lt;script&gt;
            // 将id=box所有的节点插入到id=subCar中
            let boxList = document.querySelector(&apos;#box&apos;).cloneNode(true);
            var oSubCar = document.querySelector(&apos;#subCar&apos;);
            oSubCar.appendChild(boxList);
        &lt;/script&gt;

    7、hasAttributes(): 判断当前节点是否拥有属性

        &lt;div id=&quot;miniCar&quot;&gt;&lt;/div&gt;
        &lt;div&gt;swsss&lt;/div&gt;

        let isAttribute = document.getElementsByTagName(&apos;div&apos;)[1].hasAttributes();
        console.log(isAttribute);   // false

    8、hasChildNodes(): 判断当前节点是否拥有子节点

    9、insertBefore(newitem, ex): 在指定节点之前插入

        insertAfter(): 这个需要自己来写没有这个方法

        let oMain = document.querySelector(&apos;#main&apos;);
        let oP = document.querySelector(&apos;p&apos;);
        let oUl = document.querySelector(&apos;.uls&apos;).cloneNode(true);
        oMain.insertBefore(oUl, oP);    将ul元素内所有节点复制并插入到oP元素之前

    10、replaceChild(newNode, oldNode): 替换节点

        document.querySelector(&apos;body&apos;).replaceChild(oMiniCar, oSubCar)


二、创建元素方法

    1、createAttribute(): 创建属性节点

    2、createElement(): 创建元素节点

    3、createTextNode(): 创建文本节点


三、操作属性方法

    1、getAttribute(): 获取属性值

    2、setAttribute(): 设置属性值
</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>1、style：获取或设置style值   Element.style.color = &apos;blue&apos; 

2、currentStyle、getCurrentStyle()获取样式中每个属性的值

    var oBox = document.querySelector(&apos;#box&apos;);
    var getStyle = function(obj, attr){
        return window.getComputedStyle ? window.getComputedStyle(obj, null)[attr] : obj.currentStyle[attr];
    }

    var attrTxt = getStyle(oBox, &apos;width&apos;);          // &apos;100px&apos;;

    注意: (1)中style只能获取元素中的内联样式，而currentStyle、getCurrentStyle()无论是内联样式还是在class中都可以找到

3、getComputedStyle(元素， 伪类): 获取指定元素值，currentStyle（ie独有） 

    &lt;script&gt;
        function getStyle(element, attr) {
            if(window.getComputedStyle) {
                return window.getComputedStyle(element, null)[attr];
            } else {
                return element.currentStyle[attr];
            }
        }

        // 获取class=position-node元素上的position值
        var dom = document.querySelector(&quot;.position-node&quot;);
        var style = getStyle(dom);
        console.log(style.position);    // 返回relative
    &lt;/script&gt;


    *** element.getComputedStyle与element.style的区别

    element.getComputedStyle: 只读
    element.style: 可读写

4、className: 获取或设置元素的类名  Element.addClass = &apos;classname&apos;
</code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><pre><code>1、write(): 向输出流写文本或html

2、document.title: 返回标题

4、&quot;javascript:&quot; : 伪协议 来调用javascript http协议(http://)，FTP协议(ftp://)

5、对象检测: 可以测试浏览器是否支持当前对象

    if(document.getElementById){ ...}
</code></pre><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><pre><code>1、createDocumentFragment: 创建文档碎片

    Example: 创建节点并插入到body中，如果不使用文档碎片，每次都需要重新插入一次

    var oFragment = document.createDocumentFragment();
    for(var i = 0 ; i &lt; 10; i ++) {
        var p = document.createElement(&quot;p&quot;);
        var oTxt = document.createTextNode(&quot;段落&quot; + i);
        p.appendChild(oTxt);
        oFragment.appendChild(p);
    }
    document.body.appendChild(oFragment);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、表单事件：

    submit事件

    reset事件

    click事件

    change事件

    focus事件（不冒泡） （IE和ES5支持冒泡的focusin）

    blur事件（不冒泡） （IE和ES5支持冒泡的focusout）

    input事件（ES5 textinput提供更方便的获取输入文字的方案）


2、Window事件

    load: 资源全部加载完成后触发事件（图片、css、js）

    DOMContentLoaded事件: Document对象构建完后就开始调用此事件

    readyStatechage事件:

    unload事件: 关闭borwser的时候触发

    beforeunload事件

    resize: 浏览器窗口发生改变触发

    scroll: 滚动条有变化时触发


3、鼠标事件

    click: 点击事件

    dbclick：双击事件

    mouseover: 鼠标移入事件（冒泡）

    mouseout: 鼠标移出事件（冒泡）

    mousedown: 鼠标按下事件

    mouseup: 鼠标放开事件

    contextmenu: 上下文本菜单事件

    mouseenter: 事件（不冒泡）

    mouseleave: 事件（不冒泡）

    mousewheel: 事件（FF DOMMouseScroll事件、DOM3 wheel事件）


4、键盘事件

    keydown事件

    keyup事件

    keypress事件
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/BOM/">BOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/BOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><pre><code>BOM   浏览器对象模型    B - Browser    O - Object     M - Model

BOM包含: history、location、navigator、screen 对象
</code></pre><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><pre><code>1、hash: 返回hash值

    https://xxx.com/#sdfsdf       // &apos;#sdfsdf&apos;

2、host: 返回主机地址  &apos;xxx.com&apos;

3、hostname: 返回主机名  &apos;xxx.com&apos;

4、href: 整个url地址  &quot;https://xxx.com/search?q=BOM&quot;

5、origin: 起源  &apos;https://xxx.com&apos;

6、pathName: 路由名

    &quot;https://xxx.com/search?q=BOM&quot;   &apos;/search&apos;

7、port: 端口

8、protocol: 协议  &apos;https&apos;

9、search: 参数 &apos;?q=BOM&apos;

10、reload(): 刷新浏览器

    location.reload(); // 重新加载（有可能从缓存中加载）
    location.reload(true); // 重新加载（从服务器重新加载）
</code></pre><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><pre><code>1、width、height: 整天个屏幕的宽、高

2、avaiWidth、avaiHeight: 返回显示屏幕的宽、高 除dock和系统上面的菜单栏

3、pixelDepth: 返回显示屏幕的颜色分辨率

4、updateInteval: 设置或返回屏幕刷新率
</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><pre><code>1、length: 历史记录的个数

2、go(): 指定跳转的历史、-1后退一页，1前进一页

3、back()、forward(): 后退和前进一页
</code></pre><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><pre><code>1、appCodeName: 浏览器代码名 &apos;Mozilla&apos;

2、appName: 浏览器名称    &apos;Netscape&apos;

3、appVersion: 浏览器版本  &apos;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;

4、browserLanguage: 浏览器语言

5、cookieEnabled: 是否启用了cookie 返回Boolean

    如果浏览器关闭cookie，当获取cookie时， document.cookie 返回的是空字符串

6、cpuClass: 返回浏览器系统的cpu等级

8、onLine: 是否处于脱机模式，Boolean

9、platform: 浏览器的操作平台

10、systemLanguage: 系统语言

11、userAgent: 客户机发送服务器的 user-agent 头部的值

12、userLanguage: 返回 OS 的自然语言设置


** 检测插件  ie无效
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

** 检测Flash
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

function hasIEPlugin(name){
    try{
        new ActiveXObject(name);
        return true;
    }catch(ex){
        return false;
    }
}

function hasFlash(){
    var result = hasPlugin(&quot;Flash&quot;);
    if (!result){
        result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);
    }
    return result;
}

console.log(hasFlash()) //true
</code></pre><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><pre><code>1、window.open(url, target, param): 打开一个新窗口

2、window.close(): 关闭一个窗口

3、setInterval()、clearInterval()

4、setTimeout()、clearTimeout()

5、screenLeft、screenTop: 浏览器当前窗口居屏幕的左、上角的位置  

    兼容:
    screenLeft || screenX
    screenTop || screenY

6、innerWidth、innerHeight: 浏览器可视区的宽高、包括滚动条

    let winHeight = window.innerHeight;

7、moveTo(x, y): 移动到屏幕左上角的位置

8、moveBy(0, 100): 向下移动100像素

9、resizeTo(x,y)、resizeBy(w, h)
</code></pre><h4 id="offset-页面元素偏移量"><a href="#offset-页面元素偏移量" class="headerlink" title="offset 页面元素偏移量"></a>offset 页面元素偏移量</h4><pre><code>1、offsetWidth、offsetHeight: 获取当前元素宽高，相当于 width + padding + border

2、offsetLeft、offsetTop: 获取元素到父级元素定位的左、上偏移，如果父级不是定位就以body元素为定位

3、offsetParent: 获取最近一个带有定位的父级元素

4、clientWidth、clientHeight: 元素本身的宽高、不包括padding和border

    兼容
    document.documentElement.clientWidth || document.body。clientWidth
    document.documentElement.clientHeight || document.body。clientHeight
</code></pre><h4 id="scroll-滚动类"><a href="#scroll-滚动类" class="headerlink" title="scroll 滚动类"></a>scroll 滚动类</h4><pre><code>窗口滚动条或带滚动条元素

1、scrollWidth、scrollheight: 对象内部实际内容的宽、高

2、scrollTop、scrollLeft: 被卷部分的顶部和左侧部分

    只挂载到了Element元素中，window和document下都没有

    let topValue = document.documentElement.scrollTop || document.body.scrollTop;       // 获取整个页面巻上去的高度和兼容方法

    let topValue = document.querySelector(&apos;#sider&apos;).scrollTop;      // 针对某个元素


3、onscroll: 侦听滚动条事件
</code></pre><h4 id="client-鼠标所在的可视区坐标"><a href="#client-鼠标所在的可视区坐标" class="headerlink" title="client 鼠标所在的可视区坐标"></a>client 鼠标所在的可视区坐标</h4><pre><code>1、clientX、clientY: 获取鼠标可视区的位置  clientX = width + padding

2、clientLeft、clientTop: 获取鼠标在可视区域的位置

3、pageX、pageY: 获取鼠标在页面中的位置， pageX = clientX + 页面滚动出的距离

node.onclick = function(evt){
    let evt = evt || window.evnet;
    console.log(evt.pageX, evt.pageY);
    console.log(evt.pageX, evt.pageY);
}
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、target: 点击的目标阶段事件，ie8之前使用srcElement

    var oT = evt.target || srcElement; console.log(oT);     // &lt;p&gt;xxxx&lt;/p&gt;

2、currentTarget: 事件流的捕获，目标及冒泡阶段

3、addEventListener()、attachEvent(): 注册事件

    addEventListener(&apos;click&apos;, fn, false);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/javascript设计模式/">设计模式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/javascript设计模式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/设计模式/">设计模式</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 面向对象(类型判断、封装、多态、闭包、高阶函数)<br>| 单例模式 - 命名空间、只被实例化一次<br>| 工厂模式 - 加工在输厂的过程<br>| 外观模式 - 将复杂的接口统一，用于低层兼容<br>| 适配器模式 - 将一个接口转化为另一个接口<br>| 代理模式 - 一个对象不能直接访问另一个对象时，使用代理对象<br>| 装饰者模式 - 不改变原有对象的，并对其进行拓展<br>| 桥接模式 - 提取公用的方法，并通过桥接来进行连接<br>| 享元模式 -<br>| 观察者模式 -<br>| 状态模式 -<br>| 访问者模式 -<br>|<br>| 组合模式<br>| 策略模式 - 将一组算法封装起来，使其可以相互之间替换<br>| 中介者模式</p>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><pre><code>只能将带有duckSinging()方法的对象加入到 choir 数组中

&lt;script&gt;

    // 方法一
    var duck = {
        duckSinging: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 方法二
    var chicken = {
        chicken: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 存储带有duckSinging()方法的对象
    var choir = [];

    var joinChoir = function(animal){
        if(animal &amp;&amp; typeof animal.duckSinging == &apos;function&apos;){        // 只能加入带有duckSinging()方法的对象
            choir.push(animal);
            console.log(&apos;恭喜入合唱团&apos;);
            console.log(&apos;合唱团已有成员数量&apos;, choir.length);
        }
    }

    joinChoir(duck);
    joinChoir(chicken);

&lt;/script&gt;
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>封装: 目的是将信息隐藏, 其它语言通过private、public、protected来处理访问权限

js没有这些关键字通过变量的作用域来实现封装

&lt;script&gt;
    var Book = funtcion(id, bookname, price){
        // 私有属性
        var name = 1;

        // 私有方法
        function checkId(){ }

        // 公有属性
        this.id = id;
        this.bookname = bookname;

        // 公有方法
        this.copy = function(){}

        // 特权方法
        this.getName() = function{ return name }
    }

    // 在原型 (prototype) 来添加属性和方法，有两种方式
    // 1、为原型一一添加属性和方法
    // 2、将一个对象赋给原型

    Book.prototype.display = function(){
        // 展示这本书
    }

    Book.prototype = {            // 这种方法会将prototype下的constructor被覆盖掉
        display: function(){
            // 展示这本书
        }
    }
&lt;/script&gt;

&lt;script&gt;
    // 闭包实现 1
    var Book = (function(){
        // 静态私有变量
        var bookNum = 0;

        // 静态私有方法
        function checkBook(name){}

        // 返回构造函数
        return function(newId, newName, newPrice){
            var name, price;
            function checkId(name){}
        }
    });

    Book.prototype = {
        isJSBook: false,
        display: function(){}
    }


    // 闭包实现 2
    var Book = (function(){

        // 私有变量
        var bookNum = 0;

        // 私有方法
        function checkBook(name){ }

        // 创建类
        function _book(newId, newName, newPrice){}
        _book.prototype = {}

        return _book
    })();
&lt;/script&gt;
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code>一、类式继承

    将父类的实例赋给子类的原形，类式继承的原因: 类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问

    &lt;script&gt;

        // 父类
        function Parent(){
            this.name = &apos;siguang&apos;
        }

        Parent.prototype.say = function(){ 
            console.log(this.name);
        }

        // 子类                
        function Childer(){}

        Childer.prototype = new Parent();   // 类式继承

        // 上一步执行后prototype的constructor会指向Parent，因为constructor指向还是在Paremt类上
        Childer.prototype.constructor = Childer;

        Childer.prototype.getSubValue = function(){
            console.log(&apos;getSubValue&apos;)
        }

        // 实例
        var oParent = new Parent();
        var oChilder = new Childer();

        oParent.say();                // siguang
        oChilder.say();                // siguang
        console.log(oChilder.name); // siguang
        oChilder.name = &apos;haha&apos;;
        oChilder.say();                // haha
        oChilder.getSubValue();        // getSubValue
    &lt;/script&gt;


二、构造函数式继承

    /*
    * 构造函数继承
    * 继承非prototype下的属性和方法
    */
    &lt;script&gt;
        // 父类继承
        function SuperClass(id){
            this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;];
            this.id = id;
            this.showId = function(){
                console.log(this.id);
            }
        }
        SuperClass.prototype.showBooks = function(){
            console.log(this.books);
        }

        // 声明子类
        function SubClass(id){
            // 继承父类所有公用属性和方法（this下的内容），但不继承prototype下的属性和方法
            SuperClass.call(this, id);
        }

        // SubClass.prototype.constructor = SubClass;

        var sub1 = new SubClass(10);
        var sub2 = new SubClass(20);

        sub1.books.push(&apos;设计模式&apos;);    
        console.log(sub1.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;设计模式&apos;]
        console.log(sub1.id);            // 10
        // sub1.showBooks();            // 报错，不
        sub1.showId();                    // 10

        console.log(sub2.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]
        console.log(sub2.id);            // 20
    &lt;/script&gt;


总结: 类似继承与构造函数式继承的区别

    1、类似继承: ChildreClass.prototype = new ParentClass();

        继承父类的公用属性和方法（this.的内容）和 prototype下的属性和方法, 需要改变constructor的名字

    2、构造函数式继承: ParentClass.call(this);

        只能继承公用属性和就去，不能继承父类prototype下的属性和方法, 不需要改变constructor的名字


三、原型继承

    通过一个继承方法，创建一个过渡对象，将继承的父对象赋给过渡对象的原型，在返回过渡对象的实例

    &lt;script&gt;
        var Parent = function(){
            this.blod = 20;
            this.level = 1;
        }
        Parent.prototype.getBlod = function(){
            console.log(this.blod, this.level);
        }

        Object.create = Object.create || function(obj){
            var F = function(){};        // 声明一个过渡对象
            F.prototype = obj;            // 过渡对象的原型继承父对象
            return new F();                // 返回过渡对象的一个实例，该实例的原型继承了父对象
        }

        var oParent = new Parent();
        var oChilde = Object.create(oParent);

        oChilde.blod = 30;    // 如果clone不设置blod属性，会到prototype的指向中找，最终会在oParent中找到属性
        oChilde.getBlod();    // 30 1

        oParent.getBlod();    // 20 1
    &lt;/script&gt;


四、寄生式继承

    就是将原型继承在二次封装，并返回一个对象

    &lt;script&gt;

        // 寄生式继承
        // 声明基对象
        var book = {
            name: &apos;js book&apos;,
            alikeBook: [&apos;css book&apos;, &apos;html book&apos;]
        }

        function createBook(obj){
            // 通过原型继承方式创建新对象
            var o = new inhreitObject(obj);
            // 拓展新对象
            o.getName = function(){
                console.log(this.name);
            }

            // 返回拓展新对象
            return o;
        }

        function inhreitObject(obj){
            var F = function(){};
            F.prototype = obj;
            return new F();
        }


        var oCreateBook = createBook(book);
        oCreateBook.getName();            // &apos;js book&apos;

    &lt;/script&gt;


五、多继承

    只适用于对象，不适用构造函数，继承某一个类，和继承多个类

    &lt;script&gt;

        // 单继承 属性复制
        // 这种是浅复制，象jquery等框架实现了深度复制
        var extend = function(target, source){
            // 遍历源对象中的属性
            for(var property in source){
                // 将源对象中的属性复制到目标对象中
                target[property] = source[property];
            }

            // 返回目标对象
            return target;
        }


        var book = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }
        var anotherBook = {
            color: &apos;blue&apos;
        }

        extend(anotherBook, book);
        console.log(anotherBook.name);
        console.log(anotherBook.alike);
        console.log(book, anotherBook);



        // 多继承 多个对象继承 属性复制
        var mix = function(){
            var i = 1,                    // 从第二个参数起为被继承的对象
                len = arguments.length,    // 获取参数长度
                target = arguments[0],    // 第一个对象为目标对象
                arg;                    // 缓存参数对象

            // 遍历被继承的对象
            for(; i&lt;len; i++){
                // 缓存当前对象
                arg = arguments[i];
                // 遍历被继承对象中的属性
                for(var property in arg){
                    // 将被继承对象中的属性复制到目标对象中
                    target[property] = arg[property];
                }
            }
            return target;
        }


        var book1 = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }

        var book2 = {
            tag: &apos;书&apos;
        }

        var book3 = {
            detail: &apos;产品优势&apos;
        }

        var newBook = mix(book1, book2, book3);

    &lt;/script&gt;
</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><pre><code>多态: 就是调用同一对象，通过参数发出不同指令，执行不同的结果

&lt;script&gt;

    var googleMap = {
        show: function(){
            console.log(&apos;开始渲染谷歌地图&apos;);
        }
    }

    var baiduMap = {
        show: function(){
            console.log(&apos;开始渲染百度地图&apos;);
        }
    }

    // 渲染地图
    var renderMap =  function(map){

        // 如果对象下有show方法就执行
        if(map.show instanceof Function){        
            map.show();
        }

        // 另一个判断类型模式
        // if(map &amp;&amp; typeof map.show == &apos;function&apos;){
        //     map.show();
        // }
    }

    renderMap(googleMap);
    renderMap(baiduMap);

&lt;/script&gt;
</code></pre><h4 id="闭包、高阶函数"><a href="#闭包、高阶函数" class="headerlink" title="闭包、高阶函数"></a>闭包、高阶函数</h4><pre><code>高阶函数至少满足以下条件之一

一、函数可以作为参数被传递

    &lt;script&gt;
        var getUserInfo = function(userId, callback){
            $.ajax(&apos;http://xx.com/user?uid=&apos;+userId, function(data){
                if(typeof callback == &apos;function&apos;){
                    callback();
                }
            })
        }
    &lt;/script&gt;

二、函数可以作为返回值输出

    &lt;script&gt;

        // 函数作为返回值输出
        var isType = function(type){
            return function(obj){
                return Object.prototype.toString.call(obj) === &apos;[object &apos;+ type +&apos;]&apos;
            }
        } 

        var str = &quot;sdfsdf&quot;
        var isString = isType(&apos;String&apos;);
        console.log(isString(str));        // true
    &lt;/script&gt;
</code></pre><h4 id="全局变量的解决方法"><a href="#全局变量的解决方法" class="headerlink" title="全局变量的解决方法"></a>全局变量的解决方法</h4><pre><code>避免全局函数: 1、对象方法   2、函数对象    3、构造函数

&lt;script&gt;

    // 都是全局变量
    function checkName(){
        // 验证姓名
    }

    function checkEmail(){
        // 验证邮箱
    }

    function checkPassword(){
        // 验证密码
    }

    /*
    * 方法一 对象收编全局变量
    */
    var ChceckObject = {
        checkName: function(){
            // 验证姓名
        },
        checkEmail: function(){
            // 验证邮箱
        },
        checkPassword: function(){
            // 验证密码
        }
    }


    /*
    * 方法二 函数对象
    */
    var CheckObject = function(){
        return {
            checkName: function(){
                // 验证姓名
            },
            checkEmail: function(){
                // 验证邮箱
            },
            checkPassword: function(){
                // 验证密码
            }
        }
    }

    // 调用
    var oCheck = CheckObject();
    oCheck.checkName();


    /*
    * 方法三 构造函数写法
    */
    var CheckObject = function(){
        this.checkName = function(){
            // 验证姓名
        }
        this.checkEmail = function(){
            // 验证邮箱
        }
        this.checkPassword = function(){
            // 验证密码
        }
    }

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 创建型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><pre><code>单例模式: 又被称为单体模式，只允许实例化一次的对象类

全局变量 var a = {};    属于单例对象, 不属于单例模式

jquery就是一个很大的单例,js载入时被初始化一次

    (function(){
        var jquery = (function(){})();
        window.jQuery = window.$ = jQuery;
    })(window);


一、最简单的单例就是一个对象

    var app = {
        util: {},
        tool: {},
        ajax: {}
    }


二、私有变量的单例模式，减少全局变量方法

    1、使用命名空间

        var MyApp = {};

        MyApp.namespace = function(name){
            var parts = name.split(&apos;.&apos;);
            var current = MyApp;
            for(var i in parts){
                if(!current[parts[i]]){
                    current[parts[i]] = {}
                }
                current = current[parts[i]];
            }
        }

        MyApp.namespace(&apos;event&apos;);
        MyApp.namespace(&apos;dom.style&apos;);


    2、使用闭包封装私有变量

        var user = (function(){
            var _name = &apos;sven&apos;,
                _age = 30;

            return {
                getUserInfo: function(){
                    return _name +&apos;-&apos;+ _age;
                }
            }
        })();


三、惰性单例模式

    &lt;script&gt;

        // 惰性单例模式  只有在需要的时候才会创建
        var createLoginLayer = (function() {
            var div;
            return function() {
                if (!div) {
                    div = document.createElement(&apos;div&apos;);
                    div.className = &apos;dialog&apos;;
                    div.innerHTML = &apos;我是登录窗口&apos;;
                    div.style.display = &apos;none&apos;;
                    document.body.appendChild(div);
                }

                return div
            }
        })();

        var oLoginBtn = document.querySelector(&apos;#loginBtn&apos;);
        oLoginBtn.onclick = function(){
            var oLayer = createLoginLayer();
            oLayer.style.display = &apos;block&apos;;
        }

    &lt;/script&gt;
</code></pre><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><pre><code>工厂模式: 将不同的参数传入到工厂方法中，进行加工后，然后在返回新的产品

// 创建一个工厂函数，并将结果返回
function createPerson(name, age, sex){
    var createObject = {};

    // 加工
    createObject = {    
        name: name,
        age: age,
        sex: sex,
        showInfo: function(){
            console.log(&apos;姓名:&apos;+ this.name +&quot;  年龄:&quot; + this.age);
        }
    }

    // 返回成品
    return createObject;
}

var person = createPerson(&apos;siguang&apos;, 30, &apos;男&apos;);
person.showInfo();
</code></pre><h4 id="建造者模式-builder"><a href="#建造者模式-builder" class="headerlink" title="建造者模式 builder"></a>建造者模式 builder</h4><pre><code>将一个复杂对象的构建层与表示层相互分离
</code></pre><h4 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h4><pre><code>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性及方法

&lt;script&gt;

    // 定义一个基本的图片轮播对象
    var LoopImages = function(imgArr, container){
        this.imgArr = imgArr;
        this.container = container;
    }
    LoopImages.prototype = {
        // 创建
        createImage: function(){
            console.log(&apos;loopImage createImage function&apos;);
        },
        // 切换方法
        changeImage: function(){
            console.log(&apos;LoopImage changeImage function&apos;);
        }
    }

    // 定义一个上下滑动的效果
    var SliderLoopImage = function(imgArr, container){
        LoopImages.call(this, imgArr, container);
    }
    SliderLoopImage.prototype = new LoopImages();            // 就是类似继承，并将要改变的方法重写

    // 重写切换方法
    SliderLoopImage.prototype.changeImage = function(){
        console.log(&apos;SlideLoopImg changeImage function&apos;);
    }

    var oSlider = new SliderLoopImage([&apos;1.jpg&apos;, &apos;2.jpg&apos;], &apos;#box&apos;);
    oSlider.createImage();
    oSlider.changeImage();

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 结构型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><pre><code>外观模式: 为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易

// 外观模式实现
function addEvent(dom, type, fn){
    if(dom.addEventListener){
        dom.addEventListener(type, fn, false);
    }
    else if(dom.attachEvent){
        dom.attachEvent(&apos;on&apos;+type, fn);
    }
    else{
        dom[&apos;on&apos;+type] = fn;
    }
}

var myInpurt = document.querySelector(&apos;#myinput&apos;);

addEvent(myInpurt, &apos;click&apos;, function(){
    console.log(&apos;绑定第一个事件&apos;)
})
</code></pre><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><pre><code>适配器模式: 将一个类的接口转化成另外一个接口，使类之间的接口不兼容问题通过适配器得以解决

一、如果有jQuery框架，现在A框架与jQuery框架基本相同可以将两种框架适配

    // 定义A框架
    var A = jQuery || {};

    A.g = function(id){
        return document.getElementById(id);
    }

    A.on = function(id, type, fn){
        var dom = typeofi id === &apos;String&apos; ? A.g(id) : id;
        if(dom.addEventListener){
            dom.addEventListener(type, fn, false);
        }
        else if(dom.attachEvent){
            dom.attachEvent(&apos;on&apos;+type, fn);
        }
        else{
            dom[&apos;on&apos;+type] = fn;
        }
    }

二、jquery适配器

    window.A = A = jQuery;

三、参数适配

    function doSomeThing(obj){
        var adapter = {
            name: &apos;雨夜&apos;,
            titel: &apos;设计&apos;,
            age: 30,
            color: &apos;pink&apos;,
            size: 100,
            prize: 50
        }

        for(var key in adapter){
            adapter[key] = obj[key] || adapter[key];        // 处理如果obj没有的参数
        }
        return adapter;            // 也可以使用extend();
    }
</code></pre><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><pre><code>代理模式: 由于一个对象不能直引用另一个对象，所以需要一个代理对象来为两个对象之间起到中介作用

&lt;script&gt;
    var Flower = function(){};

    var xiaoming = {
        sendFlower: function(target){
            var flower = new Flower();
            target.receiveFlower(flower);
        }
    }

    // B代理小明去给A送花
    var B = {
        receiveFlower: function(flower){
            A.listenGoodModd(function(){        // 侦听A的心情
                A.receiveFlower(flower);
            })
        }
    }

    // A接收小明的花
    var A = {
        receiveFlower: function(flower){
            console.log(&apos;收到花&apos;+ flower);
        },
        listenGoodModd: function(fn){
            setTimeout(function(){
                fn()
            }, 10000);
        }
    }

    xiaoming.sendFlower(B);
&lt;/script&gt;
</code></pre><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><pre><code>装饿者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求

&lt;p&gt;姓名: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;username&quot; /&gt;&lt;span id=&quot;usernameError&quot;&gt;Error username xxxx&lt;/span&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;密码: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;password&quot; /&gt;&lt;span id=&quot;passwordError&quot;&gt;Error password xxxx&lt;/span&gt;&lt;/p&gt;

&lt;script&gt;

    /*
    * 装饰者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求
    */

    // 点击文本框，显示提示信息，并保留原input上的事件
    var username = document.querySelector(&apos;#username&apos;);
    var password = document.querySelector(&apos;#password&apos;);

    // 基础需求，点击文本框后会加入文本内容
    username.onclick = function(){
        this.value = &apos;初始化username&apos;;
    }.bind(username);

    password.onclick = function(){
        this.value = &apos;初始化password&apos;;
    }.bind(password);


    // 新增的需求，点击后需要有提示消息，这里不破坏原有的功能
    // 装饰者方法
    var decorator = function(input, fn){
        var input = document.querySelector(input);

        // 判断事件是否已经绑定事件
        if(typeof input.onclick == &apos;function&apos;){
            // 缓存input本身的处理的事件
            var oldClickFn = input.onclick;

            // 为事件定义新的事件, 执行将新好的方法全执行
            input.onclick = function(){
                oldClickFn();
                fn();
            }
        }
        else{
            input.onclick = fn;
        }
    }

    // 调用
    decorator(&apos;#username&apos;, function(){
        document.querySelector(&quot;#usernameError&quot;).style.display = &apos;block&apos;;
    })
    decorator(&apos;#password&apos;, function(){
        document.querySelector(&quot;#passwordError&quot;).style.display = &apos;block&apos;;
    })

&lt;/script&gt;
</code></pre><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><pre><code>桥接模式: 将一个功能有共用的部分抽取出来，将实现与抽出来共用方法，通过桥接方法链接在一起，这就是桥接模式

&lt;div class=&quot;box&quot;&gt;
    &lt;span&gt;最新回答&lt;/span&gt;
    &lt;span&gt;热门回答&lt;/span&gt;
    &lt;span&gt;等待回答&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
    var box = document.querySelector(&apos;.box&apos;);
    var spans = box.getElementsByTagName(&apos;span&apos;);

    // 抽出的公用
    function changeColor(dom, color, bg){
        dom.style.color = color;
        dom.style.backgroundColor = bg;
    }

    // 桥接模式
    function bindSpan(){
        var i = 0;
        var len = spans.length;

        for(i; i&lt;len; i++){
            spans[i].onmouseover = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#ffbb96&apos;);
            }
            spans[i].onmouseout = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#fff2e8&apos;);
            }                
        }
    }

    bindSpan();
&lt;/script&gt;
</code></pre><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><pre><code>享元模式: 运用共享技术有效地支持大量细粒的对象，避免对象间有相同内容造成多余的开销
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 行为型设计模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>观察者模式 - 又称发布订阅模式或消息机制
</code></pre><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><pre><code>状态模式 - 当一个对象内部状态发生改变时，会导致行为改变

状态模式是解决程序中臃肿的分支判断语句问题，将每个分支转化一种状态独立出来

&lt;script&gt;

    // 创建一个玛丽类
    var MarryState = function(){

        // 存储内部状态
        var _currentState = {};

        // 动作与状态方法映射
        var states = {
            jump: function(){
                console.log(&apos;jump&apos;);
            },
            move: function(){
                console.log(&apos;move&apos;);
            },
            shoot: function(){
                console.log(&apos;shoot&apos;);
            },
            squat: function(){
                console.log(&apos;squat&apos;);
            }
        };

        // 动作控制类
        var Action = {

            // 改变状态方法
            changeState: function(){
                var arg = arguments;
                _currentState = {};
                if(arg.length){
                    for(var i=0, len=arg.length; i&lt;len; i++){
                        _currentState[arg[i]] = true;
                    }
                }
                return this;
            },

            // 执行动作
            goes: function(){
                console.log(&apos;触发一次动作&apos;);
                for(var i in _currentState){
                    states[i] &amp;&amp; states[i]();       // 如果动作存在并执行
                }
                return this;
            }
        }

        return {
            change: Action.changeState,
            goes: Action.goes
        }
    }


    MarryState()
        .change(&apos;jump&apos;, &apos;shoot&apos;)
        .goes()

&lt;/script&gt;
</code></pre><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><pre><code>策略模式: 定义一系列算法，把他们封装起来，并使它们可以相互替换

策略模式由两部分组成:

    1、策略类，策略类封装了具体的算法，并负责具体的计算过程

    2、环境类，接受客户的请求，把请求委托给一个策略类

Example:

    &lt;script&gt;
        // 需求根据KPI等级返回奖金金额

        // 定义策略类
        var strategies = {
            &apos;S&apos;: function(salary){
                return salary * 4;
            },
            &apos;A&apos;: function(salary){
                return salary * 3;
            },
            &apos;B&apos;: function(salary){
                return salary * 2;
            }
        }

        // 环境类
        var calculateBonus = function(level, salary){
            return strategies[level] &amp;&amp; strategies[level](salary);
        }

        console.log(calculateBonus(&apos;B&apos;, 2000));        // 4000
        console.log(calculateBonus(&apos;S&apos;, 5000));        // 20000

    &lt;/script&gt;
</code></pre><h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><pre><code>职责链模式 - 解决请求的发送者与请求的接受者之间的耦合
</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><pre><code>命令模式 - 将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数
</code></pre><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><pre><code>迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部

&lt;script&gt;
    var isType = function(type){
        var callType =  Object.prototype.toString.call(type);

        switch(callType){
            case &apos;[object Object]&apos;:
                return &apos;object&apos;;
                break;

            case &apos;[object Array]&apos;:
                return &apos;array&apos;;
                break;

            default: 
                return false;
                break;
        }
    }

    var each = function(arr, callback){
        if(isType(arr) == &apos;object&apos;){
            for(var key in arr){
                callback.call(arr[key], key, arr[key]);
            }
        }
        else if (isType(arr) == &apos;array&apos;){
            for(var i=0; i&lt;arr.length; i++){
                callback.call(arr[i], i, arr[i]);
            }
        }
    }

    each([1, 2, 3], function(index, val){
        console.log(index, val);
    })

    each({name: &apos;siguang&apos;, age: 32, sex: &apos;男&apos;}, function(key, val){
        console.log(key, val);
    })
&lt;/script&gt;
</code></pre><h4 id="发布订阅模式模式"><a href="#发布订阅模式模式" class="headerlink" title="发布订阅模式模式"></a>发布订阅模式模式</h4><pre><code>发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变，所有依赖于它的对象都将得到通知.

js中事件模型来替代传统的发布订阅模式
</code></pre><p>| <a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/ES5/">ES5</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/ES5/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h4><pre><code>1、async: 异步下载当前脚本，不阻塞后续代码的执行

2、charset: 字符集

3、defer: 表示当前脚本延迟到文档完全被解析和显示后在执行 defer=&quot;defer&quot;

4、src: 文件路径

5、language: 语言

6、type: 脚本类型

&apos;use strict&apos; 严格模式
</code></pre><h4 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h4><pre><code>作用域: 变量的有效范围，函数从内往外搜索变量，如果内部没有变量就去外部搜索直接全局对象

作用域链: 决定哪些变量能够被当前函数访问及访问顺序

    函数对象有一个[[Scope]]属性，包含了函数被创建作用域中对象的集合，集合被称为函数的作用域链scope chain，它决定了哪些数据能被函数访问

    function doSomething(){
            var blogName=&quot;Jessica&quot;;
            function innerSay(){
                    alert(blogName);
            }
            innerSay();
    }
    alert(blogName);        //脚本错误
    innerSay();             //脚本错误

变量生命周期：全局的变量是永久的，函数内的局部变量当退出函数时，局部变量即消毁，
</code></pre><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><pre><code>JS执行时先将代码中所有 var定义变量和function(){} 进行提取，函数内部变量除外。

将var的变量赋为undefined

将函数都为函数本身function getName(){}，所以在调用函数时无论在前还是在后都会被调用。

Example:
    var add = &apos;bbb&apos;; 
    function add(){console.log(&apos;aaa&apos;)} 
    add();      报错
</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code>闭包: 函数嵌套，内部函数调用外部函数的局部变量，内部函数执行完后自动消毁，外部函数的变量不会被回收一直保存在内存中.

&lt;script&gt;
    var fun = function(){
        var a = 1;
        return function(){
            a++;
            alert(a);
        }
    }

    var f = fun();        // 这里返回了匿名函数的引用，里面的局部变量就不会被消毁
    f();    // 2
    f();    // 3
    f();    // 4
&lt;/script&gt;
</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>JS的七种数据类型: Number、String、Boolean、Undefined、Object、Function、Symbol

一、 获取数据类型

    获取数据的类型: 返回的值（number、string、boolean、array、object、function、undefined、symbol）

    Object.prototype.toString.call(val) - 获取JS私有的 Class 属性, 这个隐藏的属性是不能被改的

    // 判断类型
    function returnType(val) {
        let typeName;
        if (typeof val === &apos;object&apos;) {
            let typeName = Object.prototype.toString.call(val);

            if (typeName == &apos;[object Array]&apos;) {
                return &apos;array&apos;
            } 
            else if (typeName == &apos;[object Object]&apos;) {
                return &apos;object&apos;
            }
            else if(typeName == &apos;[object Null]&apos;){
                return &apos;null&apos;
            }
        } 
        else {
            return typeof val;
        }
    }


二、NaN 非数值

    isNaN() 是否是一个NaN非数值， 如果是数字返回false, 否则返回true

        isNaN(NaN);     // true
        isNaN(10);      // false
        isNaN(&apos;10&apos;);    // false 转换后是一个数字
        isNaN(&apos;blue&apos;);  // true 转换后不会是一个数字
        isNaN(true);    // false true转换后为1是一个数字      


三、类型转换

    String to Number: 类型转换只支持十进制（30）、二进制（0b111）、八进制（0o13）、十六进制（0xFF）

    Number比parseInt和parseFloat更好的选择，一些古老的浏览器parseInt还支持0开头数字的八进制前缀，这是错误的，在任何环境下都建议传入parseInt第二个参数

    1、Number() 布尔转换成1或0，null返回0，undefined返回NaN

    2、parseiInt(num, 10): 第二个参数来规则用哪个进制来转换

    3、parseFloat(): 直接将字符串以十进制来转换
</code></pre><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><pre><code>var str = &apos;1234567&apos;;
str.length;        // 返回7

str原始值只是一个字符串，为什么会有属性和方法，它经历了一个过程叫『包装类』
JS在执行些方法的时候会隐式的转成 new String(str)，执行完后在乐逍毁掉
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>一、函数没有重载: 当两个函数名相同，后面的函数会覆盖掉之前的函数

    function getUserName(){
        console.log(&apos;a&apos;);
    }

    function getUserName(){
        console.log(&apos;b&apos;);
    }

    getUserName();      // &apos;b&apos;


二、声明函数和匿名函数

    function person() {  ...  };          // 声明
    var person = function() {  ...  }     // 匿名

    Example:

        getName();          // b
        var getName = function(){       // 优先级要高于声明函数，但要必须执行到这里才有效
            console.log(&apos;a&apos;);
        };

        getName();          // a

        function getName(){
            console.log(&apos;b&apos;);
        }
        getName();          // a


三、函数参数

    1、形参、实参

        function add(a, b){ return a+b }    // 形参

        add(1,2)    // 实参


    2、arguments数组: 函数参数的数组

    3、callee 函数的调用当前函数的本身，可以使用arguments.caller(), 可以用于递归

        function factorial(num){
            if(num &lt; 1){
                return 1;
            }
            else{
                return num * arguments.callee(num-1);
            }
        }

    4、caller 返回被调用函数的本身

        function outer() {
            inner();
        }

        function inner() {
            alert(arguments.callee);        // function inner(){ ... }
            alert(arguments.callee.caller); // function outer(){ ... }
        }

        outer();

四、如果函数没有return返回undefined

    var fn = function(){ }; 
    fn();       // undefined
</code></pre><h4 id="call-、apply-、bind"><a href="#call-、apply-、bind" class="headerlink" title="call()、apply()、bind()"></a>call()、apply()、bind()</h4><pre><code>Function.prototype.call() 和 Function.prototype.apply() 用于改变函数的this指向

一、call无参

    var obj1 = {
        name: &apos;siguang&apos;,
        getName: function(){
            return this.name;
        }
    }
    var obj2 = {
        name: &apos;lulu&apos;
    }
    console.log(obj1.getName());  // siguang

    // 注意这里是将getName中的this指定指向了obj2，并且执行了getName()函数
    var n1 = obj1.getName.call(obj2);
    console.log(n1);        // lulu


二、apply有参

    var objA = {
        num: 10,
        add: function(a, b){
            return a + b + this.num;
        }
    }
    var objB = {
        num: 20
    } 

    var n1 = objA.add(1, 2);
    console.log(n1);    // 13

    var n2 = objA.add.call(objB, 1, 2);     // 如果objA.add.apply(objB, [1,2]);
    console.log(n2)     // 23


三、bind(): 一个函数绑定之后，可以保持传递this的上下文

    bind与call、apply的用法不同，但作用是一样的.

    var obj = {
        nameStr: 20,
        getName: function(){
            setTimeout(function(){
                console.log(this.nameStr);
            }.bind(obj), 10)
        }
    }

    // 输出20，如果不加bind()，this指向window所以输出的是undeined
    obj.getName();
</code></pre><h4 id="void-0"><a href="#void-0" class="headerlink" title="void(0)"></a>void(0)</h4><pre><code>这个操作符允许插入一个计算结果等效于undefined的表达式。

void操作符经常仅仅是用来获得undefined值，比如经常使用到的“void(0)”(这等效于“void 0”)

当浏览器遇到一个javascript:URI，它会运算带有URI的代码，然后将计算结果替换当前页面的内容，除非它的返回值是undefined。void操作符可以被用于返回undefined

&lt;a href=&quot;javascript:void(0);&quot;&gt;Click here to do nothing&lt;/a&gt;
</code></pre><h4 id="装箱、拆箱转换"><a href="#装箱、拆箱转换" class="headerlink" title="装箱、拆箱转换"></a>装箱、拆箱转换</h4><pre><code>一、装箱: 把基本类型转换为对应的对象

    var symbolObject = Object(Symbol(&quot;a&quot;));
    console.log(typeof symbolObject);                   // object
    console.log(symbolObject instanceof Symbol);        // true 是Symbol的实例
    console.log(symbolObject.constructor == Symbol);    // true


二、拆箱

    对象到String和Number转换同都遵循『先拆箱在转换』的规则，通过拆箱把对象变成基本类型，在从基本类型转为string或number

    toString(): 将该对象的原型始以字符串形式返回   xx.toString();       // &apos;xx&apos;

    valueOf(): 返回最适合该对象的类型的原始值
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>var testA = 3 &amp;&amp; 2;             // 返回 2，如果左侧为真返回右侧，否则返回左侧

var testB = 0 || 3;             // 返回3，如果左侧为假返回右侧

var a = 1; console.log(!!a);    // 返回true，!!强制转换成布尔值

var a = &apos;123.563&apos;; console.log( +a );  // 123.563，+转换成数值类型
</code></pre><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><pre><code>for(var i=0; i&lt;10; i++){}

do{....} while(express)

while(){ ... }

for( in ){}

break 退出整个循环        continue 跳出当前循环，继续执行下一个循环

switch case default
</code></pre><h4 id="定时器的运行机制"><a href="#定时器的运行机制" class="headerlink" title="定时器的运行机制"></a>定时器的运行机制</h4><pre><code>JavaScript是通过事件循环（event loop）来实现的，事件循环机制也就是今天要说的JavaScript运行机制。

第一，判断JS是同步还是异步，同步进入主线程，异步则进入event table。

第二，异步任务在event table中注册函数，当满足触发条件后，被推入event queue(事件队列)。

第三，同步任务进入主线程后一直执行，直到主线程空闲，才会去event queue中查看是否有可执行的异步任务，如果有就推入主线程

异步为了避免一些长时间任务造成的无意义等待，和假死状态 - ajax、定时器、Promise

Example:

    // HTML5规范规定最小时间不能小于4ms(毫秒)，如果小于4会被当4来处理，Chrome可以设置1ms
    console.log(1);
    setTimeout(function(){
        console.log(2);
    }, 0);
    console.log(3);         // 1、3、2
</code></pre><h4 id="JS异步有哪些方式"><a href="#JS异步有哪些方式" class="headerlink" title="JS异步有哪些方式"></a>JS异步有哪些方式</h4><pre><code>1、setTimeOut()

2、Promise

3、Generator

4、async、await

5、ajax
</code></pre><h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><pre><code>JS的运行机制。也就是事件循环。解释一下：

    第一，执行一个宏任务（主线程的同步script代码），过程中如果遇到微任务，就将其放到微任务的事件队列里。

    第二，当前宏任务执行完成后，会查微任务的事件队列，将全部的微任务依次执行完，再去依次执行宏任务事件队列。

    宏任务：包括整体script代码，setTimeout，setInterval

    微任务：Promise，process.nextTick。

setTimeout(() =&gt; {
    console.log(1) 
}, 3000); 

new Promise((resolve, reject) =&gt; { 
    console.log(2); 
    resolve(&apos;2&apos;) 
})
.then(function(){  
    console.log(3) 
});

console.log(4);                // output 2、4、3、1
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>一、事件机制: 事件捕获 和 事件冒泡, IE11之前没有捕获

二、事件委托

    事件委托（也称事件代理）: 将事件绑定到父元素上，利用冒泡机制来对点击的元素进行处理

    &lt;div id=&quot;boxList&quot;&gt;
        &lt;ul&gt;
            &lt;li data-attr=&quot;a1&quot;&gt;aaa&lt;/li&gt;
            &lt;li data-attr=&quot;a2&quot;&gt;bbb&lt;/li&gt;
            &lt;li data-attr=&quot;a3&quot;&gt;ccc&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var oList = document.querySelector(&apos;#boxList&apos;);
        oList.onclick = function(e){
            var arrtName = e.target.getAttribute(&apos;data-attr&apos;);
            console.log(arrtName);
        }
    &lt;/script&gt;


三、自定义事件

四、onLoad与DOMContentLoaded事件的区别

    onLoad: 是当所有资源都加载完成后在执行onLoad函数内的程序

    DOMContentLoaded: 是当DOM树加载完成后就执行此函数内的程序


五、onmouseover、onmouseout与onmouseEnter、onmouseLeave

    onmouseover、onmouseout 会冒泡

    onmouseEnter、onmouseLeave 不会冒泡


六、addEventListener(事件类型, 执行函数, boolear): 第三个参数，如果是true表示在捕获取中调用事件，false冒泡时调用

    这里执行的函数不会被重载

    var oSendBtn = document.querySelector(&apos;#sendBtn&apos;);      // 点击会输出&apos;aa&apos;, &apos;bb&apos;

    oSendBtn.addEventListener(&apos;click&apos;, function(){
            console.log(&apos;aa&apos;);
    }, false);

    oSendBtn.addEventListener(&apos;click&apos;, function(){
            console.log(&apos;bb&apos;);
    }, false);
</code></pre><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>一、加载非阻塞脚本:  

    浏览器遇到 &lt;script&gt; 标签时，页面加载都会停下来，先执行js代码，然后在继续加载（因为不知道脚本里有没有document.wirte()
    来向页面写内容，所以会需要先执行完js文件在继续）

    使用动态创建DOM元素，将脚本加载放到&lt;/body&gt;之前来加载，这样不会影响页面的内容展示


二、按需加载: 可以分图片按需加载，js文件按需加载、数据接需加载

    图片按需加载使用的lazyload

    JS按需加载类似模块化开发，只对依赖的文件进行加载


三、图片预加载: 通过new Images()来创建图像对象提前将图片进行加载

    function preloadImg(url) {
        var img = new Image();
        img.src = url;
        if(img.complete) {
            //接下来可以使用图片了
            //do something here
        }
        else {
            img.onload = function() {
                //接下来可以使用图片了
                //do something here
            };
        }
    }
</code></pre><h4 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h4><pre><code>由于同源策略，安全性，ajax不同域下的数据不可以调用

跨域的产生: 1、同域名不同端口        2、同域名不同协议        3、主域和子域之间        4、子域和子域之间

解决跨域的方法: 

一、JSONP

    JSONP利用script标签中的src属性，src属性没有跨域限制，通过url的参数将回调函数的名称和数据请求给服务器，服务器接收到url参数进行处理，并将数据挂载到回调函数的参数并执行回调函数，客户端有与回调函数名相同，来处理这些数据

    // 处理回调函数数据的函数
    function doSomething(data) {
            // 对data处理
    }
    var script = document.createElement(&quot;script&quot;);
    script.src = &quot;http://www.b.com/b.html?callback=doSomething&quot;;
    document.body.appendChild(script);


二、document.domain: 

    适用于主域相同子域不同，比如 www.renrendai.com 和 action.renrendai.com

    例如: 两个域下各有a.html和b.html, a通过iframe嵌到另一个子域b.html是无权访问b.html文档内的元素, 所以通过document.domain来设置

    a.html: 
        document.domain = &quot;www.we.com&quot;;
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://a.we.com/b.html&quot;;
        document.body.appendChild(iframe);
        iframe.onload = function() {
            console.log(iframe.contentWindow....); // 在这里操作b.html里的元素数据
        }

    b.html:
        document.domain = &quot;www.we.com&quot;;       // b页面必须要设置a.html


三、HTML5 postMessage() 处理iframe跨域问题

    如果在一个主域中的a.html嵌套个 &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

    postMessage有两个接口: postMessage(send) 发送数据和 onmessage接收数据事件通过e.data来获取到

    Example: 
        // a.html
        &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot; id=&quot;messageId&quot;&gt;&lt;/iframe&gt;

        var oMessage = document.getElementById(&apos;messageId&apos;);
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收b的数据
            }, false);
            oMessage.postMessage(&apos;发送给b的数据&apos;, &apos;http://www.b.com/b.html&apos;);
        }

        // b.html
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收a的数据
            })
            window.parent.postMessage(&apos;发送给a的数据&apos;, &apos;http://www.a.html/a.html&apos;);
        }

    传统的iframe跨域使用方法: http://www.cnblogs.com/snandy/p/3900016.html


四、window.name + iframe

    window.name原理是利用同一个窗口在不同页面共用一个window.name，这个需要在a.com下建立一个代理文件c.html，使同源后a.html能获取c.html的window.name.

        // a.html
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.b.com/b.html&quot;;
        document.body.appendChild(iframe); // 现在a.html里建一个引用b.html的iframe，获得b的数据

        var flag = true;
        iframe.onload = function() {
            if (flag) {
                iframe.src = &quot;c.html&quot;;          // 这里在去加载c.html
                // 判断是第一次载入的话，设置代理c.html使和a.html在同目录同源，这样才能在下面的else取到data
                flag = false;
            } 
            else { 
                // 第二次载入由于a和c同源，a可以直接获取c的window.name
                alert(iframe.contentWindow.name);

                iframe.contentWindow.close();
                document.body.removeChild(iframe);
                iframe.src = &apos;&apos;;
                iframe = null;
            }
        }

        // b.html
        window.name = &quot;这是 b 页面的数据&quot;;


五、window.location.hash + iframe

    b.html将数据以hash值的方式附加到c.html的url上，在c.html页面通过loaction.hash获取数据后传到a.html

    // a.html
    var iframe = document.createElement(&quot;iframe&quot;);
    iframe.src = &quot;http://www.b.com/b.html&quot;;
    document.body.appendChild(iframe); // 在a页面引用b
    function check() { 
        // 设置个定时器不断监控hash的变化，hash一变说明数据传过来了
        var hashs = window.location.hash;
        if (hashs) {
            clearInterval(time);
            alert(hashs.substring(1));
        }
    }
    var time = setInterval(check, 30);

    //b.html
    window.onload = function() {
        var data = &quot;this is b&apos;s data&quot;; 
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.a.com/c.html#&quot; + data;         
        document.body.appendChild(iframe); // 将数据附加在c.html的hash上
    }

    //c.html
    // 获取自身的hash再传到a.html的hash里，数据传输完毕
    parent.parent.location.hash = self.location.hash.substring(1);


六、CORS跨域资源共享

    1、CORS概念: 是指跨域资源共享, 用于解决前端跨域问题, 使用自定义头部让浏览器与服务器进行沟通, 来进行请求成功或失败

        原理: 服务器对header设置一个Access-Control-Allow-Origin: *, 开启跨域请求。

        *表示接受所有域名的请求。也可以指定特定的域名 Access-Control-Allow-Origin: http://www.client.com。


    2、CORS优点: 跨域最常用的是JSONP但这种方式是通过Get的方式请求src完成的，很多跨域问题JSONP无法解决，比如: 

        1）post请求跨域

        2）&quot;script error&quot; 的脚本错误提示

        3）canvas中无法获取跨域图片的信息，如果使用CORS上面几个问题就可以解决


    3、CORS缺点: 

        1）cookie不会随请求发送，也不会响应

        2）不能设置请求头的Content-Type字段

        3）不能访问响应头信息
</code></pre><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><pre><code>面向对象的特点: 封装、继承、多态

对象组件: 私有、公有属性、方法和特权方法

一、对象的数据属性和访问器属性（getter、setter）

    var o = { a: 1 };
o.b = 2;
console.log(o.a, o.b); //1 2

二、constructor属性: 指向这个原型的构造函数，如果是类式继承需要修改子类的constructor的指向，如果不改子类会指向父类.

三、原型和原型链: 

    prototype原型: 在创建函数的时候JS会为这个函数自动加上prototype属性

    原型链: 每一个构造函数都有一个prototype, prototype包含一个指向构造函数的指针, 而实例包含指向原型的对象的指针, 都是通过 __proto__ 属性来指向

    1、构造函数实例化后，prototype下的所有属性和方法都为公用的一套, 这样为了节省资源提高性能

    2、优先级: 如果同时在构造函数内或prototype中定义相同的属性或方法名, 会先找到执行构造函数内的属性或方法, 如果没有在到prototype中查找。

            __proto__属性: __proto__是实例与prototype之间的链接，实例的__proto__指向构造函数的prototype.function F(){}; 

            var f = new F(); 
            console.log(f.__proto__ === F.prototype);           // true
            Object.prototype是顶级对象，所有对象都继承它

四、继承

    每个对象都是由Object.prototype对象继承的

        继承分为: 类式继承、原型链继承、拷贝继承。

        1、类式继承: 

            function Parent(){}
            Parent.prototype.say = function(){ 
                console.log(&apos;haha&apos;)
            }

            function Childer(){}

            /* 将第一个类的实例赋给第二个类的原形，类式继承的原因
            *  类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问
            */
            Childer.prototype = new Parent();   

            // 上一步执行后prototype的constructor会指向Parent，所以需要修正回来
            Childer.prototype.constructor = Childer;    
            Childer.prototype.getAuthor = function(){ console.log(&apos;siguang&apos;) }


        2、原型链继承: 

            // 原型链式继承
            /*
            * 流程:
            * 1、clonePlan调用blood属性会在clonePlan查找所有属性，
            * 2、如果没有找到在看clonePlan的__proto__指象哪里，这里指向了F，到F对象下的prototype下查找
            * 3、plane将prototype赋给了F的prototype所以最终找到了blood属性
            */

            function extend(obj){
                    var F = function(){};
                    F.prototype = obj;
                    return new F();
            }

            // 定义一个类
            var Plane = function(){
                    this.blood = 100;
                    this.attackLevel = 1;
                    this.defenseLevel = 1;
            }
            Plane.prototype = {
                    getBlood: function(){
                            console.log(this.blood);
                    },
                    getAttackLevel: function(){
                            console.log(this.attackLevel)
                    }
            }
            var plane = new Plane();

            // 将类通过extend函数继承过来
            var clonePlan = extend(plane);
            clonePlan.blood = 1234;
            clonePlan.attackLevel = 4567;

            clonePlan.getBlood();               // 1234
            clonePlan.getAttackLevel();         // 4567


        3、拷贝继承

            function extend(parent, childer){
                for(var key in parent){
                    childer[key] = parent[key];
                }
            }

            extend(a.prototype, b.prototype);


        4、Object.create()继承

            function Car(desc){
                this.desc = desc;
                this.color = &apos;red&apos;
            }

            Car.prototype = {
                getInfo: function(){
                    return `color: ${this.color}, desc: ${this.desc}`
                }
            }

            // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
            var child = Object.create(Car.prototype);
            child.desc = &apos;aaa&apos;;
            child.color = &apos;bbb&apos;;

            // 改变子类不会影响到父类
            console.log(child);
            var childCar = child.getInfo();
            console.log(childCar)       // color: bbb, desc: aaa

            var oCar = new Car(&apos;ccc&apos;);
            console.log(oCar.getInfo());    /// color: red, desc: ccc


五、SuperClass.prototype = {} 与 SuperClass.prototype.getName = function(){} 区别

    一个是将对象覆盖prototype, 一个是将方法添加到prototype中

    存在的问题，SuperClass.prototype = {}这种方式，实例的对象没有constructor,
</code></pre><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><pre><code>一、XMLHttpRequrest 缓存

    缓存只有在get请求中存在，如果服务端设置了缓存，如果在缓存失效前请求就会取到缓存的数据，解决有两种方法:

    1、加If-Modified-Since头

        xhr.setRequestHeader(&apos;If-Modified-Since&apos;, &apos;0&apos;);

        jquery中设置  $.ajax({ cache: false })

    2、给请求的URL后加参数 

        let sendUrl = &quot;http://host/getUser&quot;+&quot;?&quot;+Math.random();


// 创建一个XMLHttpRequest对象
var xhr = window.XMLHttpRequrest ? new XMLHttpRequrest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);   

属性: 服务器响应

    1、reponseText: 字符串响应数据

    2、responseXML: 获取XML响应数据

    3、timout: 设置超时请求时间

    4、responseType: 设置返回数据类型

            1、text: 字符串      2、document: Document对象       3、json: json数据       4、blob: 二进制对象       5、arrayBuffer: 二进制

方法: 

    1、open(请求类型，请求地址，同步/异步): 请求类型

    2、send(): 请求发送到服务器

    3、setRequestHeader(key，value): 设置请求头

    4、getResponseHeader(header)、getAllResponseHeaders(): 获取响应头

事件: 

    1、onabort: 停止传输

    2、onerror: 错误

    3、onload: 

    4、ontimout: 超时执行的事件

    5、onreadystatechange: 请求发送到服务器时，接收一些响应

        readyState: XMLHttpRequest的状态，

            0: 请求未初始化    1、服务器连接已建立      2、请求已接收     3、请求处理中     4、请求已完成，已响应

        status:  200: 成功  404:  未找到资源

        xhr.onreadystatechange = function(e){
            if(this.readyState == 4 &amp;&amp; this.state == 200){
                console.log(this.reponseText)
            }
        }

    6、upload: 上传 XMLHttpRequestUpload

        function uploadFile() {  
            // 创建FormData对象
            var fd = new FormData();
            // 添加值
            fd.append(&quot;fileToUpload&quot;, document.getElementById(&apos;fileToUpload&apos;).files[0]); 

            // 创建XMLHttpRequest()请求
            var xhr = new XMLHttpRequest();  
            // 文件上传时侦听progress事件
            xhr.upload.addEventListener(&quot;progress&quot;, uploadProgress, false);  

            xhr.addEventListener(&quot;load&quot;, uploadComplete, false);    // 载入 
            xhr.addEventListener(&quot;error&quot;, uploadFailed, false);     // 错误
            xhr.addEventListener(&quot;abort&quot;, uploadCanceled, false);   // 终止

            // 请求方式和地址
            xhr.open(&quot;POST&quot;, &quot;test2.php&quot;);  
            // 发送请求到服务器
            xhr.send(fd);  
        }

        function uploadProgress(evt) { 
            // evt.loaded 当前上传的大小， evt.total 文件总大小
            if (evt.lengthComputable) {  
                var percentComplete = Math.round(evt.loaded * 100 / evt.total);  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = percentComplete.toString() + &apos;%&apos;;  
            }  
            else {  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = &apos;unable to compute&apos;;  
            }
        }

        function uploadComplete(evt) {  
            /* This event is raised when the server send back a response */  
            alert(evt.target.responseText);  
        }

        function uploadFailed(evt) {  
            alert(&quot;There was an error attempting to upload the file.&quot;);  
        }

        function uploadCanceled(evt) {  
            alert(&quot;The upload has been canceled by the user or the browser dropped the connection.&quot;);  
        }
</code></pre><h4 id="content-type四种类型"><a href="#content-type四种类型" class="headerlink" title="content-type四种类型"></a>content-type四种类型</h4><pre><code>get请求包括请求头、状态行

post请求包括请求头、状态行、请求主体（主体类型设置就是content-type来处理）

Content-Type:

一、application/x-www-form-urlencoded: 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据

    jquery和ajax的默认的方式 content-type:「application/x-www-form-urlencoded;charset=utf-8」

    header:
    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/x-www-form-urlencoded;charset=utf-8 

    ** Form Data

        incomeTime: &quot;16:25:13&quot;
        serialNumber: &quot;223&quot;
        incomeBank: &quot;中央银行&quot;
        incomeAccount: &quot;穷逼&quot;


二、multipart/form-data: 一般用来上传文件，必须让 form 的 enctyped 等于这个值

    content-type: multipart/form-data

    POST http://wwwexamplecom HTTP/11 
    Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA 

    ** Request Payload

            ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
            Content-Disposition: form-data; name=&quot;text&quot; 

            title 
            ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
            Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chromepng&quot; 
            Content-Type: image/png 

            PNG  content of chromepng  
            ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 


三、application/json: 告诉服务端消息主体是序列化后的 JSON 字符串

    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/json;charset=utf-8 

    // ajax请求
    var data = {&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]};
    $ajaxpost(url, data)success(function(result){

    });

    // 发送
    POST http://wwwexamplecom HTTP/11
    Content-Type: application/json;charset=utf-8

    ** Request Payload

        {&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]}


四、text/xml: XML文件作为编码方式的需要用到的类型

    POST http://wwwexamplecom HTTP/11
    Content-Type: text/xml

    ** Request Payload


五、HTML5中的fromData异步上传表单

    这里注意需设置 content-type:false 和 processData: false

    function upThumbSubmit() {
        if(!windowFormData) {　
            alert(&apos;your brower is too old&apos;);
            return false;
        }
        var formData = new FormData($( &quot;#upForm&quot; )[0]);
        var upLoadFile = documentquerySelector(&apos;upfile&apos;)files[0];
        formDataappend(&apos;file&apos;: upLoadFile);

        $ajax({
            url:&apos;?c=api&amp;a=upload&apos;,
            type:&apos;post&apos;,
            data:formData,
            processData: false,        // 不会被序列化
            contentType: false,        
            dataType:&apos;json&apos;,
            success:function(data){
                alert(data);
                return false;
            }
        });
    }
</code></pre><h4 id="iframe父子页面的通信"><a href="#iframe父子页面的通信" class="headerlink" title="iframe父子页面的通信"></a>iframe父子页面的通信</h4><pre><code>Example:

    parent.html:
        &lt;body&gt;
            &lt;iframe src=&quot;child.html&quot; frameborder=&quot;0&quot; id=&quot;child&quot;&gt;&lt;/iframe&gt;
        &lt;/body&gt;

    childe.html:
        &lt;body&gt;
            &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
        &lt;/body&gt;

一、父页面获取子页面

    &lt;script&gt;
        var myIframe = document.querySelector(&apos;#child&apos;), 
                childDocument;

        if(myIframe.document){
            childDocument = myIframe.docuemnt;
        }
        else{
            childDocument = myIframe.contentWindow.docuemnt;
        }

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;
    &lt;/script&gt;

    1、先获取iframe节点

        var myIframe = document.querySelector(&apos;#child&apos;);        // 或 myIframe = window.frames[&apos;child&apos;];

    2、获取iframe页面的document对象

        // ie浏览器
        var childDocument = myIframe.docuemnt;

        // 其它浏览器
        var childWindow = myIframe.contentWindow;     // 获取iframe的window对象
        var childDocument = myIframe.contentWindow.docuemnt;    // 获取iframe的document对象
        var childDocuemnt = myIframe.contentDocument;   // 也是获取document对象  与 myIframe.contentWindow.docuemnt 相同

    3、向id=&apos;box&apos;设置内容

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;


二、子页面获取父页面

    1、获取父页面的document对象

        var parentDocument = window.parent.document;

    2、如果iframe嵌套多个iframe，想直接取到最顶层的iframe

        var selfDocument = window.self.document;
</code></pre><p>——————— ES5 API ————————</p>
<h4 id="提供全局的JSON对象"><a href="#提供全局的JSON对象" class="headerlink" title="提供全局的JSON对象"></a>提供全局的JSON对象</h4><pre><code>1、JSON.parse(): 将字符串转成对象

2、JSON.stringify(): 将对象转成字符串
</code></pre><h4 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h4><pre><code>1、push(): 向数组最后插入内容   unshift():向数据最前面插入一项

2、pop(): 删除数组最后一项内容  shift(): 删除数组第一项内容

    var arr = [1, 2, 3];   
    console.log(arr.pop());     // 3
    console.log(arr)    // [1, 2]

3、reverse(): 数组顺序颠倒

4、sort(): 排序

    let arr = [1, 123, 23, 4, 125, 6, 2, 31];
    arr.sort(function(v1, v2) {
        return v1 &lt; v2 // 从大到小排列
    })

5、concat(): 两个数组进行合并, 也可以拷贝成为一个新数组，而不是带指向

    var arrA = [1,2,3];
    var arrB = arrA.concat();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

6、slice(开始，结束): 返回一个子数组,  如果结束参数不传为从开始取到最后的值

    let arr = [125, 123, 31, 23, 6, 4, 2, 1];
    let newArr = arr.slice(2, 5);  
    console.log(newArr, arr);        // [31, 23, 6]    [125, 123, 31, 23, 6, 4, 2, 1]

7、splice(): 用于替换、插入、删除

    splice(1,3): 删除 下标1-3的数据
    splice(3,0, &apos;insert&apos;): 插入 在位置3一个&apos;insert&apos;字符串
    splice(2,4, &apos;replce&apos;): 替换 将2-4的数组用 &apos;replce&apos;符

8、indexOf(): 查找数组中指定的字位的位置，未找到返回-1

    var arr = [1,2,3,4,5,6];  arr.indexOf(3);         // 返回2

9、lastIndexOf(): 查找数组中指定的字位的位置，从后向前查找，未找到返回-1


* 迭代方法

10、every(): 每一项为true，结果返回true

    // 数组中是否包含大于2的数
    var num = [1,2,3,2,1];
    var result = num.every(function(item,index,array) {    // item: 1, index: 0, array: [1,2,3,2,1]
        return (item &gt; 2);
    })
    console.log(result);        // true


11、some(): 有一项为true就不会往下执行，并返回true

    var dwarfPlanets = [&quot;ceres&quot;, &quot;pluto&quot;, &quot;haumea&quot;, &quot;makemake&quot;, &quot;eris&quot;];
    var result = dwarfPlanets.some(function(element) {
        return (element === &quot;pluto&quot;);
    });   
    console.log(result)     // true


5、filter(): 条件中返回true结果，重新返回一个新数组

    var arr = [1, 2, 3, 2, 5, 7];
    var result = arr.filter(function(item,index,array){
        return (item &gt; 2);
    })
    console.log(result);        // [3, 5, 7];


6、forEach(): 遍历数组, forEach无法跳出循环, 只能通过try...catch

    var arr = [&apos;lulu&apos;, &apos;siguang&apos;, &apos;mama&apos;, &apos;baba&apos;];
    arr.forEach(function(item, index, arr){  // lulu  0  [&quot;lulu&quot;, &quot;siguang&quot;, &quot;mama&quot;, &quot;baba&quot;]
        console.log(&apos;name:&apos;+item, index, arr);
    })


7、map(): 将每次return的数据，最终组成一个数组返回

    var srcColors = [
        {r: 255, g: 255, b: 255 },
        {r: 128, g: 128, b: 128 },
        {r: 0,   g: 0,   b: 0   }
    ];

    var newColor = srcColors.map(function(item, index, arr){         
        return item.r;
    })
    console.log(newColor);        // 返回 [255, 128, 0]


8、reduce(上次执行的结果，当前值，当前索引，数组对象)、reduceRight(): 归并数组，每次循环都会返回上一次值和当前值

    var val = [1,2,3,4,5];
    var sum = val.reduce(function(prev, cur, index, arr){   // prev 第一次执行的是1, 第二次执行的就是上次1+2返回的结果
        return prev + cur;   
    })
    console.log(sum);   // 15
</code></pre><h4 id="对象属性和方法"><a href="#对象属性和方法" class="headerlink" title="对象属性和方法"></a>对象属性和方法</h4><pre><code>1、__proto__: 对象实例与prototype之间的连接，原型链

2、prototype: 原型，公用的，节省内存开支，查找先去对象本身找属性和方法，如果没有到prototype下查找

3、constructor: 保存用于创建当前对象的构造函数名

4、toString()、valueOf()

5、delete: 删除对象属性

6、hasOwnProperty(propertyName): 判断对象属性是否在对象中（而不是prototype原型中） var obj = {name: &apos;aaa&apos;}; obj.hasOwnProperty(&apos;name&apos;)

    function Persion(){
        this.name = &apos;siguang&apos;;
    }
    Persion.protoType = {
        age: 35,
        getName: function(){
            return this.name;
        }
    }
    let oPer = new Persion();
    oPer.hasOwnProperty(&apos;name&apos;);        // true
    oPer.hasOwnProperty(&apos;age&apos;);            // false

7、isPrototypeOf(object): 判断传入的对象是否是传入对象的原型

    var o = new Object();
    Object.prototype.isPrototypeOf(o)

8、instanceof: 用来判断一个构造函数的prototype属性是否在另一个检测对象的原型链上

    class A {};
    let oA = new A():
    console.log(oA instancof A);        // true

9、in: 属性是否在对象中能访问，返回true或false

    function Persion(){
        var sex = &apos;男&apos;;
        this.name = &apos;siguang&apos;;
    }
    Persion.prototype.age = &apos;haha&apos;;

    var p1 = new Persion();
    console.log(&apos;name&apos; in p1);      // true
    console.log(&apos;age&apos; in p1);       // true
    console.log(&apos;sex&apos; in p1);       // false;


10、Object.create(o, p): 可以创建一个干净的对象，给o对象创建一个prototype，如果p对象存在

    var oA = Object.create(null);    // 创建一个干净的对象，没有__proto__属性
    var oB = {};        // 存储__proto__

    function Car(desc){
        this.desc = desc;
        this.color = &apos;red&apos;
    }

    Car.prototype = {
        getInfo: function(){
            return `color: ${this.color}, desc: ${this.desc}`
        }
    }

    // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
    var child = Object.create(Car.prototype);
    child.desc = &apos;aaa&apos;;
    child.color = &apos;bbb&apos;;

    // 改变子类不会影响到父类
    console.log(child);
    var childCar = child.getInfo();
    console.log(childCar)       // color: bbb, desc: aaa

    var oCar = new Car(&apos;ccc&apos;);
    console.log(oCar.getInfo());    /// color: red, desc: ccc

    1) Object.create()与new Object()的区别

        var Base = function () {}
        var o1 = new Base();
        var o2 = Object.create(Base);

        Object.create(null) 是创建一个空对象，这个对象不继承Object.prototype原型链上的属性或方法


11、Object.defineProperty(obj, prop, descriptor): 对象新增或修改一个属性会执行set()、get()方法来通知

    参数: obj 目标对象     prop需要定义的属性      descriptor该属性拥有的特性，可设置的值有

    descriptor的值: 

        value 属性的值，默认为 undefined。

        writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。

        get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。

        set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。

        configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。

        enumerable 是否能在for...in循环中遍历出来或在Object.keys中列举出来。默认为 false。

    Example:
        var obj = {};
        Object.defineProperty(obj, &apos;name&apos;, {
            get: function(){
                debugger;
                // this.name;  
                return 23;
            },
            set: function(newValue){
                debugger
            }
        })

        Object.defineProperty(obj, &apos;sex&apos;, {
            get: function(){
                debugger;
                return &apos;女&apos;;
            },
            set: function(newValue){
                debugger
            }
        })

        obj.name = &apos;sss&apos;;           // 调用set()
        console.log(obj.name);      // 调用get()   23

        obj.sex = &apos;男&apos;;
        console.log(obj.sex);       // 女


    MVVM的核心: 

        &lt;div&gt;
            &lt;p&gt;你好，&lt;span id=&apos;nickName&apos;&gt;&lt;/span&gt;&lt;/p&gt;
            &lt;div id=&quot;introduce&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            // 视图控制器
            var userInfo = {};
            Object.defineProperty(userInfo, &quot;nickName&quot;, {
                get: function(){
                    return document.getElementById(&apos;nickName&apos;).innerHTML;
                },
                set: function(nick){
                    document.getElementById(&apos;nickName&apos;).innerHTML = nick;
                }
            });

            Object.defineProperty(userInfo, &quot;introduce&quot;, {
                get: function(){
                    return document.getElementById(&apos;introduce&apos;).innerHTML;
                },
                set: function(introduce){
                    document.getElementById(&apos;introduce&apos;).innerHTML = introduce;
                }
            })

            userInfo.nickName = &quot;siguang&quot;;
            userInfo.introduce = &quot;我是&quot;+ userInfo.nickName +&quot;，我来自黑龙江，...&quot;
        &lt;/script&gt;

    https://segmentfault.com/a/1190000004346467


12、Object.defineProperties: 与defineProperty相同就是可以设置多个属性

    let book = { year: 2004, edit: 1}
    Object.defainProperyies(book, {
        year:{
            get: function(){},
            set: function(){}
        },
        edit: {
            get: function(){},
            set: function(){}
        }
    })


13、Object.getPrototypeOf(object): 调用父类原型上的方法

    // 定义一个父类
    function PersonA(){
        this.methodA = function(){ 
            alert(&quot;a&quot;);
        }
    }
    PersonA.prototype.methodB = function(){
        alert(&apos;b&apos;);
    }

    // 定义一个子类
    function Man(){
        this.m1 = function(){
            //getPrototypeOf只有继承父类的时候才可以调用其方法
            Object.getPrototypeOf(this).methodA();        
        }
    }

    Man.prototype = new PersonA();
    Man.prototype.m2 = function(){
        Object.getPrototypeOf(this).methodB();
    }

    var man = new Man();
    man.m1();        // a
    man.m2();        // b


14、Object.keys(obj): 将对象obj下所有的属性的key，返回一个数组，用可以用它来判断是数组是否为空

    Object.keys(obj).length 是否等于0

15、Object.getOwnPropertyDescriptor():     
</code></pre><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><pre><code>var od = new Date();    // 创建当前中国标准时间 Thu Apr 27 2017 18:39:17 GMT+0800 (CST)
var od = new Date(&apos;2017-04-27 18:40:00&apos;);   // 指定时间 返回当前标准时间 Thu Apr 27 2017 18:40:00 GMT+0800 (CST)

1、getTime(): 返回当前毫秒数

2、setTime(): 以毫秒设置时期

    var od = new Date(); 
    od.setTime(12312312312332); 
    console.log(od);        // Mon Feb 29 2360 22:45:12 GMT+0800 (CST)

3、getFullYear()、setFullYear(): 获取或设置年份

4、getMonth()、setMonth(): 获取或设置月份，值需要+1

5、getDate()、setDate(): 获取或设置日

6、getDay(): 返回星期几，值是0-6

7、getHours(): 小时

8、getMinutes(): 分钟

9、getSeconds(): 秒
</code></pre><h4 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h4><pre><code>1、toFixed(): 将值格式化小数点后几位
</code></pre><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><pre><code>1、length: 字符串长度

2、charAt(): 返回指定位置的字符  &apos;abcde&apos;.charAt(3)  &apos;d&apos;

3、chartCodeAt(): 返回指定位置的字符编码

4、concat(): 两个字符串拼接

5、split(): 将字符串以什么为分割，并返回为一个数组

截取

6、slice(begin,end): 截取字符串指定开始和结束位置的字符并返回， 可以接受负数

7、substring(begin,end): 截取字符串从开始到结束，

8、substr(begin, length): 返回一个指定开始到一个结束长度的字符

位置

9、indexOf(): 查找指定字符所在的位置

10、lastIndexOf(): 从后向前查找指定字符的位置

11、trim(): 删除前后空格  str.replace(/^\s*|$\s*/g, &apos;&apos;);

12、toLocaleUpperCase(): 转成小写字母

13、toUpperCase(): 转成大写字母

正则

14、search(reg): 搜索正则中匹配字符的位置，没有返回-1

15、match(reg): 将匹配的正则返回一个数组

    let text = &quot;cat, bat, sat, fat&quot;;
    let om = text.match(/.at/g);        // [&quot;cat&quot;, &quot;bat&quot;, &quot;sat&quot;, &quot;fat&quot;]

16、exec():

17、replace(reg, 替换字符): 替换指定字符
</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><pre><code>1、min()、max(): 返回最小、最大值

舍入

2、ceil(): 向上舍入

3、floor(): 向下舍入

4、round(): 四舍五入

5、random(): 随机数 0-1之间

6、abs(): 绝对值

7、sin()、cos()
</code></pre><h4 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h4><pre><code>encodeURI()、encodeURIComponent()
</code></pre><h4 id="前端动画实现种类"><a href="#前端动画实现种类" class="headerlink" title="前端动画实现种类"></a>前端动画实现种类</h4><pre><code>1、纯粹的CSS3: transition/animation+transform（animate.css）

2、JS+CSS3 transition或者animation: 这里第一种一样，只是通过js里add class和remove class去增加或者移除对应的动画

3、纯粹JS控制时间轴: 第一和第二种都是自带时间轴，使用 setInterval / setTimeout / requestAnimationFrame 不断地修改 DOM 的 style 属性产生动画
</code></pre><h4 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h4><pre><code>1、==、===

    &apos;100&apos; == 100;     // true;    undefined == null; 因为JS会将两个值转换为相同类型
    &apos;100&apos; === 100;     // false

    == 是先将数值转换后在进行比较，JS的一个设计缺陷、 === 不转换数值进行比较


2、 while和do...while 

    do...while 不管条件是否成立都会执行一次
    var cont = 0;
    do{
        cont++;
        console.log(cont);                // 1;
    }while(cont &gt; 10);


3、break 退出循环、continue 退出当前循环开始下一循环
</code></pre><p>| <a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es5/</a>    ES5兼容表<br>| <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/className" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/className</a>        API<br>| <a href="https://segmentfault.com/a/1190000000515151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000515151</a><br>| <a href="https://segmentfault.com/a/1190000005653355" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005653355</a><br>| <a href="https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx</a><br>| <a href="http://www.alloyteam.com/2016/05/javascript-timer/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/05/javascript-timer/</a>        js运行机制</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/weex/">Weex</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/weex/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Weex/">Weex</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="Native调研"><a href="#Native调研" class="headerlink" title="Native调研"></a>Native调研</h1><h3 id="目前主流的应用大体分成三类：Native-App-Web-App-Hybrid-App"><a href="#目前主流的应用大体分成三类：Native-App-Web-App-Hybrid-App" class="headerlink" title="目前主流的应用大体分成三类：Native App, Web App, Hybrid App."></a>目前主流的应用大体分成三类：Native App, Web App, Hybrid App.</h3><h3 id="三类主流的优点"><a href="#三类主流的优点" class="headerlink" title="三类主流的优点"></a>三类主流的优点</h3><pre><code>1、native App

    性能好
    用户体验也比较好
    开发成本高，无法跨平台
    升级困难(审核),维护成本高

2、Web App特点:

    开发成本低,更新快,版本升级容易,自动升级
    跨平台，Write Once , Run Anywhere
    无法调用系统级的API
    临时入口，用户留存度低
    性能差,体验差,设计受限制
    相比Native App，Web App体验中受限于以上5个因素：网络环境，渲染性能，平台特性，受限于浏览器，系统限制。

3、Hybrid App(混合app)特点:

    Native App 和 Web App 折中的方案，保留了 Native App 和 Web App 的优点。
    但是还是性能差。页面渲染效率低，在Webview中绘制界面，实现动画，资源消耗都比较大,受限于技术,网速等因素
</code></pre><h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h3><pre><code>weex是阿里巴巴公司与2016年6月开源的一种用于构建移动跨平台的UI框架

特点:

    1、一次性编写代码多端运行，

    2、使用的vue的语法，RN使用的react语法

    3、轻量级,语法简单,易于使用

    4、可扩展,丰富内置组件,可扩展的API

    5、High Performance: 高性能


缺点: 只调研IOS

    1、weex开源比较晚资料也比较少，资料也不太容易看懂;

    2、没有对硬件调用的直接接口，需要swift进行modul的扩展（）;

    3、支持的组件也不完善;

    3、开发完成后对xcode不了解，所以在生成项目这块和导出包这块一直也没有解决(github上有人将创建了一个完整的项目);


weex流程:

    需要xcode、cocoapods、

    创建weex-cli  =&gt;  




基于JS开发框架:

    weex基于vue.js


性能对比:
</code></pre><div style="width:200px;"><br>    <img src="./img/1.png"><br></div>


<h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本:"></a>学习成本:</h4><pre><code>1.环境配置：

    ReactNative需要按照文档安装配置很多依赖的工具，相对比较麻烦。 weex安装cli之后就可以使用


2.vue vs react:

    react模板JSX学习使用有一定的成本 vue更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css
</code></pre><h4 id="weex-使用"><a href="#weex-使用" class="headerlink" title="weex 使用"></a>weex 使用</h4><pre><code>1、手机下载

    Weex Playground  可以通过二维码来看服务 


集成IOS

需要安装 iOS 开发环境 和 CocoaPods  


2、Cocoapods安装  http://blog.csdn.net/showhilllee/article/details/38398119/

    需要Ruby环境，Mac本身就自带Ruby

    $ sudo gem install cocoapods
</code></pre><p>思考:</p>
<pre><code>1、与web app 相比 navtive是不是可以不用考虑页面兼容问题（不同设备和系统）

2、cocoapads，xcode的一些处理，打包是否不用处理，还是只考虑写vue这块的内容就可以

3、weex怎么调用硬件设备

4、如果是原生与weex结合怎么来进行通信

5、weex不适用于做什么，和优、缺点是什么
</code></pre><p>|<br>| <a href="https://weex.apache.org/cn/" target="_blank" rel="noopener">https://weex.apache.org/cn/</a>      weex官网<br>| <a href="https://market.dotwe.org/ext/list.htm#6" target="_blank" rel="noopener">https://market.dotwe.org/ext/list.htm#6</a><br>| <a href="https://github.com/joggerplus/awesome-weex" target="_blank" rel="noopener">https://github.com/joggerplus/awesome-weex</a><br>| <a href="https://github.com/weexteam/weex-hackernews/blob/master/README.zh.md" target="_blank" rel="noopener">https://github.com/weexteam/weex-hackernews/blob/master/README.zh.md</a><br>| <a href="https://github.com/weexteam" target="_blank" rel="noopener">https://github.com/weexteam</a><br>| <a href="http://i.youku.com/i/UNDEzMDY2NjI0MA==/videos" target="_blank" rel="noopener">http://i.youku.com/i/UNDEzMDY2NjI0MA==/videos</a><br>| <a href="http://www.jianshu.com/p/cb6de4b85ea3" target="_blank" rel="noopener">http://www.jianshu.com/p/cb6de4b85ea3</a><br>| <a href="http://www.apicloud.com/" target="_blank" rel="noopener">http://www.apicloud.com/</a><br>| <a href="https://yq.aliyun.com/articles/57996" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57996</a>   react native与weex<br>| <a href="http://div.io/topic/1478" target="_blank" rel="noopener">http://div.io/topic/1478</a><br>| <a href="https://github.com/Elemefe/weex-vue-starter-kit" target="_blank" rel="noopener">https://github.com/Elemefe/weex-vue-starter-kit</a><br>|<br>|<br>| <a href="http://reactnative.cn/" target="_blank" rel="noopener">http://reactnative.cn/</a>         react native<br>| <a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="noopener">https://github.com/jondot/awesome-react-native</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/Linux命令/">Linux命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/Linux命令/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Linux/">Linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>[root@localhost~]  root 管理员    localhost 主机名    ~ 用户的目录 $ 为普通用户 # root用户

1、命令 [选项] [参数]    选项可简化  -a 等于 --all

2、Linux中 .xxx文件 是隐藏文件

3、命令补全: 输入一个开头字母，按Tab会将当前目录下所有的相关文件显示

4、sudo 使用超级使用者权限

    nginx 目录: /usr/local/openresty/nginx 9092

    启动 sudo /usr/local/openresty/nginx/sbin/nginx

    重启 /usr/local/openresty/nginx/sbin/nginx -s reload
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>使用 SecureCRT 工具

1、exit 或 logout 退出登录

2、文件上传和下载 到服务器

    $ sz 要下载的文件或目录   在secureCRT中设置 options -&gt; session options -&gt; x/z/zmodem 中设置的下载目录 

    $ rz 上传的文件            上传相同名文件，不会被替换，不能上传目录，可以直接发压缩gzip包在传

3、查看日志  使用tail 或 cat来查看文件内容

    $ tail -fn  显示行数  服务器的日志文件

    tail -fn 100  /opt/server/apache-tomcat-6.0.41_8084/logs/catalina.2016-01-21.log    56服务器8084端口

4、解决secureCRT 中文编码问题

    options -&gt;    session options  -&gt; terminal 下的 appearance  将 character encodeing 改成 utf-8

5、清理服务器缓存

    进入到apache-tomcat服务中的works中清楚loaclhost目录 

    $ cd /opt/server/apache-tomcat-6.0.41_8084/works/Catalina

    $ rm -rf  localhost

    8084：网站  apache-tomcat-6.0.41_8084

    8086：H5   apache-tomcat-7.0.47_8086

6、open 打开目录

7、clear 清除当前屏    cmd+k 清除所有

8、tree 打印出目录树

    mac下没有tree命令，需要安装  brew install tree

    $ tree -a   显示所有的文件和目录

    $ tree -L 1 -a  只显示一个层级的目录和文件(包括隐藏文件)

    $ tree -L 1 -d
</code></pre><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><pre><code>-rw-r--r--@   1 apple  staff   8196  5 15 19:26 .gitignore.js

一、文件类型    -rw-r--r--

    rw- u所有者    r-- g所属组    r-- o其它人

    r 读        w 写        x 执行

二、目录类型    drwxr-xr-x

    1、- 文件    如果第一个符号为&apos;-&apos;就是一个普通文件

    2、d 目录 

    3、l 软链接文件

三、查目录权限 

    $ cd /

    $ ls -l         显示根目录所的权限

四、chown设置目录权限

    1、命令格式：

        chown [选项]... [所有者][:[组]] 文件...

    2．命令功能：

        通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。

    3．命令参数：

        -c 显示更改的部分的信息

        -f 忽略错误信息

        -h 修复符号链接

        -R 处理指定目录以及其子目录下的所有文件

        -v 显示详细的处理信息

        -deference 作用于符号链接的指向，而不是链接文件本身

        选择参数:

        --reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组

        --from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变

        --help 显示帮助信息

        --version 显示版本信息

    4．使用实例：

        实例1：改变拥有者和群组

        命令：

        chown mail:mail log2012.log
</code></pre><h4 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h4><pre><code>1、cd 切换到指定目录

    cd 与 cd ~  回到apple目录, 也就是 /Users/apple

    cd -   回到上次操作所在的目录

    cd ..  进入到上一级目录

2、mkdir [-p]  dirname 创建目录 

    -p 递归创建  mkdir -p parent/child    可以直接创建多个目录，如果不加就只能创建一个目录

3、pwd 显示当前路径

4、rm 删除文件或目录   rm -rf [文件或目录]

    -r  递归删除文件夹        -f  强制

5、cp 复制目录或文件   cp [选项][原文件或目录][目标目录]

    -r 递归复制文件夹

    -p 连带文件属性复制 一些类似文件创建日期等

    -d 如果源文件是链接文件，则复制链接属性

    -a 相当于 -pdr

6、mv 移动目录或文件    mv [源文件或目录] [目标目录]

    mv dir1 dir2 将文件或目录移动到指定目录中  

    mv a.js b.js 修改文件或目录名  
</code></pre><h4 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h4><pre><code>1、touch .gitignore  创建文件

2、ls 显示文件

    # 显示详细列表
    $ ls -l  显示详细信息
    # 
    $ ll 是ls -l的简写
    # 
    $ ls -a 显示所有文件，包含隐藏文件（以. 起头的文件名）
    # 
    $ ls -R 显示文件及所有子目录
    $ 
    $ ls -F 显示文件（后跟*）和目录（后跟/）
    # 
    $ ls -d 与l选项合用，显示目录名而非其内容
    #
    $ ls -h 显示文件大小
    #
    $ ls -i 显示文件的id号    30988816 README.md

3、cat 查看文件内容

    cat package.json

4、echo 输出内容

5、ln 文件名   将文件的内容输出带行号

    $ ln package.json

6、wc 文件名  统计指定文件中的字节数、字数、行数，并将统计结果显示输出

    -c 统计字节数。

    -l 统计行数。

    -m 统计字符数。这个标志不能与 -c 标志一起使用。

    -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。

    -L 打印最长行的长度。
</code></pre><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><pre><code>一、find [搜索范围] [搜索条件]  避免大范围搜索，耗费系统资源

    通配符: * 匹配任意内容      ? 匹配任意一个字符      [] 匹配任意一个中括号内的字符

    $ find / -name person.js     从根目录开始搜索person.js文件

    1、-name   搜索文件名   

    2、-iname  搜索的文件名不区分大小写

    3、-user   按所有者文件

    4、-nouser  没有所有者文件


    按时间搜索   $ find /var/log/ -mtime +10    搜索10天前修改的文件   +10 十天前     10 十天当天修改    -10  十天内修改文件

    5、-mtime  修改文件内容

    6、-atime  文件访问时间

    7、-ctime  改变文件属性


    按文件大小搜索   $ find . -size 25k  查找文件大小是25K的文件  -25k 小于25k   +25k 大于25k   25k 等于25k

        注意: M 是大写   k 用小写

    8、-size  查找文件大小

    9、-inum  通过 i 节点个数来查看   ls -i 查看当前目录下的文件带id   29560848 Bluetooth    31587257 opendirectoryd.log.0  31745680 system.log.4.gz

        find /var/log/ -inum  29560848   // 返回 Bluetooth

        逻辑运算符  -a 逻辑与    -o 逻辑或

        example   find /var/log -size +20K  -a  -size -50K    查找大于20K并小于50K

    10、-exec ... {} \;  将搜索的内容交给第二条命令来处理

         find /var/log -size +20k -a -size -500M  -exec ls -l -a {} \;


二、grep 在文件中匹配符合条件的字符串   grep [选项]  字符串   文件名

    -i 忽略大小写

    -v 排除指定字符串    

    $ grep -i 丝绸之路 package.json 


三、whereis 和 which  搜索系统命令

    whereis vim        // 输出 /usr/bin/vim 可以

    which 指令会在环境变量$PATH设置的目录里查找符合条件的文件。

        which mongod        // 返回当前mongod命令所在的目录 /usr/local/bin/mongod


四、locate 文件名   在后台数据库中按文件名搜索，搜索速度快

    locate不是在文件中搜索，而是在 /var/lib/mlocat 只在后台数据库搜索

    updatedb  更新数据库
</code></pre><h4 id="ln-链接命令-ln-s-原文件或目录-目录文件"><a href="#ln-链接命令-ln-s-原文件或目录-目录文件" class="headerlink" title="ln 链接命令   ln -s [原文件或目录] [目录文件]"></a>ln 链接命令   ln -s [原文件或目录] [目录文件]</h4><pre><code>硬链接: 硬链接看做是文件或目录的副本，两个i节点和存储，可以看成是同一个文件

软链接: 软连接看做是文件或目录的快捷方式

选项:

-s 创建软链接    

    注意软链接要写绝对路径 ln -s /Users/apple/siguang.liu/linux/catalogB   /Users/apple/siguang.liu/linux/lnDir

    appledeMacBook-Pro-2:lnDir apple$ ls -il
    31874703 lrwxr-xr-x  1 apple  staff  39  5 16 18:54 catalogB -&gt; /Users/apple/siguang.liu/linux/catalogB    这种 -&gt; 就是指的软链接 或者 lrwxr第一个类型为『l』

删除软连接就去目标目录直接把软链接的目录直接删掉
</code></pre><h4 id="压缩文件、目录"><a href="#压缩文件、目录" class="headerlink" title="压缩文件、目录"></a>压缩文件、目录</h4><pre><code>一、zip压缩文件、目录

    1、压缩文件     zip 压缩文件名  源文件        // 注意这里压缩zip，原文件不会被删除，而gzip会删除源文件

    2、压缩目录  zip -r 压缩文件名.zip   要压缩的目录       // 最好先进入要指定压缩的目录，如果写成a/b/c，这样就会将所有目录一层一层压缩，如果要压缩的目录在aa下面，而且你当前就在aa目录下面不用从指定根目录，否则解压后会一层一层的 

    3、解压缩    unzip 解压的文件

二、gzip压缩

    压缩后的扩展为 .gz  

    1、gzip 源文件      压缩为.gz文件，源文件会消失

    2、gzip -c 源文件 &gt; 压缩 文件     压缩为.gz文件，保留源文件

    3、gzip -r 目录     压缩目录下所有子文件，但不压缩目录

    2、gunzip             解压文件名


三、tar压缩目录

    通过tar来对目录进行打包，然后通过gzip进行压缩

    $ 格式: tar -cvf  打包文件名  源文件

    1、打包成 .tar文件

        1) tar -cvf  压缩后的目录  要压缩的目录 

        2) tar -xcvf  打包的文件名

    2、打包成 .tar.gz格式

        1) tar -zcvf  压缩后的目录  要压缩的目录 

        2) tar -zxcvf  打包的文件名

        -c: 产生.tar打包文件

        -v: 显示详细信息

        -f: 指定压缩后缀名

        -z: 打包同时压缩

    3、当包解压到当前目录

        tar zxf  nginx-1.12.2.tar.gz
</code></pre><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><pre><code>所有程序只要运行就会产生一个进程，客户端网页访问服务器就会产生一个进程

一、查看进程

    1、ps aux  系统所有进程

        ps -ef|grep nginx 查看nginx服务的进程

            a 显示所有进程，包括会话引线

            u 显示进程的归属用户及内存使用情况

            x 显示没有控制终端进程

            -l 长格式显示 显示更详细信息

            -e 显示所有进程，和-A作用一致

    2、pstree [选项]

        -p 显示进程PID

        -u 显示进程用户

    3、top  每3秒查看一下系统的健康，有cpu和内存的数据和所有进程


二、杀死进程

    kill -1 进程ID    重启进程

    kill -9 进程ID    强制杀死进程
</code></pre><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><pre><code>一、curl

https://www.cnblogs.com/duhuo/p/5695256.html

二、ping 
</code></pre><h4 id="环境变量和host的修改"><a href="#环境变量和host的修改" class="headerlink" title="环境变量和host的修改"></a>环境变量和host的修改</h4><pre><code>一、host文件

    $ vim etc/hosts

二、环境变量、export 设置或显示环境变量  export [-fnp][变量名称]=[变量设置值]

    -f 　代表[变量名称]中为函数名称。 

    -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 

    -p 　列出所有的shell赋予程序的环境变量。

    $ export   查看环境变量

三、设置环境变量有两种: 

    1、使用export命令 这种方法只是临时设置，重启终端就

        $ export PATH=$PATH:/opt/au1200_rm/build_tools/bin

    2、修改profile文件 或者设置到 source ~/.bash_profile 

        $ vi ~/.profile

            export PATH=$PATH:/usr/local/zend/mysql/bin/:/usr/local/zend/bin     // 设置$PATH 扩展一下加一下

        $ source ~/.profile    立即执行

    注意两个环境变量使用 “:”来分割


三、通过环境变量来设置命令快捷键

    $ vi ~/.profile

        alias ll=&quot;ls -a&quot;
        alias ..=&quot;cd ..&quot;
        alias ...=&quot;cd ../../&quot;
        alias ....=&quot;cd ../../../&quot;
        alias .....=&quot;cd ../../../../&quot;
        alias ......=&quot;cd ../../../../../&quot;
</code></pre><h4 id="man-–help-帮助"><a href="#man-–help-帮助" class="headerlink" title="man  –help  帮助"></a>man  –help  帮助</h4><pre><code>一、man ls  查看帮助信息

二、ls --help   
</code></pre><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><pre><code>一、日期

    date 日期时间

    cal  显示当前日历

二、关机重启系统

    1、shutdown [选项] 时间   来进行重启和关机

        shutdown -r now    立即重启  -h 立即关机

        shutdown -r 18:00  定时在18点的时候重启

        -c: 取消前一个关机命令

        -h: 关机

        -r: 重启

    2、halt  回车  直接关机

    3、poweroff  回车  直接关机

    4、init 0 回车  直接关机

    5、reboot 回车  直接重启

三、查询与自动挂载

    1、mount
</code></pre><h4 id="linux根目录"><a href="#linux根目录" class="headerlink" title="linux根目录"></a>linux根目录</h4><pre><code>Linux的目录

    根目录下的 bin目录不允许操作， usr下的 sbin目录是可以操作的

    /bin 传统unix命令的存放目录，如ls，rm，mv等。
    /sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。
    /tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。
    /usr 第三方程序安装目录。
        /usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）.
    /etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。        
    /var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。


OS X系统中，除了标准的unix目录外，还增加了特有的目录。

    /Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；
    /Library 系统的数据文件、帮助文件、文档等等；
    /Network 网络节点存放目录；
    /System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。
    /Users 存放用户的个人资料和配置。每个用户有自己的单独目录。
    /Volumes 文件系统挂载点存放目录。
    /cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。
    /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。


/bin是系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。

/sbin一般是指超级用户指令。主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。

/usr/bin　是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等。

/usr/sbin   放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。

/usr/bin用于分发包管理器（如Ubuntu apt等）存放它所管理的应用的路径, /usr/sbin与/usr/bin的关系类似与/bin和/sbin的关系

/usr/local/bin用于存放用户自己的程序（如自己编译出来的包等），不受分发包管理器的控制。如果用户把自己的程序放在/usr/bin下，则有可能在未来被包管理器给修改或删除了。
</code></pre><h4 id="vim-编辑器"><a href="#vim-编辑器" class="headerlink" title="vim 编辑器"></a>vim 编辑器</h4><pre><code>vi  文件名    或vim 文件名

命令状态：

H 左  L 右   K 上  J 下

0（零） 行首     $（shift+5） 行尾       G（shift+G） 文件尾

i 插入命令

dd  删除当前行    pp 复制并粘贴当前行    x: 删除光标处字符

control+f 后翻页        control+b前翻页

u 取消上次操作)


a,A:追加命令，a 在当前光标后追加，A 在行末追加

o,O:打开命令，o 在当前行下打开一行，O在当前行上插入一行

r,R :替换命令，r 替换当前光标处字符，R从光标处开始替换

数字s: 替换指定数量字符

d0: 删除光标前半行

d$: 删除光标后半行

/string 查找字符串

n 继续查找

N 反向继续查找

% 查找对应括号

ex命令状态

    ：0 文件首

    ：1,5 copy 7 块拷贝

    ：1，5 del 块删除

    ：1，5 move 7 块移动

    ：1，$s/string1/string2/g 全文件查找string1并替换为string2

    ：wq! 存盘退出

保存命令

    按ESC键 跳到命令模式，然后：

    :w   保存文件但不退出vi

    :w file 将修改另外保存到file中，不退出vi

    :w!  强制保存，不推出vi

    :wq  保存文件并退出vi

    :wq! 强制保存文件，并退出vi

    q:   不保存文件，退出vi

    :q!  不保存文件，强制退出vi

    :e!  放弃所有修改，从上次保存文件开始再编辑
</code></pre><h4 id="Mac终端下的快捷键"><a href="#Mac终端下的快捷键" class="headerlink" title="Mac终端下的快捷键"></a>Mac终端下的快捷键</h4><pre><code>control + A 移到行首
control + E 移到行尾
control + U 清除当前行命令

cmd + L 清除上一次操作的内容
cmd + K 清除所有内容

cmd + option + H 将所有窗口隐藏到应用程序图标
cmd + H  将当前窗口隐藏到图标中
cmd + M  将当前窗口最小化到

cmd + shift + .  显示/隐藏当前文件的隐藏文件

traceroute -n 125.35.51.162        // 查看当前网络访问到这个ip都通过哪些途径

mac 打开iphone界面  iphone与mac连接，打开QuickTime，文件 -&gt; 新建录制影片
</code></pre><h4 id="修改mac地址"><a href="#修改mac地址" class="headerlink" title="修改mac地址"></a>修改mac地址</h4><pre><code>$ ifconfig        en0:  ether ac:bc:32:83:a2:4b     原始的mac地址

$ openssl rand -hex 6 | sed &apos;s/\(..\)/\1:/g; s/.$//&apos;        生成一个mac地址

$ sudo /System/Library/PrivateFrameworks/Apple80211.framework/Resources/airport -z      断开airport无线网卡连接

$ sudo ifconfig en0 ether 7e:df:f7:a5:07:56        修改成生成的mac地址

$ networksetup -detectnewhardware     重新连接网卡

$ ifconfig    查看是否是改后的mac地址

44:9f:24:59:ca:13
</code></pre><h4 id="SSL-权限"><a href="#SSL-权限" class="headerlink" title="SSL 权限"></a>SSL 权限</h4><pre><code>open ~/.ssh/     打开ssh目录

GitLab：中配置ssh

1、登录后找到 Profile Settings  -&gt;  SSH Keys  添加Key来做映射

id_rsa.pub 文件

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCcmEJCTlr57na4TJ8xU8J/EG0KcrH6Dh+MwBPbs0NO6lA09Pdjro4knzSRYeSHc9X63Km/OR18JU7ygcE9foUYAN8BatnDTh6R+ynyQxyIqIG7Gn8YGF0g8Zx8oU9LsYc8SWP6zdryr7NaQZ41583jt9JxheG0la6D10cqZRQiix7pZMiXmHZXPKCSkTZSGHLaR0Ws24eyz1Yt9HmLXZem8FPkUrwmn2IYk05cwMyK+NE/g9pPJbpVEtEssU4FZ4I++LNltMbAxgtCp2QXZ7Z7ViA3CvK9u8g6u4yLLBPydpXWJ1pu+9bYFV3CvoTEawN3+mIIMsDaDhPlI6PJMk/j 632505215@qq.com
</code></pre><p>| <a href="http://www.cnblogs.com/webzhangnan/p/3221410.html" target="_blank" rel="noopener">http://www.cnblogs.com/webzhangnan/p/3221410.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之积累篇/">React Native之积累篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之积累篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="IOS、Android的图标、app名称和启动图"><a href="#IOS、Android的图标、app名称和启动图" class="headerlink" title="IOS、Android的图标、app名称和启动图"></a>IOS、Android的图标、app名称和启动图</h4><pre><code>一、App名称修改

    Xcode中打开项目下info.plist -&gt; Bundle name 和 Bundle display name 都修改APP的名称

二、App图标

    方法1 Xcode中配置:

        Xcode工程目录下的Images.xcassets -&gt; AppIcon中将来加载图标，分别为120x120、180x180

    方法2 代码中配置

        1、使用icon psd模板右键 Edit me and save图层 ——&gt; 编辑内容 ——&gt; 编辑完后保存 ——&gt; 导出图片（窗口）——&gt; 动作 ——&gt; 右上角按钮选择载入动作将App Icon Template [3.3].atn文件载入 ——&gt; 选择导出动作中有两种一个都是圆角图标一个是方形图标

        2、将导出的图标添加到项目中 找到ios/gzApp/Images.xcassets ——&gt; 将所有导出的图标放到这个目录下

三、设置启动图

    方法1 Xcode中配置:

        Xcode工程下点击Images.xcassets -&gt; 进入后 右键 App Icons &amp; launch Image -&gt; New IOS Launch Image -&gt; 将启动图加载到各配置中（注意如果尺寸与当前不配置编译时会报错）

        在项目的General面板 Launch Images Source 选择刚才创建的launchImage, launch Screen File设置为空，App Icons Source就是图标的配置

    方法2 代码配置

        https://github.com/fbsamples/f8app/tree/master/ios/F8v2   // Base.lproj -&gt; LaunchScreen.xib

        在ios文件夹 -&gt; gzCar项目 -&gt; Base.Iproj -&gt; LaunchScreen.xib 使用文件替换，将Splash.png文件导入到项目中，启动


http://www.cnblogs.com/allenxieyusheng/p/5802179.html
http://www.jianshu.com/p/adpKye/
https://appicontemplate.com/ios9    图标尺寸导出  

转icon尺寸
http://www.zcool.com.cn/article/ZNjE1MTI=.html
http://makeappicon.com/
http://blog.csdn.net/leiyu231/article/details/52830151
</code></pre><h4 id="fetch-请求提示netWork-quest-failed"><a href="#fetch-请求提示netWork-quest-failed" class="headerlink" title="fetch 请求提示netWork quest failed"></a>fetch 请求提示netWork quest failed</h4><pre><code>在 Xcode 7.0 bata、ios9 中fetch默认https请求, 对http不起作用，需要修改info.plist配置

1、在Info.plist中添加 NSAppTransportSecurity 类型 Dictionary ; 
2、在 NSAppTransportSecurity 下添加 NSAllowsArbitraryLoads 类型Boolean ,值设为 YES;

http://blog.csdn.net/liyijun4114/article/details/51792179
</code></pre><h4 id="网络图片无法加载问题"><a href="#网络图片无法加载问题" class="headerlink" title="网络图片无法加载问题"></a>网络图片无法加载问题</h4><pre><code>在iOS9之后，网络请求默认为Https请求，如需支持Http，修改info.plist文件添加键值对设置允许http访问。

在App Transport Security Settings中添加 Allow Arbitrary Loads设置为 YES
</code></pre><h4 id="内测平台"><a href="#内测平台" class="headerlink" title="内测平台"></a>内测平台</h4><pre><code>https://www.pgyer.com/      蒲公英将测试包分发给多人的设备上进行测试

    在Xcode中倒出一个应用包，通过蒲公英上传进行分发多个设备

https://developer.apple.com/  苹果开发者账号申请

苹果开发者平台可以进行

苹果的安装包为 *.ipa 文件

1、先登录Account，注册苹果开发者账号个人或企业

2、Xcode 打包IOS文件 https://www.pgyer.com/doc/view/app_upload
</code></pre><h4 id="代码类"><a href="#代码类" class="headerlink" title="代码类"></a>代码类</h4><pre><code>一、render中调用方法将View返回

    class TabPage extends Component {

        _createNav(name, colorValue){
            return (
                &lt;View&gt;
                    &lt;Text style={{color: colorValue}}&gt;{name}&lt;/Text&gt;
                &lt;/View&gt;
            )
        }

        render(){
            return (
                &lt;View&gt;
                    {this._createNav(&apos;siguang&apos;, &apos;#ddd&apos;)}
                &lt;/View&gt;
            )
        }
    }
</code></pre><p>| 参考资料<br>|  react.parts/native<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/函数式编程/">函数式编程</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/函数式编程/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/函数式编程/">函数式编程</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="纯函数式"><a href="#纯函数式" class="headerlink" title="纯函数式"></a>纯函数式</h4><pre><code>一、非纯净的

    let number = 1;

    const increment = () =&gt; number += 1;

    increment();  // 2


二、纯净的

    const increment = n =&gt; n + 1;

    increment(1);
</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><pre><code>把函数当做其它函数的参数来传递

let sum = (x, y) =&gt; x+y;

let calculate = (fn, x, y) =&gt; fn(x,y);

calculate(sum, 1, 2)
</code></pre><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><pre><code>柯里化就是将多参函数转换成单参函数

// 一个多参函数 
var add = (a, b) =&gt; a + b;
add(1, 2); // =&gt; 3

// 柯里化
var add = a =&gt; b =&gt; a+b;
add(1)(2);


Example:

    var say = function(title) {
        return function(type){
            return title + &quot; is &quot; + type;
        }
    }

    var sayFP = say(&quot;Functional Programming&quot;);
    var sayOther = say(&quot;Other Programming&quot;);

    sayFP(&quot;good&quot;); // =&gt; Functional Programming is good
    sayOther(&quot;bad&quot;); // =&gt; Other Programming is good
</code></pre><h4 id="compose-函数组合"><a href="#compose-函数组合" class="headerlink" title="compose 函数组合"></a>compose 函数组合</h4><pre><code>将多个函数组合成一个函数

Example:

    var compose = function(fn1, fn2) {
        return function(arg){
            return fn1(fn2(arg));
        }
    }

    var a = arg =&gt; arg + &apos;a&apos;;
    var b = arg =&gt; arg + &apos;b&apos;;

    var c = compose(a, b); // 将a,b函数进行组合
    console.log(c(&apos;c&apos;));  // =&gt; cba
</code></pre><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><pre><code>function isDataType(type){
    var typeName = &apos;&apos;;

    switch(toString.call(type)){
        case &apos;[object String]&apos;:
            return &apos;string&apos;;
            break;

        case &apos;[object Number]&apos;:
            if(type.toString().indexOf(&apos;.&apos;) != -1){
                return &apos;float&apos;;
            }
            else{
                return &apos;number&apos;;
            }
            break;

        case &apos;[object Array]&apos;:
            return &apos;array&apos;;
            break;

        case &apos;[object Object]&apos;:
            return &apos;object&apos;;
            break;

        case &apos;[object Undefined]&apos;:
            return &apos;undefined&apos;;
            break;

        case &apos;[object Null]&apos;:
            return &apos;null&apos;;
            break;    

        default: break;
    }

    return typeName;
}
</code></pre><p>| <a href="http://www.alloyteam.com/2016/09/talk-about-functional-programming/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/09/talk-about-functional-programming/</a><br>| <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/Git/">Git</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/Git/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Git/">Git</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><pre><code>1、安装brew   https://brew.sh/ 后在安装

2、brew install git

3、git --version   查看git版本

4、which git       显示当前git所在的目录
</code></pre><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><pre><code>版本控制分为 集成式版本控制 和 分布式开发

    1、集成式开发（svn）：需要一台中央服务器，客户端需要连接到中央服务器进行更新、提交代码文件等

    2、分布式开发（Git）：每台机器都有自己版本库不需要中央服务器

分布式的好处：

    1、不需要连接中央服务器来提交和更新文件

    2、通过不同的版本来做不同阶段开发，不同的版本文件可以随时切换回之前的版本

    3、分支管理上要比svn方便很多


[master +0 ~0 -0 !1]: + 增加  ~修改  -删除  !有冲突

Git的配置文件：vi ~/.gitconfig
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>1、将远端的库克隆到本地:  git clone 远程代码库

2、切换到一个分支: git checkout 分支名

3、如果分支存在只切换分支，如果不存在则创建并切换到分支:  git checkout -b   新建本地分支名  origin/远端分支名

4、查看当前所在的分支:  git branch

   创建新分支: git branch 新分支名

5、将文件添加到暂存区:  git add 文件名         git add .  添加所有工作区文件到暂存区

6、提交文件:  git commit -m &apos;提交版本内容说明&apos;

7、将本地代码提交到远端库:  git push origin/develop_web  本地分支名

8、查看当前文件状态:  git status 

9、从远端拉取拉取代码:  git pull 远端分支名

10、临时保存:  git stash   git stash pop

11、从主分支上merge代码:  git merge origin/dev_crm2.6_base

12、将本地分支提交到主分支:  pull resquest

13、删除本地分支:  git branch -d dev_crm2.8_base

14、删除远端分支:  git push origin :PublicAdmin_V1.0.0_liusiguang        或  git branch -r -d origin/PublicAdmin_V1.0.0_liusiguang

15、从远端单独拉取一个文件:  git checkout origin/master -- path/to/file

16、撤消最后一次commit提交：git reset --hard HEAD^

17、chenkout一个分支后，pull的时候想在app_master下切换，使用下面命令进行转换

    git branch --set-upstream 当前分支名 远端分支名

18、git branch --track branch 名称 远端branch 建立一个 tracking 远端 branch 的 branch，这样以后 push/pull都会直接对应到该远端的branch。
    git branch --set-upstream branch 远端branch 将一个已存在的 branch 设定成 tracking 远端的branch。
</code></pre><h4 id="版本库介绍"><a href="#版本库介绍" class="headerlink" title="版本库介绍"></a>版本库介绍</h4><pre><code>工作区（文件）      暂存区（过度）     版本库      |       远端（服务器版本）    

1、工作区:  开发的区域

2、暂存区: 将工作区的文件执行 git add &apos;文件名&apos; 命令会使文件添加到暂存区，工作区的文件如果删除了就没有了

    git add &apos;文件名&apos;


3、版本库: 通过commit来提交到版本库， 暂存区需要先提交到版本库才能最后提交远端

    git commit -m &apos;提交说明内容&apos;

    add 和 commit 连着的写法
    git commit -a -m &apos;提交注释&apos;        // 这样可以省略add的步骤


4、提交到远端: 通过push来提交到远端

    git push origin develop_web_2.5.1_siguang            // 提交到远端
</code></pre><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><pre><code>1、设置贡献者

    设置用户名:     git config  --global user.name “username”

    设置Email-id:  git config  --global user.email “email”


2、设置避免PULLING提交合并:   git config --global branch.autosetuprebase always

3、颜色高亮

    git config --global color.ui true

    git config --global color.status auto

    git config --global color.branch auto


4、设置默认编辑器:  git config --global core.editor vim        Git的使用系统默认取自VISUAL或EDITOR环境变量的编辑器

5、设置默认的合并工具:  git config --global merge.tool vimdiff

6、查看设置命令:  git config --list
</code></pre><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><pre><code>1、git init 库名： 创建一个git仓库 

2、git remote add origin git@xbc.me:wordpress.git:    添加远程版本库origin

3、git remote:   显示所有远端主机

    git remote  -v:        查看远程仓库地址

    git remote show &lt;主机名&gt;:     查看远端主机的详细信息

    git remote add &lt;主机名&gt; &lt;网址&gt;:    添加远程主机

    git remote rm &lt;主机名&gt;:    删除远端主机

    git remote rename &lt;原主机名&gt; &lt;新主机名&gt;:    对无端主机进行改名

     在clone完成之后，Git 会自动为你将此远程仓库命名为origin，origin只相当于一个别名，运行git remote –v可以看到下载的版本路径。


克隆项目地址:    git clone 远程版本库地址
</code></pre><h4 id="文件操作（查看、添加、提交、删除、恢复，撤消）"><a href="#文件操作（查看、添加、提交、删除、恢复，撤消）" class="headerlink" title="文件操作（查看、添加、提交、删除、恢复，撤消）"></a>文件操作（查看、添加、提交、删除、恢复，撤消）</h4><pre><code>查看:

    1、git help:  显示help的命令功能

    2、git show 提交ID:  显示某次提交的内容，先通过git log来查看提交的ID

        commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e         // 提交的ID

    3、git log:  显示所有的版本记录


添加: 添加到缓存区

    1、git add 文件名:  将工作文件修改提交到本地暂存区            add只是刷新了git的跟踪信息，并未发到版本库中

    2、git add --all:  将所有修改过的文件提交到暂存区


提交: 提交到版本库

    1、git commit -m &apos;注释提交理由&apos;:  代码提交

        git commit --amend:  使用最后一次提交的注释在提交

    2、git push origin master:  将刚commit的版本推送到远程服务器


删除：

    1、git rm &apos;main.js&apos;:     删除暂存区的main.js文件

    2、git rm -f &apos;main.js&apos;:  删除工作区和暂存区的main.js文件

    3、git rm --cached &apos;main.js&apos;:  如果工作区和暂存区都有main.js，只删除暂存区文件


恢复：

    如果把工作区的文件删除了，想从版本库中恢复回来的方法:

    1、恢复文件

        先 git log 来查看commit 提交的历史版本，获取到commitId

        commit d5d9357319a4ef536b30f2d906bb71700beaa899
        Author: liusiugang &lt;liusiguang@renrendai.com&gt;
        Date:   Thu Nov 3 15:19:00 2016 +0800

            修改邻趣配送时间接口加merchantId参数+

        git checkout  [commitId] [要恢复的文件名]

        // 这样就将版本库中的common.coffee.js恢复到了工作区
        git checkout d5d9357319a4ef536b30f2d906bb71700beaa899  common.coffee.js   


    2、恢复版本

        1）git reset --hard  [commitId]    恢复到指定提交的版本的内容，通过commitId来指定版本

        2）git reset --hard HEAD^    恢复向后一个版本

        3）git reflog    显示所有的操作记录


撤消：

    1、git reset &lt;file&gt;：    从暂存区恢复到工作文件

    2、git reset --：        从暂存区恢复到工作文件

    3、git reset --hard：    恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改

    4、git reset HEAD b：    现在你只想提交a文件，不想提交b文件，应该这样

    5、git revert &lt;$id&gt;：    恢复某次提交的状态，恢复动作本身也创建了一次提交对象

    6、git revert HEAD：    恢复最后一次提交的状态

        git checkout -- filname  撤回远端版本或指定文件

        git commit --amend    重新合并一个提交方案


文件重命名：

    1、git mv reademe.txt 新文件名


查看当前库状态: git status

    显示
    On branch master        // master分支
    Your branch is up-to-date with &apos;origin/master&apos;.        // 你的分支是最新的 master
    nothing to commit, working directory clean            // 无提交，工作目录干净
</code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code>1、查看分支

    查看本地分支:  git branch

    查看远端分支:  git branch -r

    查看本地和远端分支:  git branch -a

    查看各分支最后提交的信息:  git branch -v

2、创建分支 

    git branch 分支名称

3、把分支提交到远端分支

    # 如果在本地创建一个分支，与团队其它人一起开发，需要将这个分支push到远端仓库，不然这个分支只是存在你本地，其它人看不到，每次commit完代码就需要提交到远端

    git push origin 本地分支名

    Example:

        appledeMacBook-Pro:what apple$ git push origin dev_1.1_lulu           // 将dev_1.1_lulu分支提交到远端
        Username for &apos;https://github.com&apos;: siguang1983            // 输入远程的用户名
        Password for &apos;https://siguang1983@github.com&apos;:             // 输入远端的密码
        Counting objects: 4, done.                                // 成功

4、删除分支: 

    git branch -d &lt;branch&gt;        删除某个分支

    git branch -D &lt;branch&gt;        强制删除某个分支 (未被合并的分支被删除的时候需要强制)

5、切换分支:

    git checkout [要切换的分支]        本地切换分支

    git checkout -b [新创建分支名]  [远端地址分支]            创建并且直接切换到这个新分支

6、合并分支: git morge  分支名

    git merge master develop        # 将develop分支合并到master上

7、分支的更新与合并

    # 将本地仓库更新到最新版本，直接更新自动合并冲突，如果执行fetch提示哪些冲突需要手动更新
    git pull origin 分支名

    # 执行一下合并，并且手动去去解决冲突
    git merge [branch]

    # 将这个冲突文件重新提交 
    git add &lt;filename&gt;

    # 查看一下冲突的文件
    git diff 确定分支  目标分支

    # 冲突处理完后就可以commit
    git commit -m &apos;fix conflict&apos;

8、删除远程版本:  git push origin :br-1.0.0

9、查看分支提交的记录:  git whatchanged

    commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e            // 提交的状态码
    Author: apple &lt;apple@appledeMacBook-Pro.local&gt;            // 提交人
    Date:   Mon May 2 17:24:16 2016 +0800                    // 日期

        siguang add index.js                // 提交文件

    :100644 100644 e69de29... 50b777e... M  js/index.js
</code></pre><h4 id="拉取远端代码-和-提交远端代码"><a href="#拉取远端代码-和-提交远端代码" class="headerlink" title="拉取远端代码 和 提交远端代码"></a>拉取远端代码 和 提交远端代码</h4><pre><code>1、pull、fetch 两种都是拉取代码功能，有一些小的差别

    git pull : 拉取远端代码，直接合并        // Already up-to-date. 已更新

    git fetch: 拉取远端代码，并不合并，查看哪些冲突，来进行手动merge合并


2、版本库提交到远端

    git push origin/dev_crm2.9_base


3、pull request：将代码提交到远端版本中的一个请求，在merge就可以直接合到远端仓库中
</code></pre><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><pre><code>拉取完代码git pull 或 git fetch 拉取远程某个分支的代码，再与本地的指定分支合并（包括fetch和merge）

git pull origin/dev_crm2.5_base 

git merge origin/dev_crm2.5_base

    有时候pull的时候会提示：git branch --set-upstream master origin/next  

    Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）

    如果有冲突 常见提示：
        Auto-merging addCacke.html            // 自动合并了这个文件
        CONFLICT (content): Merge conflict in addCacke.html            // 有冲突在 addCacke.html文件中合并冲突
        Automatic merge failed; fix conflicts and then commit the result.        // 自动合并失败解决冲突
</code></pre><h4 id="查看文件之间区别-diff"><a href="#查看文件之间区别-diff" class="headerlink" title="查看文件之间区别 diff"></a>查看文件之间区别 diff</h4><pre><code>1、git diff &lt;file&gt;:        是工作区与暂存区的

2、git diff &lt;$id1&gt; &lt;$id2&gt;:    比较两次提交之间的差异

3、git diff &lt;branch1&gt;..&lt;branch2&gt;:    在两个分支之间比较

4、git diff --staged:    比较暂存区和版本库差异

5、git diff --cached:    暂存区和版本区差异

6、git diff --stat:         仅仅比较统计信息
</code></pre><h4 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h4><pre><code>1、git log:  显示提交的所有记录

    commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e         // 提交的ID
    Author: apple &lt;apple@appledeMacBook-Pro.local&gt;         // 提交用户
    Date:   Mon May 2 17:24:16 2016 +0800                 // 提交日期

        siguang add index.js            // 提交文件

2、git log &lt;file&gt;:        查看该文件每次提交记录

3、git log -p &lt;file&gt; :    查看每次详细修改内容的diff

4、git log -p -2:        查看最近两次详细修改内容的diff

5、git log --status:     查看提交统计信息
</code></pre><h4 id="sourceTree-使用"><a href="#sourceTree-使用" class="headerlink" title="sourceTree 使用"></a>sourceTree 使用</h4><pre><code>一、设置拉取、推送默认密码

    仓库 -&gt; 远程仓库 -&gt; 将路径配置成 http://用户名:密码@172.16.x.xx:7990/scm/ibg/ibg.git
</code></pre><blockquote>
<p>参考资料：</p>
<p>可视化工具：SourceTree<br>远端：stash</p>
<p><a href="http://iissnan.com/progit/" target="_blank" rel="noopener">http://iissnan.com/progit/</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</a><br><a href="http://www.yiibai.com/git/git_update_operation.html" target="_blank" rel="noopener">http://www.yiibai.com/git/git_update_operation.html</a></p>
</blockquote>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Précédent</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">Suivant &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
