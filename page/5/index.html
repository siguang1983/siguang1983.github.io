<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/BOM/">BOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/BOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><pre><code>BOM   浏览器对象模型    B - Browser    O - Object     M - Model

BOM包含: history、location、navigator、screen 对象
</code></pre><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><pre><code>1、hash: 返回hash值

    https://xxx.com/#sdfsdf       // &apos;#sdfsdf&apos;

2、host: 返回主机地址  &apos;xxx.com&apos;

3、hostname: 返回主机名  &apos;xxx.com&apos;

4、href: 整个url地址  &quot;https://xxx.com/search?q=BOM&quot;

5、origin: 起源  &apos;https://xxx.com&apos;

6、pathName: 路由名

    &quot;https://xxx.com/search?q=BOM&quot;   &apos;/search&apos;

7、port: 端口

8、protocol: 协议  &apos;https&apos;

9、search: 参数 &apos;?q=BOM&apos;

10、reload(): 刷新浏览器

    location.reload(); // 重新加载（有可能从缓存中加载）
    location.reload(true); // 重新加载（从服务器重新加载）
</code></pre><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><pre><code>1、width、height: 整天个屏幕的宽、高

2、avaiWidth、avaiHeight: 返回显示屏幕的宽、高 除dock和系统上面的菜单栏

3、pixelDepth: 返回显示屏幕的颜色分辨率

4、updateInteval: 设置或返回屏幕刷新率
</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><pre><code>1、length: 历史记录的个数

2、go(): 指定跳转的历史、-1后退一页，1前进一页

3、back()、forward(): 后退和前进一页
</code></pre><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><pre><code>1、appCodeName: 浏览器代码名 &apos;Mozilla&apos;

2、appName: 浏览器名称    &apos;Netscape&apos;

3、appVersion: 浏览器版本  &apos;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;

4、browserLanguage: 浏览器语言

5、cookieEnabled: 是否启用了cookie 返回Boolean

    如果浏览器关闭cookie，当获取cookie时， document.cookie 返回的是空字符串

6、cpuClass: 返回浏览器系统的cpu等级

8、onLine: 是否处于脱机模式，Boolean

9、platform: 浏览器的操作平台

10、systemLanguage: 系统语言

11、userAgent: 客户机发送服务器的 user-agent 头部的值

12、userLanguage: 返回 OS 的自然语言设置


** 检测插件  ie无效
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

** 检测Flash
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

function hasIEPlugin(name){
    try{
        new ActiveXObject(name);
        return true;
    }catch(ex){
        return false;
    }
}

function hasFlash(){
    var result = hasPlugin(&quot;Flash&quot;);
    if (!result){
        result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);
    }
    return result;
}

console.log(hasFlash()) //true
</code></pre><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><pre><code>1、window.open(url, target, param): 打开一个新窗口

2、window.close(): 关闭一个窗口

3、setInterval()、clearInterval()

4、setTimeout()、clearTimeout()

5、screenLeft、screenTop: 浏览器当前窗口居屏幕的左、上角的位置  

    兼容:
    screenLeft || screenX
    screenTop || screenY

6、innerWidth、innerHeight: 浏览器可视区的宽高、包括滚动条

    let winHeight = window.innerHeight;

7、moveTo(x, y): 移动到屏幕左上角的位置

8、moveBy(0, 100): 向下移动100像素

9、resizeTo(x,y)、resizeBy(w, h)
</code></pre><h4 id="offset-页面元素偏移量"><a href="#offset-页面元素偏移量" class="headerlink" title="offset 页面元素偏移量"></a>offset 页面元素偏移量</h4><pre><code>1、offsetWidth、offsetHeight: 获取当前元素宽高，相当于 width + padding + border

2、offsetLeft、offsetTop: 获取元素到父级元素定位的左、上偏移，如果父级不是定位就以body元素为定位

3、offsetParent: 获取最近一个带有定位的父级元素

4、clientWidth、clientHeight: 元素本身的宽高、不包括padding和border

    兼容
    document.documentElement.clientWidth || document.body。clientWidth
    document.documentElement.clientHeight || document.body。clientHeight
</code></pre><h4 id="scroll-滚动类"><a href="#scroll-滚动类" class="headerlink" title="scroll 滚动类"></a>scroll 滚动类</h4><pre><code>窗口滚动条或带滚动条元素

1、scrollWidth、scrollheight: 对象内部实际内容的宽、高

2、scrollTop、scrollLeft: 被卷部分的顶部和左侧部分

    只挂载到了Element元素中，window和document下都没有

    let topValue = document.documentElement.scrollTop || document.body.scrollTop;       // 获取整个页面巻上去的高度和兼容方法

    let topValue = document.querySelector(&apos;#sider&apos;).scrollTop;      // 针对某个元素


3、onscroll: 侦听滚动条事件
</code></pre><h4 id="client-鼠标所在的可视区坐标"><a href="#client-鼠标所在的可视区坐标" class="headerlink" title="client 鼠标所在的可视区坐标"></a>client 鼠标所在的可视区坐标</h4><pre><code>1、clientX、clientY: 获取鼠标可视区的位置  clientX = width + padding

2、clientLeft、clientTop: 获取鼠标在可视区域的位置

3、pageX、pageY: 获取鼠标在页面中的位置， pageX = clientX + 页面滚动出的距离

node.onclick = function(evt){
    let evt = evt || window.evnet;
    console.log(evt.pageX, evt.pageY);
    console.log(evt.pageX, evt.pageY);
}
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、target: 点击的目标阶段事件，ie8之前使用srcElement

    var oT = evt.target || srcElement; console.log(oT);     // &lt;p&gt;xxxx&lt;/p&gt;

2、currentTarget: 事件流的捕获，目标及冒泡阶段

3、addEventListener()、attachEvent(): 注册事件

    addEventListener(&apos;click&apos;, fn, false);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/函数式编程/">函数式编程</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/函数式编程/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/函数式编程/">函数式编程</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="纯函数式"><a href="#纯函数式" class="headerlink" title="纯函数式"></a>纯函数式</h4><pre><code>一、非纯净的

    let number = 1;

    const increment = () =&gt; number += 1;

    increment();  // 2


二、纯净的

    const increment = n =&gt; n + 1;

    increment(1);
</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><pre><code>把函数当做其它函数的参数来传递

let sum = (x, y) =&gt; x+y;

let calculate = (fn, x, y) =&gt; fn(x,y);

calculate(sum, 1, 2)
</code></pre><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><pre><code>柯里化就是将多参函数转换成单参函数

// 一个多参函数 
var add = (a, b) =&gt; a + b;
add(1, 2); // =&gt; 3

// 柯里化
var add = a =&gt; b =&gt; a+b;
add(1)(2);


Example:

    var say = function(title) {
        return function(type){
            return title + &quot; is &quot; + type;
        }
    }

    var sayFP = say(&quot;Functional Programming&quot;);
    var sayOther = say(&quot;Other Programming&quot;);

    sayFP(&quot;good&quot;); // =&gt; Functional Programming is good
    sayOther(&quot;bad&quot;); // =&gt; Other Programming is good
</code></pre><h4 id="compose-函数组合"><a href="#compose-函数组合" class="headerlink" title="compose 函数组合"></a>compose 函数组合</h4><pre><code>将多个函数组合成一个函数

Example:

    var compose = function(fn1, fn2) {
        return function(arg){
            return fn1(fn2(arg));
        }
    }

    var a = arg =&gt; arg + &apos;a&apos;;
    var b = arg =&gt; arg + &apos;b&apos;;

    var c = compose(a, b); // 将a,b函数进行组合
    console.log(c(&apos;c&apos;));  // =&gt; cba
</code></pre><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><pre><code>function isDataType(type){
    var typeName = &apos;&apos;;

    switch(toString.call(type)){
        case &apos;[object String]&apos;:
            return &apos;string&apos;;
            break;

        case &apos;[object Number]&apos;:
            if(type.toString().indexOf(&apos;.&apos;) != -1){
                return &apos;float&apos;;
            }
            else{
                return &apos;number&apos;;
            }
            break;

        case &apos;[object Array]&apos;:
            return &apos;array&apos;;
            break;

        case &apos;[object Object]&apos;:
            return &apos;object&apos;;
            break;

        case &apos;[object Undefined]&apos;:
            return &apos;undefined&apos;;
            break;

        case &apos;[object Null]&apos;:
            return &apos;null&apos;;
            break;    

        default: break;
    }

    return typeName;
}
</code></pre><p>| <a href="http://www.alloyteam.com/2016/09/talk-about-functional-programming/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/09/talk-about-functional-programming/</a><br>| <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之组件篇/">React Native之组件篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之组件篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h5 id="组件列表"><a href="#组件列表" class="headerlink" title="组件列表"></a>组件列表</h5><pre><code>ListView - 用于展示数据列表

ScrollView - 带滚动条的容器

Fetch - 请求网络接口数据

TarBarIOS - 切换菜单

TouchableHighlight - 封装视图，可以将一些内容放到这个容器中方便处理点击


View - 窗口，相当于div

Image - 加载图片

Text - 展示文本

TextInput - 文本输入框

Button - 按钮
</code></pre><h4 id="根据ios、android不同系统"><a href="#根据ios、android不同系统" class="headerlink" title="根据ios、android不同系统"></a>根据ios、android不同系统</h4><pre><code>定义一个兼容组件:
    var Component = Platform.select({
        ios: () =&gt; require(&apos;ComponentIOS&apos;),
        android: () =&gt; require(&apos;ComponentAndroid&apos;),
    })();

调用组件
    &lt;Component /&gt;


样式兼容:
    import { Platform, StyleSheet } from &apos;react-native&apos;;
    var styles = StyleSheet.create({
        height: (Platform.OS === &apos;ios&apos;) ? 200 : 100,
    });

    import { Platform, StyleSheet } from &apos;react-native&apos;;
    var styles = StyleSheet.create({
        container: {
            flex: 1,
            ...Platform.select({
            ios: {
                backgroundColor: &apos;red&apos;,
            },
            android: {
                backgroundColor: &apos;blue&apos;,
            },
            }),
        },
    });
</code></pre><h4 id="react-native-内置组件"><a href="#react-native-内置组件" class="headerlink" title="react-native 内置组件"></a>react-native 内置组件</h4><pre><code>需要在react-native对象进行解构 

import {View, TextInput, Text} from &apos;react-native&apos;
</code></pre><h4 id="View-用来布局的组件"><a href="#View-用来布局的组件" class="headerlink" title="View 用来布局的组件"></a>View 用来布局的组件</h4><pre><code>&lt;View style={{ flex: 1; justifyContent: 'center', alignItems: 'center}}&gt;
    &lt;Text&gt;xxxxx&lt;/Text&gt;
&lt;/View&gt;
</code></pre><h4 id="Text-显示文本内容"><a href="#Text-显示文本内容" class="headerlink" title="Text 显示文本内容"></a>Text 显示文本内容</h4><pre><code>&lt;Text&gt;Component A&lt;/Text&gt;
</code></pre><h4 id="TextInput-文本输入框"><a href="#TextInput-文本输入框" class="headerlink" title="TextInput 文本输入框"></a>TextInput 文本输入框</h4><pre><code>属性: 

    autoCapitalize - 枚举类型，可选值有none,sentences,words,characters.当用户输入时，用于提示。

    placeholder - 占位符，在输入前显示的文本内容。

    value - 文本输入框的默认值。

    placeholdertTextColor - 占位符文本颜色。

    password - 如果为ture ， 则是密码输入框，文本显示为＊＊＊。

    multiline - 如果为true ， 则是多行输入。

    editable - 如果为false ， 文本框不可输入。其默认值事true。

    autoFocus - 如果为true， 将自动聚焦。

    clearButtonMode - 枚举类型，可选值有never，while－enditing , unless-editing,always.用于显示清除按钮。

    maxLength - 能够输入的最长字符数。

    enablesReturnKeyAutomatically : 如果值为true，表示没有文本时键盘是不能有返回键的。其默认值为false。

    returnKeyType - 枚举类型，可选值有default,go,google,join,next,route,search,send,yahoo,done,emergency-call。表示软键盘返回键显示的字符串。

事件:

    onChangeText - 当文本输入框的内容发生变化时，调用该函数。onChangeText接收一个文本的参数对象。

    onChange - 当文本变化时，调用该函数。

    onEndEditing - 当结束编辑时，调用该函数。

    onBlur - 失去焦点出发事件。

    onFocus - 获得焦点出发事件。

    onSubmitEditing : 当结束编辑后，点击键盘的提交按钮出发该事件。


&lt;TextInput
    style={styles.inp}
    placeholder=&quot;none&quot;
    autoCapitalize=&quot;none&quot; /&gt;
</code></pre><h4 id="Keyboard-控制-键盘的"><a href="#Keyboard-控制-键盘的" class="headerlink" title="Keyboard 控制 键盘的"></a>Keyboard 控制 键盘的</h4><h4 id="KeyboardAvoidingView-键盘"><a href="#KeyboardAvoidingView-键盘" class="headerlink" title="KeyboardAvoidingView  键盘"></a>KeyboardAvoidingView  键盘</h4><pre><code>用于解决手机上弹出键盘挡住视图，本组件可以自动根据键盘的位置，调整自身的position
</code></pre><h4 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h4><pre><code>color: 颜色       disabel: 是否可用       onPress: 点击事件       title: 按钮文本

&lt;Button
    onPress={onPressLearnMore}
    title=&quot;Learn More&quot;
    color=&quot;#841584&quot;
    accessibilityLabel=&quot;Learn more about this purple button&quot; /&gt;
</code></pre><h4 id="Image-图片-加载的两种方式"><a href="#Image-图片-加载的两种方式" class="headerlink" title="Image 图片 加载的两种方式"></a>Image 图片 加载的两种方式</h4><pre><code>onLayout: 元素挂载或布局中改变调用      onLoad: 加载成功完成调用        onLoadEnd: 加载结束后，无论成功失败都调用

resizeMode:  cover:等比拉伸      strech:保持原有大小       contain:图片拉伸  充满空间

source: 图片的资源地址


1、require引用  使用静态图片资源

    &lt;Image source={require(&apos;./components/images/i1.png&apos;)} style={{width: 100, height: 100}} resizeMode={&apos;cover&apos;} /&gt;

    注: 使用require静态资源，不允许拼接url &lt;Image source={require(&apos;./img/my_icon&apos;+&apos;.png&apos;)} /&gt;


2、uri  使用网络图片资源

    &lt;Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} style={{width: 400, height: 400}} /&gt;


3、使用原生图片资源(ios中的图片)

    打开xCode 在工程 打开images xcassets目录，将图片vue-banner.jpg拖入到appicon下进行导入

    加载 &lt;Image source={{uri: 'vue-banner'}} style={styles.imgStyle2} resizeMode=&quot;cover&quot; /&gt;  重启项目


4、使用本地文件系统中的资源(相册里的图片)
</code></pre><h4 id="TarBarIOS-选项卡插件-只能在根元素不能被任何元素包裹"><a href="#TarBarIOS-选项卡插件-只能在根元素不能被任何元素包裹" class="headerlink" title="TarBarIOS  选项卡插件 只能在根元素不能被任何元素包裹"></a>TarBarIOS  选项卡插件 只能在根元素不能被任何元素包裹</h4><pre><code>TabBarIOS 属性

    barTintColor 标签栏背景色 

    tintColor 当前选中的标签颜色 

    translucent Boolean  是否标签栏半透明

    &lt;TabBarIOS barTintColor=&quot;#ccc&quot; tintColor=&quot;#fff&quot;&gt;
        &lt;TabBarIOS.Item&gt; ... &lt;/TabBarIOS.Item&gt;
    &lt;/TabBarIOS&gt;


TabBarIOS.Item 属性

    title: 图标下面的标题文字

    badge: 右上角显示一个红色气泡 提示气泡

    icon: 显示的图标  

        icon={require(&apos;../images/i4.png&apos;)} 加载本地

        icon={{uri: base64Icon, scale: 3}} 加载其它 并且带缩放

    selectedIcon: 选中的图标

    selected: 是否为选中状态 selected: {this.state.selectName = &apos;blue&apos;}

    onPress(): 按下
</code></pre><h4 id="Fetch-网络请求"><a href="#Fetch-网络请求" class="headerlink" title="Fetch 网络请求"></a>Fetch 网络请求</h4><pre><code>获取接口数据, 处理get或post的请求

Example:

    1、Get

    onPressLearnMore(){
        let that = this;
        const REQUEST_URL = &apos;http://goucai.diyicai.com/lottery/hisnumber.action?lotteryId=001&amp;issueLen=20&amp;d=1496242956216&apos;;

        fetch(REQUEST_URL)
            .then((response) =&gt; {
                return response.json();  //把response转为json
            })
            .then((responseData) =&gt; {   // 接收上面的转好的json
                debugger;
                let data = responseData[0].ernieDate;
                that.setState({lotter: data})
                console.log(data);
            })
            .catch((error) =&gt; {
                this.setState({
                    error: true,
                    errorInfo: error
                })
            })
            .done();
    }

    2、post:

    fetch(&apos;https://mywebsite.com/endpoint/&apos;, {
        method: &apos;POST&apos;,
        headers: {
            &apos;Accept&apos;: &apos;application/json&apos;,
            &apos;Content-Type&apos;: &apos;application/json&apos;,
        },
        body: JSON.stringify({
            firstParam: &apos;yourValue&apos;,
            secondParam: &apos;yourOtherValue&apos;,
        })
    })
</code></pre><h4 id="FlatList-加载网络数据"><a href="#FlatList-加载网络数据" class="headerlink" title="FlatList 加载网络数据"></a>FlatList 加载网络数据</h4><h4 id="SectionList-分组的列表组件"><a href="#SectionList-分组的列表组件" class="headerlink" title="SectionList 分组的列表组件"></a>SectionList 分组的列表组件</h4><pre><code>不需要分组可以使用FlatList, 如果需要分组使用SectionList
</code></pre><h4 id="TouchableHighlight-封装视图-把一部分内容放到一个容器中可以方便处理"><a href="#TouchableHighlight-封装视图-把一部分内容放到一个容器中可以方便处理" class="headerlink" title="TouchableHighlight  封装视图 把一部分内容放到一个容器中可以方便处理"></a>TouchableHighlight  封装视图 把一部分内容放到一个容器中可以方便处理</h4><pre><code>render: function () {
    return (
        &lt;TouchableHighlight onPress={this._onPressButton} style={styles.mt40}&gt;
            &lt;View&gt;
                &lt;Text&gt;{this.state.userName}&lt;/Text&gt;
                &lt;Image
                    style={styles.mt40}
                    source={require(&apos;./src/images/1.jpg&apos;)}
                /&gt;
            &lt;/View&gt;                    
        &lt;/TouchableHighlight&gt;
    );
}
</code></pre><h4 id="Dimensions-获取设备屏幕的宽高"><a href="#Dimensions-获取设备屏幕的宽高" class="headerlink" title="Dimensions  获取设备屏幕的宽高"></a>Dimensions  获取设备屏幕的宽高</h4><pre><code>let winWidth = Dimensions.get(&apos;window&apos;).width;
let winHeight = Dimensions.get(&apos;window&apos;).height;
</code></pre><h4 id="DatePickerIOS-日期选择器"><a href="#DatePickerIOS-日期选择器" class="headerlink" title="DatePickerIOS  日期选择器"></a>DatePickerIOS  日期选择器</h4><pre><code>date: 当前被选中的日期      mode: 选择器模式       onDateChange: 选中事件

maximumdDate: 可选的最大日期       minimumDate: 可选的最小日期        

minuteInterval: 可选的最小分钟     timeZoneOffsetInMinutes: 时区差，单位分钟
</code></pre><h4 id="TimePickerAndroid-Android时间选择器的对话框"><a href="#TimePickerAndroid-Android时间选择器的对话框" class="headerlink" title="TimePickerAndroid Android时间选择器的对话框"></a>TimePickerAndroid Android时间选择器的对话框</h4><h4 id="ActivityIndicator-loading加载图标"><a href="#ActivityIndicator-loading加载图标" class="headerlink" title="ActivityIndicator  loading加载图标"></a>ActivityIndicator  loading加载图标</h4><pre><code>animating: 是否显示 true false

color: 图片颜色

size: 大小  small large
</code></pre><h4 id="Modal-弹层"><a href="#Modal-弹层" class="headerlink" title="Modal  弹层"></a>Modal  弹层</h4><pre><code>不是弹窗，而是整弹个层

animationType: 展示层的动画效果  slide 滑动   fade 淡入淡出    none 无

onRequestClose: 
</code></pre><h4 id="alert、AlertIOS-对话框"><a href="#alert、AlertIOS-对话框" class="headerlink" title="alert、AlertIOS  对话框"></a>alert、AlertIOS  对话框</h4><pre><code>Alert.alert(标题，内容，[{确定按钮和}]

&lt;Text onPress={() =&gt; Alert.alert(
    &apos;这里是弹层的标题&apos;,
    &apos;这里是内容&apos;,
    [
        {text: &apos;取消&apos;, onPress: () =&gt; console.log(&apos;Cancel Pressed!&apos;)},    // 显示的按钮和回调函数
        {text: &apos;确定&apos;, onPress: () =&gt; console.log(&apos;OK Pressed!&apos;)},
    ]
)}&gt;点击显示弹窗&lt;/Text&gt;
</code></pre><h4 id="Navigator-NavigatorIOS-导航"><a href="#Navigator-NavigatorIOS-导航" class="headerlink" title="Navigator NavigatorIOS  导航"></a>Navigator NavigatorIOS  导航</h4><h4 id="StatusBar-状态栏组件"><a href="#StatusBar-状态栏组件" class="headerlink" title="StatusBar 状态栏组件"></a>StatusBar 状态栏组件</h4><pre><code>控制顶部运营商、电量位置的

属性: 

    animated bool   进行设置当状态栏的状态发生变化的时候是否需要加入动画。当前该动画支持backgroundColor,barStyle和hidden属性

    hidden  bool  进行设置状态栏是否隐藏（最顶部的那条栏）

    backgroundColor   color类型，仅支持Android设备，设置状态栏的背景颜色

    translucent bool类型，仅支持Android设备, 进行设置状态栏是否为透明。当状态栏的值为true的时候，应用将会在状态栏下面进行绘制显示。这样在Android平台上面就是沉浸式的效果，可以达到Android和iOS应用一致性效果。该值常常配置半透明效果的状态栏颜色一起使用

    barStyle  enum(&apos;default&apos;,&apos;light-content&apos;)  枚举类型，仅支持iOS设备。进行设置状态栏文字的颜色

    networkActivityIndicatorVisible   bool类型，仅支持iOS设备。设置状态栏上面的网络进度加载器是否进行显示

    showHideTransition   enum(&apos;fade&apos;,&apos;slide&apos;) 枚举类型，仅支持iOS设备。进行设置当隐藏或者显示状态栏的时候的动画效果。默认值为&apos;fade&apos;
</code></pre><h4 id="Picker-PickerIOS-象select的选择菜单"><a href="#Picker-PickerIOS-象select的选择菜单" class="headerlink" title="Picker PickerIOS  象select的选择菜单"></a>Picker PickerIOS  象select的选择菜单</h4><pre><code>1、selectedValue: 选中后的值

2、onValueChange: 触发事件

3、PickerIOS.Item: 定义菜单的先项

&lt;PickerIOS
    style={{width:200}}
    selectedValue={this.state.language}
    onValueChange={(lang) =&gt; this.setState({language: lang})}&gt;
    &lt;PickerIOS.Item label=&quot;Java&quot; value=&quot;java&quot; /&gt;
    &lt;PickerIOS.Item label=&quot;JavaScript&quot; value=&quot;js&quot; /&gt;
&lt;/PickerIOS&gt;
&lt;Text&gt;当前选择的是:{this.state.language}&lt;/Text&gt;
</code></pre><h4 id="Slider-选择一个范围的组件-滑块"><a href="#Slider-选择一个范围的组件-滑块" class="headerlink" title="Slider  选择一个范围的组件, 滑块"></a>Slider  选择一个范围的组件, 滑块</h4><pre><code>属性:

    disabled    bool    如果为true，用户无法移动这个滑动条。默认值为false

    maximumValue    number    滑动条最大值。默认为1

    minimumValue    number    滑动条最小值，默认为0

    onSlidingComplete    function    当用户完成值的改变被回调的方法

    onValueChange    function    当用户正在滑动滑动条持续回调的方法

    step    number    滑动条的最小单位。这个值应该在0到最大值-最小值之间。默认为0

    testID    string    

    value    number    滑动条选择的值。这个值应该在最小值和最大值之间，它们的默认值分别为0和1。默认值为0
</code></pre><h4 id="Switch-开关滑块组件"><a href="#Switch-开关滑块组件" class="headerlink" title="Switch  开关滑块组件"></a>Switch  开关滑块组件</h4><pre><code>disabled 是否禁用

onValueChange 当值改变时回调

value 开关是否打开，默认false

onTintColor: 开启状态背景颜色

tintColor: 关闭状态时边框颜色或背景色

thumbTintColor: 开关上按钮的颜色     

testID
</code></pre><h4 id="ScrollView-可滚动的容器，可以放多个组件和视图"><a href="#ScrollView-可滚动的容器，可以放多个组件和视图" class="headerlink" title="ScrollView  可滚动的容器，可以放多个组件和视图"></a>ScrollView  可滚动的容器，可以放多个组件和视图</h4><h4 id="ListView-用于垂直滚动列表，用于元素之间结构近似而仅数据不同-listView不立即渲染所有元素-优先渲染屏幕可见元素"><a href="#ListView-用于垂直滚动列表，用于元素之间结构近似而仅数据不同-listView不立即渲染所有元素-优先渲染屏幕可见元素" class="headerlink" title="ListView  用于垂直滚动列表，用于元素之间结构近似而仅数据不同, listView不立即渲染所有元素, 优先渲染屏幕可见元素"></a>ListView  用于垂直滚动列表，用于元素之间结构近似而仅数据不同, listView不立即渲染所有元素, 优先渲染屏幕可见元素</h4><pre><code>ListView继承了ScrollView所以有ScrollView下所有的属性

ListView属性:

    dataSource - 列表数据源

    renderRow - 解析每一条的数据的展示结构样式

    rowHasChanged - 函数也是ListView的必需属性。这里我们只是简单的比较两行数据是否是同一个数据（===符号只比较基本类型数据的值，和引用类型的地址）来判断某行数据是否变化了。

    scrollView - automaticallyAdjustContentInsets={false} 如果不设置这个属性顶部会一个块留白

ListView方法:

    ListView.DataSource - 用于比对两条数据是否相同，如果不相同进行渲染


Example:

    class DemoComponent extends Component {
        constructor(props){
            super(props);
            const ds = new ListView.DataSource({
                rowHasChanged: (r1, r2) =&gt; r1 !== r2
            });

            this.state = {
                dataSource: ds.cloneWithRows([
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    },
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    },
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    }               
                ])
            }
        }

        // 返回每一条数据的结构
        carRenderRow(rowData){
            return (
                &lt;View style={styles.carList}&gt;
                    &lt;Image source={rowData.img} style={styles.carPicture} /&gt;
                    &lt;Text style={styles.carFont1}&gt;{rowData.title}&lt;/Text&gt;                  
                &lt;/View&gt;
            )
        }

        render(){
            return (
                &lt;View style={{flex: 1, marginBottom: 60}}&gt;
                    &lt;ListView
                        dataSource={this.state.dataSource}
                        renderRow={this.carRenderRow} /&gt;             
                &lt;/View&gt;
            )
        }
    }
</code></pre><h4 id="RefreshControl-下拉刷新"><a href="#RefreshControl-下拉刷新" class="headerlink" title="RefreshControl  下拉刷新"></a>RefreshControl  下拉刷新</h4><pre><code>PullToRefreshAndroidView 也是实现下拉刷新的组件

属性方法

    onRefresh  function方法 当视图开始刷新的时候调用

    refreshing  bool  决定加载进去指示器是否为活跃状态，也表名当前是否在刷新中

    colors [ColorPropType]   android平台适用  进行设置加载进去指示器的颜色，至少设置一种，最好可以设置4种

    enabled  bool   android平台适用   用来设置下拉刷新功能是否可用

    progressBackgroundColor ColorPropType  设置加载进度指示器的背景颜色

    size RefreshLayoutConsts.SIZE.DEFAULT  android平台适用  加载进度指示器的尺寸大小 ，具体可以查看RefreshControl.SIZE(详细点击进入)

    tintColor ColorPropType   iOS平台适用  设置加载进度指示器的颜色

    title string iOS平台适用  设置加载进度指示器下面的标题文本信息
</code></pre><h4 id="AppState、AppStateIOS-获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你"><a href="#AppState、AppStateIOS-获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你" class="headerlink" title="AppState、AppStateIOS  获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你"></a>AppState、AppStateIOS  获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你</h4><pre><code>AppState.currentState 返回的值:

    active - 表示当前App在前台运行

    background - 应用正在后台运行。用户既可能在别的应用中，也可能在桌面。

    inactive - 该状态我们可以暂时不考虑，因为该状态不会出现在现在React Native App中。
</code></pre><h4 id="AppRegistry-运行RN的入口"><a href="#AppRegistry-运行RN的入口" class="headerlink" title="AppRegistry 运行RN的入口"></a>AppRegistry 运行RN的入口</h4><pre><code>AppRegistry.registerComponent(&apos;exampleApp&apos;, () =&gt; exampleApp);
</code></pre><h4 id="AsyncStorage-简单的、未加密的、异步的、持久化的Key-Value存储系统"><a href="#AsyncStorage-简单的、未加密的、异步的、持久化的Key-Value存储系统" class="headerlink" title="AsyncStorage  简单的、未加密的、异步的、持久化的Key-Value存储系统"></a>AsyncStorage  简单的、未加密的、异步的、持久化的Key-Value存储系统</h4><pre><code>一、方法: anyncStroage每个方法返回的都是一个Promise

    getItem(key, callback) - 获取数据

    setItem(key, value, callback) - 存储数据

    removeItem(key, callback) - 删除数据

    mergeItem(key, value, callback) - 合并两值

    clear() - 删除全部

    getAllKeys(callback) - 获取所有可访问到的数据

    flushGetRequest() - 清除所有进行中的查询操作

    multiGet(keys &lt;Array&gt;, callback) - 获取keys所包含所有的字段值

        AsyncStroage.multiGet([&apos;user&apos;, &apos;enter&apos;])
            .then((data) =&gt; {
                // 这里可以取到本地存储中的user和enter的值
                /*
                * data返回的是一个二维数组
                * [
                *   [&quot;key1&quot;, &quot;aaa&quot;],
                *   [&quot;key2&quot;, &quot;bbb&quot;]
                * ]
                */

                let user = JSON.parse(data);
            })
</code></pre><h4 id="ProgressBarAndroid-ProgressViewIOS-加载进度"><a href="#ProgressBarAndroid-ProgressViewIOS-加载进度" class="headerlink" title="ProgressBarAndroid ProgressViewIOS 加载进度"></a>ProgressBarAndroid ProgressViewIOS 加载进度</h4><pre><code>属性:

    View 相关属性样式全部继承(例如:宽和高,背景颜色,边距等相关属性样式)

    progress number  设置进度值 (范围在0-1之间)

    progressTintColor  string  设置进度条本身的颜色

    progressViewStyle   enum(&apos;default&apos;,&apos;bar&apos;)  加载进度的风格   枚举类型 默认风格和Bar条类型

    trackImage   Image.propTypes.source    设置一个可以拉伸的图片，设置进度条剩下部分进度的图片

    trackTintColor  string   进度条的颜色(已经有进度的情况)
</code></pre><h4 id="DrawerLayoutAndroid-抽屉-安卓"><a href="#DrawerLayoutAndroid-抽屉-安卓" class="headerlink" title="DrawerLayoutAndroid   抽屉 安卓"></a>DrawerLayoutAndroid   抽屉 安卓</h4><p>SegmentedControlIOS<br>ToolbarAndroid<br>TouchableNativeFeedback<br>TouchableOpacity<br>TouchableWithoutFeedback<br>ViewPagerAndroid<br>VirtualizedList<br>WebView</p>
<p>API<br>ActionSheetIOS<br>AdSupportIOS<br>Animated<br>BackAndroid<br>BackHandler     后退<br>CameraRoll      访问本地相册<br>Clipboard       读写剪贴板的内容<br>DatePickerAndroid  Android日期选择器的对话框<br>Easing<br>Geolocation     地理位置<br>ImageEditor     根据URI剪裁对应的图片<br>ImagePickerIOS<br>ImageStore<br>InteractionManager<br>LayoutAnimation 当布局变化时，自动将视图运动到它们新的位置上<br>Linking         传入和传出的App链接进行交互<br>NativeMethodsMixin<br>NetInfo         获取设备联网或离线的状态信息<br>PanResponder    多点触摸操作协调成一个手势<br>PermissionsAndroid<br>PixelRatio      获取设备的像素密度的方法<br>PushNotificationIOS 处理应用的推送通知<br>Share           打开一个对话框来共享文本内容<br>StyleSheet      定义css样式<br>Systrace<br>ToastAndroid<br>Vibration       控制设备震动<br>布局样式属性<br>阴影样式属性</p>
<hr>
<h4 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h4><pre><code>rnpm介绍 下载完第三方组件不能直接用，需要通过rnpm 直接组件的内容挂载到工程中去，需要执行$ rnpm link 模块名 ，与react-native link 相同

    安装rnpm  $ npm i rnpm -g

    link的原因：以下组件都是原生开发，wrapper了一层js，因此需要link .a到project中

$ react-native-elements   基础组件    https://github.com/react-native-community/react-native-elements#buttons


$ lodash 

$ query-string 

$ sha1      加密模块

$ react-native-button

$ react-native-audio      音频

$ react-native-video      视频  https://github.com/react-native-community/react-native-video

$ react-native-image-picker  摄像头和本地相册  https://github.com/marcshilling/react-native-image-picker

$ react-native-progress   进度条

$ react-native-storage    存储  https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md

$ react-native-sk-countdown  倒计时

$ react-native-swiper     轮播 https://github.com/leecade/react-native-swiper

$ react-native-barcodescanner 扫二维码 Android   https://github.com/ideacreation/react-native-barcodescanner
                                      http://blog.csdn.net/liu__520/article/details/52889950

$ react-native-animatable  动画   https://github.com/oblador/react-native-animatable

$ react-native-device-info 设备信息  https://github.com/rebeccahughes/react-native-device-info
                                    http://www.ncloud.hk/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/react-native-acquisition-device-information-component-react-native-device-info/


Geolocation  内置的地理位置 


http://www.jianshu.com/p/53ff78168acc       整理的插件
https://yq.aliyun.com/articles/78154?utm_campaign=wenzhang&amp;utm_medium=article&amp;utm_source=QQ-qun&amp;201759&amp;utm_content=m_20152
http://www.jianshu.com/p/e30feb098ef2
</code></pre><h4 id="react-native-vector-icons-图标类"><a href="#react-native-vector-icons-图标类" class="headerlink" title="react-native-vector-icons 图标类"></a>react-native-vector-icons 图标类</h4><pre><code>1、安装 npm i react-native-vector-icons --save &amp;&amp; react-native link react-native-vector-icons

2、引用

    import FontAwesome from &apos;react-native-vector-icons/FontAwesome&apos;;        // 引用的FontAwesome文件
    /* 图标文件名
        Entypo
        EvilIcons 
        FontAwesome 
        Foundation 
        Ionicons 
        MaterialIcons
        MaterialCommunityIcons 
        Octicons 
        Zocial 
        SimpleLineIcons 
    */

    class myfirst extends Component {
        render() {
            return (
                &lt;View style={styles.container}&gt;
                    &lt;FontAwesome name=&quot;address-book&quot; size={20} color=&quot;#4F8EF7&quot; /&gt;
                &lt;/View&gt;
            )
        }
    }

3、注意: 这里icon对一些组件封装

    import Icon from &apos;react-native-vector-icons/Ionicons&apos;;
    return (
        &lt;TabBarIOS&gt;
            &lt;Icon.TabBarItem        // 这里对TabBarItem进行了封装  或者ToolbarAndroid
                title=&quot;Home&quot;
                iconName=&quot;ios-home-outline&quot;     // 这里属性名为 iconName 而不是 icon
                selectedIconName=&quot;ios-home&quot;&gt;    // 选中的
                &lt;View style={styles.tabContent}&gt;&lt;Text&gt;Home Tab&lt;/Text&gt;&lt;/View&gt;
            &lt;/Icon.TabBarItem&gt;
        &lt;/TabBarIOS&gt;
    );

https://github.com/oblador/react-native-vector-icons
http://ionicons.com/  图标官网
http://blog.csdn.net/uuq/article/details/53150841  使用方法  
https://github.com/oblador/react-native-vector-icons#installation   图标对应的name值 
</code></pre><h4 id="mockjs"><a href="#mockjs" class="headerlink" title="mockjs"></a>mockjs</h4><pre><code>npm i mockjs --save

import Mock from &apos;mockjs&apos;
</code></pre><p>| 参考资料<br>| react.parts/native   // 第三方组件列表 <strong><em><br>|<br>| <a href="http://www.lcode.org/react-native/" target="_blank" rel="noopener">http://www.lcode.org/react-native/</a><br>| <a href="http://blog.csdn.net/hsbirenjie/article/category/6307126/3" target="_blank" rel="noopener">http://blog.csdn.net/hsbirenjie/article/category/6307126/3</a><br>| <a href="http://blog.csdn.net/jiangqq781931404/article/category/6055594/2" target="_blank" rel="noopener">http://blog.csdn.net/jiangqq781931404/article/category/6055594/2</a><br>| <a href="http://www.hangge.com/blog/cache/category_76_1.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/category_76_1.html</a>       </em></strong><br>| <a href="http://blog.csdn.net/mengks1987/article/category/6850683" target="_blank" rel="noopener">http://blog.csdn.net/mengks1987/article/category/6850683</a><br>| <a href="http://blog.csdn.net/yuanguozhengjust/article/category/6058018" target="_blank" rel="noopener">http://blog.csdn.net/yuanguozhengjust/article/category/6058018</a><br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之积累篇/">React Native之积累篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之积累篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="IOS、Android的图标、app名称和启动图"><a href="#IOS、Android的图标、app名称和启动图" class="headerlink" title="IOS、Android的图标、app名称和启动图"></a>IOS、Android的图标、app名称和启动图</h4><pre><code>一、App名称修改

    Xcode中打开项目下info.plist -&gt; Bundle name 和 Bundle display name 都修改APP的名称

二、App图标

    方法1 Xcode中配置:

        Xcode工程目录下的Images.xcassets -&gt; AppIcon中将来加载图标，分别为120x120、180x180

    方法2 代码中配置

        1、使用icon psd模板右键 Edit me and save图层 ——&gt; 编辑内容 ——&gt; 编辑完后保存 ——&gt; 导出图片（窗口）——&gt; 动作 ——&gt; 右上角按钮选择载入动作将App Icon Template [3.3].atn文件载入 ——&gt; 选择导出动作中有两种一个都是圆角图标一个是方形图标

        2、将导出的图标添加到项目中 找到ios/gzApp/Images.xcassets ——&gt; 将所有导出的图标放到这个目录下

三、设置启动图

    方法1 Xcode中配置:

        Xcode工程下点击Images.xcassets -&gt; 进入后 右键 App Icons &amp; launch Image -&gt; New IOS Launch Image -&gt; 将启动图加载到各配置中（注意如果尺寸与当前不配置编译时会报错）

        在项目的General面板 Launch Images Source 选择刚才创建的launchImage, launch Screen File设置为空，App Icons Source就是图标的配置

    方法2 代码配置

        https://github.com/fbsamples/f8app/tree/master/ios/F8v2   // Base.lproj -&gt; LaunchScreen.xib

        在ios文件夹 -&gt; gzCar项目 -&gt; Base.Iproj -&gt; LaunchScreen.xib 使用文件替换，将Splash.png文件导入到项目中，启动


http://www.cnblogs.com/allenxieyusheng/p/5802179.html
http://www.jianshu.com/p/adpKye/
https://appicontemplate.com/ios9    图标尺寸导出  

转icon尺寸
http://www.zcool.com.cn/article/ZNjE1MTI=.html
http://makeappicon.com/
http://blog.csdn.net/leiyu231/article/details/52830151
</code></pre><h4 id="fetch-请求提示netWork-quest-failed"><a href="#fetch-请求提示netWork-quest-failed" class="headerlink" title="fetch 请求提示netWork quest failed"></a>fetch 请求提示netWork quest failed</h4><pre><code>在 Xcode 7.0 bata、ios9 中fetch默认https请求, 对http不起作用，需要修改info.plist配置

1、在Info.plist中添加 NSAppTransportSecurity 类型 Dictionary ; 
2、在 NSAppTransportSecurity 下添加 NSAllowsArbitraryLoads 类型Boolean ,值设为 YES;

http://blog.csdn.net/liyijun4114/article/details/51792179
</code></pre><h4 id="网络图片无法加载问题"><a href="#网络图片无法加载问题" class="headerlink" title="网络图片无法加载问题"></a>网络图片无法加载问题</h4><pre><code>在iOS9之后，网络请求默认为Https请求，如需支持Http，修改info.plist文件添加键值对设置允许http访问。

在App Transport Security Settings中添加 Allow Arbitrary Loads设置为 YES
</code></pre><h4 id="内测平台"><a href="#内测平台" class="headerlink" title="内测平台"></a>内测平台</h4><pre><code>https://www.pgyer.com/      蒲公英将测试包分发给多人的设备上进行测试

    在Xcode中倒出一个应用包，通过蒲公英上传进行分发多个设备

https://developer.apple.com/  苹果开发者账号申请

苹果开发者平台可以进行

苹果的安装包为 *.ipa 文件

1、先登录Account，注册苹果开发者账号个人或企业

2、Xcode 打包IOS文件 https://www.pgyer.com/doc/view/app_upload
</code></pre><h4 id="代码类"><a href="#代码类" class="headerlink" title="代码类"></a>代码类</h4><pre><code>一、render中调用方法将View返回

    class TabPage extends Component {

        _createNav(name, colorValue){
            return (
                &lt;View&gt;
                    &lt;Text style={{color: colorValue}}&gt;{name}&lt;/Text&gt;
                &lt;/View&gt;
            )
        }

        render(){
            return (
                &lt;View&gt;
                    {this._createNav(&apos;siguang&apos;, &apos;#ddd&apos;)}
                &lt;/View&gt;
            )
        }
    }
</code></pre><p>| 参考资料<br>|  react.parts/native<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/金融类/">金融类</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/金融类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/金融/">金融</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="居民的金融四大决策"><a href="#居民的金融四大决策" class="headerlink" title="居民的金融四大决策"></a>居民的金融四大决策</h4><pre><code>一、消费决策和储蓄决策 - 多少财富用于消费，多少为储蓄

二、投资决策 - 怎么样投资所节省的资金

三、融资决策 - 自己的消费和投资计划

四、风险管理决策 - 降低金融不确定性
</code></pre><h4 id="金融体系"><a href="#金融体系" class="headerlink" title="金融体系"></a>金融体系</h4><pre><code>金融体系包括金融市场、金融中介、金融服务企业以其它用来执行居民户、企业和政府的金融决策的机构

1、金融中介 - 主要业务向客户提供金融产品和服务的企业，主要包括(银行、存款储蓄机构、保险公司、养老金与退休基金、投资银行、风险投资企业、资产管理企业)
</code></pre><h2 id="M0、M1、M2"><a href="#M0、M1、M2" class="headerlink" title="M0、M1、M2"></a>M0、M1、M2</h2><h2 id="什么是金融、金融体系"><a href="#什么是金融、金融体系" class="headerlink" title="什么是金融、金融体系"></a>什么是金融、金融体系</h2><h2 id="赤字"><a href="#赤字" class="headerlink" title="赤字"></a>赤字</h2><h2 id="金融危机和次贷危机"><a href="#金融危机和次贷危机" class="headerlink" title="金融危机和次贷危机"></a>金融危机和次贷危机</h2><pre><code>低利率照成所有人去银行进行贷款，然后使用杠杆

杠杆是用借贷来扩大交易收益的手段

杠杆的操作 - 例 A用1万美元买一个箱子，在以1.1万美元卖给B，在中间赚了1千美元，这属于正常操作，

        如果用杠杆就是 A有1万美元，又去借了99万美元，这样手里有100万美元，去买了100个箱子，赚取110万，还了99万借款和1万的利息，赚了9万美元

次贷危机 - 通过这种杠杆会使大面积的贷款短贷导金融系统破崩溃
</code></pre><h2 id="刚性兑付"><a href="#刚性兑付" class="headerlink" title="刚性兑付"></a>刚性兑付</h2><pre><code>就是投资、理财的项目，无论赔了赚了都有平台或银行兜底，打破刚性兑付就是将打掉这种模式，平台和银行不在兜底，赔与赚要看借款方的企业
</code></pre><h2 id="投资类型"><a href="#投资类型" class="headerlink" title="投资类型"></a>投资类型</h2><pre><code>股票

基金

p2p借贷

股权投资
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>只要政府低利率加上超发货币，资产一定会上涨
</code></pre><p><a href="https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=340s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=340s</a><br><a href="https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=342s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=342s</a></p>
<p><a href="https://www.youtube.com/watch?v=eY_Y_w_95JY&amp;list=PLuoaTfw_1lYwyxS-RQ7_Hwsd_gcAdVJtV" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eY_Y_w_95JY&amp;list=PLuoaTfw_1lYwyxS-RQ7_Hwsd_gcAdVJtV</a>  金融学</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/微观经济学/">微观经济学</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/微观经济学/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/经济学/">经济学</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是经济"><a href="#什么是经济" class="headerlink" title="什么是经济"></a>什么是经济</h2><pre><code>经济 - 管理一个家庭的人

稀缺性 - 社会资源的有限性

经济学 - 研究社会如休管理自己的稀缺资源
</code></pre><h2 id="经济学的十大原理"><a href="#经济学的十大原理" class="headerlink" title="经济学的十大原理"></a>经济学的十大原理</h2><pre><code>一、人们面临权衡取舍 - 要知道做一件事情得到了什么，又舍去了什么，什么都想要最后确什么都没有
</code></pre><h2 id="绝对优势、比较优势"><a href="#绝对优势、比较优势" class="headerlink" title="绝对优势、比较优势"></a>绝对优势、比较优势</h2><pre><code>比较优势说明每种物品应该由生产这种物品成本较低的国家生产
</code></pre><h2 id="进口、出口"><a href="#进口、出口" class="headerlink" title="进口、出口"></a>进口、出口</h2><pre><code>进口: 在国外生产在国内销售的物品叫进口

出口: 在国内生产而在国外销售的物品称出口
</code></pre><h2 id="成本机会"><a href="#成本机会" class="headerlink" title="成本机会"></a>成本机会</h2><h2 id="供给与需求"><a href="#供给与需求" class="headerlink" title="供给与需求"></a>供给与需求</h2><pre><code>供给量是卖者愿意并且能够出售该物品的数量

供给定理是一种物品价格上升，该物品供给量增加，物品价格下降，物品供给量减少
</code></pre><h2 id="过剩、短缺"><a href="#过剩、短缺" class="headerlink" title="过剩、短缺"></a>过剩、短缺</h2><pre><code>过剩 - 当价格下降，供给者不能卖出他们想卖的所有物品

短缺 - 当前价格下，需求者不能买到他们想买的物品
</code></pre><h2 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h2><pre><code>市场是由某种物品或服务的买者或卖者组成的一个群体，买者作为一个群体决定了一种产品的需求，而卖者作为一个群体决定了一个产品的代给
</code></pre><h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><pre><code>竞争市场有许多买者与卖者并且每
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/宏观经济学/">宏观经济学</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/宏观经济学/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/经济学/">经济学</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="宏观经济、微观经济"><a href="#宏观经济、微观经济" class="headerlink" title="宏观经济、微观经济"></a>宏观经济、微观经济</h2><pre><code>宏观经济 - 研究整体经济现象，包括通货膨胀、失业和经济增长

微观经济 - 研究家庭和企业如何做出决策，以及市场上的相互影响
</code></pre><h2 id="GDP"><a href="#GDP" class="headerlink" title="GDP"></a>GDP</h2><pre><code>国内生产总值即GDP，可以衡量经济中所有人总收

GDP = 消费 + 投资 + 政府购买 + 净出口

一、消费

    消费是家庭除购买住房之外用于物品与服务的支出

二、投资

    用于未来生产更多物品和服务的物品，如房产，这里投资与金融投资不同

三、政府购买 

    包括政府员工薪水与公务支出

四、净出口

    等于外国对国内生产的物品进行购买
</code></pre><h2 id="CPI"><a href="#CPI" class="headerlink" title="CPI"></a>CPI</h2><pre><code>消费物价指数 - 是普通消费者所购买的物品与服务总费用的衡量指标
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/NPM/">NPM 常用命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/NPM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/npm/">npm</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么"></a>npm是什么</h4><pre><code>资源包的管理器，安装NodeJS时会直接安装NPM
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>$ 下载并安装node.js也就将npm直接安装

$ npm install npm@latest -g        // 更新npm

$ npm i [package_name]         // 安装包，将在当前目录创建一个node_modules目录，将下载的包保存到这个目录

$ npm update     // 获取最新的包并更新

$ npm uninstall [package_name]    // 卸载包，命令是将node_modules目录将包的文件删除

$ npm uninstall --save [package_name]    // 卸载包，将从package.json文件中删除依赖, 如果--save-dev安装就需要换成--save-dev

# npm i -g [package_name]    // 全局安装包，两种安装本地和全局安装，如果遇到acces错误权限问题，需要在前面加sudo，安装在/usr/local/lib/node_modules/中

$ npm update -g [package_name]    // 更新全局包

$ npm uninstall -g [package_name]    // 卸载全局包
</code></pre><h4 id="package-json参数介绍"><a href="#package-json参数介绍" class="headerlink" title="package.json参数介绍"></a>package.json参数介绍</h4><pre><code>name - 包名

version - 包的版本号

description - 包的描述

homepage - 包的官网 url 

author - 包的作者姓名

contributors - 包的其他贡献者姓名

dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下

repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上

main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(&quot;express&quot;)

keywords - 关键字
</code></pre><h4 id="npm-install-安装模块"><a href="#npm-install-安装模块" class="headerlink" title="npm install 安装模块"></a>npm install 安装模块</h4><pre><code>npm i [package_name] --save-dev

1、-S, --save 安装包添加到dependencies（项目依赖)中

    npm i 包名 --save

    当发布时可以不会将node_module目录发布出去，可以将package.json发布出去，其它项目的人，可以通过npm install 下载dependenciess中的所有包内容.

    例：
        npm install gulp --save 或 npm install gulp -S

        &quot;dependencies&quot;: {
            &quot;gulp&quot;: &quot;^1.0.0&quot;
        }

2、-D, --save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它

    npm install gulp --save-dev 或 npm install gulp -D

    &quot;devDependencies&quot;: {
        &quot;gulp&quot;: &quot;^1.0.0&quot;
    }


3、-O, --save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）

    npm install gulp --save-optional 或 npm install gulp -O

    &quot;optionalDependencies&quot;: {
        &quot;gulp&quot;: &quot;^1.0.0&quot;
    }


4、-E, --save-exact 精确安装指定模块版本

    npm install gulp --save-exact 或 npm install gulp -E

    输入命令npm install gulp -ES，留意package.json 文件的 dependencies 字段，以看出版本号中的^消失了

    &quot;dependencies&quot;: {
        &quot;gulp&quot;: &quot;3.9.1&quot;
    }
</code></pre><h4 id="npm-i-选项–global，–save，–save-dev"><a href="#npm-i-选项–global，–save，–save-dev" class="headerlink" title="npm i 选项–global，–save，–save-dev"></a>npm i 选项–global，–save，–save-dev</h4><pre><code>-global: 简写 -g

-save: 简写 -S, 作用是在package.json的dependencies字段增加或修改安装包和版本号

-save-dev: 简写 -D, 是修改devDependencies, 这样就不用安装了某个包之后手动修改package.json
</code></pre><h4 id="与-版本"><a href="#与-版本" class="headerlink" title="~ 与 ^ 版本"></a>~ 与 ^ 版本</h4><pre><code>版本分为: 主版本号、次版本号、补丁版本号

&quot;devDependencies&quot;: {
    &quot;vue&quot;: &quot;~2.2.2&quot;,            // 匹配最近小版本，如，会匹配所有的2.2.x版本，但最高不会匹配2.3.0
    &quot;vue-router&quot;: &quot;^2.2.0&quot;        // 最近的一个大版本，所有 2.x.x但不不包括3.0.0，相当于 2.0.0 &lt;= version &lt; 3.0.0
}
</code></pre><h4 id="npm-ls-查看安装的模块"><a href="#npm-ls-查看安装的模块" class="headerlink" title="npm ls 查看安装的模块"></a>npm ls 查看安装的模块</h4><pre><code>查看安装模块及依赖：npm ls -g
</code></pre><h4 id="发布模块"><a href="#发布模块" class="headerlink" title="发布模块"></a>发布模块</h4><pre><code>使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：

$ npm adduser
Username: mcmohd
Password:
Email: (this IS public) xxxxxx@qq.com

来发布模块命令: $ npm publish
</code></pre><h4 id="script属性"><a href="#script属性" class="headerlink" title="script属性"></a>script属性</h4><pre><code>script属性定义的对应了一段shell脚本

1、npm start 启动模块

    该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序

    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;gulp -ws&quot;
    }

2、npm stop 停止模块

3、npm restart 重新启动模块
</code></pre><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><pre><code>一、npm使用过程中遇到的 Cannot find module &apos;internal/fs&apos;，错误场景 gulp中执行任务报错，的确amd-optimize插件中的graceful-fs与gulp中graceful-fs的版本问题，

    解决:
        删除插件 npm uninstall graceful-fs
        安装  npm i graceful-fs --save

二、$ npm view react versions    查看包在npm所有版本

三、$ npm i vue@2.0.0 --save    安装指定版本
</code></pre><p>| 参考资料<br>| <a href="https://www.npmjs.com.cn/" target="_blank" rel="noopener">https://www.npmjs.com.cn/</a><br>| <a href="https://www.cnblogs.com/blackgan/p/7828047.html" target="_blank" rel="noopener">https://www.cnblogs.com/blackgan/p/7828047.html</a>            常用命令<br>| <a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/master-npm/</a><br>| <a href="https://github.com/ericdum/mujiang.info/issues/6/" target="_blank" rel="noopener">https://github.com/ericdum/mujiang.info/issues/6/</a><br>| <a href="http://www.luckyonecn.com/blog/difference_between_dependencies_and_devdependencies_in_npm/" target="_blank" rel="noopener">http://www.luckyonecn.com/blog/difference_between_dependencies_and_devdependencies_in_npm/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/Linux命令/">Linux命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/Linux命令/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Linux/">Linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>[root@localhost~]  root 管理员    localhost 主机名    ~ 用户的目录 $ 为普通用户 # root用户

1、命令 [选项] [参数]        选项可简化  -a 等于 --all

2、Linux中 .xxx文件 是隐藏文件

3、命令补全: 输入一个开头字母，按Tab会将当前目录下所有的相关文件显示

4、sudo 使用超级使用者权限

nginx 目录: /usr/local/openresty/nginx 9092

启动 sudo /usr/local/openresty/nginx/sbin/nginx

重启 /usr/local/openresty/nginx/sbin/nginx -s reload
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>使用 SecureCRT 工具

1、exit 或 logout 退出登录

2、文件上传和下载 到服务器

    $ sz 要下载的文件或目录   在secureCRT中设置 options -&gt; session options -&gt; x/z/zmodem 中设置的下载目录 

    $ rz 上传的文件            上传相同名文件，不会被替换，不能上传目录，可以直接发压缩gzip包在传

/Users/apple/siguang.liu/技术积累/大前端技术/前端框架/技术笔记/Nginx服务器.md
3、查看日志  使用tail 或 cat来查看文件内容

    $ tail -fn  显示行数  服务器的日志文件

    tail -fn 100  /opt/server/apache-tomcat-6.0.41_8084/logs/catalina.2016-01-21.log    56服务器8084端口


4、解决secureCRT 中文编码问题

    options -&gt;    session options  -&gt; terminal 下的 appearance  将 character encodeing 改成 utf-8


5、清理服务器缓存

    进入到apache-tomcat服务中的works中清楚loaclhost目录 

    $ cd /opt/server/apache-tomcat-6.0.41_8084/works/Catalina

    $ rm -rf  localhost

    8084：网站  apache-tomcat-6.0.41_8084

    8086：H5   apache-tomcat-7.0.47_8086


6、open 打开目录

7、clear 清除当前屏    cmd+k 清除所有

8、tree 打印出目录树

    mac下没有tree命令  brew install tree  安装

    $ tree -a   显示所有的文件和目录

    $ tree -L 1 -a  只显示一个层级的目录和文件(包括隐藏文件)

    $ tree -L 1 -d
</code></pre><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><pre><code>Example: 

-rw-r--r--@   1 apple  staff   8196  5 15 19:26 .gitignore.js

一、第一个字符为文件类型 -

    剩下每三位一组

        rw- u所有者    r-- g所属组    r-- o其它人

    r 读        w 写        x 执行


一、文件类型

    1、- 文件    如果第一个符号为&apos;-&apos;就是一个普通文件

    2、d 目录 

    3、l 软链接文件
</code></pre><h4 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h4><pre><code>1、cd 切换到指定目录

    cd 与 cd ~  回到apple目录, 也就是 /Users/apple

    cd -   回到上次操作所在的目录

    cd ..  进入到上一级目录


2、mkdir [-p]  dirname 创建目录 

    -p 递归创建  mkdir -p parent/child    可以直接创建多个目录，如果不加就只能创建一个目录


3、pwd 显示当前路径

4、rm 删除文件或目录   rm -rf [文件或目录]

    -r  删除目录 如果删除目录必须要加 -r, 删除文件不需要

    -f  强制


5、cp 复制目录或文件   cp [选项][原文件或目录][目标目录]

    -r 复制目录

    -p 连带文件属性复制 一些类似文件创建日期等

    -d 如果源文件是链接文件，则复制链接属性

    -a 相当于 -pdr


6、mv 移动目录或文件    mv [源文件或目录] [目标目录]

    mv dir1 dir2 将文件或目录移动到指定目录中  

    mv a.js b.js 修改文件或目录名  


七、查目录权限 

    $ cd /

    $ ls -l         显示根目录所的权限

7、chown设置目录权限

    1、命令格式：

        chown [选项]... [所有者][:[组]] 文件...

    2．命令功能：

        通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。

    3．命令参数：

        必要参数:

        -c 显示更改的部分的信息

        -f 忽略错误信息

        -h 修复符号链接

        -R 处理指定目录以及其子目录下的所有文件

        -v 显示详细的处理信息

        -deference 作用于符号链接的指向，而不是链接文件本身

        选择参数:

        --reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组

        --from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变

        --help 显示帮助信息

        --version 显示版本信息

    4．使用实例：

        实例1：改变拥有者和群组

        命令：

        chown mail:mail log2012.log
</code></pre><h4 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h4><pre><code>1、touch .gitignore  创建文件

2、ls 显示文件

    # 显示详细列表
    $ ls -l  显示详细信息
    # 
    $ ll 是ls -l的简写
    # 
    $ ls -a 显示所有文件，包含隐藏文件（以. 起头的文件名）
    # 
    $ ls -R 显示文件及所有子目录
    $ 
    $ ls -F 显示文件（后跟*）和目录（后跟/）
    # 
    $ ls -d 与l选项合用，显示目录名而非其内容
    #
    $ ls -h 显示文件大小
    #
    $ ls -i 显示文件的id号    30988816 README.md


3、cat 显示文件内容

    cat package.json


4、echo 输出内容

5、ln 文件名   将文件的内容输出带行号

    $ ln package.json


6、wc 文件名  统计指定文件中的字节数、字数、行数，并将统计结果显示输出

    -c 统计字节数。

    -l 统计行数。

    -m 统计字符数。这个标志不能与 -c 标志一起使用。

    -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。

    -L 打印最长行的长度。
</code></pre><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><pre><code>一、find [搜索范围] [搜索条件]  避免大范围搜索，耗费系统资源

    通配符: * 匹配任意内容      ? 匹配任意一个字符      [] 匹配任意一个中括号内的字符

    按文件名搜索    $find / -name person.js     从根目录开始搜索person.js文件

    1、-name   搜索文件名   

    2、-iname  搜索的文件名不区分大小写

    3、-user   按所有者文件

    4、-nouser  没有所有者文件


    按时间搜索   $ find /var/log/ -mtime +10    搜索10天前修改的文件   +10 十天前     10 十天当天修改    -10  十天内修改文件

    5、-mtime  修改文件内容

    6、-atime  文件访问时间

    7、-ctime  改变文件属性


    按文件大小搜索   $ find . -size 25k  查找文件大小是25K的文件  -25k 小于25k   +25k 大于25k   25k 等于25k

        注意: M 是大写   k 用小写

    8、-size  查找文件大小

    9、-inum  通过 i 节点个数来查看   ls -i 查看当前目录下的文件带id   29560848 Bluetooth    31587257 opendirectoryd.log.0  31745680 system.log.4.gz

        find /var/log/ -inum  29560848   // 返回 Bluetooth

        逻辑运算符  -a 逻辑与    -o 逻辑或

        example   find /var/log -size +20K  -a  -size -50K    查找大于20K并小于50K

    10、-exec ... {} \;  将搜索的内容交给第二条命令来处理

         find /var/log -size +20k -a -size -500M  -exec ls -l -a {} \;


二、grep 在文件中匹配符合条件的字符串   grep [选项]  字符串   文件名

    -i 忽略大小写

    -v 排除指定字符串    

    $ grep -i 丝绸之路 package.json 


三、whereis 和 which  搜索系统命令

    whereis vim        // 输出 /usr/bin/vim 可以

    which 指令会在环境变量$PATH设置的目录里查找符合条件的文件。

        which mongod        // 返回当前mongod命令所在的目录 /usr/local/bin/mongod


四、locate 文件名   在后台数据库中按文件名搜索，搜索速度快

    locate不是在文件中搜索，而是在 /var/lib/mlocat 只在后台数据库搜索

    updatedb  更新数据库
</code></pre><h4 id="ln-链接命令-ln-s-原文件或目录-目录文件"><a href="#ln-链接命令-ln-s-原文件或目录-目录文件" class="headerlink" title="ln 链接命令   ln -s [原文件或目录] [目录文件]"></a>ln 链接命令   ln -s [原文件或目录] [目录文件]</h4><pre><code>硬链接: 硬链接看做是文件或目录的副本，两个i节点和存储，可以看成是同一个文件

软链接: 软连接看做是文件或目录的快捷方式

选项:

-s 创建软链接    

    注意软链接要写绝对路径 ln -s /Users/apple/siguang.liu/linux/catalogB   /Users/apple/siguang.liu/linux/lnDir

    appledeMacBook-Pro-2:lnDir apple$ ls -il
    31874703 lrwxr-xr-x  1 apple  staff  39  5 16 18:54 catalogB -&gt; /Users/apple/siguang.liu/linux/catalogB    这种 -&gt; 就是指的软链接 或者 lrwxr第一个类型为『l』

删除软连接就去目标目录直接把软链接的目录直接删掉
</code></pre><h4 id="压缩文件、目录"><a href="#压缩文件、目录" class="headerlink" title="压缩文件、目录"></a>压缩文件、目录</h4><pre><code>一、zip压缩文件、目录

    1、压缩文件     zip 压缩文件名  源文件        // 注意这里压缩zip，原文件不会被删除，而gzip会删除源文件

    2、压缩目录  zip -r 压缩文件名.zip   要压缩的目录       // 最好先进入要指定压缩的目录，如果写成a/b/c，这样就会将所有目录一层一层压缩，如果要压缩的目录在aa下面，而且你当前就在aa目录下面不用从指定根目录，否则解压后会一层一层的 

    3、解压缩    unzip 解压的文件


二、gzip压缩

    压缩后的扩展为 .gz  

    1、gzip 源文件      压缩为.gz文件，源文件会消失

    2、gzip -c 源文件 &gt; 压缩 文件     压缩为.gz文件，保留源文件

    3、gzip -r 目录     压缩目录下所有子文件，但不压缩目录

    2、gunzip             解压文件名


三、tar压缩目录

    通过tar来对目录进行打包，然后通过gzip进行压缩

    $ 格式: tar -cvf  打包文件名  源文件

    1、打包成 .tar文件

        1) tar -cvf  压缩后的目录  要压缩的目录 

        2) tar -xcvf  打包的文件名


    2、打包成 .tar.gz格式

        1) tar -zcvf  压缩后的目录  要压缩的目录 

        2) tar -zxcvf  打包的文件名

        -c: 产生.tar打包文件

        -v: 显示详细信息

        -f: 指定压缩后缀名

        -z: 打包同时压缩


    3、当包解压到当前目录

        tar zxf  nginx-1.12.2.tar.gz
</code></pre><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><pre><code>所有程序只要运行就会产生一个进程，客户端网页访问服务器就会产生一个进程

一、查看进程

    1、ps aux  系统所有进程

        ps -ef|grep nginx 查看nginx服务的进程

            a 显示所有进程，包括会话引线

            u 显示进程的归属用户及内存使用情况

            x 显示没有控制终端进程

            -l 长格式显示 显示更详细信息

            -e 显示所有进程，和-A作用一致

    2、pstree [选项]

        -p 显示进程PID

        -u 显示进程用户

    3、top  每3秒查看一下系统的健康，有cpu和内存的数据和所有进程


二、杀死进程

    kill -1 进程ID    重启进程

    kill -9 进程ID    强制杀死进程
</code></pre><h4 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h4><pre><code>https://www.cnblogs.com/duhuo/p/5695256.html
</code></pre><h4 id="环境变量和host的修改"><a href="#环境变量和host的修改" class="headerlink" title="环境变量和host的修改"></a>环境变量和host的修改</h4><pre><code>一、host目录

    etc/hosts

二、环境变量、export 设置或显示环境变量  export [-fnp][变量名称]=[变量设置值]

    -f 　代表[变量名称]中为函数名称。 

    -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 

    -p 　列出所有的shell赋予程序的环境变量。


    $ export   查看环境变量


    设置环境变量有两种: 

        1、使用export命令 这种方法只是临时设置，重启终端就

            $ export PATH=$PATH:/opt/au1200_rm/build_tools/bin

        2、修改profile文件 或者设置到 source ~/.bash_profile 

            $ vi ~/.profile

              export PATH=$PATH:/usr/local/zend/mysql/bin/:/usr/local/zend/bin     // 设置$PATH 扩展一下加一下

            $ source ~/.profile    立即执行

    注意两个环境变量使用 “：”来分割


三、通过环境变量来设置命令快捷键

    $ vi ~/.profile

        alias ll=&quot;ls -a&quot;
        alias ..=&quot;cd ..&quot;
        alias ...=&quot;cd ../../&quot;
        alias ....=&quot;cd ../../../&quot;
        alias .....=&quot;cd ../../../../&quot;
        alias ......=&quot;cd ../../../../../&quot;
</code></pre><h4 id="man-–help-帮助"><a href="#man-–help-帮助" class="headerlink" title="man  –help  帮助"></a>man  –help  帮助</h4><pre><code>一、man ls  查看帮助信息

二、ls --help   
</code></pre><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><pre><code>一、日期

    date 日期时间

    cal  显示当前日历

二、关机重启系统

    1、shutdown [选项] 时间   来进行重启和关机

        shutdown -r now    立即重启  -h 立即关机

        shutdown -r 18:00  定时在18点的时候重启

        -c: 取消前一个关机命令

        -h: 关机

        -r: 重启

    2、halt  回车  直接关机

    3、poweroff  回车  直接关机

    4、init 0 回车  直接关机

    5、reboot 回车  直接重启

三、查询与自动挂载

    1、mount
</code></pre><h4 id="linux根目录"><a href="#linux根目录" class="headerlink" title="linux根目录"></a>linux根目录</h4><pre><code>Linux的目录

    根目录下的 bin目录不允许操作， usr下的 sbin目录是可以操作的

    /bin 传统unix命令的存放目录，如ls，rm，mv等。
    /sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。
    /tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。
    /usr 第三方程序安装目录。
        /usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）.
    /etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。        
    /var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。


OS X系统中，除了标准的unix目录外，还增加了特有的目录。

    /Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；
    /Library 系统的数据文件、帮助文件、文档等等；
    /Network 网络节点存放目录；
    /System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。
    /Users 存放用户的个人资料和配置。每个用户有自己的单独目录。
    /Volumes 文件系统挂载点存放目录。
    /cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。
    /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。


/bin是系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。

/sbin一般是指超级用户指令。主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。

/usr/bin　是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等。

/usr/sbin   放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。

/usr/bin用于分发包管理器（如Ubuntu apt等）存放它所管理的应用的路径, /usr/sbin与/usr/bin的关系类似与/bin和/sbin的关系

/usr/local/bin用于存放用户自己的程序（如自己编译出来的包等），不受分发包管理器的控制。如果用户把自己的程序放在/usr/bin下，则有可能在未来被包管理器给修改或删除了。
</code></pre><h4 id="vim-编辑器"><a href="#vim-编辑器" class="headerlink" title="vim 编辑器"></a>vim 编辑器</h4><pre><code>vi  文件名    或vim 文件名

命令状态：

H 左  L 右   K 上  J 下

0（零） 行首     $（shift+5） 行尾       G（shift+G） 文件尾

i 插入命令

dd  删除当前行    pp 复制并粘贴当前行    x: 删除光标处字符

control+f 后翻页        control+b前翻页

u 取消上次操作)


a,A:追加命令，a 在当前光标后追加，A 在行末追加

o,O:打开命令，o 在当前行下打开一行，O在当前行上插入一行

r,R :替换命令，r 替换当前光标处字符，R从光标处开始替换

数字s: 替换指定数量字符

d0: 删除光标前半行

d$: 删除光标后半行

/string 查找字符串

n 继续查找

N 反向继续查找

% 查找对应括号

ex命令状态

    ：0 文件首

    ：1,5 copy 7 块拷贝

    ：1，5 del 块删除

    ：1，5 move 7 块移动

    ：1，$s/string1/string2/g 全文件查找string1并替换为string2

    ：wq! 存盘退出

保存命令

    按ESC键 跳到命令模式，然后：

    :w   保存文件但不退出vi

    :w file 将修改另外保存到file中，不退出vi

    :w!  强制保存，不推出vi

    :wq  保存文件并退出vi

    :wq! 强制保存文件，并退出vi

    q:   不保存文件，退出vi

    :q!  不保存文件，强制退出vi

    :e!  放弃所有修改，从上次保存文件开始再编辑
</code></pre><h4 id="Mac终端下的快捷键"><a href="#Mac终端下的快捷键" class="headerlink" title="Mac终端下的快捷键"></a>Mac终端下的快捷键</h4><pre><code>cmd + A 移到行首
cmd + E 移到行尾

cmd + L 清除上一次操作的内容
cmd + K 清除所有内容

cmd + option + H 将所有窗口隐藏到应用程序图标
cmd + H  将当前窗口隐藏到图标中
cmd + M  将当前窗口最小化到

control + U 清除当前行命令

cmd + shift + .  显示/隐藏当前文件的隐藏文件

traceroute -n 125.35.51.162        // 查看当前网络访问到这个ip都通过哪些途径

mac 打开iphone界面  iphone与mac连接，打开QuickTime，文件 -&gt; 新建录制影片
</code></pre><h4 id="修改mac地址"><a href="#修改mac地址" class="headerlink" title="修改mac地址"></a>修改mac地址</h4><pre><code>$ ifconfig        en0:  ether ac:bc:32:83:a2:4b     原始的mac地址

$ openssl rand -hex 6 | sed &apos;s/\(..\)/\1:/g; s/.$//&apos;        生成一个mac地址

$ sudo /System/Library/PrivateFrameworks/Apple80211.framework/Resources/airport -z      断开airport无线网卡连接

$ sudo ifconfig en0 ether 7e:df:f7:a5:07:56        修改成生成的mac地址

$ networksetup -detectnewhardware     重新连接网卡

$ ifconfig    查看是否是改后的mac地址

44:9f:24:59:ca:13
</code></pre><h4 id="SSL-权限"><a href="#SSL-权限" class="headerlink" title="SSL 权限"></a>SSL 权限</h4><pre><code>open ~/.ssh/     打开ssh目录

GitLab：中配置ssh

1、登录后找到 Profile Settings  -&gt;  SSH Keys  添加Key来做映射

id_rsa.pub 文件

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCcmEJCTlr57na4TJ8xU8J/EG0KcrH6Dh+MwBPbs0NO6lA09Pdjro4knzSRYeSHc9X63Km/OR18JU7ygcE9foUYAN8BatnDTh6R+ynyQxyIqIG7Gn8YGF0g8Zx8oU9LsYc8SWP6zdryr7NaQZ41583jt9JxheG0la6D10cqZRQiix7pZMiXmHZXPKCSkTZSGHLaR0Ws24eyz1Yt9HmLXZem8FPkUrwmn2IYk05cwMyK+NE/g9pPJbpVEtEssU4FZ4I++LNltMbAxgtCp2QXZ7Z7ViA3CvK9u8g6u4yLLBPydpXWJ1pu+9bYFV3CvoTEawN3+mIIMsDaDhPlI6PJMk/j 632505215@qq.com
</code></pre><p>| <a href="http://www.cnblogs.com/webzhangnan/p/3221410.html" target="_blank" rel="noopener">http://www.cnblogs.com/webzhangnan/p/3221410.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/JS作用域和整理经验/">JS作用域和整理经验</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/JS作用域和整理经验/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><pre><code>一、示例

    console.log(str);        // 输出undefined  因为读取的是解析器预先存储的str，还没有被赋值
    var str = 1;         


二、示例2

    alert(a);        // 弹出的是function a(){ alert(&quot;2&quot;)}
    var a = 1;
    function a(){
        alert(&quot;2&quot;)
    }

    预解析会保存a = undefinded，和 a = function a(){alert(&quot;2&quot;)}，
    因为函数与变量重名，函数后最执行所以保留函数，结果输出的就是函数


三、示例3

    var a = 1;
    function a(){
        alert(&quot;2&quot;);
    }

    // 报错，因为a被定义成变量，typeof a 返回的是number，如果 var a;不能定义值那么a()是成功的
    a();


四、示例4

    var a = 1;
    function fn1(){
        alert(a);
        // 注意这里因为是使用var声明所以执行数预解析器才会把它单独存储起来，
        // 如果将var去掉，a=2改成了赋值这样会改变外部的a的值，下面输出的就是1，2
        var a = 2;
    }

    fn1();                        // undefined
    console.log(a);        // 1


五、示例5

    function foo(){
        return fn1;

        function fn1(){};
        var fn1 = 10;
    }

    var f = foo();

    // 输出 function fn1(){};    因为调用foo函数时，return  fn1因为变量还未定义所以 直接调用的函数
    alert(f);                


六、示例6

    var  myname = &quot;global&quot;; // 全局变量
    function func() {

        // &quot;undefined&quot;，如果函数内不在定义myname就会找全局的变量，但函数本身已经定义了，预编译会先将变量定义成undefined
        alert(myname);                 
        var myname = &quot;local&quot;;
        alert(myname);                 // &quot;local&quot;
    }
    func();


七、示例7

    &lt;script&gt;
        window.name = &apos;globalName&apos;;

        var getName = function(){
            return this.name;
        }

        getName();         // &apos;globalName&apos;
    &lt;/script&gt;


八、示例8

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var callback = function(){
                return this.id;        // divA
            }
            callback();            // window
        }
    &lt;/script&gt;


 九、示例9

    1、Example
        var getName;
        console.log(getName)    // undefined

        getName()                // Uncaught TypeError: getName is not a function

        var getName = function() {
            console.log(&apos;wscat&apos;)
        }

    2、Example
        var getName;
        console.log(getName)    // function getName() {console.log(&apos;oaoafly&apos;)}

        getName()                // oaoafly

        function getName() {
            console.log(&apos;oaoafly&apos;)
        }


十、bind()

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var obj = {
                id: &apos;objId&apos;,
                callback: function(){
                    return this.id;         // &apos;divA&apos;
                }.bind(window)                // 通过bind来将callback内的this指向window
            }

            console.log(obj.callback());    // &apos;window&apos;
        }
    &lt;/script&gt;


十一、严格模式下的this

    &lt;script&gt;
        &apos;use strict&apos;

        function fun(){
            alert(this);        // 返回 &apos;undefined&apos;, strict模式下this不会指向全局
        }

        fun();
    &lt;/script&gt;


十二、箭头函数下的this指向

    let Template = {
        test(){
            console.log(this);        // this指向Template

            document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                // 如果非箭头函数this应该指向 #showThis
                // 这里箭头函数不是指向调用者，所以指向了 Template
                console.log(this);    
            }
        }
    }
    Template.test();
</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code>1、函数本身是对象也是构造函数

2、直接挂载到函数下，是对象的属性和方法

    function Foo(){};
    Foo.username = &apos;111&apos;;     // 注意这里Foo的属性不能为name因为被name被函数的名所占用
    Foo.getName = function(){ console.log(this.username) };

    // 调用
    Foo.getName();        // 111

3、在构造函数的内部属性和方法

    function Foo() {
        this.username = &apos;111&apos;
    }
    Foo.username = &apos;222&apos;;

    // 调用
    console.log(new Foo().username);    // 111

&lt;script&gt;
    function Foo() {
        getName = function() {
            console.log(this);
            console.log(1);
        }

        console.log(this);
        return this;
    }
    Foo.getName = function() { // 这里只是Foo对象的方法，而不是构造函数的方法，
        console.log(2);
    }

    // Foo.prototype.getName = function() {
    //     console.log(3);
    // }

    var getName = function() {
        console.log(4)
    }

    function getName() {
        console.log(5)
    }

    Foo.getName(); // 2    Foo.getName=function(){}  是存到Foo下的方法，Foo.getName()可以取到
    getName(); // 4     如果一个作用域下有var的变量名与函数名相当，var的作用域提升高于function
    Foo().getName();     // 1  因为Foo()被调用，定义中加了return this，Foo指向的是window全局，getName没有var升明，所以为全局，所以相当于window.getName()，Foo中如果不加return this那么就会报错，因为Foo没有链式调用，所以this断了
    getName(); // 1   因为上面已经将Foo内的getName()提升成全局，所以会赋盖掉var getName、function getName定义的全局方法

    // var ofo = new Foo;
    // ofo.getName();   // 3

    // Foo既是一个对象也是一个构造函数
    new Foo.getName();             // 2  先执行Foo.getName()，因为&quot;.&quot;运算符优先于new运算符，所以这时候Foo只是一个对象并不是构造函数的实例，所以会调用对象下的方法
    new Foo().getName();         // 1  先执行new Foo()构造函数，然后在构造函数下去找getName方法，Foo构造函数方法没有getName()所以到prototype下去找
    new new Foo().getName();     // 1  与上面相同
&lt;/script&gt;
</code></pre><h4 id="将对象拷贝并不引用指针"><a href="#将对象拷贝并不引用指针" class="headerlink" title="将对象拷贝并不引用指针"></a>将对象拷贝并不引用指针</h4><pre><code>有两种方法，一是使用for...in将一个对象拷贝到另一个对象

另一种方法是使用Object.assign()

let objA = {
    name: &apos;siguang&apos;,
    age: 30
}
let objB = Object.assign({}, objA);
objB.name = &apos;lulu&apos;;         // lulu
console.log(objA.name);     // siguang
</code></pre><h4 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h4><pre><code>浅拷贝就是对象之间还存引用关系，深拷贝就是两个对象之间没有引用关系

一、浅拷贝

    const a = {t: 1, p: &apos;gg&apos;};
    const b = a;
    b.t = 3;
    console.log(a);     // {t: 3, p: &apos;gg&apos;}
    console.log(b);     // {t: 3, p: &apos;gg&apos;}

二 、深拷贝

    1、Object.assign() 方法是将两个对象合并，并返回一个新对象

        **** 注意assig()只能拷贝一层，多层结构还是浅拷贝 ****

        const c = {t: 1, p: &apos;gg&apos;};
        const d = Object.assign({}, c);
        d.t = 3;
        console.log(c);     // {t: 1, p: &apos;gg&apos;}
        console.log(d);     // {t: 3, p: &apos;gg&apos;}

    2、Object.create() 将拷贝的内容入到prototype下，对象和数组都适用

        对象:

            var oA = {
                name: &apos;sg&apos;,
                age: 33
            }
            var oB = {};
            oB = Object.create(oA);

            oB.eat = &apos;bread&apos;;

        数组:

            var oA = [1,2]
            var oB = [];
            oB = Object.create(oA);

            oB.push(3);            // oB.length;   3        

    3、jQuery.extend()

        let oa = {a: 1, b: 2}; let ob = {};  
        $.extend(ob, oa); 
        ob.b = 3; 
        console.log(oa, ob);        // oa: {a: 1, b: 2}、 ob: {a: 1, b: 3}
</code></pre><h4 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h4><pre><code>一、concat()方法

    var arrA = [1,2,3];
    var arrB = arrA.concat();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

二、slice()方法

    var arrA = [1,2,3];
    var arrB = arrA.slice();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

两种方法都是回返一个不带指向的新数组
</code></pre><h4 id="对象处理"><a href="#对象处理" class="headerlink" title="对象处理"></a>对象处理</h4><pre><code>一、查看是否是一个空对象

    // 使用keys来查看对象中所有的kyes并返回一个数组，如果数组为度为0则对象为空
    var obj = {}; 
    var Len = Object.keys(obj);         
    console.log(Len.length);

二、查看对象中属性是否存在

    var obj = {
        a: 1,
        b: 2
    }
    console.log(obj.c);        // undefined
</code></pre><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><pre><code>function isDataType(data){

}
</code></pre><h4 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h4><pre><code>一、数据去重

    1、普通方法

        function clearRepeat(arr){
            var newArr = [], obj = {};
            for(var i=0; i&lt;arr.length; i++){
                if(!obj[arr[i]]){
                    obj[arr[i]] = &apos;&apos;;        // 对象属性相同会直接覆盖
                    newArr.push(key);        
                }
            }
            return newArr;
        }

        let retArray = clearRepeat([3,2,3,4,5,5,2,2,13,3]);


    2、使用ES6的set()方法，set方法就是不允许数组内有重复的值

        let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
        console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
        let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    http://www.jb51.net/article/46154.htm


二、数组排序

    1、使用sort方法

        var arr = [6,7,5,8,4,2342342,23,234,2,34];
        arr.sort(function(v1, v2){
            return v1 - v2        // 正序
        })
        console.log(arr);


三、返回数组中最大最小值

    let arr = [2,1,423,343,5,67,8];
    let min = Math.min.apply(null, arr);
    let max = Math.max.apply(null, arr);
</code></pre><h4 id="编写组件并兼容AMD、ES6写法"><a href="#编写组件并兼容AMD、ES6写法" class="headerlink" title="编写组件并兼容AMD、ES6写法"></a>编写组件并兼容AMD、ES6写法</h4><pre><code>;(function(root, factory){

    // 判断使用的支持定义模块的方式
    if(typeof define === &apos;function&apos; &amp;&amp; define.amd){
        define(factory)
    }
    else if(typeof exports === &apos;object&apos;){
        module.exports = factory();
    }
    else{
        root.NProgress = factory();
    }

})(this, function(){
    console.log(`输出内容`);
})
</code></pre><p>| <a href="https://juejin.im/entry/58db95eaac502e0058f8472e" target="_blank" rel="noopener">https://juejin.im/entry/58db95eaac502e0058f8472e</a><br>| <a href="http://www.iamaddy.net/2015/04/front-end-engineering/" target="_blank" rel="noopener">http://www.iamaddy.net/2015/04/front-end-engineering/</a>       // 前端的发展</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
