<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/24/LodashJS/">LodashJS</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/24/LodashJS/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-24T03:43:51.000Z" itemprop="datePublished">2017-04-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端插件/">前端插件</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="LodashJS"><a href="#LodashJS" class="headerlink" title="LodashJS"></a>LodashJS</h4><pre><code>工具库，处理数组、对象的一些方法

官网: https://lodash.com/

中文官网: http://lodashjs.com/docs/#_chunkarray-size1
</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>let box = document.querySelector(&quot;#box&quot;);

let arr = [1,2,3,4,5,6];

// 将数组每两个下标值，转成一个二维数组 
// arr = _.chunk(arr, 2);      // [[1,2], [3,4], [5,6]]

// 删除数组中的false, null, 0, &apos;&apos;, undefined, Nan
// arr = [1, 0, 3, &apos;&apos;, false, &apos;ss&apos;]
// arr = _.compact(arr);      //   [1,3,&apos;ss&apos;] 

// 合并数组
// arr = [1];
// arr = _.concat(arr, 2, [3], [[4]]);    // [1, 2, 3, [4]]

// 去除数组中指定的数值
// arr = _.difference(arr, [2,3,4]);   // [1,5,6]

// 截取数组从第个开始直到最后的值
// arr = _.drop(arr, 2);      // [3,4,5,6]

// 指定删除的下标个数，从右开始
// arr = _.dropRight(arr, 2);    // [1,2,3]

// 填充数组元素，全部或指定区域
// arr = _.fill(arr, &apos;a&apos;);       // [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;];
// arr = _.fill(arr, &apos;*&apos;, 1, 4);    // [1, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;, 5, 6]

// 查找指定的值返回下标
// arr = [
//   {user: &apos;siguang&apos;, age: 30},
//   {user: &apos;lulu&apos;, age: 20},
//   {user: &apos;haha&apos;, age: 10}
// ]
// arr = _.findIndex(arr, function(o){ return o.user == &apos;lulu&apos; });   // 1
// arr = _.findIndex(arr, [&apos;age&apos;, 10])     // 2 如果不存在返回-1

// findLastIndex() 与findIndex()相同只是从后向前
// lastIndex()

// 将一个二维数组转成对象
// arr = [[&apos;a&apos;, 1], [&apos;b&apos;, 2]];
// arr = _.fromPairs(arr);     // {a: 1, b: 2}

// 返回数组第一个、最后一个元素
// arr = _.head(arr);    // 1
// arr = _.last(arr);    // 6

// 根据下标返回值
// arr = _.indexOf(arr, 2);   // 1

// 删除最后一个数组值
// arr = _.initial(arr);     // [1, 2, 3, 4, 5]

// 将数组元素用分割符分开，返回一个字符串
// arr = _.join(arr, &apos;~&apos;);      // &quot;1~2~3~4~5~6&quot;

// 根据下标的返回数组中的值，如果是负数从后开始
// arr = _.nth(arr, 2);      // 3
// arr = _.nth(arr, -2);        // 5

// 删除数组中指定的值
// arr = _.pull(arr, 3, 4, 5);   // [1, 2, 6]
// arr = _.pullAll(arr, [3,4,5]);   // [1, 2, 6]

// 返回指定下标的数组值
// arr = _.pullAt(arr, [1,3,5]);   // [2, 4, 6]

// 删除数组元素
arr = _.remove(arr, function(n){ return n % 2 == 0 });    // [2, 4, 6]


console.log(arr);    
box.innerHTML = &apos;sss&apos;
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/24/eCharts图表插件/">EChart</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/24/eCharts图表插件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-24T03:43:51.000Z" itemprop="datePublished">2017-04-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端插件类/">前端插件类</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>1、npm install echarts --save

2、引入echarts的两种方式

    页面直接引入文件: &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;

    webpack: import echarts from &apos;echarts&apos;

3、页面创建DOM的容器

    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;        必须要一个高度值
</code></pre><h4 id="异步数据加载和更新"><a href="#异步数据加载和更新" class="headerlink" title="异步数据加载和更新"></a>异步数据加载和更新</h4><pre><code>1、数据异步

    将数据通过ajax异步取到后，在通过setOption()方式直接加到载插件中


2、loading动画

    showLoading()来显示、hideLoading()隐藏

    Exampole
    var myChart = echarts.init(document.getElementById(&apos;main&apos;));

    myChart.showLoading();
    $.ajax({
        success:function(data){
            myChart.hideLoading();
        }
    })


3、数据的动态更新

    只需要加单个数据，先data.push(vlaue), 在通过setOption()将数据渲染出来

    var data = [];        // 存储数据 

    // 创建图表将data数据加入
    ....

    // 添加数据 
    function addData(){
        data.push(Math.random()*100);
    }

    setInterval(function(){
        addData();
        myChart.setOption({
            数据
        })
    },1000)
</code></pre><h4 id="数据区缩放组件-dataZoom"><a href="#数据区缩放组件-dataZoom" class="headerlink" title="数据区缩放组件 dataZoom"></a>数据区缩放组件 dataZoom</h4><pre><code>option = {
    xAxis: {
        type: &apos;value&apos;
    },
    yAxis: {
        type: &apos;value&apos;
    },

    dataZoom: [
        {   // 这个dataZoom组件，默认控制x轴。
            type: &apos;slider&apos;, // 这个 dataZoom 组件是 slider 型 dataZoom 组件
            start: 10,      // 左边在 10% 的位置。
            end: 60         // 右边在 60% 的位置。
        }
    ],

    series: [
        {
            type: &apos;scatter&apos;, // 这是个『散点图』
            itemStyle: {
                normal: {
                    opacity: 0.8
                }
            },
            symbolSize: function (val) {
                return val[2] * 40;
            },
            data: [[&quot;14.616&quot;,&quot;7.241&quot;,&quot;0.896&quot;],[&quot;3.958&quot;,&quot;5.701&quot;,&quot;0.955&quot;],[&quot;2.768&quot;,&quot;8.971&quot;,&quot;0.669&quot;],[&quot;9.051&quot;,&quot;9.710&quot;,&quot;0.171&quot;],[&quot;14.046&quot;,&quot;4.182&quot;,&quot;0.536&quot;],[&quot;12.295&quot;,&quot;1.429&quot;,&quot;0.962&quot;],[&quot;4.417&quot;,&quot;8.167&quot;,&quot;0.113&quot;],[&quot;0.492&quot;,&quot;4.771&quot;,&quot;0.785&quot;],[&quot;7.632&quot;,&quot;2.605&quot;,&quot;0.645&quot;],[&quot;14.242&quot;,&quot;5.042&quot;,&quot;0.368&quot;]]
        }
    ]
}
</code></pre><h4 id="事件和行为"><a href="#事件和行为" class="headerlink" title="事件和行为"></a>事件和行为</h4><pre><code>Echarts中有两种事件，1、用户的鼠标事件   2、交互组件后触发的行为事件

一、鼠标事件

    鼠标事件: &apos;click&apos;、&apos;dblclick&apos;、&apos;mousedown&apos;、&apos;mousemove&apos;、&apos;mouseup&apos;、&apos;mouseover&apos;、&apos;mouseout&apos;

    myChart.on(&apos;click&apos;, function(params){
        console.log(params.name)
    })


二、交互组件

    myChart.dispatchAction({ type: &apos;&apos; })        // 通过dispatchAction触发

    1、legendselectchanged: 切换图例开关时触发

    2、datazoom: 数据区域缩放触发


二、params 对象

    {
        // 当前点击的图形元素所属的组件名称，
        // 其值如 &apos;series&apos;、&apos;markLine&apos;、&apos;markPoint&apos;、&apos;timeLine&apos; 等。
        componentType: string,

        // 系列类型。值可能为：&apos;line&apos;、&apos;bar&apos;、&apos;pie&apos; 等。当 componentType 为 &apos;series&apos; 时有意义。
        seriesType: string,

        // 系列在传入的 option.series 中的 index。当 componentType 为 &apos;series&apos; 时有意义。
        seriesIndex: number,

        // 系列名称。当 componentType 为 &apos;series&apos; 时有意义。
        seriesName: string,

        // 数据名，类目名
        name: string,

        // 数据在传入的 data 数组中的 index
        dataIndex: number,

        // 传入的原始数据项
        data: Object,

        // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data，
        // dataType 的值会是 &apos;node&apos; 或者 &apos;edge&apos;，表示当前点击在 node 还是 edge 上。
        // 其他大部分图表中只有一种 data，dataType 无意义。
        dataType: string,

        // 传入的数据值
        value: number|Array

        // 数据图形的颜色。当 componentType 为 &apos;series&apos; 时有意义。
        color: string
    }
</code></pre><h4 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h4><pre><code>1、title: 标题（包括主副标题、链接、样式）

2、legend: 标记的区域 （对legend的显隐、宽高、位置、横纵向排列）

3、grid: 图表的网格区域 （是否显示网格、位标、宽高、背景色、边线色）

4、xAxis、yAxis: x、y坐标轴
    {
        splitLine:{
            show: false,                // 去掉网格线
            lineStyle: {
                color: &apos;#48484a&apos;    // 设置网络线颜色 
            }
        },                
        splitArea : {show : true}                //保留网格区域
    }

5、dataZoom: 数据缩放 （）

6、toolTip: 提示信息，鼠标移到数据点浮现的提示信息（）

7、axisPointer:

8、toolBox: 工具栏 （导出图表、数据视图、动态类型切换、缩放、重置）

9、series: 系列列表（来决定图表的类型、图表的数据）

10、color: 图表每一项的颜色

11、background: 图表背景色

12、textStyle: 文本样式

13、animate: 是否开启动画

----- 组件 -------

14、timeline: 时间轴组件

15、graphic: 原生图形元素组件

16、calendar: 日历坐标组件

17、brush: 区域选择组件

18、geo: 地理坐标系组件

19、parallel: 平行坐标系

20、parallelAxis: 这个组件是平行坐标系中的坐标轴

21、singleAxis: 单轴。可以被应用到散点图中展现一维数据
</code></pre><h4 id="series对象"><a href="#series对象" class="headerlink" title="series对象"></a>series对象</h4><pre><code>type: 展示图表的类型

name: 名称

label: 图形上文本标签的控制（show、position、offset、formatter、）

    formatter可以是字符串也可以是函数 

        字符串模板，模板变量有 {a}、{b}、{c}，分别表示系列名，数据名，数据值。

        formatter: &apos;{b}: {c}&apos;

        label:{
            normal:{
                formatter: function(data){            // callback
                    return data.percent + &apos;%&apos;;
                }
            }
        }, 

        params:
        {
            componentType: &apos;series&apos;,
            // 系列类型
            seriesType: string,
            // 系列在传入的 option.series 中的 index
            seriesIndex: number,
            // 系列名称
            seriesName: string,
            // 数据名，类目名
            name: string,
            // 数据在传入的 data 数组中的 index
            dataIndex: number,
            // 传入的原始数据项
            data: Object,
            // 传入的数据值
            value: number|Array,
            // 数据图形的颜色
            color: string,

            // 百分比
            percent: number,

        }

labelLine: 图形上图形与文本之间连接线的控制

data: 数据

center: 饼图中心坐标

radius: 半径
</code></pre><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><pre><code>1、x、y轴文字的颜色和角度

    xAxis: {
        type: &apos;category&apos;,
        boundaryGap: false,
        data: [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;, &apos;Sat&apos;, &apos;Sun&apos;],
        axisLabel: {            // 这里控制颜色
            show: true,
            textStyle: {
                color: &apos;#fff&apos;
            },
            rotate: 45
        }
    },
</code></pre><blockquote>
<p>参考资料<br><a href="http://echarts.baidu.com/echarts2/doc/doc.html#Title" target="_blank" rel="noopener">http://echarts.baidu.com/echarts2/doc/doc.html#Title</a><br><a href="http://echarts.baidu.com/gallery/editor.html" target="_blank" rel="noopener">http://echarts.baidu.com/gallery/editor.html</a>   在线编辑</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/06/Nginx服务器/">Nginx</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/06/Nginx服务器/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-06T10:18:51.000Z" itemprop="datePublished">2017-04-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/服务器/">服务器</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h4><pre><code>服务器分类: Nginx、Apache、tomcat、Micorsoft Server

ng是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器，超越Apache的高性能和稳定性.
</code></pre><h4 id="四层和七层负载均衡"><a href="#四层和七层负载均衡" class="headerlink" title="四层和七层负载均衡"></a>四层和七层负载均衡</h4><pre><code>负载均衡设备也被称为&quot;四到七层交换机&quot;，四层就是基于IP+端口的负载均衡，七层就是基于URL等应用信息的负载均衡.

如果只做HTTP的负载均衡，用haproxy好了。性能很强。

七层负载均衡优点:

    1、高并发连接: 支撑5万并发连接

    2、内存消耗少: 在3万并发连接，开启10个Nginx进程消耗150M内存

    3、配置文件简单

    4、节省带宽: 支持GZIP压缩，可以添加浏览器本地缓存的Header头，

    5、稳定性高: 用于反向代理, 宕机概率小

    9、支持热部署: 不间断服务进行更新
</code></pre><h4 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h4><pre><code>一、七层负载均衡优势:

    1、对HTTP报头检查，可以检出状态码为400、500、600的错误信息，如果有错误将连接请求重新定向到另一台服务器

    2、可以根据数据类型（判断数据包是图像、压缩文件、或多媒体文件等），将数据引向内容服务器

    3、根据请求类型，将普通文本、图象等静态文档，或是动态文档请求，引向相应的服务器来处理


二、Nginx负载均衡是基于内容和应用的七层资的，Nginx抗并发强，是因为Nginx使用了非阻塞、异步传输

三、模块

    1、nginx负载均衡模块

        配置负载均衡是ngx_http_upstream_module，这模块是默认安装

    2、代理模块

        Proxy为nginx的代理模块, 允许将用户的HTTP请求转发到后端服务器

四、反向代理 

    反向代理是指以代理服务器接受internet上的连接请求，将请求转发给内部服务器，并将从服务器得到结果返回给internet的客户端
</code></pre><h4 id="Nginx负载均衡调试策略"><a href="#Nginx负载均衡调试策略" class="headerlink" title="Nginx负载均衡调试策略"></a>Nginx负载均衡调试策略</h4><pre><code>ng的upstream目前支付几种分配:

1、轮询: 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务down掉，能自动剔除

2、weight: 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况

    upstream bakend { 
        server 192.168.0.14 weight=10; 
        server 192.168.0.15 weight=10; 
    }

3、ip_hash: 每个请求按访问ip的hash结果分配，每个访客访问一个固定的后端服务器

    upstream bakend { 
        ip_hash; 
            server 192.168.0.14:88; 
            server 192.168.0.15:80; 
        }
    }

4、fair（第三方）

5、url_hash（第三方）

    upstream backend { 
        server squid1:3128; 
        server squid2:3128; 
        hash $request_uri; 
        hash_method crc32; 
    }
</code></pre><h4 id="通过brew安装nginx"><a href="#通过brew安装nginx" class="headerlink" title="通过brew安装nginx"></a>通过brew安装nginx</h4><pre><code>$ brew install nginx

    cd /usr/local/etc/nginx/            // nginx.conf 配置目录

    open /usr/local/Cellar/nginx  // 其实这个才是nginx被安装到的目录

$ cd /usr/local/var/www                // 进入到目录 localhost:9080

$ nginx             // 启动服务

重启ng:

    ps -ef|grep nginx

    kill -9 进程号
</code></pre><h4 id="Nginx安装和删除"><a href="#Nginx安装和删除" class="headerlink" title="Nginx安装和删除"></a>Nginx安装和删除</h4><pre><code>主要步骤: 下载包，压缩、配置编译

$ https://nginx.org/en/download.html    下载一个nginx包版本

$ cd /usr/local/ &amp;&amp; mkdir newNginx     // 进入到local目录并创建一个newNginx目录

$ 将下载的包copy到新创建的newNginx目录, 并将包解压到当前目录   tar zxf nginx-1.12.2.tar.gz 

$ cd nginx-1.12.2

$ ./configure        // 验证过程

$ make

$ make install         // 这时候会创建一个nginx目录 /usr/local/nginx

$ 将newNginx目录的文件copy到nginx目录
</code></pre><h4 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h4><pre><code>默认该配置文件被命名nginx.conf

    配置server

    server {
        listen       9092;                                // 端口
        root /Users/apple/siguang.liu/Hh/hh_h5;            // 指定根目录

        location / {
            proxy_pass  http://174.16.1.82:8080/;        // 代理到的服务器
        }

        error_page   500 502 503 504  /50x.html;        // 错误
        location = /50x.html {
            root   html;
        }

        location ^~ /api {
            proxy_pass  http://172.16.1.82:8080/;        // 如果访问以&quot;/api&quot;开头的代理的服务器
        }

        location ~ \.(gif|jpg|png|js|css|html|map)$ {    // 指定静态资源
            root /Users/apple/siguang.liu/Hh/hh_h5;
        }
    }

    可以通过include来将另一个文件的内容引用

    include servers/*.conf;


一、所存在的目录 /usr/local/nginx/conf            // 本机mac /usr/local/openresty/nginx

二、启动  sudo /usr/local/openresty/nginx/sbin/nginx      // 需要sudo管理员权限

三、启动后的可以通过调用带-s参数来执行文件来控制 

    $ nginx -s 命令

    1、reload - 重启  sudo /usr/local/openresty/nginx/sbin/nginx -s reload

    2、stop - 快速关机 sudo /usr/local/openresty/nginx/sbin/nginx -s stop

    3、quit - 优雅关机 sudo /usr/local/openresty/nginx/sbin/nginx -s quit

    4、reopen - 重新打开日志文件 sudo /usr/local/openresty/nginx/sbin/nginx -s reopen

四、查看、杀掉进程

    $ ps -ex | grep nginx

    $ kill -s quit 1682

五、配置文件结构

    指令分为简单指令和块指令，以空格分隔，以分号(;)结束

四、注释使用 #

    # HTTPS server
    #
    # server {
    #    listen       443 ssl;
    #    server_name  localhost;
    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;
    # }
</code></pre><h4 id="Nginx配置-HTTP2-0"><a href="#Nginx配置-HTTP2-0" class="headerlink" title="Nginx配置 HTTP2.0"></a>Nginx配置 HTTP2.0</h4><pre><code>https://www.nginx.com/blog/nginx-1-9-5/
</code></pre><p>| <a href="https://www.cnblogs.com/meng1314-shuai/p/8335140.html" target="_blank" rel="noopener">https://www.cnblogs.com/meng1314-shuai/p/8335140.html</a>          // 安装Ng<br>| <a href="http://www.cnblogs.com/felixzh/category/937300.html" target="_blank" rel="noopener">http://www.cnblogs.com/felixzh/category/937300.html</a><br>| <a href="https://www.cnblogs.com/felixzh/p/6283788.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/6283788.html</a><br>| <a href="https://www.cnblogs.com/taiyonghai/p/6728707.html" target="_blank" rel="noopener">https://www.cnblogs.com/taiyonghai/p/6728707.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/06/服务器端概念/">大型网站架构</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/06/服务器端概念/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-06T10:18:51.000Z" itemprop="datePublished">2017-04-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/服务端开发/">服务端开发</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="cookie、session、token"><a href="#cookie、session、token" class="headerlink" title="cookie、session、token"></a>cookie、session、token</h4><pre><code>一、Session

    是另一种记录客户端状态的机制，cookie保存客户端，session存储在服务器上

    登录成功 =&gt; 服务器存储Session =&gt; 并在客户端的cookie中也存储一个 =&gt; 之后客户端请求，服务端取到cookie的Session的值，在与服务器保存的来进行比较是否存在（这个过程是session内部的机制，程序只需要判断就行）

二、cookie

    存储在客户端本地，js和服务器都可以存、取、删cookie的值，cookie组成（key、value、domain、域、失效时间）

三、token

    token的意思是令牌，用户身份验证，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串

    作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态

http://blog.csdn.net/qq_33401924/article/details/52947514
http://blog.csdn.net/jikeehuang/article/details/51488020
</code></pre><h4 id="验证码的流程"><a href="#验证码的流程" class="headerlink" title="验证码的流程"></a>验证码的流程</h4><pre><code>通过插件来生成图型 =&gt; 并将图片结果存到session中，并存到用户的cookie中 =&gt; 登录时来判断session中的值与用户请求参数的值是否相同

https://github.com/lemonce/svg-captcha/blob/master/README_CN.md

// 生成验证码
async captcha() {
    const svgCaptcha = require(&apos;svg-captcha&apos;);
    const { ctx } = this;
    const captcha = svgCaptcha.createMathExpr({
        size: 4,                 // 验证码长度
        ignoreChars: &apos;0o1i&apos;,     // 验证码字符中排除 0o1i
        noise: 3,                 // 干扰线条的数量
        color: true,             // 验证码的字符是否有颜色，默认没有，如果设定了背景，则默认有
        background: &apos;rgba(0,0,0,0.3)&apos;, // 验证码图片背景颜色
    });
    ctx.session.captcha = captcha.text;
    ctx.type = &apos;image/svg+xml&apos;;        // 设置header的content-type
    ctx.body = captcha.data;
}

// 用户登录
async login() {
    const { ctx, app, service } = this;

    if (ctx.session.captcha &amp;&amp; ctx.session.captcha !== ctx.request.body.captcha) {
    this.success({
        data: {},
        message: &apos;验证码错误&apos;,
        statusType: app.statusType.otherError,
    });
    return;
    }

    if (
    app.validateParams({
        userName: { type: &apos;string&apos;, max: 100, min: 2 },
        pwd: { type: &apos;string&apos;, min: 1 },
    }, ctx)
    ) {

    const data = await service.auth.login(ctx.request.body);
    this.success(data);
    }
}
</code></pre><h4 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h4><pre><code>https://segmentfault.com/a/1190000003801450
</code></pre><h4 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h4><pre><code>session或token

密码加盐 MD5（username + password + salt）
</code></pre><p>———————– 概念 ———————– </p>
<h4 id="服务器、虚拟机"><a href="#服务器、虚拟机" class="headerlink" title="服务器、虚拟机"></a>服务器、虚拟机</h4><pre><code>服务器: 只是一个硬件虚拟服务只是系统部分

虚拟机: 允许一台HTTP服务器搭建多个web建点，也就是一台服务器可以为多个用户服务，每个用户通过域名运行各自的网站，这就是利用了虚拟机（又称虚拟服务器）的功能
</code></pre><h4 id="前后分离"><a href="#前后分离" class="headerlink" title="前后分离"></a>前后分离</h4><pre><code>前后端数据分离登录失效判断可以通过session服务端来判断 =&gt; 跳转会员管理每个页面 =&gt; 服务器端判断session是否失效 =&gt; 失效跳到登录

其它页面的登录信息可以前端可以通过cookie来获取
</code></pre><h4 id="正向代理、反向代理-Proxy"><a href="#正向代理、反向代理-Proxy" class="headerlink" title="正向代理、反向代理 Proxy"></a>正向代理、反向代理 Proxy</h4><pre><code>一、正向代理: 比如翻墙，直接访问国外网站访问不了，需要可以一个服务器来进行访问。正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。
</code></pre><p><img src="images/105641260.jpg" alt="正向代理"> </p>
<pre><code>二、反向代理: 代理理服务器来接受网络的连接请求，然后将请求转发给内部网络的服务器 （服务方的需求，为了解决一些负载等问题）

    作用: 保证内网的安全，负载均衡
</code></pre><p><img src="images/110207878.jpg" alt="反向代理"><br><img src="images/305504-20161112125907030-1432469707.png" alt="反向代理"></p>
<pre><code>http://www.cnblogs.com/Anker/p/6056540.html
</code></pre><h4 id="CDN和反向代理"><a href="#CDN和反向代理" class="headerlink" title="CDN和反向代理"></a>CDN和反向代理</h4><pre><code>CDN: 部署在网络提供的机房，用户请求时可以从最近的网络提供商机房获取数据
</code></pre><h4 id="负载的均衡"><a href="#负载的均衡" class="headerlink" title="负载的均衡"></a>负载的均衡</h4><pre><code>通过反向代理服务器来优化网站的负载
</code></pre><p><img src="images/305504-20161112124423530-566240666.png" alt="负载的均衡"></p>
<h4 id="集群、分布式"><a href="#集群、分布式" class="headerlink" title="集群、分布式"></a>集群、分布式</h4><h4 id="跳板机"><a href="#跳板机" class="headerlink" title="跳板机"></a>跳板机</h4><pre><code>跳板机是开发者登录到网站分配给应用服务器的唯一途径。开发者必须首先登录跳板机，再通过跳板机登录到应用服务器

k踏板机属于内控堡垒机范围，用于单点登录的主机，之前是为了运维人员远程登录进行管理，会在机房部署跳板机，踏板机就是一台服务器，维护人员在维护过程先要统一登录在这台服务器上在登录到目录服务器进行维护
</code></pre><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><pre><code>网站缓存有两种：缓存在应用服务器上（本地缓存）和缓存在专门的分布式缓存服务器上（远端缓存）
</code></pre><h4 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h4><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><pre><code>1、通过设置服务器对header设置一个Access-Control-Allow-Origin: *, 开启跨域请求。在被请求的Response header中加入

    // 指定允许其他域名访问  
    header(&apos;Access-Control-Allow-Origin:*&apos;);
    // 响应类型  
    header(&apos;Access-Control-Allow-Methods:POST&apos;);
    // 响应头设置  
    header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);  

2、CORS优点: 跨域最常用的是JSONP但这种方式是通过Get的方式请求src完成的，很多跨域问题JSONP无法解决，比如: 

    1) post请求跨域

    2) &quot;script error&quot; 的脚本错误提示

    3) canvas中无法获取跨域图片的信息，如果使用CORS上面几个问题就可以解决
</code></pre><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><pre><code>一、XSS 攻击: 对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作

二、CSRF 攻击: 伪造用户请求向网站发起恶意请求

三、钓鱼攻击: 利用网站的跳转链接或者图片制造钓鱼陷阱
</code></pre><p>———————– 网络 ———————– </p>
<h4 id="网关、隧道"><a href="#网关、隧道" class="headerlink" title="网关、隧道"></a>网关、隧道</h4><pre><code>网关: 转发其它服务器通信数据的服务器，接收从客户端发送来的

隧道: 将客户端和服务器之间进行中转，并保持双方通信连接的应用程序
</code></pre><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><pre><code>域名系统（英文：Domain Name System，缩写：DNS）是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS 使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。

http://www.alloyteam.com/2015/05/dns%EF%BC%8Cnode%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E5%92%8C%E5%BA%94%E7%94%A8/
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/02/mongoose/">Mongoose</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/02/mongoose/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-02T11:15:23.000Z" itemprop="datePublished">2017-04-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/数据库/">数据库</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>Schema[ˈskimə] - 数据库存储格式的约定协议，可以理解为数据表的字段类型声明

Model -  由Schema转化的数据模型，具有抽象属性和行为的数据库操作，可以进行查询操作

Entity [ˈɛntɪti] - 由Model创建的实体，可以对数据库表进行完整的CRUD操作
</code></pre><h4 id="Mongoose使用"><a href="#Mongoose使用" class="headerlink" title="Mongoose使用"></a>Mongoose使用</h4><pre><code>一、安装

    $ npm install mongoose

二、示例

    const mongoose = require(&apos;mongoose&apos;);
    const Schema = mongoose.Schema;

    // 连接mongodb
    mongoose.connect(&apos;mongodb://car:welcomeCar@localhost/myCar&apos;);       // mongodb://用户名:密码@数据库IP/库名

    // 连接成功
    mongoose.connection(&apos;connected&apos;, ()=&gt;{
        console.log(&apos;connect success&apos;);
    })

    // 连接失败
    mongoose.connection(&apos;error&apos;, ()=&gt;{
        console.log(&apos;connect error&apos; + err);
    })

    // 连接断开
    mongoose.connection(&apos;disconnected&apos;, ()=&gt;{
        console.log(&apos;connect disconnected&apos;);
    })


    // 创建Schema
    const UserSchema = new Schema({
        username: String,
        password: String,
        age: Number,
        LoginAt: Date
    })

    // 定义Model
    const UserModel = mongoose.model(&apos;User&apos;, UserSchema);

    // 插入数据
    let userData = new UserModel({
        username: &apos;siguang&apos;,
        password: &apos;ssssss&apos;,
        age: 20,
        loginAt: new Date()
    })

    // 保存
    userData.save((err, res)=&gt;{
        if(err){
            return console.log(err)
        }
        console.log(res);
    })

    // 删除
    userData.remove({age: 30}, (err, doc) =&gt; {
        if(err){
            return console.log(err)
        }
        console.log(doc);
    })

    // 查询
    userData.find({username: &apos;siguang&apos;, (err, doc)=&gt;{
        if(err){
            return console.log(err)
        }
        console.log(doc);
    })

    // 数量
    userData.count({age: 20}, (err, doc)=&gt;{
        if(err){
            return console.log(err)
        }
        console.log(doc);
    })
</code></pre><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><pre><code>mongoose两种连接： connect连单个db并打开，createConnect连接多个db

一、mongoose.connect()方法连接

    写法1:
        connect(&apos;mongodb://[username]:[password]@host:port/database?options...&apos;);   // 用户名、密码、主机、端口、库名、参数

        let db = mongoose.connect(&apos;mongodb://[username]:[password]@127.0.0.1:27017/myDB&apos;);

    写法2:
        -- conect(uri, options) --

        var options = {
            db: { native_parser: true },
            server: { poolSize: 5 },
            replset: { rs_name: &apos;myReplicaSetName&apos; },
            user: &apos;myUserName&apos;,
            pass: &apos;myPassword&apos;
        }
        var uri = &apos;mongodb://localhost/dbName?poolSize=4&apos;;
        mongoose.connect(uri, options);

    -- mongoose.createConnection() --

二、多个连接

    let mongoose = require(&apos;mongoose&apos;);
    let db = mongoose.connect(&apos;mongodb://127.0.0.1:27017/myDB&apos;);        // mongodb://IP:端口号/数据库名

    // 侦听打开的回调
    db.connection.on(&apos;error&apos;, function(error){
        console.log(&apos;数据库连接失败&apos;+error);
    })

    // 侦听连接成功
    db.connection.on(&apos;open&apos;, function(){
        console.log(&apos;连接成功&apos;)
    })

三、两者的区别

    var mongoose = require(&apos;mongoose&apos;);
    db = mongoose.createConnection(&apos;localhost&apos;, &apos;test&apos;);
    var schema = new mongoose.Schema({ name: String });
    var collectionName = &apos;kittens&apos;;
    var M = db.model(&apos;Kitten&apos;, schema, collectionName);

    var mongoose = require(&apos;mongoose&apos;);
    mongoose.connect(&apos;mongodb://localhost/test&apos;);
    db = mongoose.connection;
    db.once(&apos;open&apos;, function callback () {
        // yay!
    });    

    createConnection，可以open，但完全不会查询。第二种方法就可以
</code></pre><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><pre><code>Schema: 一种文件形式存储数据库模型的骨架，无法直接连接数据端，不具备操作数据库的能力，叫数据属性模型或集合

一、定义表的文档结构

    let personSchema = new mongoose.Schema({        
        name: String,
        age: Number,
        email: { type: String, max: 20 }
    })

二、实例方法、静态方法

    let PersonSchema = new mongoose.Schema({        
        name: String,
        age: Number,
        email: { type: String, max: 20 }
    })

    var Person = mongoose.model(&apos;person&apos;, PersonSchema);
    var silence = new Person({ name: &apos;Silence&apos; });

    PersonSchema.methods.speak = function(){

    }

三、index 索引

    let Schema = mongoose.Schema;
    let carSchema = new Schema({
        name: String,
        title: { type: String, index: true },   // index 索引
        uid: { type: Number, unique: true },    // unique 独一无二的
        date: { type: Date, default: Date.now } // default 默认值
    })

    // 文档索引和字段索引
    let carSchema = new Schema({
        name: String,
        title: { type: [String], index: true },   // 字段索引
    })

    carSchema.index({ name: 1, type: -1});  // 
</code></pre><h4 id="Schema-Type"><a href="#Schema-Type" class="headerlink" title="Schema Type"></a>Schema Type</h4><pre><code>一、类型

    1、String：字符串

    2、Number：数值

    3、Date：日期

    4、Buffer： 二进制

    5、Boolean：布尔

    6、Mixed： 混合

    7、ObjectId： ObjectId

    8、Array：数组

二、其它参数

    default: 默认       // updated: { type: Date, default: Date.now }

    min/max: 最小或最大  // age: { type: Number, min: 18, max: 65 }

    trim: 去掉两端空格

    lowercase: true     // 保存前将字符转成小写

    uppercase: true     // 保存前将字符转成大写

    required: true      // 必填

    match：RegExp       // 创建一个正则验证器

    enum：Array         // 检查值是否在给定的数组中

    index: true         // 索引

    unique: true        // 索引，指定字段为独一无二

三、Example

    var schema = new Schema({
        idCard: { type: String, unique: true, trim: true },     // 用户id 字段独一无二、去掉两端空格
        name:    String,            // 可以直接写成String，也可以写成 {type: String}
        binary:  Buffer,
        living:  Boolean,
        updated: { type: Date, default: Date.now }
        age:     { type: Number, min: 18, max: 65 }
        mixed:   Schema.Types.Mixed,
        _someId: Schema.Types.ObjectId,
        array:      [],
        ofString:   [String],
        ofNumber:   [Number],
        ofDates:    [Date],
        ofBuffer:   [Buffer],
        ofBoolean:  [Boolean],
        ofMixed:    [Schema.Types.Mixed],
        ofObjectId: [Schema.Types.ObjectId],
        nested: {
            stuff: { type: String, lowercase: true, trim: true }
        }
    })
</code></pre><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><pre><code>具有操作数据库的能力，类似管理数据库的属性和行的类

创建model  mongoose.model(&apos;集合名&apos;, schema);

    let personScheam = new Scheam({
        name: &apos;String&apos;,
        password: &apos;String&apos;
    }, {
        timestamps: true,             // 设置timestamps，多加两个字段createdTime、updatedTime，来记录插入时间和更新时间
        collection: &apos;report_warning_config&apos;,
    })

    let personModel = mongoose.model(&apos;person&apos;, personSchema);
</code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>一、find, findById, findOne, or where 

    let TankScheam = new Scheam({
        name: &apos;String&apos;,
        password: &apos;String&apos;
    })

    let Tank = mongoose.model(&apos;Tank&apos;, personSchema);

    Tank.find({size: &apos;samll&apos;}).where(&apos;createDate&apos;).gt(oneYear).exec(callback);

二、条件查询中常用属性

    $or　　　　或关系
    $nor　　　　或关系取反
    $gt　　　　大于
    $gte　　　　大于等于
    $lt　　　　小于
    $lte　　　　小于等于
    $ne　　　　不等于
    $in　　　　在多个值范围内
    $nin　　　　不在多个值范围内
    $all　　　　匹配数组中多个值
    $regex　　　　正则，用于模糊查询
    $size　　　　匹配数组大小
    $maxDistance　　　　范围查询，距离（基于LBS）
    $mod　　　　取模运算
    $near　　　　邻域查询，查询附近的位置（基于LBS）
    $exists　　　　字段是否存在
    $elemMatch　　　　匹配内数组内的元素
    $within　　　　范围查询（基于LBS）
    $box　　　　范围查询，矩形范围（基于LBS）
    $center　　　　范围醒询，圆形范围（基于LBS）
    $centerSphere　　　　范围查询，球形范围（基于LBS）
    $slice　　　　查询字段集合中的元素（比如从第几个之后，第N到第M个元素


三、方法

    1、where(&apos;price&apos;) - 查询的字段  Tank.find().where(&apos;price&apos;)

    2、find() - 查询所有，返回的是数组

    3、findOne({name: &apos;siguang&apos;}) - 只把第一条name为siguang的数据，如果find会将所有都返回

    4、findById(id) - 根据一条id来查找，返回的是一条记录的对象，而不是一个数组，与find({_id: &apos;59bf7ee03f55167fb6cdd75c&apos;})相同

    5、findByIdAndRemove(id) - 根据id查找，并删除这个条数据，如果查找不到返回 null

    6、findByIdAndUpdate(id, update) - 

    7、lean() - Tank.find().lean()      // 默认参数为true, 可以设置 lean(false)
</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>Tank.remove({size: &apos;large&apos;})

// 查找并删除
Tank.findByAndRemove()
</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><pre><code>Tank.update({_id: id}, {$set: {size: &apos;large&apos;}, callback);

// 查找并更新
Tank.findByIdAndUpdate(id, [update]);
</code></pre><h4 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h4><h4 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h4><pre><code>insert和update都需要save(),
</code></pre><h4 id="egg-mongose"><a href="#egg-mongose" class="headerlink" title="egg-mongose"></a>egg-mongose</h4><pre><code>1、在model中创建模型

    module.exports = app =&gt; {
        const mongoose = app.mongoose;

        const NewsSchema = new mongoose.Schema({
            newsTitle: {type: String, max: 32},
            newsContent: {type: String},
        },{
            timestamps: true,               // 插入记录时会自动创建一个createAt和updateAt时间字段
            collection: &apos;news&apos;,             // mongo中存的collection名
        });

        return mongoose.model(&apos;News&apos;, NewsSchema);      // News调用时的名
    }


2、在service中调用

    let doc = await app.model.News.find();

3、创建和查询

    const doc = await new app.model.User(user).save();          // 创建时需要new 

    const user = await app.model.User.findOne({_id: user._id});     // 查询时不需要new


4、使用find()查询 使用. ()

    如果使用find().lean()返回的是纯javascript对象，而不是mongoose文档，他们没有保存方法

    Example:

    const resourceTree = await app.model.Resource.find({});

        返回
        { _id: 5a535142fe6d170e82135e89,
            displayName: &apos;欢欢&apos;,
            username: &apos;huanhuan&apos;,
            mobile: 13012309874,
            email: &apos;huan@126.com&apos; 
        },
        { _id: 5a5357d2bd53b40f791362aa,
            username: &apos;maolv&apos;,
            displayName: &apos;毛驴&apos;,
            mobile: 13290984585,
            email: &apos;maolv@126.com&apos; 
        }

    const resourceTree = await app.model.Resource.find({}).lean();

        返回
        [
            { _id: 5a535142fe6d170e82135e89,
                displayName: &apos;欢欢&apos;,
                username: &apos;huanhuan&apos;,
                mobile: 13012309874,
                email: &apos;huan@126.com&apos; 
            },
            { _id: 5a5357d2bd53b40f791362aa,
                username: &apos;maolv&apos;,
                displayName: &apos;毛驴&apos;,
                mobile: 13290984585,
                email: &apos;maolv@126.com&apos; 
            }
        ]
</code></pre><p>| <a href="https://mongoose.shujuwajue.com/guide/schemas.html" target="_blank" rel="noopener">https://mongoose.shujuwajue.com/guide/schemas.html</a>        // 中文API<br>| <a href="http://www.nodeclass.com/api/mongoose.html" target="_blank" rel="noopener">http://www.nodeclass.com/api/mongoose.html</a><br>| <a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a>         egg-mongoose<br>| <a href="http://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="noopener">http://cnodejs.org/topic/504b4924e2b84515770103dd</a><br>| <a href="http://www.cnblogs.com/xuange306/p/4603551.html" target="_blank" rel="noopener">http://www.cnblogs.com/xuange306/p/4603551.html</a><br>| <a href="http://www.cnblogs.com/winyh/p/6682039.html" target="_blank" rel="noopener">http://www.cnblogs.com/winyh/p/6682039.html</a><br>| <a href="http://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="noopener">http://cnodejs.org/topic/504b4924e2b84515770103dd</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/02/mongoDB/">MongoDB</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/02/mongoDB/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-02T11:15:23.000Z" itemprop="datePublished">2017-04-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/数据库/">数据库</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>创建用户权限<br>数据类型 - null、boolean、Number、Float、String、Date、表达式、二进制、undefined、Array、Object<br>库操作 - show dbs、show collections、use db、db、db.dropDatabase()<br>创建和删除集合 -  db.createCollection、db.myColl.insert({})、db.myColl.drop()<br>删除行 -<br>插入值 - db.myColl.insert({name: ‘haha’})<br>更新值 - db.myColl.update({name: ‘haha}, {$set: {age: 20}}, false, true)<br>        $set、$unset、$inc、$push、$pushAll、$pop、$pull、$pullAll、$rename<br>删除值 -  db.myColl.remove({name: ‘’})、remove({})<br>查询值 - db.myColl.find({})<br>        .sort()、count()、limite()、skip()<br>        查询条件 $gt、$gte、$lt、$lte、!= 、=、and、or、in、notIn<br>        数组查询 $all、$size、$sclie<br>        $where 子句<br>索引 db.myColl.ensureIndex({key:1})、getIndexes()、dropIndexes()、background:true修改索引<br>       索引类型: _id索引、单键索引、多键索引、复合索引、过期索引、全文索引、唯一索引<br>复制集<br>分片<br>数据均衡<br>性能分析</p>
</blockquote>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>自动提示，按两次Tab

db.getMongo() - 查看当前mongo的ip和端口

启动服务 - /usr/local/Cellar/mongodb/3.4.3/bin  =&gt;  $ mongod &amp;

停止服务 - 进入 use admin  =&gt; $ db.shutdownServer()

查看服务进程 -  ps -rf | grep mongod   ps -rf | grep mongo    kill -9 xxxx

---------------------------------------------------------------------------------------

db.copyDatabase(&apos;旧数据库名&apos;, &apos;新数据库名&apos;) - Copy数据库

---------------------------------------------------------------------------------------

show dbs - 查询所有数据库

show collections - 查询所有当前数据库下所有的数据表

use myDataBase - 创建并切换库，如果没有就创建这个库，创建库时在内存中，只有对库插入集合操作才会真正存在硬盘上

db - 查看当前选择的库

db.dropDataBase() - 删除数据库


db.createCollection(表名，指定大小和索引选项) - 创建集合

db.myColl.drop() - 删除集合


db.myColl.insert({_id: ObjectId(&quot;5a4b5f29cca1d978501c9c52&quot;), name: &apos;aa&apos;, age: 30}) - 插入主键不能相同

db.myColl.save({_id: ObjectId(&quot;5a4b5f29cca1d978501c9c52&quot;), name: &apos;aa&apos;, age: 30}) - 插入允许主键相同的数据


db.myColl.find(query) - 查看文档

db.myColl.findOne() - 取第一条记录

db.myColl.update({}) - 更新文档

db.myColl.remove(query, {justOne}) - 删除一条文档

db.myColl.update({name: &apos;siguang&apos;}, {$unset: {name: 1}}) - 删除一个字段


db.myColl.ensureIndex() - 创建索引

db.myColl.getIndexes() - 查看当前集合索引

db.myColl.dropIndexes() - 删除索引 

db.myColl.ensureIndex({id: 1}, {background: true}) - 修改索引


db.createUser() - 创建用户角色
</code></pre><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><pre><code>一、MongoDB优点

    1、无数据结构限制（没有表结构概念，每条记录可以有完全不同的结构）

    2、完全的索引支持（单键索引、数组索引、全文索引、地理位置索引）

    3、数据安全性和分片扩展数据规模

    1、简单的单机服务    2、搭建具有冗余容错功能的复制集    3、搭建大规模数据集群        4、完成集群的自动部署

    MongoDB逻辑结构是一种层次结构，文档(document)、集合(collection)、数据库(database)这三部分组成的。 


二、数据库分类

    1、SQL数据库，支持SQL语言的数据库，如 Oracle，Mysql

    2、NoSQL数据库，不支持SQL语言的数据库，Redis, MongoDB


三、mongo与sql概念

    SQL术语/概念    MongoDB术语/概念    解释/说明

    database        database         数据库
    table            collection         数据库表/集合
    row                document         数据记录行/文档
    column            field             数据字段/域
    index            index             索引
    table             joins              表连接,MongoDB不支持
    primary key        primary key         主键,MongoDB自动将_id字段设置为主键
</code></pre><h4 id="MongoDB安装、连接、启动服务"><a href="#MongoDB安装、连接、启动服务" class="headerlink" title="MongoDB安装、连接、启动服务"></a>MongoDB安装、连接、启动服务</h4><pre><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;    // 安装brew

$ brew update                // 更新brew

$ brew install mongodb         // 安装的目录 /usr/local/Cellar/mongodb/   

    brew uninstall mongodb  // 卸载mongo

$ brew list                    // 查看brew安装的列表中是否存在brew

$ sudo mkdir -p /data/db       // 用来存放mongo创建的数据文件

    注意这里如果启动服务时报/data权限问题需要执行

    $ sudo chmod -R 777 /data

$ 连接本地和远端服务器的mongoDB

    本地mongo: $ mongo localhost:27017/test -u user -p password            // 如果没有用户名和密码直接mongo

    远端mongo: $ mongo 192.168.1.200:27017/test -u user -p password        // test为数据库名

        mongodb://10.10.13.123:27017,10.10.13.341:27017/ibg_node_core

$ 启动和关闭服务

    启动服务: 

        $ cd /usr/local/Cellar/mongodb/3.6.1/bin        // 进入到目录

        $ mongod &amp;            // &amp; 关闭终端mongod服务不会被kill掉  如果启用权限使用 mongod --auth

    关闭服务:

        $ use admin         // 需要先进入到admin库

        $ db.shutdownServer()


$ brew info mongodb            // 查看安装信息    mongod --config /usr/local/etc/mongod.conf

    mongodb.conf内容

        systemLog:        // log目录
            destination: file
        path: /usr/local/var/log/mongodb/mongo.log
            logAppend: true
        storage:        // db目录
            dbPath: /usr/local/var/mongodb        // 数据存储的目录
        net:
            bindIp: 128.0.0.1

    http://blog.csdn.net/sun491922556/article/details/74973191            // 3.4版本配置

$ mongo --version            // 查看版本

https://www.imooc.com/article/23046
</code></pre><h4 id="mongo的基本数据类型"><a href="#mongo的基本数据类型" class="headerlink" title="mongo的基本数据类型"></a>mongo的基本数据类型</h4><pre><code>null、boolean、Number、Float、String、Date、表达式、二进制、undefined、Array、Object
</code></pre><h4 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h4><pre><code>一、查询库、查询集合

    1、show dbs — 查询所有的数据库列表

    2、show collections — 显示当前库下所有集合


二、创建库和删库

    1、use testDatabase — 创建一个数据库，如果库存在则使用当前库，创建时只在内存中，只有对这个库有操作后这个数据库才能真正创建

    2、db - 查看当前所在的库库

    3、db.dropDatabase() - 删除这个数据库

        use tsetDatabase     // 先进入要操作的数据库
        db.dropDatabase()     // 删除库
</code></pre><h4 id="文档的创建和删除"><a href="#文档的创建和删除" class="headerlink" title="文档的创建和删除"></a>文档的创建和删除</h4><pre><code>查看常用的方法  db.myColl.help()

一、建表两种方法

    db.createCollection(名称, 指定有关内存大小和索引选项);    -    创建集合

        options:
            capped - Boolean    （可选）如果为true，则启用封顶集合。封顶集合是固定大小的集合，会自动覆盖最早的条目，当它达到其最大大小。如果指定true，则需要也指定尺寸参数。
            autoIndexID - Boolean    （可选）如果为true，自动创建索引_id字段的默认值是false。
            size - number    （可选）指定最大大小字节封顶集合。如果封顶如果是 true，那么你还需要指定这个字段。
            max - number

    db.myColl.insert({name:’hf’,age:20}) — 在mongodb中在插入数据时即创建了改表，此时创建的是名为myColl的数据表

        for(i=0; i&lt;100; i++) db.myTabel.insert({&apos;age&apos;, i})        循环插入


二、删除集合、文档

    db.myColl.remove({type: &apos;马尔代夫&apos;}) - 删除myColl集合中 type=&apos;马尔代夫&apos; 这条文档

    db.myColl.drop(); — 删除myColl这个集合
</code></pre><h4 id="insert-插入文档"><a href="#insert-插入文档" class="headerlink" title="insert 插入文档"></a>insert 插入文档</h4><pre><code>1、insert() - 插入主键不能相同，自动生成_id    db.myColl.insert({name:’hahaha’, age:12});

2、save() - 允许插入重复数据，直接添加一个文档

    db.myColl.save({        // 直接向集合中插入文档
        data: {},
        message: &quot;操作成功&quot;,
        status: 0
    })

二者的区别，insert()在主键相同时会报错，save()不会

    $ db.user.find();        // { &quot;_id&quot; : ObjectId(&quot;5a4b5df1cca1d978501c9c50&quot;), &quot;username&quot; : &quot;siguang&quot; }

    $ db.user.insert({ &quot;_id&quot; : ObjectId(&quot;5a4b5df1cca1d978501c9c50&quot;), &quot;username&quot; : &quot;siguang&quot; })        // 报错

    $ db.user.save({ &quot;_id&quot; : ObjectId(&quot;5a4b5df1cca1d978501c9c50&quot;), &quot;username&quot; : &quot;siguang1111111&quot; })    // 执行成功，并将username的值改了
</code></pre><h4 id="find-文档查询"><a href="#find-文档查询" class="headerlink" title="find 文档查询"></a>find 文档查询</h4><pre><code>http://www.cnmyColls.com/egger/p/3135847.html

1、findOne() - 查询第一条记录，然后闭关游标    

2、find() - 返回符合条件的所有记录        db.role.find({age:30}) 返回role中age等于30的集合

3、sort() - db.myColl.find().sort({age:1})      // age=1为升序，-1为降序  sort()

4、count() - db.myColl.find().count();          // 返回表中记录的个数 count()        

5、limit() - db.myColl.find().limit(5)          // 返回前5条数据 limit()

            db.myColl.find().skip(10).limit(20);        返回11-30条数据， 用于分页

6、skip() - db.myColl.find().skip(50)          // 跳过前50条数据

7、pretty() - 将查询出的内容进行格式显示        

8、查询条件

    1）条件查询   &gt; $gt、 &gt;= $gte、 &lt; $lt、 &lt;= $lte、 != $ne

        db.cars.find({carMoney: {$lt:100}})        // 查询carMoney小于100的值

        db.cars.find({carMoney: {$lt:100, $gt:20}})        // 查询carMoney 大于20小于100的值

    2）$and、$or、$in、$notIn

        $and    db.cars.find({name: &apos;卡宴&apos;, price: 200})        // name=卡宴 并且 price=200    

        $in      db.myColl.find({price: {$in: [100, 300, 500]});        // 查询出price field中为100、300、500值的字段

        $or     db.cars.find({ $or: [ {id: 9}, {carType: 735}] })        // 查询出id=9 或者 carType=735

                db.cars.find({ isDeleted: false, $or: [ {id: /huang/i}, {carType: 735}] });    // 查询 isDeleted等于false 并且id带有&apos;huang&apos;字符 或者 carType等于735

        $not    不包括的数据

9、$type 类型操作符查询

    例如: 将name字段中的所有为数字的查询出来，

    $ db.tourism.find({&apos;name&apos;: {$type: 1}})

    对应表:

        类型                    数字            备注

        Double                1                数字
        String                2     
        Object                3     
        Array                4     
        Binary data            5     
        Undefined            6               已废弃。
        Object id            7     
        Boolean                8     
        Date                9     
        Null                10
        Regular Expression    11
        JavaScript            13     
        Symbol                14     
        JavaScript (with scope)    15     
        32-bit integer        16     
        Timestamp            17     
        64-bit integer        18     
        Min key                255            Query with -1.
        Max key                127     


10、数组查询

    1）$all - 用来查询数组中是否包含指定的值

        // content field值为数组
        db.myColl.find({content: {$all: [1, 8]})        返回content中包含1或8的数组


    2）$size - 查询数组的长度

        db.myColl.find({content: {$size: 3}});        返回content数组字段长度为3个


    3）$slice - 控制指定字段中返回数组的个数

        db.myColl.find({}, {content: {$slice: 3}} )    返回所有记录 content数组只取前三个

        db.myColl.find({}, {content: {$slice: -3}} )    从后取3个

        db.myColl.find({}, {content: {$slice: [1, 3]}} )    取1-3的范围


11、$where 子句

    相当于用一个js查询一部分，如果为true则返回数据，则否不返回

    字符串形式
    db.myColl.find({$where: &quot;this.title.length &gt; 23&quot;}, {title: 1})    对title field中的字符长度大于23的返回

    函数形式
    db.myColl.find({$where: function(){ return this.title.length &gt; 23 }})


12、Example

    db.myColl.find();  —  查询myColl中的所有数据， 带条件 .fin({x: 1}) x=1的记录

    db.myColl.find({}, {id: &apos;&apos;, price: &apos;&apos;}) — 查询其中两个字段的值

    db.myColl.find({id: 5}, {username: 1}) - 只返回id=5 的 username的字段，其余的不返回

        { &quot;_id&quot; : ObjectId(&quot;58e85c84784a18c26f9a1fa5&quot;), &quot;username&quot; : &quot;siguang5&quot; }

    db.myColl.find({carType: 33}, {id: &apos;&apos;, price: &apos;&apos;}) — 返回carType=33的id和price字段的值

    db.myColl.update({}, {$unset:{&apos;name&apos;:&apos;&apos;}}, false, true)        // 删除一个字段

    db.myColl.find({title: /美舰/}, {title: 1})    -    查找出title中带有&quot;美舰&quot;的字符，并只返回title字段
</code></pre><h4 id="update-更新文档"><a href="#update-更新文档" class="headerlink" title="update 更新文档"></a>update 更新文档</h4><pre><code>update(更新条件, 更新的值，[如果不存在是否创建 - 默认false]，[是否更新全部 - 默认false])

1、$set - 更新值

    update() 第四个参数为true更所有匹配的值，false只更新一个

    // 只更匹配的第一条 如果type=&apos;123&apos;不存在, 则插入一条只有name=&apos;456&apos;的数据
    db.myColl.update({type: &apos;123&apos;}, {name: &apos;456&apos;});        // 注意如果不使用$set那么type=123这行记录只剩name=456

    // 更新全部匹配
    db.myColl.update({name:’hf’}, {$set:{age:25}}, false, true)

    // {multi:true} 更新多条
    db.myColl.update({&apos;title&apos;:&apos;MongoDB 教程&apos;}, {$set:{&apos;title&apos;:&apos;MongoDB&apos;}}, {multi:true})

    // 为集合中所有文档添加一个字段
    db.user.update({}, {$set: {password: &apos;******&apos;}}, {multi: 1})


2、$unset - 删除字段列

    db.myColl.update({id: 1}, {$unset: {content: 1}});        // 删除id=1，content字段


3、$inc - 只能对一个数字字段的值的进行累加，key不存在或者非数字都报错

    db.myColl.find({id: 1});        result: { username: &apos;siguang&apos;, password: 100 }

    // 如果password的值存在则 +1000
    db.myColl.update({id: 1}, {$inc: {password: 1000}})    
    db.myColl.find({id: 1});        result: { username: &apos;siguang&apos;, password: 1100 }


4、$push、$pushAll - 对一个数组字段在插入值

    db.myColl.find({id: 3});            Result: { &quot;id&quot; : 3, &quot;username&quot; : &quot;siguang3&quot;,  &quot;content&quot; : [ 1, 2, 3 ] }

    db.myColl.update({id: 3}, {$push: {content: 4}})
    db.myColl.find({id: 3});            Result: { &quot;id&quot; : 3, &quot;username&quot; : &quot;siguang3&quot;,  &quot;content&quot; : [ 1, 2, 3, 4] }


5、$addToSet - 向一个数组中添加数据，如果数组中存在这个值则不添加，如果不存在则添到数组中

    db.myColl.find({id: 3});            Result: { &quot;id&quot; : 3, &quot;username&quot; : &quot;siguang3&quot;,  &quot;content&quot; : [ 1, 2, 3 ] }

    db.myColl.update({id: 3}, {$addToSet: {content: 3}});        // 数组中存在不添加
    db.myColl.update({id: 3}, {$addToSet: {content: 4}});        // &quot;content&quot; : [ 1, 2, 3, 4 ]


6、$pop - 删除数组中第一个或最后一个值 

    db.myColl.update({id: 3}, {$pop: {content: -1}});        // content为1 删除数组第一个值，-1删除数组最后一个值


7、$pull、$pullAll - 删除数组中指定相同的值

    db.myColl.update({id: 4}, {$set: {content: [1,2,34,4,1,2,3,1,1,6,1,34]}});    将content field为数组

    db.myColl.update({id: 4}, {$pull: {contentn: 1}});
    db.myColl.find({id: 4});        Result  {content: [2,34,4,2,3,6,34]}}  将数组中的1全部删除


8、$rename - 对某个字段进行更名

    db.myColl.update({id: 4}, {$rename: {content: &apos;title&apos;}});        // 将id=4的 content field 名更改为title


http://chenzhou123520.iteye.com/myColl/1637629
</code></pre><h4 id="remove-删除文档"><a href="#remove-删除文档" class="headerlink" title="remove() 删除文档"></a>remove() 删除文档</h4><pre><code>1、db.myColl.remove({name: &apos;hf&apos;}) - 删除name字段值为空的行, 此处相当于关系数据库中的 delete myColl where name = ‘hf’

2、db.myColl.remove({_id: ObjectId(&quot;593526143793ca468ceb963c&quot;)}) - 通过id来删除文档

3、db.myColl.remove({}) - 删除集合中所有文档
</code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>索引就是用来加速查询

索引的优缺点:

    优点: 索引加快查询的速度

    缺点: 增加磁盘空间消耗，降低写入性能

一、命令

    1、查看索引 - getIndexes()    db.myColl.getIndexes()

    2、创建、修改索引 - ensureIndex()    

        创建: db.myColl.ensureIndex({userId: 1})        // 1升序  -1降序

        上修改: db.myColl.ensureIndex({id: 1}, {background: true});        // {background: true}

    3、删除索引 - dropIndexes()

        db.myColl.dropIndexes(name);        // getIndexes()中查出来所索name的值


二、ensureIndex()参数

    1、background - Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 &quot;background&quot; 可选参数。 &quot;background&quot; 默认值为false。

    2、unique - Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false.

    3、name - string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。

    4、dropDups - Boolean 在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.

    5、sparse - Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.

    6、expireAfterSeconds - nteger    指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。

    7、v - index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。

    8、weights - document索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。

    9、default_language - string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语

    10、language_override - string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.

http://blog.51cto.com/chenql/2071267


三、索引类型

    创建索引的两种不同:

        非全文索引     ensureIndex({key: value}): key为字段名，值为1或-1代表索引的排序方向
        全文索引     ensureIndex({key: &apos;text&apos;}): key为字段名，value为固定的&apos;text&apos;字符串

    1、_id索引 - 是绝大多数集合默认建立的索引, 插入一条数据自动创建一个索引

    2、单键索引 - 最普通的索引 与_id不同的是，单键索引不会自动创建

        Example:

            {x: 1, y: 2, z: 3}        // 当前表

            db.myColl.ensureIndex({x: 1})        // 使用 x 作为索引
            for(var i=0, i&lt;10; i++) db.myColl.insert({x: 2, y: i+&apos;y&apos;; z: i+&apos;z&apos;});
            for(var i=0, i&lt;10; i++) db.myColl.insert({x: 1, y: i+&apos;y&apos;; z: i+&apos;z&apos;});        // 插入10条数据，x为1
            db.myColl.find({x:1});            // 用索引查出数据


    3、多键索引 - 多键索引与单键索引创建形势相同

            单键索引: 值是一个单一的值，如字符串、数字或日期

            多键索引: 值有多个记录，如数组

            db.myColl.insert({x: [1,2,3,4,5]});


    4、复合索引 - 查询条件不只有一个，需要建立复合索引            

        db.myColl.ensureIndex({x: 1, y: 1})        // 定义复合索引
        db.myColl.find({x:1, y: 1})        // 通过复合索引查询

        设置后的索引:
        [
            {
                &quot;v&quot; : 2,
                &quot;key&quot; : {
                    &quot;_id&quot; : 1
                },
                &quot;name&quot; : &quot;_id_&quot;,
                &quot;ns&quot; : &quot;tuniu.gt&quot;
            },
            {
                &quot;v&quot; : 2,
                &quot;key&quot; : {
                    &quot;x&quot; : 1,        // 这里
                    &quot;y&quot; : 1
                },
                &quot;name&quot; : &quot;id_1_money_1&quot;,
                &quot;ns&quot; : &quot;tuniu.gt&quot;
            }
        ]


    5、过期索引 - 在一段时间后会过期的索引, expireAfterSeconds

        索引过期后数据会被删除, 插入的数据会在30秒后删除, 如用户登录信息, 存储日志

        db.myColl.ensureIndex({time: 1}, {expireAfterSeconds: 30})        // expireAfterSeconds 定义30秒后 time值的索引删除

        db.myColl.insert({username: &apos;siguang&apos;, password: &apos;xxxx&apos;, time: new Date()});        // new Date() 当前时间, 30秒后会自动删除当前这条记录

        ** 注意 当数据量不大的时候最小间隔为60秒, 就算设置30秒也会按60秒来完成 ** 
        ** 创建time的值必须是时间类型ISODate **


    6、全文索引

        *** 注意：mongo中不支持中文的全文索引 ***

        全文索引每次只能使用一个$text查询

        db.myColl.ensureIndex({key: &quot;text&quot;})

        db.myColl.ensureIndex({&quot;$**&quot;: &quot;text&quot;})        对所有字段作全文索引，而不是某一个字段


        查询全文索引：

            db.myTabel.find({$test: {$search: &apos;aa&apos;}})   只有值为aa时不包含其它字符时返回

            db.myTabel.find({$test: {$search: &apos;aa bb cc&apos;}})   如果是 aa 或 bb 或 cc 时返回  相当于 ||

            db.myTabel.find({$test: {$search: &apos;aa bb -cc&apos;}})  包含 aa 或 bb ，但不包含 cc 时返回

            db.myTabel.find({$test: {$search: &apos;\&apos;aa\&apos; \&apos;bb\&apos; \&apos;cc\&apos;&apos;}})  aa bb cc 都包含  相当于 &amp;&amp;


        相适度: $meta

            {score: {$meta: &apos;textscore&apos;}}  写在查询条件后面可以返回相似度的结果，与sort一起使用可以达到实用的效果

            Example:

            db.app.find({$text: {$search: &apos;新京报&apos;}}, {score: {$meta: &apos;textScore&apos;}})

            // db.app.find({$text: {$search: &apos;新京报&apos;}}, {score: {$meta: &apos;textScore&apos;}}).sort({scope: {$meta: &apos;textScore&apos;}})       // scope值来排序

            { &quot;_id&quot; : ObjectId(&quot;58e31b4c47e9f10d47bd55ec&quot;), &quot;title&quot; : &quot;共享单车相随总理出国门&quot;, &quot;article&quot; : &quot;今年1月，摩拜单车创始人&quot;, &quot;author&quot; : &quot;新京报(北京)&quot;, &quot;dateTime&quot; : ISODate(&quot;2017-04-04T04:04:28.585Z&quot;), &quot;score&quot; : 0.75 }
            { &quot;_id&quot; : ObjectId(&quot;58e31b4c47e9f10d47bd55ed&quot;), &quot;title&quot; : &quot;李克强赞这家企业一分钟穿越了两个时代&quot;, &quot;article&quot; : &quot;当时，来这里考察的。&quot;, &quot;author&quot; : &quot;新京报123(北京)&quot;, &quot;dateTime&quot; : ISODate(&quot;2017-04-04T04:04:28.624Z&quot;), &quot;score&quot; : 0.75 }

            这里结果返回 scope 的值是就相适度的情况


四、索引属性

    1、name 为索引指定name值

        例如定义一个复合索引，可以统一给他们一个名这样，在删除索引的时候也可以通过名字来删除

        db.myColl.ensureIndex({id: 1, type: 1, money: 1}, {name: &apos;idx&apos;});        // 定义索引name, 如果不加mongo会自动生成一个name值 为key_1

        db.myColl.dropIndexes(&apos;idx&apos;);


    2、unique 唯一索引

        唯一索引：不能在一个字段插入相同的值，如id如果有1，在插入id=1不允许

        db.myColl.ensureIndex({id: 1}, {unique: true/false});        // 设置了id字段为唯一索引

        db.myColl.insert({id:1, title:&apos;xxx&apos;});        如果id=1存在则不会被插入


    3、sparse 稀疏性


五、地理位置索引

    将一些点的位置存储在mongo中，创建索引后可以按照位置来查找其点

    子分类： 2d索引，用于存储和查找平面上的点        2dsphere索引，用于存储和查找球面上的点

    查找方式: 查找某个点一定距离内的点（打车软件）    查找包含在某个区域内的点

    1、创建 2D索引 平面地理位置索引

        db.location.ensureIndex({w: &apos;2d&apos;})        // 创建索引

        db.location.insert({w: [1, 1]});        // 插入经、纬度， 经度值在-180 至 180 之间， 纬度值在 -90 至 90 之间
        db.location.insert({w: [132, 112]});
        db.location.insert({w: [22, 14]});
        db.location.insert({w: [165, 13]});

        db.location.find({w: {$near: [1,1]}})        // $near 查找近的
        db.location.find({w: {$near: [1,140], $maxDistance: 150}})    // 查找经度 1-150之间， 或者纬度140-150之间   $maxDistrance 最大距离
</code></pre><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><pre><code>aggregate() 主要用于处理数据，返回计算后的数据结果

一、$group: 将集合中的文档分组，用于统计结果

    1、sum - 计算个数    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$sum : &quot;$currentCount&quot;}}}])

    2、avg - 计算平均值    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$avg : &quot;$currentCount&quot;}}}])

    3、min - 获取集合中所有文档对应值得最小值。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$min : &quot;$currentCount&quot;}}}])

    4、max - 获取集合中所有文档对应值得最大值。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$max : &quot;$currentCount&quot;}}}])

    5、push - 在结果文档中插入值到一个数组中。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$push: &quot;$currentCount&quot;}}}])

    6、addToSet - 在结果文档中插入值到一个数组中，但不创建副本。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$addToSet : &quot;$currentCount&quot;}}}])

    7、first - 根据资源文档的排序获取第一个文档数据。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, firstDoc: {$first : &quot;$currentCount&quot;}}}])

    8、last - 根据资源文档的排序获取最后一个文档数据    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, firstDoc: {$last : &quot;$currentCount&quot;}}}])

    Example:

        // 查出来的文档
        db.col.find().pretty();        
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d0&quot;),
            &quot;dimensionType&quot; : &quot;AGE&quot;,
            &quot;loanId&quot; : &quot;113029&quot;,
            &quot;currentCount&quot; : 30000,
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d1&quot;),
            &quot;dimensionType&quot; : &quot;OMG&quot;,
            &quot;loanId&quot; : &quot;1129602&quot;,
            &quot;currentCount&quot; : 30000
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d2&quot;),
            &quot;dimensionType&quot; : &quot;AGE&quot;,
            &quot;loanId&quot; : &quot;113031&quot;,
            &quot;currentCount&quot; : 40000
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d3&quot;),
            &quot;dimensionType&quot; : &quot;AGE&quot;,
            &quot;loanId&quot; : &quot;113016&quot;,
            &quot;currentCount&quot; : 40000
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d4&quot;),
            &quot;dimensionType&quot; : &quot;HSR&quot;,
            &quot;loanId&quot; : &quot;112910&quot;,
            &quot;currentCount&quot; : 30000
        }

        1）通过游标来计算 dimensionType计算出类别的个数

            db.col.aggregate([
                {
                    $group:{
                        _id: &quot;$dimensionType&quot;,
                        count: {$sum: 1}
                    }
                }
            ])        

            // 结果 返回
            { 
                &quot;_id&quot; : &quot;HSR&quot;, 
                &quot;count&quot; : 1.0
            }
            { 
                &quot;_id&quot; : &quot;OMG&quot;, 
                &quot;count&quot; : 1.0
            }
            { 
                &quot;_id&quot; : &quot;AGE&quot;, 
                &quot;count&quot; : 3.0
            }

        2) 通过dimensionType列 中不同类型来计算 currentCount列的总合

            db.col.aggregate([
                {
                    $group:{
                        _id: &quot;$dimensionType&quot;,
                        total: {$sum: &quot;$currentCount&quot;}
                    }
                }
            ])

            // 返回结果
            { 
                &quot;_id&quot; : &quot;HSR&quot;, 
                &quot;total&quot; : 30000.0
            }
            { 
                &quot;_id&quot; : &quot;OMG&quot;, 
                &quot;total&quot; : 30000.0
            }
            { 
                &quot;_id&quot; : &quot;AGE&quot;, 
                &quot;total&quot; : 110000.0
            }


二、管道符:

    $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。

    $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。

        db.col.aggregate([
            {
                $match: {
                    currentCount: {$gt: 30000}
                }
            },
            {
                $group:{
                    _id: &quot;$dimensionType&quot;,
                    min: {$sum: &quot;$currentCount&quot;}
                }
            }
        ])
        先将currentCount字段大于30000的匹配出来，在通过分组取出currentCount的总和

    $limit：用来限制MongoDB聚合管道返回的文档数。

    $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。

    $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。

    $group：将集合中的文档分组，可用于统计结果。

    $sort：将输入文档排序后输出。

    $geoNear：输出接近某一地理位置的有序文档。


三、count()  返回个数

    db.cars.count();        // 返回记录的个数

    db.cars.count({price: 1000})    // 返回price=1000 记录的个数

    db.cars.count({price: {$lt: 1000})    // 返回price &lt; 1000 记录的个数


四、distinct()  指定某一个字段返回不重复的数据，如 age: &apos;a&apos;  age: &apos;b&apos;  age: &apos;a&apos;   

    db.myColl.distinct(&quot;price&quot;);        // [&apos;a&apos;, &apos;b&apos;]    

五、mapReduce(）
</code></pre><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><h4 id="创建用户管理"><a href="#创建用户管理" class="headerlink" title="创建用户管理"></a>创建用户管理</h4><pre><code>mongo默认是没有管理员账户，需要在admin数据库中使用db.addUser()来添加管理员账号，否则任何人都可以操作数据库，admin库中有system.user的collection这就是用户表，用来存放超级管理员

用户分为两种: 一种是admin用户，另一种是在指定数据库的用户，admin用户是最高权限 

1、createUser() 创建用户

    $ use admin    // 先要切换到admin库

    $ show users     // 显示当前库下设置的所有设置的用户权限

    $ db.createUser(
        {
            user: &quot;root&quot;,        // 用户名
            pwd: &quot;ssssss&quot;,        // 密码
            roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]
        }
    )

    user - 段介绍： user字段，为新用户的名字；
    pwd - 用户的密码；
    cusomData - 为任意内容，例如可以为用户全名介绍；
    roles - 指定用户的角色，可以用一个空数组给新用户设定空角色；可以指定内置角色和用户定义的角色。

    Roles（内置角色）： 

        1. 数据库用户角色：read、readWrite;      // 读、读写

        2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；    // 管理权限

        3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；

        4. 备份恢复角色：backup、restore；

        5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase

        6. 超级用户角色：root   // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）

        7. 内部角色：__system

        PS：关于每个角色所拥有的操作权限可以点击上面的内置角色链接查看详情。


2、设置完用户权限进行重启mongod服务

    $ db.shtdownServer();        // 关闭mongod服务，或者kill掉

    // 进入bin目录下启动mongod

    $ mongod --auth                // 注意加权限就需要使用这个来启动服务,而不是单独的mongod &amp;


3、mongo登录

    $ mongo --port 27017 -u &quot;root&quot; -p &quot;ssssss&quot; --authenticationDatabase &quot;admin&quot;

    $ use admin

    $ db.auth(&quot;root&quot;, &quot;ssssss&quot;);        // 1表示登录成功，0表示登录失败。


4、创建其它用户

    use myCar
    db.createUser(
        {
            user: &quot;car&quot;,
            pwd: &quot;welcomeCar&quot;,
            roles: [ 
                { role: &quot;readWrite&quot;, db: &quot;myCar&quot; },
                { role: &quot;dbAdmin&quot;, db: &quot;myCar&quot; },
                { role: &quot;clusterMonitor&quot;, db:&quot;admin&quot;}
            ]
        }
    )


5、作为其它用户进行连接和验证身份

    mongo --port 27017
    use myCar
    db.auth(&quot;car&quot;, &quot;welcomeCar&quot;)


6、修改角色

    db.grantRolesToUser(
        &quot;sms&quot;,
        [
            { role: &quot;clusterMonitor&quot;, db:&quot;admin&quot;} 
        ]
    )
</code></pre><h4 id="conf配置文件"><a href="#conf配置文件" class="headerlink" title=".conf配置文件"></a>.conf配置文件</h4><pre><code>systemLog:
    destination: file
path: /usr/local/var/log/mongodb/mongo.log
    logAppend: true
storage:
    dbPath: /usr/local/var/mongodb
net:
    bindIp: 127.0.0.1
security:
    authorization:enabled      // 开启权限
</code></pre><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><h4 id="MongoDB导入、导出及数据库备份与恢复"><a href="#MongoDB导入、导出及数据库备份与恢复" class="headerlink" title="MongoDB导入、导出及数据库备份与恢复"></a>MongoDB导入、导出及数据库备份与恢复</h4><pre><code>1、mongoexport - 将 collection 导出成JSON或CSV格式

    mongoexport  -d 库名  -c collection名   -o 输出的文件名   --type 导出的格式json/csv  -f  输出的字段，如果type是CSV需要指定字段名

    Example: sudo mongoexport -d tun -c gt -o gentuanyou --type json


2、mongoimport - 将 collection 导入到

    mongoimport  -d 库名  -c colection名  --file 导入的文件名   --type 导入的格式  -f 导入的字段名  --headerline 如果导入是csv则可以使用第一行标题 


3、mongodump - 库备份

    mongodump  -h 服务器地址   -d 数据库名   -o 备份的位置

    Example: mongodump -h 127.0.0.1 -d tun -o /Users/apple/siguang.liu/mongoBackup


4、mongorestore - 数据库恢复

    mongorestore  -h 服务器地址  -d 需要恢复的数据库   --dir 备份数据的位置    [--drop 恢复先删除数据，然后恢复数据]

    mongorestore -h 127.0.0.1 -d tun --dir /Users/apple/siguang.liu/mongoBackup
</code></pre><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><pre><code>对MongoDB服务的运行情况和性能进行监控

1、mongostat、mongoStop      mongostat是mongdb自带的状态检测工具, 查看mongo运行状态的程序

    使用: 先到bin目录 cd /usr/local/Cellar/mongodb/3.4.3/bin                进行 mongostat目录 $ mongostat --help   来查看文档

            mongostat -h 127.0.0.1:123    -u用户名 -p密码        执行侦听

    日志: 

        http://www.cnmyColls.com/zhuque/archive/2013/03/29/2988577.html

        insert    插入数量
        query    查询数量
        update  更新数量
        delete     删除数量
        getmore 
        command 
        flushes    虚拟映射
        mapped     
        vsize   占磁盘的空间
        res     占内存大小
        idx miss 如果值过高，说明索引创建的有问题
        qrw     qr 读队列，qw 写队列 性能指标的一块，如果值比较高出现性能问题
        arw 
        net_in 
        net_out 
        conn    连接mongo的数量            
        time


2、profile 集合介绍

    db.getProfilingStatus();        // 获取


3、日志介绍

4、explain(): 

    db.users.find({id: 10000}).explain(&apos;executionStats&apos;)

        explain()三个参数：&apos;queryPlanner&apos;, &apos;executionStats&apos;, 和&apos;allPlansExecution&apos;

    result:
    {
        &quot;queryPlanner&quot; : {
            &quot;plannerVersion&quot; : 1,
            &quot;namespace&quot; : &quot;myCar.users&quot;,
            &quot;indexFilterSet&quot; : false,
            &quot;parsedQuery&quot; : {
                &quot;name&quot; : {
                    &quot;$eq&quot; : &quot;user99989&quot;
                }
            },
            &quot;winningPlan&quot; : {
                &quot;stage&quot; : &quot;COLLSCAN&quot;,
                &quot;filter&quot; : {
                    &quot;name&quot; : {
                        &quot;$eq&quot; : &quot;user99989&quot;
                    }
                },
                &quot;direction&quot; : &quot;forward&quot;
            },
            &quot;rejectedPlans&quot; : [ ]
        },
        &quot;executionStats&quot; : {
            &quot;executionSuccess&quot; : true,        // 是否成功
            &quot;nReturned&quot; : 1,                // 返回的数量
            &quot;executionTimeMillis&quot; : 49,        // *** 重要的执行时间   
            &quot;totalKeysExamined&quot; : 0,
            &quot;totalDocsExamined&quot; : 100000,    // 总共检查了多少个文档
            &quot;executionStages&quot; : {
                &quot;stage&quot; : &quot;COLLSCAN&quot;,
                &quot;filter&quot; : {
                    &quot;name&quot; : {
                        &quot;$eq&quot; : &quot;user99989&quot;
                    }
                },
                &quot;nReturned&quot; : 1,
                &quot;executionTimeMillisEstimate&quot; : 50,
                &quot;works&quot; : 100002,
                &quot;advanced&quot; : 1,
                &quot;needTime&quot; : 100000,
                &quot;needYield&quot; : 0,
                &quot;saveState&quot; : 783,
                &quot;restoreState&quot; : 783,
                &quot;isEOF&quot; : 1,
                &quot;invalidates&quot; : 0,
                &quot;direction&quot; : &quot;forward&quot;,
                &quot;docsExamined&quot; : 100000
            }
        },
        &quot;serverInfo&quot; : {
            &quot;host&quot; : &quot;appledeMacBook-Pro-2.local&quot;,
            &quot;port&quot; : 27017,
            &quot;version&quot; : &quot;3.4.3&quot;,
            &quot;gitVersion&quot; : &quot;f07437fb5a6cca07c10bafa78365456eb1d6d5e1&quot;
        },
        &quot;ok&quot; : 1
    }
</code></pre><h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><pre><code>Studio-3T、Robomongo
</code></pre><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><pre><code>1、使用mongoShell语句来通过_id查询更新时需要加ObjectId(&quot;&quot;), 如果程序处理不需要加

    db.col.update({_id: ObjectId(&quot;59acc404bef510c028190630&quot;)},{$set: {&apos;by&apos;: &apos;mongodb&apos;}})
</code></pre><h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><pre><code>1、首次安装 创建存放数据的目录时 $ sudo mkdir -p /data/db  如果这两个文件夹的权限是root那启动mongod就会报错，需要修改一下这两个目录的权限

    $ sudo chown apple:admin /data        // apple为我当前用户的名称

    $ sudo chown apple:admin /data/db

2、启动时如果提示 Failed to unlink socket file /tmp/mongodb-27017.sock errno:1 Operation not permitted

    因为/tmp/mongodb-27017.sock这个文件没有操作权限, 是root用户启动没成功后创建了这个文件
    需要到tmp目录下删除这个文件在重启

    $ cd /tmp &amp;&amp; sodu rm -rf mongodb-27017.sock
</code></pre><p>| 参考资料<br>|<br>| <a href="http://www.mongoing.com" target="_blank" rel="noopener">http://www.mongoing.com</a>            // 中文网站<br>| <a href="http://www.jianshu.com/p/dd0c39bf7be4" target="_blank" rel="noopener">http://www.jianshu.com/p/dd0c39bf7be4</a>                      // mongo安装<br>| <a href="http://www.runoob.com/mongodb/mongodb-objectid.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-objectid.html</a>      // 文档<br>| <a href="http://www.yiibai.com/mongodb/mongodb_drop_database.html" target="_blank" rel="noopener">http://www.yiibai.com/mongodb/mongodb_drop_database.html</a><br>| <a href="http://blog.csdn.net/jaylong35/article/details/7219410" target="_blank" rel="noopener">http://blog.csdn.net/jaylong35/article/details/7219410</a>  // 服务的开启与关闭<br>| <a href="http://blog.csdn.net/dbabruce/article/details/50963956" target="_blank" rel="noopener">http://blog.csdn.net/dbabruce/article/details/50963956</a>  // 用户权限<br>| <a href="http://www.cnblogs.com/qingtianyu2015/p/5968400.html" target="_blank" rel="noopener">http://www.cnblogs.com/qingtianyu2015/p/5968400.html</a>    // 库的导入、导出<br>| <a href="https://robomongo.org" target="_blank" rel="noopener">https://robomongo.org</a>     // mongoDB可视化工具<br>|<br>| <a href="http://blog.csdn.net/u013457382/article/category/6114612" target="_blank" rel="noopener">http://blog.csdn.net/u013457382/article/category/6114612</a><br>| <a href="http://www.cnblogs.com/zhongweiv/p/node_mongodb.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhongweiv/p/node_mongodb.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/06/nodeJS（之四）Strame/">nodeJS（之一）Stream</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/06/nodeJS（之四）Strame/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-06T02:43:21.000Z" itemprop="datePublished">2017-03-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createReadStream() - 创建可读流<br>| createWriteStream() - 创建可写流<br>| setEncodeing() - 设置编码<br>| </p>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><pre><code>Stream把较大的数据，拆分成小的部分

读取文件的两种: fs.readFile()和fs.createReadStream()

stream提供了以下四种类型的流：

    var Stream = require(&apos;stream&apos;);

    var Readable = Stream.Readable;
    var Writable = Stream.Writable;
    var Duplex = Stream.Duplex;
    var Transform = Stream.Transform;
</code></pre><h4 id="createReadStream-、createWriteStream"><a href="#createReadStream-、createWriteStream" class="headerlink" title="createReadStream()、createWriteStream()"></a>createReadStream()、createWriteStream()</h4><pre><code>// 创建一个Readable对象以读取bigFile内容
// 如果使用fs.readFile()可以会由于文件过大而失败
fs.createReadStream(bigFile);
</code></pre><h4 id="setEncodeing-设置编码"><a href="#setEncodeing-设置编码" class="headerlink" title="setEncodeing() 设置编码"></a>setEncodeing() 设置编码</h4><pre><code>var readerStream = fs.createReadStream(&apos;input.txt&apos;);

readerStream.setEncodeing(&apos;UTF8&apos;);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>可读数据流的事件

    readable 数据向外流时触发

    data 对于那些没有显式暂停的数据流，添加data事件监听函数，会将数据流切换到流动态，尽快向外提供数据

    end 读取完数据时触发。注意不能和 writeableStream.end() 混淆，writeableStream 并没有 end 事件，只有 .end() 方法

    close 数据源关闭时触发

    error 读取数据发生错误时触发


可写数据流的事件

    drain writable.write(chunk) 返回 false 之后，缓存全部写入完成，可以重新写入时就会触发

    finish 调用 .end 方法时，所有缓存的数据释放后触发，类似于可读数据流中的 end 事件，表示写入过程结束

    pipe 作为 pipe 目标时触发

    unpipe 作为 unpipe 目标时触发

    error 写入数据发生错误时触发
</code></pre><p>| <a href="https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8" target="_blank" rel="noopener">https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8</a><br>| <a href="http://fe.meituan.com/stream-basics.html" target="_blank" rel="noopener">http://fe.meituan.com/stream-basics.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/04/nodeJS（之三）Buffer/">nodeJS (之三) Buffer</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/04/nodeJS（之三）Buffer/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-04T10:30:21.000Z" itemprop="datePublished">2017-03-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| Buffer.from() - 创建buffer  // 老方法 new Buffer(str, encode);<br>| toString() - Buffer转字符串<br>| length - 返回Buffer的长度<br>| concat([buf1, buf2], 输出的长度) - 合并<br>| slice(start, end) - 截取<br>| copy(buffer, 开始目标位置, start, end) - 拷贝<br>| compare() - 比较两个buffer的大小<br>| fill() - 用指定的值填充Buffer<br>| indexOf(val) - 返回指定字符所在Buffer的位置<br>| lastIndexOf() - 从后向前查找<br>| includes(val, begin, uncode) - 查找是否存在<br>| keys() - 获取<br>| write() - 向指定的buffer写入内容<br>|<br>| Buffer.isBuffer(buf) - 是否是一个buffer<br>| Buffer.isEncoding(‘utf-8’) - 检测是否是一个有效的编码<br>| Buffer.byteLength - 判断字符的长度</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><pre><code>Buffer用于创建存放和处理二进制数据的缓存区，buffer是全局不需要require(&apos;buffer&apos;)

网络上发送和接收经常是以二进制传输数据:

    - 通过TCP连接发送和接收数据；
    - 从图像或者压缩文件读取二进制数据；
    - 从文件系统读写数据；
    - 处理来自网络的二进制数据流


1、字节byte: 1个字节等于8位二进制

       位bit: 每位存储0或1，每8位等于一个字节，最大0-255字节

       一个汉字三个字节，其它两个字节


2、Node.js 目前支持的字符编码包括: 

    &apos;ascii&apos; - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。

    &apos;utf8&apos; - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。

    &apos;utf16le&apos; - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。

    &apos;ucs2&apos; - &apos;utf16le&apos; 的别名。

    &apos;base64&apos; - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。

    &apos;latin1&apos; - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。

    &apos;binary&apos; - &apos;latin1&apos; 的别名。

    &apos;hex&apos; - 将每个字节编码为两个十六进制字符。
</code></pre><h4 id="new-Buffer"><a href="#new-Buffer" class="headerlink" title="new Buffer"></a>new Buffer</h4><pre><code>new Buffer(size): 创建一个Buffer对象, 并返回一个数组

Buffer创建的三种类型:

    1、new Buffer(2)            // 创建buffer的长度

        let buf = new Buffer(2);
        buf[1] = &apos;232&apos;;
        buf[2] = &apos;2312&apos;;
        buf[3] = &apos;asasdf&apos;;
        console.log(&apos;输出buffer: &apos;, buf);        // 输出buffer:  &lt;Buffer 00 e8&gt;  只能输出两个字节

    2、new Buffer(数组)            // new Buffer([1,3,5])

    3、new Buffer(字符串)        // new Buffer(&apos;我&apos;)
</code></pre><h4 id="字符串与buffer互转"><a href="#字符串与buffer互转" class="headerlink" title="字符串与buffer互转"></a>字符串与buffer互转</h4><pre><code>1、字符串转buffer

    let buf = new Buffer(&apos;sss&apos;)
    console.log(buf);            // &lt;Buffer 73 73 73&gt;


2、toString(编码, 获取开始位置 , 获取结束位置): buffer转换成字符串

    let buf = Buffer.from(&apos;sss&apos;);
    console.log(buf);            // Buffer e7 be 8e e5 a5 bd  输出的6个字符
    console.log(buf.length);    // 6 buffer的长度
    console.log(&apos;输出buffer: &apos;, buf.toString(&apos;utf-8&apos;, 3, 6));    // 输出好     
</code></pre><h4 id="length-获取长度"><a href="#length-获取长度" class="headerlink" title="length 获取长度"></a>length 获取长度</h4><pre><code>let buf = new Buffer(&apos;sssss&apos;);
console.log(buf.length);     // 5
</code></pre><h4 id="concat-要合并的数据集合-要输出的长度-合并"><a href="#concat-要合并的数据集合-要输出的长度-合并" class="headerlink" title="concat([ 要合并的数据集合 ], 要输出的长度):  合并"></a>concat([ 要合并的数据集合 ], 要输出的长度):  合并</h4><pre><code>let buf1 = new Buffer(&apos;忍&apos;);
let buf2 = new Buffer(&apos;者&apos;);
let buf3 = new Buffer(&apos;神&apos;);
let buf4 = new Buffer(&apos;龟&apos;);

let newBuf = Buffer.concat([buf1, buf2, buf3, buf4]);
console.log(newBuf);                // 12字节
console.log(newBuf.toString());     // 输出忍者神龟
</code></pre><h4 id="slice-start-end-截取"><a href="#slice-start-end-截取" class="headerlink" title="slice(start, end): 截取"></a>slice(start, end): 截取</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
console.log(buf.slice(9, 15).toString());        // 返回 截取
</code></pre><h4 id="copy-buffer-开始目标位置-start-end-拷贝"><a href="#copy-buffer-开始目标位置-start-end-拷贝" class="headerlink" title="copy(buffer, 开始目标位置, start, end): 拷贝"></a>copy(buffer, 开始目标位置, start, end): 拷贝</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
let copyBuf = new Buffer(9);
buf.copy(copyBuf, 6, 0, 9);     // 从buf的第六个字节开始,0到9字符copy

console.log(copyBuf.toString());        // 输出 来截取
</code></pre><h4 id="Buffer-byteLength-判断字符的长度"><a href="#Buffer-byteLength-判断字符的长度" class="headerlink" title="Buffer.byteLength:  判断字符的长度"></a>Buffer.byteLength:  判断字符的长度</h4><h4 id="toString-Buffer转字符串"><a href="#toString-Buffer转字符串" class="headerlink" title="toString() Buffer转字符串"></a>toString() Buffer转字符串</h4><pre><code>toString([字符编码], [开始转换位置], [结束转换位置])

let buf = new Buffer(&apos;哈哈哈&apos;);
console.log(buf.toString(&apos;utf8&apos;));        // urt8输出为 哈哈哈

可以转换成:  ascii、utf8、utf16le、ucs2、base64
</code></pre><h4 id="compare-比较buffer"><a href="#compare-比较buffer" class="headerlink" title="compare() 比较buffer"></a>compare() 比较buffer</h4><pre><code>返回比较结果: 0 两个buffer相等， -1 前者小于后者， 1 前者大于后者

const bufA = new Buffer(&apos;123345&apos;);
const bufB = new Buffer(&apos;123345aaaaa&apos;);
const result = bufA.compare(bufB);

switch(result){
    case -1: 
        console.log(`bufA 小于 bufB`);
        break;

    case 0: 
        console.log(`bufA 等于 bufB`);
        break;

    case 1: 
        console.log(`bufA 大于 bufB`);
        break;

    default: break;
}
</code></pre><h4 id="fill-用指定的值来填充Buffer"><a href="#fill-用指定的值来填充Buffer" class="headerlink" title="fill() 用指定的值来填充Buffer"></a>fill() 用指定的值来填充Buffer</h4><pre><code>fill(val,[offset], [end], [encode]): 用指定的值来填充Buffer

Example:
    let buf = new Buffer(5);    
    buf.fill(&apos;#&apos;);
    console.log(buf);
</code></pre><p>/<strong><strong><strong>**</strong></strong></strong> 查找与搜索  <strong><strong><strong>*</strong></strong></strong>/</p>
<h4 id="indexOf-返回指定字符所在Buffer的位置"><a href="#indexOf-返回指定字符所在Buffer的位置" class="headerlink" title="indexOf() 返回指定字符所在Buffer的位置"></a>indexOf() 返回指定字符所在Buffer的位置</h4><pre><code>let buf = new Buffer(&apos;aabbbccc&apos;);
console.log(buf.indexOf(&apos;b&apos;));      // 返回2 如果不存在返回-1
</code></pre><h4 id="lastIndexOf-从尾查找所在的位置"><a href="#lastIndexOf-从尾查找所在的位置" class="headerlink" title="lastIndexOf() 从尾查找所在的位置"></a>lastIndexOf() 从尾查找所在的位置</h4><h4 id="includes-val-返回指定字符是否存在"><a href="#includes-val-返回指定字符是否存在" class="headerlink" title="includes(val) 返回指定字符是否存在"></a>includes(val) 返回指定字符是否存在</h4><pre><code>includes(搜索的值, [buf开始搜索的位置], [搜索的编码])

Example:
    let buf = new Buffer(&apos;aaabbbcccddd&apos;);
    console.log(buf.includes(&apos;b&apos;, 2));     // true 或  false
</code></pre><h4 id="keys-把buffer中的数组下标"><a href="#keys-把buffer中的数组下标" class="headerlink" title="keys() 把buffer中的数组下标"></a>keys() 把buffer中的数组下标</h4><pre><code>const buf = new Buffer(&apos;buffer&apos;);
console.log(buf)

for(const key of buf.keys()){
    console.log(key);            // 0、1、2、3、4、5
}
</code></pre><h4 id="write-将值写入到buffer的指定位置"><a href="#write-将值写入到buffer的指定位置" class="headerlink" title="write() 将值写入到buffer的指定位置"></a>write() 将值写入到buffer的指定位置</h4><pre><code>write(string, [写入的位置], [写入的字节], [字符编码])
</code></pre><h4 id="Buffer-isBuffer-判断是否是Buffer"><a href="#Buffer-isBuffer-判断是否是Buffer" class="headerlink" title="Buffer.isBuffer() 判断是否是Buffer"></a>Buffer.isBuffer() 判断是否是Buffer</h4><pre><code>let str = &apos;&apos;;
let buf = new Buffer(10);
console.log(Buffer.isBuffer(str));      // false
console.log(Buffer.isBuffer(buf));      // true
</code></pre><h4 id="Buffer-isEncoding-endcode-判断编码"><a href="#Buffer-isEncoding-endcode-判断编码" class="headerlink" title="Buffer.isEncoding(endcode): 判断编码"></a>Buffer.isEncoding(endcode): 判断编码</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/03/nodeJS（之六）QueryString/">nodeJS（之六）Querystring</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/03/nodeJS（之六）QueryString/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-03T07:54:45.000Z" itemprop="datePublished">2017-03-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="parse-str-sep-eq-options-解析url的查询字符串"><a href="#parse-str-sep-eq-options-解析url的查询字符串" class="headerlink" title="parse(str, [sep], [eq], [options]) 解析url的查询字符串"></a>parse(str, [sep], [eq], [options]) 解析url的查询字符串</h4><pre><code>var param = &apos;user=siguang&amp;age=30&apos;;
qs.parse(param).user;    // &apos;siguang&apos;
</code></pre><h4 id="stringify-obj-sep-eq-将对象转成url的参数字符串"><a href="#stringify-obj-sep-eq-将对象转成url的参数字符串" class="headerlink" title="stringify(obj, [sep], [eq])  将对象转成url的参数字符串"></a>stringify(obj, [sep], [eq])  将对象转成url的参数字符串</h4><pre><code>const obj = {name: &apos;一介布衣&apos;, url: &apos;http://yijiebuyi.com&apos;};
const param = querystring.stringify(obj);
console.log(param);            // name=%E4%B8%80%E4%BB%8B%E5%B8%83%E8%A1%A3&amp;url=http%3A%2F%2Fyijiebuyi.com

qs.stringify({foo: &apos;bar&apos;, baz: &apos;qux&apos;}, &apos;;&apos;, &apos;:&apos;)
// 返回 &apos;foo:bar;baz:qux&apos;
</code></pre><h4 id="escape-str-字符进行编码"><a href="#escape-str-字符进行编码" class="headerlink" title="escape(str) 字符进行编码"></a>escape(str) 字符进行编码</h4><pre><code>let url = &apos;https://github.com/siguang1983&apos;;
console.log(qs.escape(url));        // https%3A%2F%2Fgithub.com%2Fsiguang1983
</code></pre><h4 id="unescape-str-字符进行解码"><a href="#unescape-str-字符进行解码" class="headerlink" title="unescape(str) 字符进行解码"></a>unescape(str) 字符进行解码</h4><pre><code>let code = &apos;https%3A%2F%2Fgithub.com%2Fsiguang1983&apos;;
console.log(qs.unescape(url));        // https://github.com/siguang1983
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/02/nodeJS（之七）URL/">nodeJS（之七）URL</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/02/nodeJS（之七）URL/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-02T10:05:25.000Z" itemprop="datePublished">2017-03-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| URL 用于URL的处理和解析<br>| const url = require(‘url’)    // 引用</p>
<h4 id="href-解析后的完整url"><a href="#href-解析后的完整url" class="headerlink" title="href 解析后的完整url"></a>href 解析后的完整url</h4><pre><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;
</code></pre><h4 id="protocol-返回协议-‘http’"><a href="#protocol-返回协议-‘http’" class="headerlink" title="protocol 返回协议 ‘http’"></a>protocol 返回协议 ‘http’</h4><h4 id="host-返回主机和端口"><a href="#host-返回主机和端口" class="headerlink" title="host 返回主机和端口"></a>host 返回主机和端口</h4><h4 id="auth-返回-URL-的用户名与密码部分"><a href="#auth-返回-URL-的用户名与密码部分" class="headerlink" title="auth 返回 URL 的用户名与密码部分"></a>auth 返回 URL 的用户名与密码部分</h4><h4 id="hostname-主机"><a href="#hostname-主机" class="headerlink" title="hostname 主机"></a>hostname 主机</h4><h4 id="port-端口"><a href="#port-端口" class="headerlink" title="port 端口"></a>port 端口</h4><h4 id="pathname-URL的整个路径部分"><a href="#pathname-URL的整个路径部分" class="headerlink" title="pathname URL的整个路径部分"></a>pathname URL的整个路径部分</h4><h4 id="search-获取url参数-‘-query-string’-包括-号"><a href="#search-获取url参数-‘-query-string’-包括-号" class="headerlink" title="search 获取url参数 ‘?query=string’  包括?号"></a>search 获取url参数 ‘?query=string’  包括?号</h4><h4 id="path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’"><a href="#path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’" class="headerlink" title="path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’"></a>path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’</h4><h4 id="query-返回参数对象返回-‘query-string’-or-‘query’-‘string’"><a href="#query-返回参数对象返回-‘query-string’-or-‘query’-‘string’" class="headerlink" title="query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}"></a>query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}</h4><h4 id="hash-返回hash部分-‘-’"><a href="#hash-返回hash部分-‘-’" class="headerlink" title="hash 返回hash部分 ‘#’"></a>hash 返回hash部分 ‘#’</h4><h4 id="url-format-urlObject-根据对象构建一个路径"><a href="#url-format-urlObject-根据对象构建一个路径" class="headerlink" title="url.format(urlObject) 根据对象构建一个路径"></a>url.format(urlObject) 根据对象构建一个路径</h4><pre><code>var obj = { 
    protocol: &apos;https&apos;,
    host: &apos;www.sss.com:4000&apos;,
    pathname: &apos;index&apos; 
}
url.format(obj)
//returns &apos;https://www.sss.com:4000/index&apos;
</code></pre><h4 id="parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符"><a href="#parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符" class="headerlink" title="parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符"></a>parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符</h4><pre><code>exports.createServer2 = function(){
    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url);
        console.log(&apos;路径&apos;, oUrl);               
    });

    server.listen(8081, &apos;localhost&apos;);
}

返回：
{
    protocol: null,            // 协议 http
    slashes: null,
    auth: null,                // 身份
    host: null,                // 主机    
    port: null,                // 端口
    hostname: null,            // 主机名
    hash: null,
    search: null,
    query: null,            // 查询参数或者使用querystring.parse() 返回{username:&apos;siguang&apos;};
    pathname: &apos;/apples/&apos;,    // 路径名
    path: &apos;/apples/&apos;,        // 路由
    href: &apos;/apples/&apos;         // 链接
}
</code></pre><h4 id="resolve-from-to-两个网址拼接"><a href="#resolve-from-to-两个网址拼接" class="headerlink" title="resolve(from, to) 两个网址拼接"></a>resolve(from, to) 两个网址拼接</h4><pre><code>url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;
</code></pre><h4 id="slashes"><a href="#slashes" class="headerlink" title="slashes"></a>slashes</h4>
        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
