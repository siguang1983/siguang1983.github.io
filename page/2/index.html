<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Labels</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/02/mongoose/">Mongoose</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/02/mongoose/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-02T11:15:23.000Z" itemprop="datePublished">2017-04-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/数据库/">数据库</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>Schema[ˈskimə] - 数据库存储格式的约定协议，可以理解为数据表的字段类型声明。

Model -  由Schema转化的数据模型，具有抽象属性和行为的数据库操作，可以进行查询操作

Entity [ˈɛntɪti] - 由Model创建的实体，可以对数据库表进行完整的CRUD操作
</code></pre><h4 id="Mongoose使用"><a href="#Mongoose使用" class="headerlink" title="Mongoose使用"></a>Mongoose使用</h4><pre><code>一、安装 

    $ npm install mongoose      

二、引用

    const mongoose = require(&apos;mongoose&apos;);

    // connect()创建一个数据库连接
    let db = mongoose.connect(&apos;mongodb://car:welcomeCar@localhost/myCar&apos;);          // mongodb://用户名:密码@数据库IP/库名

    db.on(&apos;error&apos;, console.error.bind(console, &apos;connection error:&apos;));   // 连接失败
    db.once(&apos;open&apos;, function (callback) {    
        // yay! 连接成功
    });

    // 定义Schema文档结构
    let Schema = mongoose.Schema;
    let carSchema = new Schema({
        id: Number,
        carName: String,
        carPrice: Nuber,
        date: {type: Date, default: Date.now}
    })

    // 定义Model模型
    let carMode = db.model(&apos;cars&apos;, carSchema);

    // 定义一个Entity
    let carEntity = new carMode({
        id: 1,
        carName: &apos;路虎&apos;,
        carPrice: 700000
    })

    // 存储
    carEntity.save(function(err){
        if(err){
            console.log(&apos;存储错误&apos;)
        }
    })

    // 查找
    carMode.find({carName: &apos;路虎&apos;}, function(err, doc){
        if(err){
            console.log(err)
        }
        else{
            console.log(doc);
        }
    })
</code></pre><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><pre><code>mongoose两种连接： connect连单个db并打开，createConnect连接多个db

一、mongoose.connect()方法连接

    写法1:
        connect(&apos;mongodb://[username]:[password]@host:port/database?options...&apos;);   // 用户名、密码、主机、端口、库名、参数

        let db = mongoose.connect(&apos;mongodb://[username]:[password]@127.0.0.1:27017/myDB&apos;);


    写法2:
        -- conect(uri, options) --

        var options = {
            db: { native_parser: true },
            server: { poolSize: 5 },
            replset: { rs_name: &apos;myReplicaSetName&apos; },
            user: &apos;myUserName&apos;,
            pass: &apos;myPassword&apos;
        }
        var uri = &apos;mongodb://localhost/dbName?poolSize=4&apos;;
        mongoose.connect(uri, options);


二、多个连接

    -- mongoose.createConnection() --

    let mongoose = require(&apos;mongoose&apos;);
    let db = mongoose.connect(&apos;mongodb://127.0.0.1:27017/myDB&apos;);        // mongodb://IP:端口号/数据库名

    // 侦听打开的回调
    db.connection.on(&apos;error&apos;, function(error){
        console.log(&apos;数据库连接失败&apos;+error);
    })

    // 侦听连接成功
    db.connection.on(&apos;open&apos;, function(){
        console.log(&apos;连接成功&apos;)
    })


三、两者的区别

    var mongoose = require(&apos;mongoose&apos;);
    db = mongoose.createConnection(&apos;localhost&apos;, &apos;test&apos;);
    var schema = new mongoose.Schema({ name: String });
    var collectionName = &apos;kittens&apos;;
    var M = db.model(&apos;Kitten&apos;, schema, collectionName);

    var mongoose = require(&apos;mongoose&apos;);
    mongoose.connect(&apos;mongodb://localhost/test&apos;);
    db = mongoose.connection;
    db.once(&apos;open&apos;, function callback () {
        // yay!
    });    

    createConnection，可以open，但完全不会查询。第二种方法就可以
</code></pre><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><pre><code>Schema: 一种文件形式存储数据库模型的骨架，无法直接连接数据端，不具备操作数据库的能力，叫数据属性模型或集合

let personSchema = new mongoose.Schema({
    name: String,
    age: Number,
    email: String
})

二、实例方法

三、静态方法

四、indexes 索引

创建规则

    let Schema = mongoose.Schema;
    let carSchema = new Schema({
        name: String,
        title: { type: String, index: true },   // index 索引
        uid: { type: Number, unique: true },    // unique 独一无二的
        date: { type: Date, default: Date.now } // default 默认值
    })

    // 文档索引和字段索引
    let carSchema = new Schema({
        name: String,
        title: { type: [String], index: true },   // 字段索引
    })

    carSchema.index({ name: 1, type: -1});  // 
</code></pre><h4 id="Schema-Type"><a href="#Schema-Type" class="headerlink" title="Schema Type"></a>Schema Type</h4><pre><code>一、类型

    String：字符串
    Number：数值
    Date：日期
    Buffer： 二进制
    Boolean：布尔
    Mixed： 混合
    ObjectId： ObjectId
    Array：数组

二、其它参数

    default: 默认         // updated: { type: Date, default: Date.now }

    min/max: 最小或最大    // age: { type: Number, min: 18, max: 65 }

    trim: 去掉两端空格

    unique: true 指定字段为独一无二

三、Example

    var schema = new Schema({
        name:    String,
        binary:  Buffer,
        living:  Boolean,
        updated: { type: Date, default: Date.now }
        age:     { type: Number, min: 18, max: 65 }
        mixed:   Schema.Types.Mixed,
        _someId: Schema.Types.ObjectId,
        array:      [],
        ofString:   [String],
        ofNumber:   [Number],
        ofDates:    [Date],
        ofBuffer:   [Buffer],
        ofBoolean:  [Boolean],
        ofMixed:    [Schema.Types.Mixed],
        ofObjectId: [Schema.Types.ObjectId],
        nested: {
            stuff: { type: String, lowercase: true, trim: true }
        }
    })
</code></pre><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><pre><code>具有操作数据库的能力，类似管理数据库的属性和行的类

创建model  mongoose.model(&apos;集合名&apos;, schema);

    let personScheam = new Scheam({
        name: &apos;String&apos;,
        password: &apos;String&apos;
    }, {
        timestamps: true,             // 设置timestamps，多加两个字段createdTime、updatedTime，来记录插入时间和更新时间
        collection: &apos;report_warning_config&apos;,
    })

    let personModel = mongoose.model(&apos;person&apos;, personSchema);
</code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>一、find, findById, findOne, or where 

    let TankScheam = new Scheam({
        name: &apos;String&apos;,
        password: &apos;String&apos;
    })

    let Tank = mongoose.model(&apos;Tank&apos;, personSchema);

    Tank.find({size: &apos;samll&apos;}).where(&apos;createDate&apos;).gt(oneYear).exec(callback);

二、条件查询中常用属性

    $or　　　　或关系
    $nor　　　　或关系取反
    $gt　　　　大于
    $gte　　　　大于等于
    $lt　　　　小于
    $lte　　　　小于等于
    $ne　　　　不等于
    $in　　　　在多个值范围内
    $nin　　　　不在多个值范围内
    $all　　　　匹配数组中多个值
    $regex　　　　正则，用于模糊查询
    $size　　　　匹配数组大小
    $maxDistance　　　　范围查询，距离（基于LBS）
    $mod　　　　取模运算
    $near　　　　邻域查询，查询附近的位置（基于LBS）
    $exists　　　　字段是否存在
    $elemMatch　　　　匹配内数组内的元素
    $within　　　　范围查询（基于LBS）
    $box　　　　范围查询，矩形范围（基于LBS）
    $center　　　　范围醒询，圆形范围（基于LBS）
    $centerSphere　　　　范围查询，球形范围（基于LBS）
    $slice　　　　查询字段集合中的元素（比如从第几个之后，第N到第M个元素


三、方法

    1、where(&apos;price&apos;) - 查询的字段  Tank.find().where(&apos;price&apos;)

    2、find() - 查询所有，返回的是数组

    3、findOne({name: &apos;siguang&apos;}) - 只把第一条name为siguang的数据，如果find会将所有都返回

    4、findById(id) - 根据一条id来查找，返回的是一条记录的对象，而不是一个数组，与find({_id: &apos;59bf7ee03f55167fb6cdd75c&apos;})相同

    5、findByIdAndRemove(id) - 根据id查找，并删除这个条数据，如果查找不到返回 null

    6、findByIdAndUpdate(id, update) - 

    7、lean() - Tank.find().lean()      // 默认参数为true, 可以设置 lean(false)
</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>Tank.remove({size: &apos;large&apos;})

// 查找并删除
Tank.findByAndRemove()
</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><pre><code>Tank.update({_id: id}, {$set: {size: &apos;large&apos;}, callback);

// 查找并更新
Tank.findByIdAndUpdate(id, [update]);
</code></pre><h4 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h4><h4 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h4><pre><code>insert和update都需要save(),
</code></pre><h4 id="egg-mongose"><a href="#egg-mongose" class="headerlink" title="egg-mongose"></a>egg-mongose</h4><pre><code>1、在model中创建模型

    module.exports = app =&gt; {
        const mongoose = app.mongoose;

        const NewsSchema = new mongoose.Schema({
            newsTitle: {type: String, max: 32},
            newsContent: {type: String},
        },{
            timestamps: true,               // 插入记录时会自动创建一个createAt和updateAt时间字段
            collection: &apos;news&apos;,             // mongo中存的collection名
        });

        return mongoose.model(&apos;News&apos;, NewsSchema);      // News调用时的名
    }


2、在service中调用

    let doc = await app.model.News.find();

3、创建和查询

    const doc = await new app.model.User(user).save();          // 创建时需要new 

    const user = await app.model.User.findOne({_id: user._id});     // 查询时不需要new


4、使用find()查询 使用. ()

    如果使用find().lean()返回的是纯javascript对象，而不是mongoose文档，他们没有保存方法

    Example:

    const resourceTree = await app.model.Resource.find({});

        返回
        { _id: 5a535142fe6d170e82135e89,
            displayName: &apos;欢欢&apos;,
            username: &apos;huanhuan&apos;,
            mobile: 13012309874,
            email: &apos;huan@126.com&apos; 
        },
        { _id: 5a5357d2bd53b40f791362aa,
            username: &apos;maolv&apos;,
            displayName: &apos;毛驴&apos;,
            mobile: 13290984585,
            email: &apos;maolv@126.com&apos; 
        }

    const resourceTree = await app.model.Resource.find({}).lean();

        返回
        [
            { _id: 5a535142fe6d170e82135e89,
                displayName: &apos;欢欢&apos;,
                username: &apos;huanhuan&apos;,
                mobile: 13012309874,
                email: &apos;huan@126.com&apos; 
            },
            { _id: 5a5357d2bd53b40f791362aa,
                username: &apos;maolv&apos;,
                displayName: &apos;毛驴&apos;,
                mobile: 13290984585,
                email: &apos;maolv@126.com&apos; 
            }
        ]
</code></pre><blockquote>
<p><a href="http://www.nodeclass.com/api/mongoose.html" target="_blank" rel="noopener">http://www.nodeclass.com/api/mongoose.html</a><br><a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a>         egg-mongoose<br><a href="http://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="noopener">http://cnodejs.org/topic/504b4924e2b84515770103dd</a><br><a href="http://www.cnblogs.com/xuange306/p/4603551.html" target="_blank" rel="noopener">http://www.cnblogs.com/xuange306/p/4603551.html</a><br><a href="http://www.cnblogs.com/winyh/p/6682039.html" target="_blank" rel="noopener">http://www.cnblogs.com/winyh/p/6682039.html</a><br><a href="http://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="noopener">http://cnodejs.org/topic/504b4924e2b84515770103dd</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/06/nodeJS（之四）Strame/">nodeJS（之一）Stream</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/06/nodeJS（之四）Strame/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-06T02:43:21.000Z" itemprop="datePublished">2017-03-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createReadStream() - 创建可读流<br>| createWriteStream() - 创建可写流<br>| setEncodeing() - 设置编码<br>| </p>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><pre><code>Stream把较大的数据，拆分成小的部分

读取文件的两种: fs.readFile()和fs.createReadStream()

stream提供了以下四种类型的流：

    var Stream = require(&apos;stream&apos;);

    var Readable = Stream.Readable;
    var Writable = Stream.Writable;
    var Duplex = Stream.Duplex;
    var Transform = Stream.Transform;
</code></pre><h4 id="createReadStream-、createWriteStream"><a href="#createReadStream-、createWriteStream" class="headerlink" title="createReadStream()、createWriteStream()"></a>createReadStream()、createWriteStream()</h4><pre><code>// 创建一个Readable对象以读取bigFile内容
// 如果使用fs.readFile()可以会由于文件过大而失败
fs.createReadStream(bigFile);
</code></pre><h4 id="setEncodeing-设置编码"><a href="#setEncodeing-设置编码" class="headerlink" title="setEncodeing() 设置编码"></a>setEncodeing() 设置编码</h4><pre><code>var readerStream = fs.createReadStream(&apos;input.txt&apos;);

readerStream.setEncodeing(&apos;UTF8&apos;);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>可读数据流的事件

    readable 数据向外流时触发

    data 对于那些没有显式暂停的数据流，添加data事件监听函数，会将数据流切换到流动态，尽快向外提供数据

    end 读取完数据时触发。注意不能和 writeableStream.end() 混淆，writeableStream 并没有 end 事件，只有 .end() 方法

    close 数据源关闭时触发

    error 读取数据发生错误时触发


可写数据流的事件

    drain writable.write(chunk) 返回 false 之后，缓存全部写入完成，可以重新写入时就会触发

    finish 调用 .end 方法时，所有缓存的数据释放后触发，类似于可读数据流中的 end 事件，表示写入过程结束

    pipe 作为 pipe 目标时触发

    unpipe 作为 unpipe 目标时触发

    error 写入数据发生错误时触发
</code></pre><p>| <a href="https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8" target="_blank" rel="noopener">https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8</a><br>| <a href="http://fe.meituan.com/stream-basics.html" target="_blank" rel="noopener">http://fe.meituan.com/stream-basics.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/04/nodeJS（之三）Buffer/">nodeJS (之三) Buffer</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/04/nodeJS（之三）Buffer/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-04T10:30:21.000Z" itemprop="datePublished">2017-03-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| Buffer.from() - 创建buffer  // 老方法 new Buffer(str, encode);<br>| toString() - Buffer转字符串<br>| length - 返回Buffer的长度<br>| concat([buf1, buf2], 输出的长度) - 合并<br>| slice(start, end) - 截取<br>| copy(buffer, 开始目标位置, start, end) - 拷贝<br>| compare() - 比较两个buffer的大小<br>| fill() - 用指定的值填充Buffer<br>| indexOf(val) - 返回指定字符所在Buffer的位置<br>| lastIndexOf() - 从后向前查找<br>| includes(val, begin, uncode) - 查找是否存在<br>| keys() - 获取<br>| write() - 向指定的buffer写入内容<br>|<br>| Buffer.isBuffer(buf) - 是否是一个buffer<br>| Buffer.isEncoding(‘utf-8’) - 检测是否是一个有效的编码<br>| Buffer.byteLength - 判断字符的长度</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><pre><code>Buffer用于创建存放和处理二进制数据的缓存区，buffer是全局不需要require(&apos;buffer&apos;)

网络上发送和接收经常是以二进制传输数据:

    - 通过TCP连接发送和接收数据；
    - 从图像或者压缩文件读取二进制数据；
    - 从文件系统读写数据；
    - 处理来自网络的二进制数据流


1、字节byte: 1个字节等于8位二进制

       位bit: 每位存储0或1，每8位等于一个字节，最大0-255字节

       一个汉字三个字节，其它两个字节


2、Node.js 目前支持的字符编码包括: 

    &apos;ascii&apos; - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。

    &apos;utf8&apos; - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。

    &apos;utf16le&apos; - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。

    &apos;ucs2&apos; - &apos;utf16le&apos; 的别名。

    &apos;base64&apos; - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。

    &apos;latin1&apos; - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。

    &apos;binary&apos; - &apos;latin1&apos; 的别名。

    &apos;hex&apos; - 将每个字节编码为两个十六进制字符。
</code></pre><h4 id="new-Buffer"><a href="#new-Buffer" class="headerlink" title="new Buffer"></a>new Buffer</h4><pre><code>new Buffer(size): 创建一个Buffer对象, 并返回一个数组

Buffer创建的三种类型:

    1、new Buffer(2)            // 创建buffer的长度

        let buf = new Buffer(2);
        buf[1] = &apos;232&apos;;
        buf[2] = &apos;2312&apos;;
        buf[3] = &apos;asasdf&apos;;
        console.log(&apos;输出buffer: &apos;, buf);        // 输出buffer:  &lt;Buffer 00 e8&gt;  只能输出两个字节

    2、new Buffer(数组)            // new Buffer([1,3,5])

    3、new Buffer(字符串)        // new Buffer(&apos;我&apos;)
</code></pre><h4 id="字符串与buffer互转"><a href="#字符串与buffer互转" class="headerlink" title="字符串与buffer互转"></a>字符串与buffer互转</h4><pre><code>1、字符串转buffer

    let buf = new Buffer(&apos;sss&apos;)
    console.log(buf);            // &lt;Buffer 73 73 73&gt;


2、toString(编码, 获取开始位置 , 获取结束位置): buffer转换成字符串

    let buf = Buffer.from(&apos;sss&apos;);
    console.log(buf);            // Buffer e7 be 8e e5 a5 bd  输出的6个字符
    console.log(buf.length);    // 6 buffer的长度
    console.log(&apos;输出buffer: &apos;, buf.toString(&apos;utf-8&apos;, 3, 6));    // 输出好     
</code></pre><h4 id="length-获取长度"><a href="#length-获取长度" class="headerlink" title="length 获取长度"></a>length 获取长度</h4><pre><code>let buf = new Buffer(&apos;sssss&apos;);
console.log(buf.length);     // 5
</code></pre><h4 id="concat-要合并的数据集合-要输出的长度-合并"><a href="#concat-要合并的数据集合-要输出的长度-合并" class="headerlink" title="concat([ 要合并的数据集合 ], 要输出的长度):  合并"></a>concat([ 要合并的数据集合 ], 要输出的长度):  合并</h4><pre><code>let buf1 = new Buffer(&apos;忍&apos;);
let buf2 = new Buffer(&apos;者&apos;);
let buf3 = new Buffer(&apos;神&apos;);
let buf4 = new Buffer(&apos;龟&apos;);

let newBuf = Buffer.concat([buf1, buf2, buf3, buf4]);
console.log(newBuf);                // 12字节
console.log(newBuf.toString());     // 输出忍者神龟
</code></pre><h4 id="slice-start-end-截取"><a href="#slice-start-end-截取" class="headerlink" title="slice(start, end): 截取"></a>slice(start, end): 截取</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
console.log(buf.slice(9, 15).toString());        // 返回 截取
</code></pre><h4 id="copy-buffer-开始目标位置-start-end-拷贝"><a href="#copy-buffer-开始目标位置-start-end-拷贝" class="headerlink" title="copy(buffer, 开始目标位置, start, end): 拷贝"></a>copy(buffer, 开始目标位置, start, end): 拷贝</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
let copyBuf = new Buffer(9);
buf.copy(copyBuf, 6, 0, 9);     // 从buf的第六个字节开始,0到9字符copy

console.log(copyBuf.toString());        // 输出 来截取
</code></pre><h4 id="Buffer-byteLength-判断字符的长度"><a href="#Buffer-byteLength-判断字符的长度" class="headerlink" title="Buffer.byteLength:  判断字符的长度"></a>Buffer.byteLength:  判断字符的长度</h4><h4 id="toString-Buffer转字符串"><a href="#toString-Buffer转字符串" class="headerlink" title="toString() Buffer转字符串"></a>toString() Buffer转字符串</h4><pre><code>toString([字符编码], [开始转换位置], [结束转换位置])

let buf = new Buffer(&apos;哈哈哈&apos;);
console.log(buf.toString(&apos;utf8&apos;));        // urt8输出为 哈哈哈

可以转换成:  ascii、utf8、utf16le、ucs2、base64
</code></pre><h4 id="compare-比较buffer"><a href="#compare-比较buffer" class="headerlink" title="compare() 比较buffer"></a>compare() 比较buffer</h4><pre><code>返回比较结果: 0 两个buffer相等， -1 前者小于后者， 1 前者大于后者

const bufA = new Buffer(&apos;123345&apos;);
const bufB = new Buffer(&apos;123345aaaaa&apos;);
const result = bufA.compare(bufB);

switch(result){
    case -1: 
        console.log(`bufA 小于 bufB`);
        break;

    case 0: 
        console.log(`bufA 等于 bufB`);
        break;

    case 1: 
        console.log(`bufA 大于 bufB`);
        break;

    default: break;
}
</code></pre><h4 id="fill-用指定的值来填充Buffer"><a href="#fill-用指定的值来填充Buffer" class="headerlink" title="fill() 用指定的值来填充Buffer"></a>fill() 用指定的值来填充Buffer</h4><pre><code>fill(val,[offset], [end], [encode]): 用指定的值来填充Buffer

Example:
    let buf = new Buffer(5);    
    buf.fill(&apos;#&apos;);
    console.log(buf);
</code></pre><p>/<strong><strong><strong>**</strong></strong></strong> 查找与搜索  <strong><strong><strong>*</strong></strong></strong>/</p>
<h4 id="indexOf-返回指定字符所在Buffer的位置"><a href="#indexOf-返回指定字符所在Buffer的位置" class="headerlink" title="indexOf() 返回指定字符所在Buffer的位置"></a>indexOf() 返回指定字符所在Buffer的位置</h4><pre><code>let buf = new Buffer(&apos;aabbbccc&apos;);
console.log(buf.indexOf(&apos;b&apos;));      // 返回2 如果不存在返回-1
</code></pre><h4 id="lastIndexOf-从尾查找所在的位置"><a href="#lastIndexOf-从尾查找所在的位置" class="headerlink" title="lastIndexOf() 从尾查找所在的位置"></a>lastIndexOf() 从尾查找所在的位置</h4><h4 id="includes-val-返回指定字符是否存在"><a href="#includes-val-返回指定字符是否存在" class="headerlink" title="includes(val) 返回指定字符是否存在"></a>includes(val) 返回指定字符是否存在</h4><pre><code>includes(搜索的值, [buf开始搜索的位置], [搜索的编码])

Example:
    let buf = new Buffer(&apos;aaabbbcccddd&apos;);
    console.log(buf.includes(&apos;b&apos;, 2));     // true 或  false
</code></pre><h4 id="keys-把buffer中的数组下标"><a href="#keys-把buffer中的数组下标" class="headerlink" title="keys() 把buffer中的数组下标"></a>keys() 把buffer中的数组下标</h4><pre><code>const buf = new Buffer(&apos;buffer&apos;);
console.log(buf)

for(const key of buf.keys()){
    console.log(key);            // 0、1、2、3、4、5
}
</code></pre><h4 id="write-将值写入到buffer的指定位置"><a href="#write-将值写入到buffer的指定位置" class="headerlink" title="write() 将值写入到buffer的指定位置"></a>write() 将值写入到buffer的指定位置</h4><pre><code>write(string, [写入的位置], [写入的字节], [字符编码])
</code></pre><h4 id="Buffer-isBuffer-判断是否是Buffer"><a href="#Buffer-isBuffer-判断是否是Buffer" class="headerlink" title="Buffer.isBuffer() 判断是否是Buffer"></a>Buffer.isBuffer() 判断是否是Buffer</h4><pre><code>let str = &apos;&apos;;
let buf = new Buffer(10);
console.log(Buffer.isBuffer(str));      // false
console.log(Buffer.isBuffer(buf));      // true
</code></pre><h4 id="Buffer-isEncoding-endcode-判断编码"><a href="#Buffer-isEncoding-endcode-判断编码" class="headerlink" title="Buffer.isEncoding(endcode): 判断编码"></a>Buffer.isEncoding(endcode): 判断编码</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/03/nodeJS（之六）QueryString/">nodeJS（之六）Querystring</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/03/nodeJS（之六）QueryString/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-03T07:54:45.000Z" itemprop="datePublished">2017-03-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="parse-str-sep-eq-options-解析url的查询字符串"><a href="#parse-str-sep-eq-options-解析url的查询字符串" class="headerlink" title="parse(str, [sep], [eq], [options]) 解析url的查询字符串"></a>parse(str, [sep], [eq], [options]) 解析url的查询字符串</h4><pre><code>var param = &apos;user=siguang&amp;age=30&apos;;
qs.parse(param).user;    // &apos;siguang&apos;
</code></pre><h4 id="stringify-obj-sep-eq-将对象转成url的参数字符串"><a href="#stringify-obj-sep-eq-将对象转成url的参数字符串" class="headerlink" title="stringify(obj, [sep], [eq])  将对象转成url的参数字符串"></a>stringify(obj, [sep], [eq])  将对象转成url的参数字符串</h4><pre><code>const obj = {name: &apos;一介布衣&apos;, url: &apos;http://yijiebuyi.com&apos;};
const param = querystring.stringify(obj);
console.log(param);            // name=%E4%B8%80%E4%BB%8B%E5%B8%83%E8%A1%A3&amp;url=http%3A%2F%2Fyijiebuyi.com

qs.stringify({foo: &apos;bar&apos;, baz: &apos;qux&apos;}, &apos;;&apos;, &apos;:&apos;)
// 返回 &apos;foo:bar;baz:qux&apos;
</code></pre><h4 id="escape-str-字符进行编码"><a href="#escape-str-字符进行编码" class="headerlink" title="escape(str) 字符进行编码"></a>escape(str) 字符进行编码</h4><pre><code>let url = &apos;https://github.com/siguang1983&apos;;
console.log(qs.escape(url));        // https%3A%2F%2Fgithub.com%2Fsiguang1983
</code></pre><h4 id="unescape-str-字符进行解码"><a href="#unescape-str-字符进行解码" class="headerlink" title="unescape(str) 字符进行解码"></a>unescape(str) 字符进行解码</h4><pre><code>let code = &apos;https%3A%2F%2Fgithub.com%2Fsiguang1983&apos;;
console.log(qs.unescape(url));        // https://github.com/siguang1983
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/02/nodeJS（之七）URL/">nodeJS（之七）URL</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/02/nodeJS（之七）URL/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-02T10:05:25.000Z" itemprop="datePublished">2017-03-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| URL 用于URL的处理和解析<br>| const url = require(‘url’)    // 引用</p>
<h4 id="href-解析后的完整url"><a href="#href-解析后的完整url" class="headerlink" title="href 解析后的完整url"></a>href 解析后的完整url</h4><pre><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;
</code></pre><h4 id="protocol-返回协议-‘http’"><a href="#protocol-返回协议-‘http’" class="headerlink" title="protocol 返回协议 ‘http’"></a>protocol 返回协议 ‘http’</h4><h4 id="host-返回主机和端口"><a href="#host-返回主机和端口" class="headerlink" title="host 返回主机和端口"></a>host 返回主机和端口</h4><h4 id="auth-返回-URL-的用户名与密码部分"><a href="#auth-返回-URL-的用户名与密码部分" class="headerlink" title="auth 返回 URL 的用户名与密码部分"></a>auth 返回 URL 的用户名与密码部分</h4><h4 id="hostname-主机"><a href="#hostname-主机" class="headerlink" title="hostname 主机"></a>hostname 主机</h4><h4 id="port-端口"><a href="#port-端口" class="headerlink" title="port 端口"></a>port 端口</h4><h4 id="pathname-URL的整个路径部分"><a href="#pathname-URL的整个路径部分" class="headerlink" title="pathname URL的整个路径部分"></a>pathname URL的整个路径部分</h4><h4 id="search-获取url参数-‘-query-string’-包括-号"><a href="#search-获取url参数-‘-query-string’-包括-号" class="headerlink" title="search 获取url参数 ‘?query=string’  包括?号"></a>search 获取url参数 ‘?query=string’  包括?号</h4><h4 id="path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’"><a href="#path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’" class="headerlink" title="path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’"></a>path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’</h4><h4 id="query-返回参数对象返回-‘query-string’-or-‘query’-‘string’"><a href="#query-返回参数对象返回-‘query-string’-or-‘query’-‘string’" class="headerlink" title="query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}"></a>query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}</h4><h4 id="hash-返回hash部分-‘-’"><a href="#hash-返回hash部分-‘-’" class="headerlink" title="hash 返回hash部分 ‘#’"></a>hash 返回hash部分 ‘#’</h4><h4 id="url-format-urlObject-根据对象构建一个路径"><a href="#url-format-urlObject-根据对象构建一个路径" class="headerlink" title="url.format(urlObject) 根据对象构建一个路径"></a>url.format(urlObject) 根据对象构建一个路径</h4><pre><code>var obj = { 
    protocol: &apos;https&apos;,
    host: &apos;www.sss.com:4000&apos;,
    pathname: &apos;index&apos; 
}
url.format(obj)
//returns &apos;https://www.sss.com:4000/index&apos;
</code></pre><h4 id="parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符"><a href="#parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符" class="headerlink" title="parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符"></a>parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符</h4><pre><code>exports.createServer2 = function(){
    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url);
        console.log(&apos;路径&apos;, oUrl);               
    });

    server.listen(8081, &apos;localhost&apos;);
}

返回：
{
    protocol: null,            // 协议 http
    slashes: null,
    auth: null,                // 身份
    host: null,                // 主机    
    port: null,                // 端口
    hostname: null,            // 主机名
    hash: null,
    search: null,
    query: null,            // 查询参数或者使用querystring.parse() 返回{username:&apos;siguang&apos;};
    pathname: &apos;/apples/&apos;,    // 路径名
    path: &apos;/apples/&apos;,        // 路由
    href: &apos;/apples/&apos;         // 链接
}
</code></pre><h4 id="resolve-from-to-两个网址拼接"><a href="#resolve-from-to-两个网址拼接" class="headerlink" title="resolve(from, to) 两个网址拼接"></a>resolve(from, to) 两个网址拼接</h4><pre><code>url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;
</code></pre><h4 id="slashes"><a href="#slashes" class="headerlink" title="slashes"></a>slashes</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之八）HTTP/">nodeJS（之八）HTTP</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之八）HTTP/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h4><pre><code>let http = require(&apos;http&apos;);        // 导入http模块

HTTP协议构建就是在请求和响应上，由http.ServerRequest和http.ServerResponse构造出来的。
</code></pre><h4 id="http-server类"><a href="#http-server类" class="headerlink" title="http.server类"></a>http.server类</h4><pre><code>是一个创建服务的类 ServerRequest()

方法:

    1、close([callback]): 停止服务器连接

    2、listen(path, [callback]): 侦听, 与TCP使用方法相同

属性:

    1、listening: 返回是否在监听连接服务器的布尔值

    2、maxHeadersCount: 限制最大的请求头数据，默认2000

    3、keepAliveTimeout

    3、setTimeout(msecs, callback): 为socket设置超时值，如果一个超时发生

事件

    1、connect - 请求时触发


Example:

    const HOST = &apos;127.0.0.1&apos;;
    const PORT = 3000;

    // 创建服务器
    let server = http.createServer((req, res) =&gt; {
        console.log(&apos;请求方法:&apos;, request.method);       // 请求方法
        console.log(&apos;请求url:&apos;, request.url);          // 请求url
        console.log(&apos;请求头:&apos;, request.headers);       // 请求头

        res.writeHead(200);
        res.end(&apos;hello world&apos;);    
    })            

    // 侦听3000端口
    server.listen(PORT, HOST, ()=&gt; {
        console.log(`server running at http://${hostname}:${port}`);
    })
</code></pre><h4 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h4><pre><code>url - 返回url地址

method - 返回请求方法
</code></pre><h4 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h4><pre><code>// 这里res返回的就是ServerResponse类
const server = http.createServer((req, res) =&gt; { ..... });   

方法:

    1、addTrailers(headers)

    2、end([data],[encoding],[callback]) - 告诉服务器所有响应头和主体都已被发送，等同于response.write()

    3、finished: 

    4、getHeader(name): 

    5、headersSent: 返回消息头是否被发送，发送为true否则false

    6、removeHeader(name): 移出一个头消息 response.removeHeader(&apos;Content-Encoding&apos;);

    7、sendDate: 如果设置为true消息头存在日期消息头则自动生成并且响应在发送

    8、setHeader(name, value): 设置头信息

        response.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);
        response.setHeader(&apos;Set-Cookie&apos;, [&apos;type=ninja&apos;, &apos;language=javascript&apos;]);

    9、setTimeout(msecs, callback): 设置 socket 的超时时间

    10、statusCode: 设置向客户端响应的状态码  res.statusCode = 200;

    11、statusMessage

    12、write(chunk[, encoding][, callback])

    13、writeContinue()

    14、writeHead(statusCode[, statusMessage][, headers]): 发送一个响应头给请求

        writeHead(状态码, [状态消息], {响应头信息})

        Example: res.writeHead(200, { content-Type: &apos;text/html&apos;, Connection: &apos;keep-alive&apos;})

    15、setEncoding(编码): 设置编码格式 res.setEncoding(&apos;utf8&apos;);


res.connection

事件:

    1、close - 关闭连接，会自动调用response.end();

    2、finish - 当响应已被发送时触发
</code></pre><h4 id="http-IncomingMessage-类"><a href="#http-IncomingMessage-类" class="headerlink" title="http.IncomingMessage 类"></a>http.IncomingMessage 类</h4><pre><code>const server = http.createServer((req, res) =&gt; { ..... });  就是req返回的类

1、headers: 客户端的请求头

2、method: 获取请求方式

3、url: 请求url

4、statusCode: 状态码

5、statusMessage: 状态消息

6、socket: 与连接有关的 net.Socket 对象。

7、destroy([error])

8、httpVersion: http的版本

9、rawHeaders

10、rawTrailers

11、setTimeout(msecs, callback)

12、trailers
</code></pre><h4 id="http-createServer-创建server服务"><a href="#http-createServer-创建server服务" class="headerlink" title="http.createServer(): 创建server服务"></a>http.createServer(): 创建server服务</h4><h4 id="http-get-options-callback-用来模拟客户端向服务器发送请求"><a href="#http-get-options-callback-用来模拟客户端向服务器发送请求" class="headerlink" title="http.get(options, [callback]): 用来模拟客户端向服务器发送请求"></a>http.get(options, [callback]): 用来模拟客户端向服务器发送请求</h4><pre><code>Example： 请求nodejs.org的index.json文件，返回json的内容

const http = require(&apos;http&apos;);

http.get(&apos;http://nodejs.org/dist/index.json&apos;, (res) =&gt; {
    const statusCode = res.statusCode;
    const contentType = res.headers[&apos;content-type&apos;];

    let error;
    if (statusCode !== 200) {
        error = new Error(`请求失败。\n` +
            `状态码: ${statusCode}`);
    } else if (!/^application\/json/.test(contentType)) {
        error = new Error(`无效的 content-type.\n` +
            `期望 application/json 但获取的是 ${contentType}`);
    }
    if (error) {
        console.log(error.message);
        // 消耗响应数据以释放内存
        res.resume();
        return;
    }

    res.setEncoding(&apos;utf8&apos;);
    let rawData = &apos;&apos;;
    res.on(&apos;data&apos;, (chunk) =&gt; rawData += chunk);
    res.on(&apos;end&apos;, () =&gt; {
        try {
            let parsedData = JSON.parse(rawData);
            console.log(parsedData);
        } catch (e) {
            console.log(e.message);
        }
    });
}).on(&apos;error&apos;, (e) =&gt; {
    console.log(`错误: ${e.message}`);
});
</code></pre><h4 id="http-request-options-callback-模拟HTTP请求"><a href="#http-request-options-callback-模拟HTTP请求" class="headerlink" title="http.request(options, [callback]): 模拟HTTP请求"></a>http.request(options, [callback]): 模拟HTTP请求</h4><pre><code>options:

    protocol &lt;String&gt; 使用的协议。默认为 &apos;http:&apos;。

    host &lt;String&gt; 请求发送至的服务器的域名或 IP 地址。默认为 &apos;localhost&apos;。

    hostname &lt;String&gt; host 的别名。为了支持 url.parse()，hostname 优于 host。

    family &lt;Number&gt; 当解析 host 和 hostname 时使用的 IP 地址族。 有效值是 4 或 6。当未指定时，则同时使用 IP v4 和 v6。

    port &lt;Number&gt; 远程服务器的端口。默认为 80。

    localAddress &lt;String&gt; 要绑定到网络连接的本地接口。

    socketPath &lt;String&gt; Unix 域 Socket（使用 host:port 或 socketPath 的其中之一）。

    method &lt;String&gt; 一个指定 HTTP 请求方法的字符串。默认为 &apos;GET&apos;。

    path &lt;String&gt; 请求的路径。默认为 &apos;/&apos;。 应包括查询字符串（如有的话）。如 &apos;/index.html?page=12&apos;。 
    当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。

    headers &lt;Object&gt; 一个包含请求头的对象。

    auth &lt;String&gt; 基本身份验证，如 &apos;user:password&apos; 来计算 Authorization 头。

    agent &lt;http.Agent&gt; | &lt;Boolean&gt; 控制 Agent 的行为。 当使用 Agent 是，请求默认为 Connection: keep-alive。 可能的值有：
    undefined (默认): 对该主机和端口使用 http.globalAgent。

    Agent 对象：显式地使用传入的 Agent。

    false: 不对连接池使用 Agent，默认请求 Connection: close。

    createConnection &lt;Function&gt; 当不使用 agent 选项时，产生一个用于请求的 socket/stream 的函数。 这可以用于避免创建一个自定义的 Agent 类，只是为了覆盖默认的 createConnection 函数。详见 agent.createConnection()。

    timeout &lt;Integer&gt;: 一个数值，指定 socket 超时的毫秒数。 它会在 socket 被连接时设置超时。


Example:

    var postData = querystring.stringify({
            &apos;msg&apos; : &apos;Hello World!&apos;
        });

    var options = {
        hostname: &apos;www.google.com&apos;,
        port: 80,
        path: &apos;/upload&apos;,
        method: &apos;POST&apos;,
        headers: {
            &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,
            &apos;Content-Length&apos;: Buffer.byteLength(postData)
        }
    };

    var req = http.request(options, (res) =&gt; {
        console.log(`STATUS: ${res.statusCode}`);
        console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
        res.setEncoding(&apos;utf8&apos;);
        res.on(&apos;data&apos;, (chunk) =&gt; {
            console.log(`主体: ${chunk}`);
        });
        res.on(&apos;end&apos;, () =&gt; {
            console.log(&apos;响应中已无数据。&apos;);
        });
    });

    req.on(&apos;error&apos;, (e) =&gt; {
        console.log(`请求遇到问题: ${e.message}`);
    });

    // 写入数据到请求主体
    req.write(postData);
    req.end();
</code></pre><h4 id="http概念"><a href="#http概念" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、请求方法:

    Get: 请求从服务器获取数据，没有请求体，不会影响服务器数据

    Post: 从服务器获取数据，有请求体，会影响服务器端的数据

    DELETE: 从服务器删除资源

    HEAD: 向服务器获取响应头，不要响应体

    PUT: 要新的服务器一个资源

    OPTIONS: 获取服务器支持的方法


2、文件类型 Content-type

    html: text/html

    ASCII文本: text/plain

    jpeg图片: image/jpeg

    GIF图片: image/gif

    javascript: text/javascript

    css: text/css

    表单: application/x-www-form-urlencoded



# 获取 index.html 文件内容返回给客户端

    var http = require(&apos;http&apos;);
    var fs = require(&apos;fs&apos;);

    exports.createServer2 = function(){
        var server = http.createServer(function(request, response){

            var url = request.url;

            // 获取 index.html 文件内容返回给客户端
            fs.readFile(&apos;./index.html&apos;, &apos;utf-8&apos;, function(err, data){
                console.log(err, data);

                response.write(data);
                response.end();
            })
        });

        server.listen(8081, &apos;localhost&apos;);
    }


# 处理Get请求的参数

    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url, true);

        console.log(oUrl.query);        // { username: &apos;siguang&apos;, age: &apos;30&apos; }

        var urlQuery = oUrl.query;
        if(urlQuery){
            response.write(&apos;服务器接收GET请求参数成功\n&apos;)
            response.write(&apos;用户名:&apos;+ urlQuery.username +&apos;\n&apos;);
            response.write(&apos;年级:&apos;+ urlQuery.age +&apos;\n&apos;);
        }
        else{
            response.write(&apos;服务器接收参数失败&apos;);
        }
        response.end();
    });

    server.listen(8081, &apos;localhost&apos;);


# 处理POST请求

    if(urlObj.pathname == &apos;/register&apos;){           // 处理 &apos;/clock&apos; 的请求
        var str = &apos;&apos;;
        var userList = {};

        // 通过on来侦听 data事件, data事件就是接收客户端传输过来的事件, 用可接收post的数据
        request.on(&apos;data&apos;, function(data){
            console.log(data.toString());          // 返回的是 Buffer
            str += data.toString();
        })

        // 所有接收完成后处理接收数据
        request.on(&apos;end&apos;, function(data){
            userList = JSON.parse(str);

            response.writeHead(&apos;200&apos;, {&apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;});
            if(userList.username == &apos;aaa&apos; &amp;&amp; userList.password == &apos;ssssss&apos;){
                 response.end(JSON.stringify({&quot;res&quot;:true,&quot;message&quot;:&quot;注册成功&quot;}));        // 这里一定要用JSON.stringify来转成串
            }
            else{
                response.end(JSON.stringify({&apos;res&apos;:false,&apos;message&apos;:&apos;注册失败&apos;}));
            }
            response.end();
        })
    }

    注意：

        1、客户端发送ajax请求时

            如果data是字符串，接收过来就是 &apos;{&apos;username&apos;: &apos;aaa&apos;, &apos;password&apos;: &apos;ssssss&apos;}&apos; 字符串可以直接转成json,

            如果data传的是一个对象，jquery会转成&quot;{&apos;username&apos;=&apos;aaa&apos;&amp;&apos;password&apos;=&apos;ssssss&apos;}&quot;, 还需要node重组
</code></pre><h4 id="http概念-1"><a href="#http概念-1" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、up 工具 通过nodeAPI来监听文件或目录下所有文件，如果有文件改变不需要重启服务器

    $ sudo npm i up -g   

    运行命令: up -watch -port 8080 server.js 
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之一）Global全局/">nodeJS基 (之一) Global全局对象</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之一）Global全局/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| <strong>filename - 前当文件名<br>| </strong>dirname - 当前所在的目录<br>| setTimeout、clearTimeout - 定时器<br>| setInterval、clearInterval - 定时器<br>| console - 打印到控制台<br>| process - 进程<br>| exports、require() - 导入、导出<br>| </p>
<h4 id="dirname-当前的绝对路径"><a href="#dirname-当前的绝对路径" class="headerlink" title="__dirname  当前的绝对路径"></a>__dirname  当前的绝对路径</h4><h4 id="filename-当前文件名"><a href="#filename-当前文件名" class="headerlink" title="__filename  当前文件名"></a>__filename  当前文件名</h4><h4 id="exports-暴露接口"><a href="#exports-暴露接口" class="headerlink" title="exports  暴露接口"></a>exports  暴露接口</h4><h4 id="require-引入模板"><a href="#require-引入模板" class="headerlink" title="require()  引入模板"></a>require()  引入模板</h4><pre><code>1、模块分为

    模块加载：require(&apos;2.js&apos;);

    1）内置模块:  var fs = require(&apos;fs&apos;);        // 加载Node的内置模块 fs文件系统

    2）文件模块: 自己定义的业务模块

        定义一个food.common.js

        var food = reuqire(&apos;./js/food.common&apos;);        // 加载业务模块

    3）加载第三方模块

        require(&apos;./2&apos;);        // 先按照加载的模块文件进行查找，如果没有找到会在文件名加上.js


2、绝对和相对路径

    var fs = require(&apos;fs&apos;);        // 绝对路径，是在Node通过内部的node_modules查找到的模块

    var moduleA = reuqire(&apos;./lib/moduleA&apos;);        // 相对路径


2、npm 全局安装和局部安装

    1）全局安装会安装到Node目录中，各项目都可以使用 npm install -g gulp

    2）局部安装，将一个模块安装到node_modules中，只在当前和子目录中使用


require.cache
require.resolve()
</code></pre><h4 id="global-全局对象"><a href="#global-全局对象" class="headerlink" title="global  全局对象"></a>global  全局对象</h4><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><pre><code>module和exports两个全局变量

1）module：每个模块下都包括module对象

    Module {
        id: &apos;.&apos;,
        exports: {},
        parent: null,
        filename: &apos;/Users/apple/siguang.liu/nodeProject/server.js&apos;,
        loaded: false,
        children: [],
        paths: [
            &apos;/Users/apple/siguang.liu/nodeProject/node_modules&apos;,
            &apos;/Users/apple/siguang.liu/node_modules&apos;,
            &apos;/Users/apple/node_modules&apos;,
            &apos;/Users/node_modules&apos;,
            &apos;/node_modules&apos;
        ]
     }

 2）exports外部接口，通过require就可以调用这个接口

     其实exports就是module.exports的引用

    exports.name = &apos;siguang&apos;;
    exports.getPrivate = function(){
        return &apos;haha&apos;;
    }
</code></pre><h4 id="process-进程"><a href="#process-进程" class="headerlink" title="process  进程"></a>process  进程</h4><h4 id="console-打印到控制台"><a href="#console-打印到控制台" class="headerlink" title="console 打印到控制台"></a>console 打印到控制台</h4><pre><code>log()、info()、error()、warn()、time()、timeEnd()
</code></pre><h4 id="setImmediate-callback-…args-、clearImmediate-immediateObject"><a href="#setImmediate-callback-…args-、clearImmediate-immediateObject" class="headerlink" title="setImmediate(callback[, …args])、clearImmediate(immediateObject)"></a>setImmediate(callback[, …args])、clearImmediate(immediateObject)</h4><h4 id="setInterval-、clearInterval"><a href="#setInterval-、clearInterval" class="headerlink" title="setInterval()、clearInterval()"></a>setInterval()、clearInterval()</h4><h4 id="setTimeout-、clearTimeout"><a href="#setTimeout-、clearTimeout" class="headerlink" title="setTimeout()、clearTimeout()"></a>setTimeout()、clearTimeout()</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之九）Connect中间件/">nodeJS（之九）Connect中间件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之九）Connect中间件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><pre><code>Connect是HTTP服务的中间件

$ 安装 npm i connect --save


// 引用模块
var connect = require(&apos;connect&apos;);

// 创建服务器
var server = connect.createServer();

// 处理静态文件
server.use(connect.static(__dirname + &apos;/statice&apos;));     // connect.static 静态文件目录

// 监听
server.listen(3000);
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>1、静态目录设置 -  server.use(connect.static(__dirname + &apos;/statice&apos;));

2、客户端缓存时间 -  server.use(connect.static(__dirname + &apos;/statice&apos;), {maxAge: 100000});

3、静态文件以&quot;.&quot;开始都认为是隐藏文件 - server.use(connect.static(__dirname + &apos;/statice&apos;), {hidden: true});

4、query中间件，解析字符串  &apos;/posts?page=5&apos;

    server.use(connect.query);
    server.use(function(req, res){
        let page = req.query.page;
    })

5、logger，打印日志，四种日志格式，default/dev/short/tiny

    connect.createServer(
        connect.logger(&apos;dev&apos;),
        function(req, res){
            res.writeHead(200);
            res.end(&apos;hello);
        }
    )

7、body parser  文件上传
</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><pre><code>使用cookieParser()

// cookie: secret1=val1; secret2=val2

server.use(cookieParser());
server.use(function(req, res){
    let ser1 = req.cookies.secret1;
    let ser2 = req.cookies.secret2;
})
</code></pre><h4 id="session-会话"><a href="#session-会话" class="headerlink" title="session 会话"></a>session 会话</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之五）Path/">nodeJS基 (之五) Path模块</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之五）Path/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| baseName() - 返回文件名，带扩展<br>| dirname() - 返回一个指定的绝对路径<br>| join() - 两个路径进行拼接<br>| extname() - 返回文件的扩展名<br>| isAbsolute() - 是否是一个绝对路径<br>| resolve() - 把路径解析成一个绝对路径<br>| format() - 从配置中返回一个路径<br>| parse() - 拆分一个路径，与format相反</p>
<h4 id="baseName-返回文件名-带扩展名"><a href="#baseName-返回文件名-带扩展名" class="headerlink" title="baseName(): 返回文件名(带扩展名)"></a>baseName(): 返回文件名(带扩展名)</h4><pre><code>let name = path.basename(&apos;./resource/haha.txt&apos;, &apos;.txt&apos;);    // 返回 haha
let allName = path.basename(&apos;./resource/haha.txt&apos;);         // 返回 haha.txt
</code></pre><h4 id="dirname-返回一个path目录"><a href="#dirname-返回一个path目录" class="headerlink" title="dirname() 返回一个path目录"></a>dirname() 返回一个path目录</h4><pre><code>let pathName = path.dirname(&apos;./&apos;);
console.log(pathName, __dirname);
</code></pre><h4 id="extname-fileStr-返回文件的扩展名"><a href="#extname-fileStr-返回文件的扩展名" class="headerlink" title="extname(fileStr) 返回文件的扩展名"></a>extname(fileStr) 返回文件的扩展名</h4><pre><code>let extension = path.extname(&apos;权限申请.xlsx&apos;);
console.log(extension);        // .xlsx
</code></pre><h4 id="isAbsolute-path-判断path是否是一个绝对路径"><a href="#isAbsolute-path-判断path是否是一个绝对路径" class="headerlink" title="isAbsolute(path) 判断path是否是一个绝对路径"></a>isAbsolute(path) 判断path是否是一个绝对路径</h4><pre><code>var absolutePath =  path.isAbsolute(&apos;./ss&apos;);
var notAbsolutePath = path.isAbsolute(&apos;/Users/apple/&apos;)
console.log(absolutePath);      // false
console.log(notAbsolutePath);   // true
</code></pre><h4 id="join-paths-多个路径拼接成一个路径"><a href="#join-paths-多个路径拼接成一个路径" class="headerlink" title="join(paths) 多个路径拼接成一个路径"></a>join(paths) 多个路径拼接成一个路径</h4><pre><code>let pathStr = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;);
let parentDirectory = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;, &apos;..&apos;);    // ..减少一级目录
console.log(pathStr);           // /foo/bar/bar/asdf/quux
console.log(parentDirectory);   // /foo/bar/bar/asdf
</code></pre><h4 id="resolve-p1-p2-把路径解析为一个绝对路径"><a href="#resolve-p1-p2-把路径解析为一个绝对路径" class="headerlink" title="resolve(p1, p2) 把路径解析为一个绝对路径"></a>resolve(p1, p2) 把路径解析为一个绝对路径</h4><pre><code>var newPath = path.resolve(__dirname, &apos;sss.txt&apos;);
console.log(newPath);
</code></pre><h4 id="format-pathobject-从配置对象返回一个路径字符串"><a href="#format-pathobject-从配置对象返回一个路径字符串" class="headerlink" title="format(pathobject) 从配置对象返回一个路径字符串"></a>format(pathobject) 从配置对象返回一个路径字符串</h4><pre><code>let basePath = path.format({
    root: &apos;/book&apos;,
    dir: &apos;/home/user/dir&apos;,
    base: &apos;file.txt&apos;
})
console.log(basePath);      // output -&gt;  /home/user/dir/file.txt
</code></pre><h4 id="parse-path-将一个路径拆分与format相反"><a href="#parse-path-将一个路径拆分与format相反" class="headerlink" title="parse(path) 将一个路径拆分与format相反"></a>parse(path) 将一个路径拆分与format相反</h4><pre><code>let pathStr = path.parse(__dirname);
console.log(pathStr);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之十）TCP/">nodeJS（之十）TCP</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之十）TCP/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><pre><code>NodeJS中有三种socket: 1、TCP   2、UDP   3、Unix域套接字

TPC套接字分为: 服务端和客户端

    服务端TCP监听来自客户端的连接请求，并使用TCP连接向客户端发送数据；客户端TCP连接到服务端并与服务器交互数据。客户端与服务端之间依靠套接字进行双向通信。

1、引用TCP模块

    const net = require(&apos;net&apos;);
    const PROT = 6969;

2、HTTP模块也是继承TCP模块
</code></pre><h4 id="net-Server类"><a href="#net-Server类" class="headerlink" title="net.Server类"></a>net.Server类</h4><pre><code>1、createServer() 创建tcp服务器

2、close() - 关闭

3、listen() - 侦听

    const HOST = &apos;127.0.0.1&apos;;
    const PORT = 6969;

    // 写法1 
    let server = net.crateServer(function(conn){
        ...
    });
    server.listen({host: HOST, port: PORT}, function(){    // 或 server.listen(PORT, HOST, function(){
        console.log(&apos;这里是异步的&apos;);
    });

    // 写法2
    let server = net.crateServer(function(conn){
        ...
    }).listen(PORT, HOST);


4、address() - 返回绑定的IP端口等信息 {&quot;address&quot;:&quot;::&quot;,&quot;family&quot;:&quot;IPv6&quot;,&quot;port&quot;:6969}

属性

1、listening - server是否正在监听连接

2、maxConnections - 当前server连接数过多时拒绝连接


事件

1、close - 关闭

2、connection - 建立连接时触发

3、error - 错误时触发

4、listening - 服务被绑定后调用
</code></pre><h4 id="net-Socket类"><a href="#net-Socket类" class="headerlink" title="net.Socket类"></a>net.Socket类</h4><h4 id="net-connect"><a href="#net-connect" class="headerlink" title="net.connect"></a>net.connect</h4>
        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Vorige</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Volgende &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
