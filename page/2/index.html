<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/02/mongoDB/">MongoDB</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/02/mongoDB/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-02T11:15:23.000Z" itemprop="datePublished">2017-04-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/数据库/">数据库</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| mongodb的安装和启动<br>| 创建用户权限<br>| 数据类型 - null、boolean、Number、Float、String、Date、表达式、二进制、undefined、Array、Object<br>| 库操作 - show dbs、show collections、use db、db、db.dropDatabase()<br>| 创建和删除集合 -  db.createCollection、db.myColl.insert({})、db.myColl.drop()<br>| 删除行 -<br>| 插入值 - db.myColl.insert({name: ‘haha’})<br>| 更新值 - db.myColl.update({name: ‘haha}, {$set: {age: 20}}, false, true)<br>|         $set、$unset、$inc、$push、$pushAll、$pop、$pull、$pullAll、$rename<br>| 删除值 -  db.myColl.remove({name: ‘’})、remove({})<br>| 查询值 - db.myColl.find({})<br>|         .sort()、count()、limite()、skip()<br>|         查询条件 $gt、$gte、$lt、$lte、!= 、=、and、or、in、notIn<br>|         数组查询 $all、$size、$sclie<br>|         $where 子句<br>| 索引 db.myColl.ensureIndex({key:1})、getIndexes()、dropIndexes()、background:true修改索引<br>|        索引类型: _id索引、单键索引、多键索引、复合索引、过期索引、全文索引、唯一索引<br>| 复制集<br>| 分片<br>| 数据均衡<br>| 性能分析</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>自动提示，按两次Tab

db.getMongo() - 查看当前mongo的ip和端口

启动服务 - /usr/local/Cellar/mongodb/3.4.3/bin  =&gt;  $ mongod &amp;

停止服务 - 进入 use admin  =&gt; $ db.shutdownServer()

查看服务进程 -  ps -rf | grep mongod   ps -rf | grep mongo    kill -9 xxxx

---------------------------------------------------------------------------------------

db.copyDatabase(&apos;旧数据库名&apos;, &apos;新数据库名&apos;) - Copy数据库

---------------------------------------------------------------------------------------

show dbs - 查询所有数据库

show collections - 查询所有当前数据库下所有的数据表

use myDataBase - 创建并切换库，如果没有就创建这个库，创建库时在内存中，只有对库插入集合操作才会真正存在硬盘上

db - 查看当前选择的库

db.dropDataBase() - 删除数据库


db.createCollection(表名，指定大小和索引选项) - 创建集合

db.myColl.drop() - 删除集合


db.myColl.insert({_id: ObjectId(&quot;5a4b5f29cca1d978501c9c52&quot;), name: &apos;aa&apos;, age: 30}) - 插入主键不能相同

db.myColl.save({_id: ObjectId(&quot;5a4b5f29cca1d978501c9c52&quot;), name: &apos;aa&apos;, age: 30}) - 插入允许主键相同的数据


db.myColl.find(query) - 查看文档

db.myColl.findOne() - 取第一条记录

db.myColl.update({}) - 更新文档

db.myColl.remove(query, {justOne}) - 删除一条文档

db.myColl.update({name: &apos;siguang&apos;}, {$unset: {name: 1}}) - 删除一个字段


db.myColl.ensureIndex() - 创建索引

db.myColl.getIndexes() - 查看当前集合索引

db.myColl.dropIndexes() - 删除索引 

db.myColl.ensureIndex({id: 1}, {background: true}) - 修改索引


db.createUser() - 创建用户角色
</code></pre><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><pre><code>一、MongoDB优点

    1、无数据结构限制（没有表结构概念，每条记录可以有完全不同的结构）

    2、完全的索引支持（单键索引、数组索引、全文索引、地理位置索引）

    3、数据安全性和分片扩展数据规模

    1、简单的单机服务    2、搭建具有冗余容错功能的复制集    3、搭建大规模数据集群        4、完成集群的自动部署

    MongoDB逻辑结构是一种层次结构，文档(document)、集合(collection)、数据库(database)这三部分组成的。 


二、数据库分类

    1、SQL数据库，支持SQL语言的数据库，如 Oracle，Mysql

    2、NoSQL数据库，不支持SQL语言的数据库，Redis, MongoDB


三、mongo与sql概念

    SQL术语/概念    MongoDB术语/概念    解释/说明

    database        database         数据库
    table            collection         数据库表/集合
    row                document         数据记录行/文档
    column            field             数据字段/域
    index            index             索引
    table             joins              表连接,MongoDB不支持
    primary key        primary key         主键,MongoDB自动将_id字段设置为主键
</code></pre><h4 id="MongoDB安装、连接、启动服务"><a href="#MongoDB安装、连接、启动服务" class="headerlink" title="MongoDB安装、连接、启动服务"></a>MongoDB安装、连接、启动服务</h4><pre><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;    // 安装brew

$ brew update                // 更新brew

$ brew install mongodb         // 安装的目录 /usr/local/Cellar/mongodb/   

    brew uninstall mongodb  // 卸载mongo

$ brew list                    // 查看brew安装的列表中是否存在brew

$ sudo mkdir -p /data/db       // 创建数据库存储目录, 这个是mongo默认找的地址，如果需要放到其它目录使用 mongod --dbpath /xxx/xxx/xx, 注意目录权限不能为root

$ 连接本地和远端服务器的mongoDB

    本地mongo: $ mongo localhost:27017/test -u user -p password            // 如果没有用户名和密码直接mongo

    远端mongo: $ mongo 192.168.1.200:27017/test -u user -p password        // test为数据库名

        mongodb://10.10.13.123:27017,10.10.13.341:27017/ibg_node_core

$ 启动和关闭mongo服务

    启动服务: 

        $ cd /usr/local/Cellar/mongodb/3.6.1/bin        // 进入到目录

        $ mongod &amp;            // &amp; 关闭终端mongod服务不会被kill掉  如果启用权限使用 mongod --auth

    关闭服务:

        $ use admin         // 需要先进入到admin库

        $ db.shutdownServer()


$ brew info mongodb            // 查看安装信息    mongod --config /usr/local/etc/mongod.conf

    mongodb.conf内容

        systemLog:        // log目录
            destination: file
        path: /usr/local/var/log/mongodb/mongo.log
            logAppend: true
        storage:        // db目录
            dbPath: /usr/local/var/mongodb        // 数据存储的目录
        net:
            bindIp: 128.0.0.1

    http://blog.csdn.net/sun491922556/article/details/74973191            // 3.4版本配置

$ mongo --version            // 查看版本
</code></pre><h4 id="mongo的基本数据类型"><a href="#mongo的基本数据类型" class="headerlink" title="mongo的基本数据类型"></a>mongo的基本数据类型</h4><pre><code>null、boolean、Number、Float、String、Date、表达式、二进制、undefined、Array、Object
</code></pre><h4 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h4><pre><code>一、查询库、查询集合

    1、show dbs — 查询所有的数据库列表

    2、show collections — 显示当前库下所有集合


二、创建库和删库

    1、use testDatabase — 创建一个数据库，如果库存在则使用当前库，创建时只在内存中，只有对这个库有操作后这个数据库才能真正创建

    2、db - 查看当前所在的库库

    3、db.dropDatabase() - 删除这个数据库

        use tsetDatabase     // 先进入要操作的数据库
        db.dropDatabase()     // 删除库
</code></pre><h4 id="文档的创建和删除"><a href="#文档的创建和删除" class="headerlink" title="文档的创建和删除"></a>文档的创建和删除</h4><pre><code>查看常用的方法  db.myColl.help()

一、建表两种方法

    db.createCollection(名称, 指定有关内存大小和索引选项);    -    创建集合

        options:
            capped - Boolean    （可选）如果为true，则启用封顶集合。封顶集合是固定大小的集合，会自动覆盖最早的条目，当它达到其最大大小。如果指定true，则需要也指定尺寸参数。
            autoIndexID - Boolean    （可选）如果为true，自动创建索引_id字段的默认值是false。
            size - number    （可选）指定最大大小字节封顶集合。如果封顶如果是 true，那么你还需要指定这个字段。
            max - number

    db.myColl.insert({name:’hf’,age:20}) — 在mongodb中在插入数据时即创建了改表，此时创建的是名为myColl的数据表

        for(i=0; i&lt;100; i++) db.myTabel.insert({&apos;age&apos;, i})        循环插入


二、删除集合、文档

    db.myColl.remove({type: &apos;马尔代夫&apos;}) - 删除myColl集合中 type=&apos;马尔代夫&apos; 这条文档

    db.myColl.drop(); — 删除myColl这个集合
</code></pre><h4 id="insert-插入文档"><a href="#insert-插入文档" class="headerlink" title="insert 插入文档"></a>insert 插入文档</h4><pre><code>1、insert() - 插入主键不能相同，自动生成_id    db.myColl.insert({name:’hahaha’, age:12});

2、save() - 允许插入重复数据，直接添加一个文档

    db.myColl.save({        // 直接向集合中插入文档
        data: {},
        message: &quot;操作成功&quot;,
        status: 0
    })

二者的区别，insert()在主键相同时会报错，save()不会

    $ db.user.find();        // { &quot;_id&quot; : ObjectId(&quot;5a4b5df1cca1d978501c9c50&quot;), &quot;username&quot; : &quot;siguang&quot; }

    $ db.user.insert({ &quot;_id&quot; : ObjectId(&quot;5a4b5df1cca1d978501c9c50&quot;), &quot;username&quot; : &quot;siguang&quot; })        // 报错

    $ db.user.save({ &quot;_id&quot; : ObjectId(&quot;5a4b5df1cca1d978501c9c50&quot;), &quot;username&quot; : &quot;siguang1111111&quot; })    // 执行成功，并将username的值改了
</code></pre><h4 id="find-文档查询"><a href="#find-文档查询" class="headerlink" title="find 文档查询"></a>find 文档查询</h4><pre><code>http://www.cnmyColls.com/egger/p/3135847.html

1、findOne() - 查询第一条记录，然后闭关游标    

2、find() - 返回符合条件的所有记录        db.role.find({age:30}) 返回role中age等于30的集合

3、sort() - db.myColl.find().sort({age:1})      // age=1为升序，-1为降序  sort()

4、count() - db.myColl.find().count();          // 返回表中记录的个数 count()        

5、limit() - db.myColl.find().limit(5)          // 返回前5条数据 limit()

            db.myColl.find().skip(10).limit(20);        返回11-30条数据， 用于分页

6、skip() - db.myColl.find().skip(50)          // 跳过前50条数据

7、pretty() - 将查询出的内容进行格式显示        

8、查询条件

    1）条件查询   &gt; $gt、 &gt;= $gte、 &lt; $lt、 &lt;= $lte、 != $ne

        db.cars.find({carMoney: {$lt:100}})        // 查询carMoney小于100的值

        db.cars.find({carMoney: {$lt:100, $gt:20}})        // 查询carMoney 大于20小于100的值

    2）$and、$or、$in、$notIn

        $and    db.cars.find({name: &apos;卡宴&apos;, price: 200})        // name=卡宴 并且 price=200    

        $in      db.myColl.find({price: {$in: [100, 300, 500]});        // 查询出price field中为100、300、500值的字段

        $or     db.cars.find({ $or: [ {id: 9}, {carType: 735}] })        // 查询出id=9 或者 carType=735

                db.cars.find({ isDeleted: false, $or: [ {id: /huang/i}, {carType: 735}] });    // 查询 isDeleted等于false 并且id带有&apos;huang&apos;字符 或者 carType等于735

        $not    不包括的数据

9、$type 类型操作符查询

    例如: 将name字段中的所有为数字的查询出来，

    $ db.tourism.find({&apos;name&apos;: {$type: 1}})

    对应表:

        类型                    数字            备注

        Double                1                数字
        String                2     
        Object                3     
        Array                4     
        Binary data            5     
        Undefined            6               已废弃。
        Object id            7     
        Boolean                8     
        Date                9     
        Null                10
        Regular Expression    11
        JavaScript            13     
        Symbol                14     
        JavaScript (with scope)    15     
        32-bit integer        16     
        Timestamp            17     
        64-bit integer        18     
        Min key                255            Query with -1.
        Max key                127     


10、数组查询

    1）$all - 用来查询是否包括数组里的值

        // content field值为数组
        db.myColl.find({content: {$all: [1, 8]})        返回content中包含1或8的数组


    2）$size - 用来查询数组的长度

        db.myColl.find({content: {$size: 3}});        返回content数组字段长度为3个


    3）$slice - 控制指定字段中返回数组的个数

        db.myColl.find({}, {content: {$slice: 3}} )    返回所有记录 content数组只取前三个

        db.myColl.find({}, {content: {$slice: -3}} )    从后取3个

        db.myColl.find({}, {content: {$slice: [1, 3]}} )    取1-3的范围


11、$where 子句

    相当于用一个js查询一部分，如果为true则返回数据，则否不返回

    字符串形式
    db.myColl.find({$where: &quot;this.title.length &gt; 23&quot;}, {title: 1})    对title field中的字符长度大于23的返回

    函数形式
    db.myColl.find({$where: function(){ return this.title.length &gt; 23 }})


12、Example

    db.myColl.find();  —  查询myColl中的所有数据， 带条件 .fin({x: 1}) x=1的记录

    db.myColl.find({}, {id: &apos;&apos;, price: &apos;&apos;}) — 查询其中两个字段的值

    db.myColl.find({id: 5}, {username: 1}) - 只返回id=5 的 username的字段，其余的不返回

        { &quot;_id&quot; : ObjectId(&quot;58e85c84784a18c26f9a1fa5&quot;), &quot;username&quot; : &quot;siguang5&quot; }

    db.myColl.find({carType: 33}, {id: &apos;&apos;, price: &apos;&apos;}) — 返回carType=33的id和price字段的值

    db.myColl.update({}, {$unset:{&apos;name&apos;:&apos;&apos;}}, false, true)        // 删除一个字段

    db.myColl.find({title: /美舰/}, {title: 1})    -    查找出title中带有&quot;美舰&quot;的字符，并只返回title字段
</code></pre><h4 id="update-更新文档"><a href="#update-更新文档" class="headerlink" title="update 更新文档"></a>update 更新文档</h4><pre><code>update(更新条件, 更新的值，[如果不存在是否创建 - 默认false]，[是否更新全部 - 默认false])

1、$set - 更新值

    update() 第四个参数为true更所有匹配的值，false只更新一个

    // 只更匹配的第一条 如果type=&apos;123&apos;不存在, 则插入一条只有name=&apos;456&apos;的数据
    db.myColl.update({type: &apos;123&apos;}, {name: &apos;456&apos;});        

    // 更新全部匹配
    db.myColl.update({name:’hf’}, {$set:{age:25}}, false, true)

    // {multi:true} 更新多条
    db.myColl.update({&apos;title&apos;:&apos;MongoDB 教程&apos;}, {$set:{&apos;title&apos;:&apos;MongoDB&apos;}}, {multi:true})

    // 为集合中所有文档添加一个字段
    db.user.update({}, {$set: {password: &apos;******&apos;}}, {multi: 1})


2、$unset - 删除字段列

    db.myColl.find({id:1})             { &quot;id&quot; : 1, &quot;content&quot; : &quot;&quot; }    注意这里要删除的字段值必须填写一个数字，可以是0、1或其它数字

    db.myColl.update({id: 1}, {$unset: {content: 1}});
    db.myColl.find({id:1})            { &quot;id&quot; : 1}     content被删除


3、$inc - 只能对一个数字字段的值的进行累加，key不存在或者非数字都报错

    db.myColl.find({id: 1});        result: { username: &apos;siguang&apos;, password: 100 }

    // 如果password的值存在则 +1000
    db.myColl.update({id: 1}, {$inc: {password: 1000}})    
    db.myColl.find({id: 1});        result: { username: &apos;siguang&apos;, password: 1100 }


4、$push、$pushAll - 对一个数组字段在插入值

    db.myColl.find({id: 3});            Result: { &quot;id&quot; : 3, &quot;username&quot; : &quot;siguang3&quot;,  &quot;content&quot; : [ 1, 2, 3 ] }

    db.myColl.update({id: 3}, {$push: {content: 4}})
    db.myColl.find({id: 3});            Result: { &quot;id&quot; : 3, &quot;username&quot; : &quot;siguang3&quot;,  &quot;content&quot; : [ 1, 2, 3, 4] }


5、$addToSet - 向一个数组中添加数据，如果数组中存在这个值则不添加，如果不存在则添到数组中

    db.myColl.find({id: 3});            Result: { &quot;id&quot; : 3, &quot;username&quot; : &quot;siguang3&quot;,  &quot;content&quot; : [ 1, 2, 3 ] }

    db.myColl.update({id: 3}, {$addToSet: {content: 3}});        // 数组中存在不添加
    db.myColl.update({id: 3}, {$addToSet: {content: 4}});        // &quot;content&quot; : [ 1, 2, 3, 4 ]


6、$pop - 删除数组中第一个或最后一个值 

    db.myColl.update({id: 3}, {$pop: {content: -1}});        // content为1 删除数组第一个值，-1删除数组最后一个值


7、$pull、$pullAll - 删除数组中指定相同的值

    db.myColl.update({id: 4}, {$set: {content: [1,2,34,4,1,2,3,1,1,6,1,34]}});    将content field为数组

    db.myColl.update({id: 4}, {$pull: {contentn: 1}});
    db.myColl.find({id: 4});        Result  {content: [2,34,4,2,3,6,34]}}  将数组中的1全部删除


8、$rename - 对某个字段进行更名

    db.myColl.update({id: 4}, {$rename: {content: &apos;title&apos;}});        // 将id=4的 content field 名更改为title


http://chenzhou123520.iteye.com/myColl/1637629
</code></pre><h4 id="remove-删除文档"><a href="#remove-删除文档" class="headerlink" title="remove() 删除文档"></a>remove() 删除文档</h4><pre><code>1、db.myColl.remove({name: &apos;hf&apos;}) - 删除name字段值为空的行, 此处相当于关系数据库中的 delete myColl where name = ‘hf’

2、db.myColl.remove({_id: ObjectId(&quot;593526143793ca468ceb963c&quot;)}) - 通过id来删除文档

3、db.myColl.remove({}) - 删除集合中所有文档
</code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>索引就是用来加速查询

索引的优缺点:

    优点: 索引加快查询的速度

    缺点: 增加磁盘空间消耗，降低写入性能

一、命令

    1、查看索引 - getIndexes()    db.myColl.getIndexes()

    2、创建索引 - ensureIndex()    db.myColl.ensureIndex({userId: 1})        // 1升序  -1降序

    3、删除索引 - dropIndexes()    db.myColl.dropIndexes()

    4、修改索引 - {background: true}        db.myColl.ensureIndex({id: 1}, {background: true});


二、ensureIndex()参数

    1、background - Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 &quot;background&quot; 可选参数。 &quot;background&quot; 默认值为false。

    2、unique - Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false.

    3、name - string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。

    4、dropDups - Boolean 在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.

    5、sparse - Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.

    6、expireAfterSeconds - nteger    指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。

    7、v - index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。

    8、weights - document索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。

    9、default_language - string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语

    10、language_override - string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.


三、索引类型

    创建索引的两种不同:

        非全文索引     ensureIndex({key: value}): key为字段名，值为1或-1代表索引的排序方向
        全文索引     ensureIndex({key: &apos;text&apos;}): key为字段名，value为固定的&apos;text&apos;字符串

    1、_id索引 - 是绝大多数集合默认建立的索引, 插入一条数据自动创建一个索引

    2、单键索引 - 最普通的索引 与_id不同的是，单键索引不会自动创建

        Example:

            {x: 1, y: 2, z: 3}        // 当前表

            db.myColl.ensureIndex({x: 1})        // 使用 x 作为索引
            for(var i=0, i&lt;10; i++) db.myColl.insert({x: 2, y: i+&apos;y&apos;; z: i+&apos;z&apos;});
            for(var i=0, i&lt;10; i++) db.myColl.insert({x: 1, y: i+&apos;y&apos;; z: i+&apos;z&apos;});        // 插入10条数据，x为1
            db.myColl.find({x:1});            // 用索引查出数据


    3、多键索引 - 多键索引与单键索引创建形势相同

            单键索引: 值是一个单一的值，如字符串、数字或日期

            多键索引: 值有多个记录，如数组

            db.myColl.insert({x: [1,2,3,4,5]});


    4、复合索引 - 查询条件不只有一个，需要建立复合索引            

        db.myColl.ensureIndex({x: 1, y: 1})        // 定义复合索引
        db.myColl.find({x:1, y: 1})        // 通过复合索引查询

        设置后的索引:
        [
            {
                &quot;v&quot; : 2,
                &quot;key&quot; : {
                    &quot;_id&quot; : 1
                },
                &quot;name&quot; : &quot;_id_&quot;,
                &quot;ns&quot; : &quot;tuniu.gt&quot;
            },
            {
                &quot;v&quot; : 2,
                &quot;key&quot; : {
                    &quot;x&quot; : 1,        // 这里
                    &quot;y&quot; : 1
                },
                &quot;name&quot; : &quot;id_1_money_1&quot;,
                &quot;ns&quot; : &quot;tuniu.gt&quot;
            }
        ]


    5、过期索引 - 在一段时间后会过期的索引, expireAfterSeconds

        索引过期后数据会被删除, 插入的数据会在30秒后删除, 如用户登录信息, 存储日志

        db.myColl.ensureIndex({time: 1}, {expireAfterSeconds: 30})        // expireAfterSeconds 定义30秒后 time值的索引删除

        db.myColl.insert({username: &apos;siguang&apos;, password: &apos;xxxx&apos;, time: new Date()});        // new Date() 当前时间, 30秒后会自动删除当前这条记录

        ** 注意 当数据量不大的时候最小间隔为60秒, 就算设置30秒也会按60秒来完成 ** 
        ** 创建time的值必须是时间类型ISODate **


    6、全文索引

        *** 注意：mongo中不支持中文的全文索引 ***

        全文索引每次只能使用一个$text查询

        db.myColl.ensureIndex({key: &quot;text&quot;})

        db.myColl.ensureIndex({&quot;$**&quot;: &quot;text&quot;})        对所有字段作全文索引，而不是某一个字段


        查询全文索引：

            db.myTabel.find({$test: {$search: &apos;aa&apos;}})   只有值为aa时不包含其它字符时返回

            db.myTabel.find({$test: {$search: &apos;aa bb cc&apos;}})   如果是 aa 或 bb 或 cc 时返回  相当于 ||

            db.myTabel.find({$test: {$search: &apos;aa bb -cc&apos;}})  包含 aa 或 bb ，但不包含 cc 时返回

            db.myTabel.find({$test: {$search: &apos;\&apos;aa\&apos; \&apos;bb\&apos; \&apos;cc\&apos;&apos;}})  aa bb cc 都包含  相当于 &amp;&amp;


        相适度: $meta

            {score: {$meta: &apos;textscore&apos;}}  写在查询条件后面可以返回相似度的结果，与sort一起使用可以达到实用的效果

            Example:

            db.app.find({$text: {$search: &apos;新京报&apos;}}, {score: {$meta: &apos;textScore&apos;}})

            // db.app.find({$text: {$search: &apos;新京报&apos;}}, {score: {$meta: &apos;textScore&apos;}}).sort({scope: {$meta: &apos;textScore&apos;}})       // scope值来排序

            { &quot;_id&quot; : ObjectId(&quot;58e31b4c47e9f10d47bd55ec&quot;), &quot;title&quot; : &quot;共享单车相随总理出国门&quot;, &quot;article&quot; : &quot;今年1月，摩拜单车创始人&quot;, &quot;author&quot; : &quot;新京报(北京)&quot;, &quot;dateTime&quot; : ISODate(&quot;2017-04-04T04:04:28.585Z&quot;), &quot;score&quot; : 0.75 }
            { &quot;_id&quot; : ObjectId(&quot;58e31b4c47e9f10d47bd55ed&quot;), &quot;title&quot; : &quot;李克强赞这家企业一分钟穿越了两个时代&quot;, &quot;article&quot; : &quot;当时，来这里考察的。&quot;, &quot;author&quot; : &quot;新京报123(北京)&quot;, &quot;dateTime&quot; : ISODate(&quot;2017-04-04T04:04:28.624Z&quot;), &quot;score&quot; : 0.75 }

            这里结果返回 scope 的值是就相适度的情况


四、索引属性

    1、name 为索引指定name值

        例如定义一个复合索引，可以统一给他们一个名这样，在删除索引的时候也可以通过名字来删除

        db.myColl.ensureIndex({id: 1, type: 1, money: 1}, {name: &apos;idx&apos;});        // 定义索引name, 如果不加mongo会自动生成一个name值 为key_1

        db.myColl.dropIndexes(&apos;idx&apos;);


    2、unique 唯一索引

        唯一索引：不能在一个字段插入相同的值，如id如果有1，在插入id=1不允许

        db.myColl.ensureIndex({id: 1}, {unique: true/false});        // 设置了id字段为唯一索引

        db.myColl.insert({id:1, title:&apos;xxx&apos;});        如果id=1存在则不会被插入


    3、sparse 稀疏性


五、地理位置索引

    将一些点的位置存储在mongo中，创建索引后可以按照位置来查找其点

    子分类： 2d索引，用于存储和查找平面上的点        2dsphere索引，用于存储和查找球面上的点

    查找方式: 查找某个点一定距离内的点（打车软件）    查找包含在某个区域内的点

    1、创建 2D索引 平面地理位置索引

        db.location.ensureIndex({w: &apos;2d&apos;})        // 创建索引

        db.location.insert({w: [1, 1]});        // 插入经、纬度， 经度值在-180 至 180 之间， 纬度值在 -90 至 90 之间
        db.location.insert({w: [132, 112]});
        db.location.insert({w: [22, 14]});
        db.location.insert({w: [165, 13]});

        db.location.find({w: {$near: [1,1]}})        // $near 查找近的
        db.location.find({w: {$near: [1,140], $maxDistance: 150}})    // 查找经度 1-150之间， 或者纬度140-150之间   $maxDistrance 最大距离
</code></pre><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><pre><code>aggregate() 主要用于处理数据，返回计算后的数据结果

一、$group: 将集合中的文档分组，用于统计结果

    1、sum - 计算个数    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$sum : &quot;$currentCount&quot;}}}])

    2、avg - 计算平均值    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$avg : &quot;$currentCount&quot;}}}])

    3、min - 获取集合中所有文档对应值得最小值。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$min : &quot;$currentCount&quot;}}}])

    4、max - 获取集合中所有文档对应值得最大值。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$max : &quot;$currentCount&quot;}}}])

    5、push - 在结果文档中插入值到一个数组中。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$push: &quot;$currentCount&quot;}}}])

    6、addToSet - 在结果文档中插入值到一个数组中，但不创建副本。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, total: {$addToSet : &quot;$currentCount&quot;}}}])

    7、first - 根据资源文档的排序获取第一个文档数据。    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, firstDoc: {$first : &quot;$currentCount&quot;}}}])

    8、last - 根据资源文档的排序获取最后一个文档数据    db.mycol.aggregate([{$group : { _id: &quot;$dimensionType&quot;, firstDoc: {$last : &quot;$currentCount&quot;}}}])

    Example:

        // 查出来的文档
        db.col.find().pretty();        
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d0&quot;),
            &quot;dimensionType&quot; : &quot;AGE&quot;,
            &quot;loanId&quot; : &quot;113029&quot;,
            &quot;currentCount&quot; : 30000,
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d1&quot;),
            &quot;dimensionType&quot; : &quot;OMG&quot;,
            &quot;loanId&quot; : &quot;1129602&quot;,
            &quot;currentCount&quot; : 30000
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d2&quot;),
            &quot;dimensionType&quot; : &quot;AGE&quot;,
            &quot;loanId&quot; : &quot;113031&quot;,
            &quot;currentCount&quot; : 40000
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d3&quot;),
            &quot;dimensionType&quot; : &quot;AGE&quot;,
            &quot;loanId&quot; : &quot;113016&quot;,
            &quot;currentCount&quot; : 40000
        },
        {
            &quot;_id&quot; : ObjectId(&quot;59ae6c665f1fe4de50cb54d4&quot;),
            &quot;dimensionType&quot; : &quot;HSR&quot;,
            &quot;loanId&quot; : &quot;112910&quot;,
            &quot;currentCount&quot; : 30000
        }

        1）通过游标来计算 dimensionType计算出类别的个数

            db.col.aggregate([
                {
                    $group:{
                        _id: &quot;$dimensionType&quot;,
                        count: {$sum: 1}
                    }
                }
            ])        

            // 结果 返回
            { 
                &quot;_id&quot; : &quot;HSR&quot;, 
                &quot;count&quot; : 1.0
            }
            { 
                &quot;_id&quot; : &quot;OMG&quot;, 
                &quot;count&quot; : 1.0
            }
            { 
                &quot;_id&quot; : &quot;AGE&quot;, 
                &quot;count&quot; : 3.0
            }

        2) 通过dimensionType列 中不同类型来计算 currentCount列的总合

            db.col.aggregate([
                {
                    $group:{
                        _id: &quot;$dimensionType&quot;,
                        total: {$sum: &quot;$currentCount&quot;}
                    }
                }
            ])

            // 返回结果
            { 
                &quot;_id&quot; : &quot;HSR&quot;, 
                &quot;total&quot; : 30000.0
            }
            { 
                &quot;_id&quot; : &quot;OMG&quot;, 
                &quot;total&quot; : 30000.0
            }
            { 
                &quot;_id&quot; : &quot;AGE&quot;, 
                &quot;total&quot; : 110000.0
            }


二、管道符:

    $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。

    $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。

        db.col.aggregate([
            {
                $match: {
                    currentCount: {$gt: 30000}
                }
            },
            {
                $group:{
                    _id: &quot;$dimensionType&quot;,
                    min: {$sum: &quot;$currentCount&quot;}
                }
            }
        ])
        先将currentCount字段大于30000的匹配出来，在通过分组取出currentCount的总和

    $limit：用来限制MongoDB聚合管道返回的文档数。

    $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。

    $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。

    $group：将集合中的文档分组，可用于统计结果。

    $sort：将输入文档排序后输出。

    $geoNear：输出接近某一地理位置的有序文档。


三、count()  返回个数

    db.cars.count();        // 返回记录的个数

    db.cars.count({price: 1000})    // 返回price=1000 记录的个数

    db.cars.count({price: {$lt: 1000})    // 返回price &lt; 1000 记录的个数


四、distinct()  指定某一个字段返回不重复的数据，如 age: &apos;a&apos;  age: &apos;b&apos;  age: &apos;a&apos;   

    db.myColl.distinct(&quot;price&quot;);        // [&apos;a&apos;, &apos;b&apos;]    

五、mapReduce(）
</code></pre><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><h4 id="创建用户管理"><a href="#创建用户管理" class="headerlink" title="创建用户管理"></a>创建用户管理</h4><pre><code>mongo默认是没有管理员账户，需要在admin数据库中使用db.addUser()来添加管理员账号，否则任何人都可以操作数据库，admin库中有system.user的collection这就是用户表，用来存放超级管理员

用户分为两种: 一种是admin用户，另一种是在指定数据库的用户，admin用户是最高权限 

1、createUser() 创建用户

    $ use admin    // 先要切换到admin库

    $ show users     // 显示当前库下设置的所有设置的用户权限

    $ db.createUser(
        {
            user: &quot;root&quot;,        // 用户名
            pwd: &quot;ssssss&quot;,        // 密码
            roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]
        }
    )

    user - 段介绍： user字段，为新用户的名字；
    pwd - 用户的密码；
    cusomData - 为任意内容，例如可以为用户全名介绍；
    roles - 指定用户的角色，可以用一个空数组给新用户设定空角色；可以指定内置角色和用户定义的角色。

    Roles（内置角色）： 

        1. 数据库用户角色：read、readWrite;      // 读、读写

        2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；    // 管理权限

        3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；

        4. 备份恢复角色：backup、restore；

        5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase

        6. 超级用户角色：root   // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）

        7. 内部角色：__system

        PS：关于每个角色所拥有的操作权限可以点击上面的内置角色链接查看详情。


2、设置完用户权限进行重启mongod服务

    $ db.shtdownServer();        // 关闭mongod服务，或者kill掉

    // 进入bin目录下启动mongod

    $ mongod --auth                // 注意加权限就需要使用这个来启动服务,而不是单独的mongod &amp;


3、mongo登录

    $ mongo --port 27017 -u &quot;root&quot; -p &quot;ssssss&quot; --authenticationDatabase &quot;admin&quot;

    $ use admin

    $ db.auth(&quot;root&quot;, &quot;ssssss&quot;);        // 1表示登录成功，0表示登录失败。


4、创建其它用户

    use myCar
    db.createUser(
        {
            user: &quot;car&quot;,
            pwd: &quot;welcomeCar&quot;,
            roles: [ 
                { role: &quot;readWrite&quot;, db: &quot;myCar&quot; },
                { role: &quot;dbAdmin&quot;, db: &quot;myCar&quot; },
                { role: &quot;clusterMonitor&quot;, db:&quot;admin&quot;}
            ]
        }
    )


5、作为其它用户进行连接和验证身份

    mongo --port 27017
    use myCar
    db.auth(&quot;car&quot;, &quot;welcomeCar&quot;)


6、修改角色

    db.grantRolesToUser(
        &quot;sms&quot;,
        [
            { role: &quot;clusterMonitor&quot;, db:&quot;admin&quot;} 
        ]
    )
</code></pre><h4 id="conf配置文件"><a href="#conf配置文件" class="headerlink" title=".conf配置文件"></a>.conf配置文件</h4><pre><code>systemLog:
    destination: file
path: /usr/local/var/log/mongodb/mongo.log
    logAppend: true
storage:
    dbPath: /usr/local/var/mongodb
net:
    bindIp: 127.0.0.1
security:
    authorization:enabled      // 开启权限
</code></pre><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><h4 id="MongoDB导入、导出及数据库备份与恢复"><a href="#MongoDB导入、导出及数据库备份与恢复" class="headerlink" title="MongoDB导入、导出及数据库备份与恢复"></a>MongoDB导入、导出及数据库备份与恢复</h4><pre><code>1、mongoexport - 将 collection 导出成JSON或CSV格式

    mongoexport  -d 库名  -c collection名   -o 输出的文件名   --type 导出的格式json/csv  -f  输出的字段，如果type是CSV需要指定字段名

    Example: sudo mongoexport -d tun -c gt -o gentuanyou --type json


2、mongoimport - 将 collection 导入到

    mongoimport  -d 库名  -c colection名  --file 导入的文件名   --type 导入的格式  -f 导入的字段名  --headerline 如果导入是csv则可以使用第一行标题 


3、mongodump - 库备份

    mongodump  -h 服务器地址   -d 数据库名   -o 备份的位置

    Example: mongodump -h 127.0.0.1 -d tun -o /Users/apple/siguang.liu/mongoBackup


4、mongorestore - 数据库恢复

    mongorestore  -h 服务器地址  -d 需要恢复的数据库   --dir 备份数据的位置    [--drop 恢复先删除数据，然后恢复数据]

    mongorestore -h 127.0.0.1 -d tun --dir /Users/apple/siguang.liu/mongoBackup
</code></pre><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><pre><code>对MongoDB服务的运行情况和性能进行监控

1、mongostat、mongoStop      mongostat是mongdb自带的状态检测工具, 查看mongo运行状态的程序

    使用: 先到bin目录 cd /usr/local/Cellar/mongodb/3.4.3/bin                进行 mongostat目录 $ mongostat --help   来查看文档

            mongostat -h 127.0.0.1:123    -u用户名 -p密码        执行侦听

    日志: 

        http://www.cnmyColls.com/zhuque/archive/2013/03/29/2988577.html

        insert    插入数量
        query    查询数量
        update  更新数量
        delete     删除数量
        getmore 
        command 
        flushes    虚拟映射
        mapped     
        vsize   占磁盘的空间
        res     占内存大小
        idx miss 如果值过高，说明索引创建的有问题
        qrw     qr 读队列，qw 写队列 性能指标的一块，如果值比较高出现性能问题
        arw 
        net_in 
        net_out 
        conn    连接mongo的数量            
        time


2、profile 集合介绍

    db.getProfilingStatus();        // 获取


3、日志介绍

4、explain(): 

    db.users.find({id: 10000}).explain(&apos;executionStats&apos;)

        explain()三个参数：&apos;queryPlanner&apos;, &apos;executionStats&apos;, 和&apos;allPlansExecution&apos;

    result:
    {
        &quot;queryPlanner&quot; : {
            &quot;plannerVersion&quot; : 1,
            &quot;namespace&quot; : &quot;myCar.users&quot;,
            &quot;indexFilterSet&quot; : false,
            &quot;parsedQuery&quot; : {
                &quot;name&quot; : {
                    &quot;$eq&quot; : &quot;user99989&quot;
                }
            },
            &quot;winningPlan&quot; : {
                &quot;stage&quot; : &quot;COLLSCAN&quot;,
                &quot;filter&quot; : {
                    &quot;name&quot; : {
                        &quot;$eq&quot; : &quot;user99989&quot;
                    }
                },
                &quot;direction&quot; : &quot;forward&quot;
            },
            &quot;rejectedPlans&quot; : [ ]
        },
        &quot;executionStats&quot; : {
            &quot;executionSuccess&quot; : true,        // 是否成功
            &quot;nReturned&quot; : 1,                // 返回的数量
            &quot;executionTimeMillis&quot; : 49,        // *** 重要的执行时间   
            &quot;totalKeysExamined&quot; : 0,
            &quot;totalDocsExamined&quot; : 100000,    // 总共检查了多少个文档
            &quot;executionStages&quot; : {
                &quot;stage&quot; : &quot;COLLSCAN&quot;,
                &quot;filter&quot; : {
                    &quot;name&quot; : {
                        &quot;$eq&quot; : &quot;user99989&quot;
                    }
                },
                &quot;nReturned&quot; : 1,
                &quot;executionTimeMillisEstimate&quot; : 50,
                &quot;works&quot; : 100002,
                &quot;advanced&quot; : 1,
                &quot;needTime&quot; : 100000,
                &quot;needYield&quot; : 0,
                &quot;saveState&quot; : 783,
                &quot;restoreState&quot; : 783,
                &quot;isEOF&quot; : 1,
                &quot;invalidates&quot; : 0,
                &quot;direction&quot; : &quot;forward&quot;,
                &quot;docsExamined&quot; : 100000
            }
        },
        &quot;serverInfo&quot; : {
            &quot;host&quot; : &quot;appledeMacBook-Pro-2.local&quot;,
            &quot;port&quot; : 27017,
            &quot;version&quot; : &quot;3.4.3&quot;,
            &quot;gitVersion&quot; : &quot;f07437fb5a6cca07c10bafa78365456eb1d6d5e1&quot;
        },
        &quot;ok&quot; : 1
    }
</code></pre><h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><pre><code>Studio-3T、Robomongo
</code></pre><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><pre><code>1、使用mongoShell语句来通过_id查询更新时需要加ObjectId(&quot;&quot;), 如果程序处理不需要加

    db.col.update({_id: ObjectId(&quot;59acc404bef510c028190630&quot;)},{$set: {&apos;by&apos;: &apos;mongodb&apos;}})
</code></pre><h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><pre><code>1、首次安装 创建存放数据的目录时 $ sudo mkdir -p /data/db  如果这两个文件夹的权限是root那启动mongod就会报错，需要修改一下这两个目录的权限

    $ sudo chown apple:admin /data        // apple为我当前用户的名称

    $ sudo chown apple:admin /data/db

2、启动时如果提示 Failed to unlink socket file /tmp/mongodb-27017.sock errno:1 Operation not permitted

    因为/tmp/mongodb-27017.sock这个文件没有操作权限, 是root用户启动没成功后创建了这个文件
    需要到tmp目录下删除这个文件在重启

    $ cd /tmp &amp;&amp; sodu rm -rf mongodb-27017.sock
</code></pre><p>| 参考资料<br>|<br>| <a href="http://www.mongoing.com" target="_blank" rel="noopener">http://www.mongoing.com</a>            // 中文网站<br>| <a href="http://www.jianshu.com/p/dd0c39bf7be4" target="_blank" rel="noopener">http://www.jianshu.com/p/dd0c39bf7be4</a>                      // mongo安装<br>| <a href="http://www.runoob.com/mongodb/mongodb-objectid.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-objectid.html</a>      // 文档<br>| <a href="http://www.yiibai.com/mongodb/mongodb_drop_database.html" target="_blank" rel="noopener">http://www.yiibai.com/mongodb/mongodb_drop_database.html</a><br>| <a href="http://blog.csdn.net/jaylong35/article/details/7219410" target="_blank" rel="noopener">http://blog.csdn.net/jaylong35/article/details/7219410</a>  // 服务的开启与关闭<br>| <a href="http://blog.csdn.net/dbabruce/article/details/50963956" target="_blank" rel="noopener">http://blog.csdn.net/dbabruce/article/details/50963956</a>  // 用户权限<br>| <a href="http://www.cnblogs.com/qingtianyu2015/p/5968400.html" target="_blank" rel="noopener">http://www.cnblogs.com/qingtianyu2015/p/5968400.html</a>    // 库的导入、导出<br>| <a href="https://robomongo.org" target="_blank" rel="noopener">https://robomongo.org</a>     // mongoDB可视化工具<br>|<br>| <a href="http://blog.csdn.net/u013457382/article/category/6114612" target="_blank" rel="noopener">http://blog.csdn.net/u013457382/article/category/6114612</a><br>| <a href="http://www.cnblogs.com/zhongweiv/p/node_mongodb.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhongweiv/p/node_mongodb.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/02/mongoose/">Mongoose</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/02/mongoose/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-02T11:15:23.000Z" itemprop="datePublished">2017-04-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/数据库/">数据库</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>Schema[ˈskimə] - 数据库存储格式的约定协议，可以理解为数据表的字段类型声明。

Model -  由Schema转化的数据模型，具有抽象属性和行为的数据库操作，可以进行查询操作

Entity [ˈɛntɪti] - 由Model创建的实体，可以对数据库表进行完整的CRUD操作
</code></pre><h4 id="Mongoose使用"><a href="#Mongoose使用" class="headerlink" title="Mongoose使用"></a>Mongoose使用</h4><pre><code>一、安装 

    $ npm install mongoose      

二、引用

    const mongoose = require(&apos;mongoose&apos;);

    // connect()创建一个数据库连接
    let db = mongoose.connect(&apos;mongodb://car:welcomeCar@localhost/myCar&apos;);          // mongodb://用户名:密码@数据库IP/库名

    db.on(&apos;error&apos;, console.error.bind(console, &apos;connection error:&apos;));   // 连接失败
    db.once(&apos;open&apos;, function (callback) {    
        // yay! 连接成功
    });

    // 定义Schema文档结构
    let Schema = mongoose.Schema;
    let carSchema = new Schema({
        id: Number,
        carName: String,
        carPrice: Nuber,
        date: {type: Date, default: Date.now}
    })

    // 定义Model模型
    let carMode = db.model(&apos;cars&apos;, carSchema);

    // 定义一个Entity
    let carEntity = new carMode({
        id: 1,
        carName: &apos;路虎&apos;,
        carPrice: 700000
    })

    // 存储
    carEntity.save(function(err){
        if(err){
            console.log(&apos;存储错误&apos;)
        }
    })

    // 查找
    carMode.find({carName: &apos;路虎&apos;}, function(err, doc){
        if(err){
            console.log(err)
        }
        else{
            console.log(doc);
        }
    })
</code></pre><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><pre><code>mongoose两种连接： connect连单个db并打开，createConnect连接多个db

一、mongoose.connect()方法连接

    写法1:
        connect(&apos;mongodb://[username]:[password]@host:port/database?options...&apos;);   // 用户名、密码、主机、端口、库名、参数

        let db = mongoose.connect(&apos;mongodb://[username]:[password]@127.0.0.1:27017/myDB&apos;);


    写法2:
        -- conect(uri, options) --

        var options = {
            db: { native_parser: true },
            server: { poolSize: 5 },
            replset: { rs_name: &apos;myReplicaSetName&apos; },
            user: &apos;myUserName&apos;,
            pass: &apos;myPassword&apos;
        }
        var uri = &apos;mongodb://localhost/dbName?poolSize=4&apos;;
        mongoose.connect(uri, options);


二、多个连接

    -- mongoose.createConnection() --

    let mongoose = require(&apos;mongoose&apos;);
    let db = mongoose.connect(&apos;mongodb://127.0.0.1:27017/myDB&apos;);        // mongodb://IP:端口号/数据库名

    // 侦听打开的回调
    db.connection.on(&apos;error&apos;, function(error){
        console.log(&apos;数据库连接失败&apos;+error);
    })

    // 侦听连接成功
    db.connection.on(&apos;open&apos;, function(){
        console.log(&apos;连接成功&apos;)
    })


三、两者的区别

    var mongoose = require(&apos;mongoose&apos;);
    db = mongoose.createConnection(&apos;localhost&apos;, &apos;test&apos;);
    var schema = new mongoose.Schema({ name: String });
    var collectionName = &apos;kittens&apos;;
    var M = db.model(&apos;Kitten&apos;, schema, collectionName);

    var mongoose = require(&apos;mongoose&apos;);
    mongoose.connect(&apos;mongodb://localhost/test&apos;);
    db = mongoose.connection;
    db.once(&apos;open&apos;, function callback () {
        // yay!
    });    

    createConnection，可以open，但完全不会查询。第二种方法就可以
</code></pre><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><pre><code>Schema: 一种文件形式存储数据库模型的骨架，无法直接连接数据端，不具备操作数据库的能力，叫数据属性模型或集合

let personSchema = new mongoose.Schema({
    name: String,
    age: Number,
    email: String
})

二、实例方法

三、静态方法

四、indexes 索引

创建规则

    let Schema = mongoose.Schema;
    let carSchema = new Schema({
        name: String,
        title: { type: String, index: true },   // index 索引
        uid: { type: Number, unique: true },    // unique 独一无二的
        date: { type: Date, default: Date.now } // default 默认值
    })

    // 文档索引和字段索引
    let carSchema = new Schema({
        name: String,
        title: { type: [String], index: true },   // 字段索引
    })

    carSchema.index({ name: 1, type: -1});  // 
</code></pre><h4 id="Schema-Type"><a href="#Schema-Type" class="headerlink" title="Schema Type"></a>Schema Type</h4><pre><code>一、类型

    String：字符串
    Number：数值
    Date：日期
    Buffer： 二进制
    Boolean：布尔
    Mixed： 混合
    ObjectId： ObjectId
    Array：数组

二、其它参数

    default: 默认         // updated: { type: Date, default: Date.now }

    min/max: 最小或最大    // age: { type: Number, min: 18, max: 65 }

    trim: 去掉两端空格

    unique: true 指定字段为独一无二

三、Example

    var schema = new Schema({
        name:    String,
        binary:  Buffer,
        living:  Boolean,
        updated: { type: Date, default: Date.now }
        age:     { type: Number, min: 18, max: 65 }
        mixed:   Schema.Types.Mixed,
        _someId: Schema.Types.ObjectId,
        array:      [],
        ofString:   [String],
        ofNumber:   [Number],
        ofDates:    [Date],
        ofBuffer:   [Buffer],
        ofBoolean:  [Boolean],
        ofMixed:    [Schema.Types.Mixed],
        ofObjectId: [Schema.Types.ObjectId],
        nested: {
            stuff: { type: String, lowercase: true, trim: true }
        }
    })
</code></pre><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><pre><code>具有操作数据库的能力，类似管理数据库的属性和行的类

创建model  mongoose.model(&apos;集合名&apos;, schema);

    let personScheam = new Scheam({
        name: &apos;String&apos;,
        password: &apos;String&apos;
    }, {
        timestamps: true,             // 设置timestamps，多加两个字段createdTime、updatedTime，来记录插入时间和更新时间
        collection: &apos;report_warning_config&apos;,
    })

    let personModel = mongoose.model(&apos;person&apos;, personSchema);
</code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>一、find, findById, findOne, or where 

    let TankScheam = new Scheam({
        name: &apos;String&apos;,
        password: &apos;String&apos;
    })

    let Tank = mongoose.model(&apos;Tank&apos;, personSchema);

    Tank.find({size: &apos;samll&apos;}).where(&apos;createDate&apos;).gt(oneYear).exec(callback);

二、条件查询中常用属性

    $or　　　　或关系
    $nor　　　　或关系取反
    $gt　　　　大于
    $gte　　　　大于等于
    $lt　　　　小于
    $lte　　　　小于等于
    $ne　　　　不等于
    $in　　　　在多个值范围内
    $nin　　　　不在多个值范围内
    $all　　　　匹配数组中多个值
    $regex　　　　正则，用于模糊查询
    $size　　　　匹配数组大小
    $maxDistance　　　　范围查询，距离（基于LBS）
    $mod　　　　取模运算
    $near　　　　邻域查询，查询附近的位置（基于LBS）
    $exists　　　　字段是否存在
    $elemMatch　　　　匹配内数组内的元素
    $within　　　　范围查询（基于LBS）
    $box　　　　范围查询，矩形范围（基于LBS）
    $center　　　　范围醒询，圆形范围（基于LBS）
    $centerSphere　　　　范围查询，球形范围（基于LBS）
    $slice　　　　查询字段集合中的元素（比如从第几个之后，第N到第M个元素


三、方法

    1、where(&apos;price&apos;) - 查询的字段  Tank.find().where(&apos;price&apos;)

    2、find() - 查询所有，返回的是数组

    3、findOne({name: &apos;siguang&apos;}) - 只把第一条name为siguang的数据，如果find会将所有都返回

    4、findById(id) - 根据一条id来查找，返回的是一条记录的对象，而不是一个数组，与find({_id: &apos;59bf7ee03f55167fb6cdd75c&apos;})相同

    5、findByIdAndRemove(id) - 根据id查找，并删除这个条数据，如果查找不到返回 null

    6、findByIdAndUpdate(id, update) - 

    7、lean() - Tank.find().lean()      // 默认参数为true, 可以设置 lean(false)
</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>Tank.remove({size: &apos;large&apos;})

// 查找并删除
Tank.findByAndRemove()
</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><pre><code>Tank.update({_id: id}, {$set: {size: &apos;large&apos;}, callback);

// 查找并更新
Tank.findByIdAndUpdate(id, [update]);
</code></pre><h4 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h4><h4 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h4><pre><code>insert和update都需要save(),
</code></pre><h4 id="egg-mongose"><a href="#egg-mongose" class="headerlink" title="egg-mongose"></a>egg-mongose</h4><pre><code>1、在model中创建模型

    module.exports = app =&gt; {
        const mongoose = app.mongoose;

        const NewsSchema = new mongoose.Schema({
            newsTitle: {type: String, max: 32},
            newsContent: {type: String},
        },{
            timestamps: true,               // 插入记录时会自动创建一个createAt和updateAt时间字段
            collection: &apos;news&apos;,             // mongo中存的collection名
        });

        return mongoose.model(&apos;News&apos;, NewsSchema);      // News调用时的名
    }


2、在service中调用

    let doc = await app.model.News.find();

3、创建和查询

    const doc = await new app.model.User(user).save();          // 创建时需要new 

    const user = await app.model.User.findOne({_id: user._id});     // 查询时不需要new


4、使用find()查询 使用. ()

    如果使用find().lean()返回的是纯javascript对象，而不是mongoose文档，他们没有保存方法

    Example:

    const resourceTree = await app.model.Resource.find({});

        返回
        { _id: 5a535142fe6d170e82135e89,
            displayName: &apos;欢欢&apos;,
            username: &apos;huanhuan&apos;,
            mobile: 13012309874,
            email: &apos;huan@126.com&apos; 
        },
        { _id: 5a5357d2bd53b40f791362aa,
            username: &apos;maolv&apos;,
            displayName: &apos;毛驴&apos;,
            mobile: 13290984585,
            email: &apos;maolv@126.com&apos; 
        }

    const resourceTree = await app.model.Resource.find({}).lean();

        返回
        [
            { _id: 5a535142fe6d170e82135e89,
                displayName: &apos;欢欢&apos;,
                username: &apos;huanhuan&apos;,
                mobile: 13012309874,
                email: &apos;huan@126.com&apos; 
            },
            { _id: 5a5357d2bd53b40f791362aa,
                username: &apos;maolv&apos;,
                displayName: &apos;毛驴&apos;,
                mobile: 13290984585,
                email: &apos;maolv@126.com&apos; 
            }
        ]
</code></pre><blockquote>
<p><a href="http://www.nodeclass.com/api/mongoose.html" target="_blank" rel="noopener">http://www.nodeclass.com/api/mongoose.html</a><br><a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a>         egg-mongoose<br><a href="http://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="noopener">http://cnodejs.org/topic/504b4924e2b84515770103dd</a><br><a href="http://www.cnblogs.com/xuange306/p/4603551.html" target="_blank" rel="noopener">http://www.cnblogs.com/xuange306/p/4603551.html</a><br><a href="http://www.cnblogs.com/winyh/p/6682039.html" target="_blank" rel="noopener">http://www.cnblogs.com/winyh/p/6682039.html</a><br><a href="http://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="noopener">http://cnodejs.org/topic/504b4924e2b84515770103dd</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/06/nodeJS（之四）Strame/">nodeJS（之一）Stream</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/06/nodeJS（之四）Strame/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-06T02:43:21.000Z" itemprop="datePublished">2017-03-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createReadStream() - 创建可读流<br>| createWriteStream() - 创建可写流<br>| setEncodeing() - 设置编码<br>| </p>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><pre><code>Stream把较大的数据，拆分成小的部分

读取文件的两种: fs.readFile()和fs.createReadStream()

stream提供了以下四种类型的流：

    var Stream = require(&apos;stream&apos;);

    var Readable = Stream.Readable;
    var Writable = Stream.Writable;
    var Duplex = Stream.Duplex;
    var Transform = Stream.Transform;
</code></pre><h4 id="createReadStream-、createWriteStream"><a href="#createReadStream-、createWriteStream" class="headerlink" title="createReadStream()、createWriteStream()"></a>createReadStream()、createWriteStream()</h4><pre><code>// 创建一个Readable对象以读取bigFile内容
// 如果使用fs.readFile()可以会由于文件过大而失败
fs.createReadStream(bigFile);
</code></pre><h4 id="setEncodeing-设置编码"><a href="#setEncodeing-设置编码" class="headerlink" title="setEncodeing() 设置编码"></a>setEncodeing() 设置编码</h4><pre><code>var readerStream = fs.createReadStream(&apos;input.txt&apos;);

readerStream.setEncodeing(&apos;UTF8&apos;);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>可读数据流的事件

    readable 数据向外流时触发

    data 对于那些没有显式暂停的数据流，添加data事件监听函数，会将数据流切换到流动态，尽快向外提供数据

    end 读取完数据时触发。注意不能和 writeableStream.end() 混淆，writeableStream 并没有 end 事件，只有 .end() 方法

    close 数据源关闭时触发

    error 读取数据发生错误时触发


可写数据流的事件

    drain writable.write(chunk) 返回 false 之后，缓存全部写入完成，可以重新写入时就会触发

    finish 调用 .end 方法时，所有缓存的数据释放后触发，类似于可读数据流中的 end 事件，表示写入过程结束

    pipe 作为 pipe 目标时触发

    unpipe 作为 unpipe 目标时触发

    error 写入数据发生错误时触发
</code></pre><p>| <a href="https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8" target="_blank" rel="noopener">https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8</a><br>| <a href="http://fe.meituan.com/stream-basics.html" target="_blank" rel="noopener">http://fe.meituan.com/stream-basics.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/04/nodeJS（之三）Buffer/">nodeJS (之三) Buffer</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/04/nodeJS（之三）Buffer/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-04T10:30:21.000Z" itemprop="datePublished">2017-03-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| Buffer.from() - 创建buffer  // 老方法 new Buffer(str, encode);<br>| toString() - Buffer转字符串<br>| length - 返回Buffer的长度<br>| concat([buf1, buf2], 输出的长度) - 合并<br>| slice(start, end) - 截取<br>| copy(buffer, 开始目标位置, start, end) - 拷贝<br>| compare() - 比较两个buffer的大小<br>| fill() - 用指定的值填充Buffer<br>| indexOf(val) - 返回指定字符所在Buffer的位置<br>| lastIndexOf() - 从后向前查找<br>| includes(val, begin, uncode) - 查找是否存在<br>| keys() - 获取<br>| write() - 向指定的buffer写入内容<br>|<br>| Buffer.isBuffer(buf) - 是否是一个buffer<br>| Buffer.isEncoding(‘utf-8’) - 检测是否是一个有效的编码<br>| Buffer.byteLength - 判断字符的长度</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><pre><code>Buffer用于创建存放和处理二进制数据的缓存区，buffer是全局不需要require(&apos;buffer&apos;)

网络上发送和接收经常是以二进制传输数据:

    - 通过TCP连接发送和接收数据；
    - 从图像或者压缩文件读取二进制数据；
    - 从文件系统读写数据；
    - 处理来自网络的二进制数据流


1、字节byte: 1个字节等于8位二进制

       位bit: 每位存储0或1，每8位等于一个字节，最大0-255字节

       一个汉字三个字节，其它两个字节


2、Node.js 目前支持的字符编码包括: 

    &apos;ascii&apos; - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。

    &apos;utf8&apos; - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。

    &apos;utf16le&apos; - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。

    &apos;ucs2&apos; - &apos;utf16le&apos; 的别名。

    &apos;base64&apos; - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。

    &apos;latin1&apos; - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。

    &apos;binary&apos; - &apos;latin1&apos; 的别名。

    &apos;hex&apos; - 将每个字节编码为两个十六进制字符。
</code></pre><h4 id="new-Buffer"><a href="#new-Buffer" class="headerlink" title="new Buffer"></a>new Buffer</h4><pre><code>new Buffer(size): 创建一个Buffer对象, 并返回一个数组

Buffer创建的三种类型:

    1、new Buffer(2)            // 创建buffer的长度

        let buf = new Buffer(2);
        buf[1] = &apos;232&apos;;
        buf[2] = &apos;2312&apos;;
        buf[3] = &apos;asasdf&apos;;
        console.log(&apos;输出buffer: &apos;, buf);        // 输出buffer:  &lt;Buffer 00 e8&gt;  只能输出两个字节

    2、new Buffer(数组)            // new Buffer([1,3,5])

    3、new Buffer(字符串)        // new Buffer(&apos;我&apos;)
</code></pre><h4 id="字符串与buffer互转"><a href="#字符串与buffer互转" class="headerlink" title="字符串与buffer互转"></a>字符串与buffer互转</h4><pre><code>1、字符串转buffer

    let buf = new Buffer(&apos;sss&apos;)
    console.log(buf);            // &lt;Buffer 73 73 73&gt;


2、toString(编码, 获取开始位置 , 获取结束位置): buffer转换成字符串

    let buf = Buffer.from(&apos;sss&apos;);
    console.log(buf);            // Buffer e7 be 8e e5 a5 bd  输出的6个字符
    console.log(buf.length);    // 6 buffer的长度
    console.log(&apos;输出buffer: &apos;, buf.toString(&apos;utf-8&apos;, 3, 6));    // 输出好     
</code></pre><h4 id="length-获取长度"><a href="#length-获取长度" class="headerlink" title="length 获取长度"></a>length 获取长度</h4><pre><code>let buf = new Buffer(&apos;sssss&apos;);
console.log(buf.length);     // 5
</code></pre><h4 id="concat-要合并的数据集合-要输出的长度-合并"><a href="#concat-要合并的数据集合-要输出的长度-合并" class="headerlink" title="concat([ 要合并的数据集合 ], 要输出的长度):  合并"></a>concat([ 要合并的数据集合 ], 要输出的长度):  合并</h4><pre><code>let buf1 = new Buffer(&apos;忍&apos;);
let buf2 = new Buffer(&apos;者&apos;);
let buf3 = new Buffer(&apos;神&apos;);
let buf4 = new Buffer(&apos;龟&apos;);

let newBuf = Buffer.concat([buf1, buf2, buf3, buf4]);
console.log(newBuf);                // 12字节
console.log(newBuf.toString());     // 输出忍者神龟
</code></pre><h4 id="slice-start-end-截取"><a href="#slice-start-end-截取" class="headerlink" title="slice(start, end): 截取"></a>slice(start, end): 截取</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
console.log(buf.slice(9, 15).toString());        // 返回 截取
</code></pre><h4 id="copy-buffer-开始目标位置-start-end-拷贝"><a href="#copy-buffer-开始目标位置-start-end-拷贝" class="headerlink" title="copy(buffer, 开始目标位置, start, end): 拷贝"></a>copy(buffer, 开始目标位置, start, end): 拷贝</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
let copyBuf = new Buffer(9);
buf.copy(copyBuf, 6, 0, 9);     // 从buf的第六个字节开始,0到9字符copy

console.log(copyBuf.toString());        // 输出 来截取
</code></pre><h4 id="Buffer-byteLength-判断字符的长度"><a href="#Buffer-byteLength-判断字符的长度" class="headerlink" title="Buffer.byteLength:  判断字符的长度"></a>Buffer.byteLength:  判断字符的长度</h4><h4 id="toString-Buffer转字符串"><a href="#toString-Buffer转字符串" class="headerlink" title="toString() Buffer转字符串"></a>toString() Buffer转字符串</h4><pre><code>toString([字符编码], [开始转换位置], [结束转换位置])

let buf = new Buffer(&apos;哈哈哈&apos;);
console.log(buf.toString(&apos;utf8&apos;));        // urt8输出为 哈哈哈

可以转换成:  ascii、utf8、utf16le、ucs2、base64
</code></pre><h4 id="compare-比较buffer"><a href="#compare-比较buffer" class="headerlink" title="compare() 比较buffer"></a>compare() 比较buffer</h4><pre><code>返回比较结果: 0 两个buffer相等， -1 前者小于后者， 1 前者大于后者

const bufA = new Buffer(&apos;123345&apos;);
const bufB = new Buffer(&apos;123345aaaaa&apos;);
const result = bufA.compare(bufB);

switch(result){
    case -1: 
        console.log(`bufA 小于 bufB`);
        break;

    case 0: 
        console.log(`bufA 等于 bufB`);
        break;

    case 1: 
        console.log(`bufA 大于 bufB`);
        break;

    default: break;
}
</code></pre><h4 id="fill-用指定的值来填充Buffer"><a href="#fill-用指定的值来填充Buffer" class="headerlink" title="fill() 用指定的值来填充Buffer"></a>fill() 用指定的值来填充Buffer</h4><pre><code>fill(val,[offset], [end], [encode]): 用指定的值来填充Buffer

Example:
    let buf = new Buffer(5);    
    buf.fill(&apos;#&apos;);
    console.log(buf);
</code></pre><p>/<strong><strong><strong>**</strong></strong></strong> 查找与搜索  <strong><strong><strong>*</strong></strong></strong>/</p>
<h4 id="indexOf-返回指定字符所在Buffer的位置"><a href="#indexOf-返回指定字符所在Buffer的位置" class="headerlink" title="indexOf() 返回指定字符所在Buffer的位置"></a>indexOf() 返回指定字符所在Buffer的位置</h4><pre><code>let buf = new Buffer(&apos;aabbbccc&apos;);
console.log(buf.indexOf(&apos;b&apos;));      // 返回2 如果不存在返回-1
</code></pre><h4 id="lastIndexOf-从尾查找所在的位置"><a href="#lastIndexOf-从尾查找所在的位置" class="headerlink" title="lastIndexOf() 从尾查找所在的位置"></a>lastIndexOf() 从尾查找所在的位置</h4><h4 id="includes-val-返回指定字符是否存在"><a href="#includes-val-返回指定字符是否存在" class="headerlink" title="includes(val) 返回指定字符是否存在"></a>includes(val) 返回指定字符是否存在</h4><pre><code>includes(搜索的值, [buf开始搜索的位置], [搜索的编码])

Example:
    let buf = new Buffer(&apos;aaabbbcccddd&apos;);
    console.log(buf.includes(&apos;b&apos;, 2));     // true 或  false
</code></pre><h4 id="keys-把buffer中的数组下标"><a href="#keys-把buffer中的数组下标" class="headerlink" title="keys() 把buffer中的数组下标"></a>keys() 把buffer中的数组下标</h4><pre><code>const buf = new Buffer(&apos;buffer&apos;);
console.log(buf)

for(const key of buf.keys()){
    console.log(key);            // 0、1、2、3、4、5
}
</code></pre><h4 id="write-将值写入到buffer的指定位置"><a href="#write-将值写入到buffer的指定位置" class="headerlink" title="write() 将值写入到buffer的指定位置"></a>write() 将值写入到buffer的指定位置</h4><pre><code>write(string, [写入的位置], [写入的字节], [字符编码])
</code></pre><h4 id="Buffer-isBuffer-判断是否是Buffer"><a href="#Buffer-isBuffer-判断是否是Buffer" class="headerlink" title="Buffer.isBuffer() 判断是否是Buffer"></a>Buffer.isBuffer() 判断是否是Buffer</h4><pre><code>let str = &apos;&apos;;
let buf = new Buffer(10);
console.log(Buffer.isBuffer(str));      // false
console.log(Buffer.isBuffer(buf));      // true
</code></pre><h4 id="Buffer-isEncoding-endcode-判断编码"><a href="#Buffer-isEncoding-endcode-判断编码" class="headerlink" title="Buffer.isEncoding(endcode): 判断编码"></a>Buffer.isEncoding(endcode): 判断编码</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/03/nodeJS（之六）QueryString/">nodeJS（之六）Querystring</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/03/nodeJS（之六）QueryString/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-03T07:54:45.000Z" itemprop="datePublished">2017-03-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="parse-str-sep-eq-options-解析url的查询字符串"><a href="#parse-str-sep-eq-options-解析url的查询字符串" class="headerlink" title="parse(str, [sep], [eq], [options]) 解析url的查询字符串"></a>parse(str, [sep], [eq], [options]) 解析url的查询字符串</h4><pre><code>var param = &apos;user=siguang&amp;age=30&apos;;
qs.parse(param).user;    // &apos;siguang&apos;
</code></pre><h4 id="stringify-obj-sep-eq-将对象转成url的参数字符串"><a href="#stringify-obj-sep-eq-将对象转成url的参数字符串" class="headerlink" title="stringify(obj, [sep], [eq])  将对象转成url的参数字符串"></a>stringify(obj, [sep], [eq])  将对象转成url的参数字符串</h4><pre><code>const obj = {name: &apos;一介布衣&apos;, url: &apos;http://yijiebuyi.com&apos;};
const param = querystring.stringify(obj);
console.log(param);            // name=%E4%B8%80%E4%BB%8B%E5%B8%83%E8%A1%A3&amp;url=http%3A%2F%2Fyijiebuyi.com

qs.stringify({foo: &apos;bar&apos;, baz: &apos;qux&apos;}, &apos;;&apos;, &apos;:&apos;)
// 返回 &apos;foo:bar;baz:qux&apos;
</code></pre><h4 id="escape-str-字符进行编码"><a href="#escape-str-字符进行编码" class="headerlink" title="escape(str) 字符进行编码"></a>escape(str) 字符进行编码</h4><pre><code>let url = &apos;https://github.com/siguang1983&apos;;
console.log(qs.escape(url));        // https%3A%2F%2Fgithub.com%2Fsiguang1983
</code></pre><h4 id="unescape-str-字符进行解码"><a href="#unescape-str-字符进行解码" class="headerlink" title="unescape(str) 字符进行解码"></a>unescape(str) 字符进行解码</h4><pre><code>let code = &apos;https%3A%2F%2Fgithub.com%2Fsiguang1983&apos;;
console.log(qs.unescape(url));        // https://github.com/siguang1983
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/02/nodeJS（之七）URL/">nodeJS（之七）URL</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/02/nodeJS（之七）URL/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-02T10:05:25.000Z" itemprop="datePublished">2017-03-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| URL 用于URL的处理和解析<br>| const url = require(‘url’)    // 引用</p>
<h4 id="href-解析后的完整url"><a href="#href-解析后的完整url" class="headerlink" title="href 解析后的完整url"></a>href 解析后的完整url</h4><pre><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;
</code></pre><h4 id="protocol-返回协议-‘http’"><a href="#protocol-返回协议-‘http’" class="headerlink" title="protocol 返回协议 ‘http’"></a>protocol 返回协议 ‘http’</h4><h4 id="host-返回主机和端口"><a href="#host-返回主机和端口" class="headerlink" title="host 返回主机和端口"></a>host 返回主机和端口</h4><h4 id="auth-返回-URL-的用户名与密码部分"><a href="#auth-返回-URL-的用户名与密码部分" class="headerlink" title="auth 返回 URL 的用户名与密码部分"></a>auth 返回 URL 的用户名与密码部分</h4><h4 id="hostname-主机"><a href="#hostname-主机" class="headerlink" title="hostname 主机"></a>hostname 主机</h4><h4 id="port-端口"><a href="#port-端口" class="headerlink" title="port 端口"></a>port 端口</h4><h4 id="pathname-URL的整个路径部分"><a href="#pathname-URL的整个路径部分" class="headerlink" title="pathname URL的整个路径部分"></a>pathname URL的整个路径部分</h4><h4 id="search-获取url参数-‘-query-string’-包括-号"><a href="#search-获取url参数-‘-query-string’-包括-号" class="headerlink" title="search 获取url参数 ‘?query=string’  包括?号"></a>search 获取url参数 ‘?query=string’  包括?号</h4><h4 id="path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’"><a href="#path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’" class="headerlink" title="path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’"></a>path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’</h4><h4 id="query-返回参数对象返回-‘query-string’-or-‘query’-‘string’"><a href="#query-返回参数对象返回-‘query-string’-or-‘query’-‘string’" class="headerlink" title="query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}"></a>query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}</h4><h4 id="hash-返回hash部分-‘-’"><a href="#hash-返回hash部分-‘-’" class="headerlink" title="hash 返回hash部分 ‘#’"></a>hash 返回hash部分 ‘#’</h4><h4 id="url-format-urlObject-根据对象构建一个路径"><a href="#url-format-urlObject-根据对象构建一个路径" class="headerlink" title="url.format(urlObject) 根据对象构建一个路径"></a>url.format(urlObject) 根据对象构建一个路径</h4><pre><code>var obj = { 
    protocol: &apos;https&apos;,
    host: &apos;www.sss.com:4000&apos;,
    pathname: &apos;index&apos; 
}
url.format(obj)
//returns &apos;https://www.sss.com:4000/index&apos;
</code></pre><h4 id="parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符"><a href="#parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符" class="headerlink" title="parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符"></a>parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符</h4><pre><code>exports.createServer2 = function(){
    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url);
        console.log(&apos;路径&apos;, oUrl);               
    });

    server.listen(8081, &apos;localhost&apos;);
}

返回：
{
    protocol: null,            // 协议 http
    slashes: null,
    auth: null,                // 身份
    host: null,                // 主机    
    port: null,                // 端口
    hostname: null,            // 主机名
    hash: null,
    search: null,
    query: null,            // 查询参数或者使用querystring.parse() 返回{username:&apos;siguang&apos;};
    pathname: &apos;/apples/&apos;,    // 路径名
    path: &apos;/apples/&apos;,        // 路由
    href: &apos;/apples/&apos;         // 链接
}
</code></pre><h4 id="resolve-from-to-两个网址拼接"><a href="#resolve-from-to-两个网址拼接" class="headerlink" title="resolve(from, to) 两个网址拼接"></a>resolve(from, to) 两个网址拼接</h4><pre><code>url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;
</code></pre><h4 id="slashes"><a href="#slashes" class="headerlink" title="slashes"></a>slashes</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之五）Path/">nodeJS基 (之五) Path模块</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之五）Path/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| baseName() - 返回文件名，带扩展<br>| dirname() - 返回一个指定的绝对路径<br>| join() - 两个路径进行拼接<br>| extname() - 返回文件的扩展名<br>| isAbsolute() - 是否是一个绝对路径<br>| resolve() - 把路径解析成一个绝对路径<br>| format() - 从配置中返回一个路径<br>| parse() - 拆分一个路径，与format相反</p>
<h4 id="baseName-返回文件名-带扩展名"><a href="#baseName-返回文件名-带扩展名" class="headerlink" title="baseName(): 返回文件名(带扩展名)"></a>baseName(): 返回文件名(带扩展名)</h4><pre><code>let name = path.basename(&apos;./resource/haha.txt&apos;, &apos;.txt&apos;);    // 返回 haha
let allName = path.basename(&apos;./resource/haha.txt&apos;);         // 返回 haha.txt
</code></pre><h4 id="dirname-返回一个path目录"><a href="#dirname-返回一个path目录" class="headerlink" title="dirname() 返回一个path目录"></a>dirname() 返回一个path目录</h4><pre><code>let pathName = path.dirname(&apos;./&apos;);
console.log(pathName, __dirname);
</code></pre><h4 id="extname-fileStr-返回文件的扩展名"><a href="#extname-fileStr-返回文件的扩展名" class="headerlink" title="extname(fileStr) 返回文件的扩展名"></a>extname(fileStr) 返回文件的扩展名</h4><pre><code>let extension = path.extname(&apos;权限申请.xlsx&apos;);
console.log(extension);        // .xlsx
</code></pre><h4 id="isAbsolute-path-判断path是否是一个绝对路径"><a href="#isAbsolute-path-判断path是否是一个绝对路径" class="headerlink" title="isAbsolute(path) 判断path是否是一个绝对路径"></a>isAbsolute(path) 判断path是否是一个绝对路径</h4><pre><code>var absolutePath =  path.isAbsolute(&apos;./ss&apos;);
var notAbsolutePath = path.isAbsolute(&apos;/Users/apple/&apos;)
console.log(absolutePath);      // false
console.log(notAbsolutePath);   // true
</code></pre><h4 id="join-paths-多个路径拼接成一个路径"><a href="#join-paths-多个路径拼接成一个路径" class="headerlink" title="join(paths) 多个路径拼接成一个路径"></a>join(paths) 多个路径拼接成一个路径</h4><pre><code>let pathStr = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;);
let parentDirectory = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;, &apos;..&apos;);    // ..减少一级目录
console.log(pathStr);           // /foo/bar/bar/asdf/quux
console.log(parentDirectory);   // /foo/bar/bar/asdf
</code></pre><h4 id="resolve-p1-p2-把路径解析为一个绝对路径"><a href="#resolve-p1-p2-把路径解析为一个绝对路径" class="headerlink" title="resolve(p1, p2) 把路径解析为一个绝对路径"></a>resolve(p1, p2) 把路径解析为一个绝对路径</h4><pre><code>var newPath = path.resolve(__dirname, &apos;sss.txt&apos;);
console.log(newPath);
</code></pre><h4 id="format-pathobject-从配置对象返回一个路径字符串"><a href="#format-pathobject-从配置对象返回一个路径字符串" class="headerlink" title="format(pathobject) 从配置对象返回一个路径字符串"></a>format(pathobject) 从配置对象返回一个路径字符串</h4><pre><code>let basePath = path.format({
    root: &apos;/book&apos;,
    dir: &apos;/home/user/dir&apos;,
    base: &apos;file.txt&apos;
})
console.log(basePath);      // output -&gt;  /home/user/dir/file.txt
</code></pre><h4 id="parse-path-将一个路径拆分与format相反"><a href="#parse-path-将一个路径拆分与format相反" class="headerlink" title="parse(path) 将一个路径拆分与format相反"></a>parse(path) 将一个路径拆分与format相反</h4><pre><code>let pathStr = path.parse(__dirname);
console.log(pathStr);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之八）HTTP/">nodeJS（之八）HTTP</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之八）HTTP/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h4><pre><code>let http = require(&apos;http&apos;);        // 导入http模块

HTTP协议构建就是在请求和响应上，由http.ServerRequest和http.ServerResponse构造出来的。
</code></pre><h4 id="http-server类"><a href="#http-server类" class="headerlink" title="http.server类"></a>http.server类</h4><pre><code>是一个创建服务的类 ServerRequest()

方法:

    1、close([callback]): 停止服务器连接

    2、listen(path, [callback]): 侦听, 与TCP使用方法相同

属性:

    1、listening: 返回是否在监听连接服务器的布尔值

    2、maxHeadersCount: 限制最大的请求头数据，默认2000

    3、keepAliveTimeout

    3、setTimeout(msecs, callback): 为socket设置超时值，如果一个超时发生

事件

    1、connect - 请求时触发


Example:

    const HOST = &apos;127.0.0.1&apos;;
    const PORT = 3000;

    // 创建服务器
    let server = http.createServer((req, res) =&gt; {
        console.log(&apos;请求方法:&apos;, request.method);       // 请求方法
        console.log(&apos;请求url:&apos;, request.url);          // 请求url
        console.log(&apos;请求头:&apos;, request.headers);       // 请求头

        res.writeHead(200);
        res.end(&apos;hello world&apos;);    
    })            

    // 侦听3000端口
    server.listen(PORT, HOST, ()=&gt; {
        console.log(`server running at http://${hostname}:${port}`);
    })
</code></pre><h4 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h4><pre><code>url - 返回url地址

method - 返回请求方法
</code></pre><h4 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h4><pre><code>// 这里res返回的就是ServerResponse类
const server = http.createServer((req, res) =&gt; { ..... });   

方法:

    1、addTrailers(headers)

    2、end([data],[encoding],[callback]) - 告诉服务器所有响应头和主体都已被发送，等同于response.write()

    3、finished: 

    4、getHeader(name): 

    5、headersSent: 返回消息头是否被发送，发送为true否则false

    6、removeHeader(name): 移出一个头消息 response.removeHeader(&apos;Content-Encoding&apos;);

    7、sendDate: 如果设置为true消息头存在日期消息头则自动生成并且响应在发送

    8、setHeader(name, value): 设置头信息

        response.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);
        response.setHeader(&apos;Set-Cookie&apos;, [&apos;type=ninja&apos;, &apos;language=javascript&apos;]);

    9、setTimeout(msecs, callback): 设置 socket 的超时时间

    10、statusCode: 设置向客户端响应的状态码  res.statusCode = 200;

    11、statusMessage

    12、write(chunk[, encoding][, callback])

    13、writeContinue()

    14、writeHead(statusCode[, statusMessage][, headers]): 发送一个响应头给请求

        writeHead(状态码, [状态消息], {响应头信息})

        Example: res.writeHead(200, { content-Type: &apos;text/html&apos;, Connection: &apos;keep-alive&apos;})

    15、setEncoding(编码): 设置编码格式 res.setEncoding(&apos;utf8&apos;);


res.connection

事件:

    1、close - 关闭连接，会自动调用response.end();

    2、finish - 当响应已被发送时触发
</code></pre><h4 id="http-IncomingMessage-类"><a href="#http-IncomingMessage-类" class="headerlink" title="http.IncomingMessage 类"></a>http.IncomingMessage 类</h4><pre><code>const server = http.createServer((req, res) =&gt; { ..... });  就是req返回的类

1、headers: 客户端的请求头

2、method: 获取请求方式

3、url: 请求url

4、statusCode: 状态码

5、statusMessage: 状态消息

6、socket: 与连接有关的 net.Socket 对象。

7、destroy([error])

8、httpVersion: http的版本

9、rawHeaders

10、rawTrailers

11、setTimeout(msecs, callback)

12、trailers
</code></pre><h4 id="http-createServer-创建server服务"><a href="#http-createServer-创建server服务" class="headerlink" title="http.createServer(): 创建server服务"></a>http.createServer(): 创建server服务</h4><h4 id="http-get-options-callback-用来模拟客户端向服务器发送请求"><a href="#http-get-options-callback-用来模拟客户端向服务器发送请求" class="headerlink" title="http.get(options, [callback]): 用来模拟客户端向服务器发送请求"></a>http.get(options, [callback]): 用来模拟客户端向服务器发送请求</h4><pre><code>Example： 请求nodejs.org的index.json文件，返回json的内容

const http = require(&apos;http&apos;);

http.get(&apos;http://nodejs.org/dist/index.json&apos;, (res) =&gt; {
    const statusCode = res.statusCode;
    const contentType = res.headers[&apos;content-type&apos;];

    let error;
    if (statusCode !== 200) {
        error = new Error(`请求失败。\n` +
            `状态码: ${statusCode}`);
    } else if (!/^application\/json/.test(contentType)) {
        error = new Error(`无效的 content-type.\n` +
            `期望 application/json 但获取的是 ${contentType}`);
    }
    if (error) {
        console.log(error.message);
        // 消耗响应数据以释放内存
        res.resume();
        return;
    }

    res.setEncoding(&apos;utf8&apos;);
    let rawData = &apos;&apos;;
    res.on(&apos;data&apos;, (chunk) =&gt; rawData += chunk);
    res.on(&apos;end&apos;, () =&gt; {
        try {
            let parsedData = JSON.parse(rawData);
            console.log(parsedData);
        } catch (e) {
            console.log(e.message);
        }
    });
}).on(&apos;error&apos;, (e) =&gt; {
    console.log(`错误: ${e.message}`);
});
</code></pre><h4 id="http-request-options-callback-模拟HTTP请求"><a href="#http-request-options-callback-模拟HTTP请求" class="headerlink" title="http.request(options, [callback]): 模拟HTTP请求"></a>http.request(options, [callback]): 模拟HTTP请求</h4><pre><code>options:

    protocol &lt;String&gt; 使用的协议。默认为 &apos;http:&apos;。

    host &lt;String&gt; 请求发送至的服务器的域名或 IP 地址。默认为 &apos;localhost&apos;。

    hostname &lt;String&gt; host 的别名。为了支持 url.parse()，hostname 优于 host。

    family &lt;Number&gt; 当解析 host 和 hostname 时使用的 IP 地址族。 有效值是 4 或 6。当未指定时，则同时使用 IP v4 和 v6。

    port &lt;Number&gt; 远程服务器的端口。默认为 80。

    localAddress &lt;String&gt; 要绑定到网络连接的本地接口。

    socketPath &lt;String&gt; Unix 域 Socket（使用 host:port 或 socketPath 的其中之一）。

    method &lt;String&gt; 一个指定 HTTP 请求方法的字符串。默认为 &apos;GET&apos;。

    path &lt;String&gt; 请求的路径。默认为 &apos;/&apos;。 应包括查询字符串（如有的话）。如 &apos;/index.html?page=12&apos;。 
    当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。

    headers &lt;Object&gt; 一个包含请求头的对象。

    auth &lt;String&gt; 基本身份验证，如 &apos;user:password&apos; 来计算 Authorization 头。

    agent &lt;http.Agent&gt; | &lt;Boolean&gt; 控制 Agent 的行为。 当使用 Agent 是，请求默认为 Connection: keep-alive。 可能的值有：
    undefined (默认): 对该主机和端口使用 http.globalAgent。

    Agent 对象：显式地使用传入的 Agent。

    false: 不对连接池使用 Agent，默认请求 Connection: close。

    createConnection &lt;Function&gt; 当不使用 agent 选项时，产生一个用于请求的 socket/stream 的函数。 这可以用于避免创建一个自定义的 Agent 类，只是为了覆盖默认的 createConnection 函数。详见 agent.createConnection()。

    timeout &lt;Integer&gt;: 一个数值，指定 socket 超时的毫秒数。 它会在 socket 被连接时设置超时。


Example:

    var postData = querystring.stringify({
            &apos;msg&apos; : &apos;Hello World!&apos;
        });

    var options = {
        hostname: &apos;www.google.com&apos;,
        port: 80,
        path: &apos;/upload&apos;,
        method: &apos;POST&apos;,
        headers: {
            &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,
            &apos;Content-Length&apos;: Buffer.byteLength(postData)
        }
    };

    var req = http.request(options, (res) =&gt; {
        console.log(`STATUS: ${res.statusCode}`);
        console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
        res.setEncoding(&apos;utf8&apos;);
        res.on(&apos;data&apos;, (chunk) =&gt; {
            console.log(`主体: ${chunk}`);
        });
        res.on(&apos;end&apos;, () =&gt; {
            console.log(&apos;响应中已无数据。&apos;);
        });
    });

    req.on(&apos;error&apos;, (e) =&gt; {
        console.log(`请求遇到问题: ${e.message}`);
    });

    // 写入数据到请求主体
    req.write(postData);
    req.end();
</code></pre><h4 id="http概念"><a href="#http概念" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、请求方法:

    Get: 请求从服务器获取数据，没有请求体，不会影响服务器数据

    Post: 从服务器获取数据，有请求体，会影响服务器端的数据

    DELETE: 从服务器删除资源

    HEAD: 向服务器获取响应头，不要响应体

    PUT: 要新的服务器一个资源

    OPTIONS: 获取服务器支持的方法


2、文件类型 Content-type

    html: text/html

    ASCII文本: text/plain

    jpeg图片: image/jpeg

    GIF图片: image/gif

    javascript: text/javascript

    css: text/css

    表单: application/x-www-form-urlencoded



# 获取 index.html 文件内容返回给客户端

    var http = require(&apos;http&apos;);
    var fs = require(&apos;fs&apos;);

    exports.createServer2 = function(){
        var server = http.createServer(function(request, response){

            var url = request.url;

            // 获取 index.html 文件内容返回给客户端
            fs.readFile(&apos;./index.html&apos;, &apos;utf-8&apos;, function(err, data){
                console.log(err, data);

                response.write(data);
                response.end();
            })
        });

        server.listen(8081, &apos;localhost&apos;);
    }


# 处理Get请求的参数

    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url, true);

        console.log(oUrl.query);        // { username: &apos;siguang&apos;, age: &apos;30&apos; }

        var urlQuery = oUrl.query;
        if(urlQuery){
            response.write(&apos;服务器接收GET请求参数成功\n&apos;)
            response.write(&apos;用户名:&apos;+ urlQuery.username +&apos;\n&apos;);
            response.write(&apos;年级:&apos;+ urlQuery.age +&apos;\n&apos;);
        }
        else{
            response.write(&apos;服务器接收参数失败&apos;);
        }
        response.end();
    });

    server.listen(8081, &apos;localhost&apos;);


# 处理POST请求

    if(urlObj.pathname == &apos;/register&apos;){           // 处理 &apos;/clock&apos; 的请求
        var str = &apos;&apos;;
        var userList = {};

        // 通过on来侦听 data事件, data事件就是接收客户端传输过来的事件, 用可接收post的数据
        request.on(&apos;data&apos;, function(data){
            console.log(data.toString());          // 返回的是 Buffer
            str += data.toString();
        })

        // 所有接收完成后处理接收数据
        request.on(&apos;end&apos;, function(data){
            userList = JSON.parse(str);

            response.writeHead(&apos;200&apos;, {&apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;});
            if(userList.username == &apos;aaa&apos; &amp;&amp; userList.password == &apos;ssssss&apos;){
                 response.end(JSON.stringify({&quot;res&quot;:true,&quot;message&quot;:&quot;注册成功&quot;}));        // 这里一定要用JSON.stringify来转成串
            }
            else{
                response.end(JSON.stringify({&apos;res&apos;:false,&apos;message&apos;:&apos;注册失败&apos;}));
            }
            response.end();
        })
    }

    注意：

        1、客户端发送ajax请求时

            如果data是字符串，接收过来就是 &apos;{&apos;username&apos;: &apos;aaa&apos;, &apos;password&apos;: &apos;ssssss&apos;}&apos; 字符串可以直接转成json,

            如果data传的是一个对象，jquery会转成&quot;{&apos;username&apos;=&apos;aaa&apos;&amp;&apos;password&apos;=&apos;ssssss&apos;}&quot;, 还需要node重组
</code></pre><h4 id="http概念-1"><a href="#http概念-1" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、up 工具 通过nodeAPI来监听文件或目录下所有文件，如果有文件改变不需要重启服务器

    $ sudo npm i up -g   

    运行命令: up -watch -port 8080 server.js 
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之九）Connect中间件/">nodeJS（之九）Connect中间件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之九）Connect中间件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><pre><code>Connect是HTTP服务的中间件

$ 安装 npm i connect --save


// 引用模块
var connect = require(&apos;connect&apos;);

// 创建服务器
var server = connect.createServer();

// 处理静态文件
server.use(connect.static(__dirname + &apos;/statice&apos;));     // connect.static 静态文件目录

// 监听
server.listen(3000);
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>1、静态目录设置 -  server.use(connect.static(__dirname + &apos;/statice&apos;));

2、客户端缓存时间 -  server.use(connect.static(__dirname + &apos;/statice&apos;), {maxAge: 100000});

3、静态文件以&quot;.&quot;开始都认为是隐藏文件 - server.use(connect.static(__dirname + &apos;/statice&apos;), {hidden: true});

4、query中间件，解析字符串  &apos;/posts?page=5&apos;

    server.use(connect.query);
    server.use(function(req, res){
        let page = req.query.page;
    })

5、logger，打印日志，四种日志格式，default/dev/short/tiny

    connect.createServer(
        connect.logger(&apos;dev&apos;),
        function(req, res){
            res.writeHead(200);
            res.end(&apos;hello);
        }
    )

7、body parser  文件上传
</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><pre><code>使用cookieParser()

// cookie: secret1=val1; secret2=val2

server.use(cookieParser());
server.use(function(req, res){
    let ser1 = req.cookies.secret1;
    let ser2 = req.cookies.secret2;
})
</code></pre><h4 id="session-会话"><a href="#session-会话" class="headerlink" title="session 会话"></a>session 会话</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之一）Global全局/">nodeJS基 (之一) Global全局对象</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之一）Global全局/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| <strong>filename - 前当文件名<br>| </strong>dirname - 当前所在的目录<br>| setTimeout、clearTimeout - 定时器<br>| setInterval、clearInterval - 定时器<br>| console - 打印到控制台<br>| process - 进程<br>| exports、require() - 导入、导出<br>| </p>
<h4 id="dirname-当前的绝对路径"><a href="#dirname-当前的绝对路径" class="headerlink" title="__dirname  当前的绝对路径"></a>__dirname  当前的绝对路径</h4><h4 id="filename-当前文件名"><a href="#filename-当前文件名" class="headerlink" title="__filename  当前文件名"></a>__filename  当前文件名</h4><h4 id="exports-暴露接口"><a href="#exports-暴露接口" class="headerlink" title="exports  暴露接口"></a>exports  暴露接口</h4><h4 id="require-引入模板"><a href="#require-引入模板" class="headerlink" title="require()  引入模板"></a>require()  引入模板</h4><pre><code>1、模块分为

    模块加载：require(&apos;2.js&apos;);

    1）内置模块:  var fs = require(&apos;fs&apos;);        // 加载Node的内置模块 fs文件系统

    2）文件模块: 自己定义的业务模块

        定义一个food.common.js

        var food = reuqire(&apos;./js/food.common&apos;);        // 加载业务模块

    3）加载第三方模块

        require(&apos;./2&apos;);        // 先按照加载的模块文件进行查找，如果没有找到会在文件名加上.js


2、绝对和相对路径

    var fs = require(&apos;fs&apos;);        // 绝对路径，是在Node通过内部的node_modules查找到的模块

    var moduleA = reuqire(&apos;./lib/moduleA&apos;);        // 相对路径


2、npm 全局安装和局部安装

    1）全局安装会安装到Node目录中，各项目都可以使用 npm install -g gulp

    2）局部安装，将一个模块安装到node_modules中，只在当前和子目录中使用


require.cache
require.resolve()
</code></pre><h4 id="global-全局对象"><a href="#global-全局对象" class="headerlink" title="global  全局对象"></a>global  全局对象</h4><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><pre><code>module和exports两个全局变量

1）module：每个模块下都包括module对象

    Module {
        id: &apos;.&apos;,
        exports: {},
        parent: null,
        filename: &apos;/Users/apple/siguang.liu/nodeProject/server.js&apos;,
        loaded: false,
        children: [],
        paths: [
            &apos;/Users/apple/siguang.liu/nodeProject/node_modules&apos;,
            &apos;/Users/apple/siguang.liu/node_modules&apos;,
            &apos;/Users/apple/node_modules&apos;,
            &apos;/Users/node_modules&apos;,
            &apos;/node_modules&apos;
        ]
     }

 2）exports外部接口，通过require就可以调用这个接口

     其实exports就是module.exports的引用

    exports.name = &apos;siguang&apos;;
    exports.getPrivate = function(){
        return &apos;haha&apos;;
    }
</code></pre><h4 id="process-进程"><a href="#process-进程" class="headerlink" title="process  进程"></a>process  进程</h4><h4 id="console-打印到控制台"><a href="#console-打印到控制台" class="headerlink" title="console 打印到控制台"></a>console 打印到控制台</h4><pre><code>log()、info()、error()、warn()、time()、timeEnd()
</code></pre><h4 id="setImmediate-callback-…args-、clearImmediate-immediateObject"><a href="#setImmediate-callback-…args-、clearImmediate-immediateObject" class="headerlink" title="setImmediate(callback[, …args])、clearImmediate(immediateObject)"></a>setImmediate(callback[, …args])、clearImmediate(immediateObject)</h4><h4 id="setInterval-、clearInterval"><a href="#setInterval-、clearInterval" class="headerlink" title="setInterval()、clearInterval()"></a>setInterval()、clearInterval()</h4><h4 id="setTimeout-、clearTimeout"><a href="#setTimeout-、clearTimeout" class="headerlink" title="setTimeout()、clearTimeout()"></a>setTimeout()、clearTimeout()</h4>
        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
