<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Mot-clés</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-数据库/">EggJS-数据库</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-数据库/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><pre><code>一、安装配置

    $ npm i --save egg-mysql

    // config/plugin.js  开启插件
    exports.mysql = {
        enable: true,
        package: &apos;egg-mysql&apos;,
    };
</code></pre><h4 id="egg-monogoose"><a href="#egg-monogoose" class="headerlink" title="egg-monogoose"></a>egg-monogoose</h4><pre><code>一、安装配置

    $ npm i egg-mongoose --save

    // {app_root}/config/plugin.js
    exports.mongoose = {
        enable: true,
        package: &apos;egg-mongoose&apos;,
    };

    // {app_root}/config/config.default.js
    module.exports = {
        mongoose: {
            url: &apos;mongodb://127.0.0.1:27017/ibg_node_core&apos;,
            options: {
                db: { native_parser: true },
                server: { poolSize: 5 },
                user: &apos;core&apos;,
                pass: &apos;we123&apos;,
            },
        },
    }


    // 多个mongos配置
    // {app_root}/config/config.default.js
    exports.mongoose = {
        url: &apos;mongodb://mongosA:27501,mongosB:27501&apos;,
        options: {}
    };


    // log
    module.exports = {
        logger: {
            dir: &apos;/home/admin/logs/demoapp&apos;,        // logger文件的目录
            level: &apos;DEBUG&apos;,                         // 开deubg模式
        },
    };


二、定义Schema

    // app/modle/reportWarningConfig.js

    module.exports = app =&gt; {
        const mongoose = app.mongoose;
        const ReportWarningConfigSchema = new mongoose.Schema({
                actionCode: { type: String, unique: true, trim: true }, // 动作编码
                interval: { type: Number, default: 1800 },  // 扫描间隔时间，单位：秒 默认 30分钟
                emailConfig: { // 发送邮件条件
                    appKey: { type: String, default: &apos;&apos;, trim: true },
                    appSecret: { type: String, default: &apos;&apos;, trim: true },
                    recipient: { type: [String] },  // 收件人
                },
                lastExecutedTime: { type: Date, default: Date.now },   // 最近执行时间
            }, 
            {
                timestamps: true,               // 设置timestamps，多加两个字段createdTime、updatedTime，来记录插入时间和更新时间
                collection: &apos;report_warning_config&apos;,
            }
        );

        return mongoose.model(&apos;ReportWarningConfig&apos;, ReportWarningConfigSchema);
    };


三、常用语句

    1、await app.model.login.find(条件): 返回的是一组数据， []

    2、await app.model.login.findOne(条件): 只返回一条数据, 如果没有匹配的返回null，

    3、await app.model.login.update(条件, 要更新的文档, 回调方法): 更新数据

    4、let loginTask = new app.model.login({ username: &apos;siguang&apos;, password: &apos;ssssss&apos;});     
       let doc = await loginTask.save();        // 插入数据 

    5、exec(callback): 在查询、更新后会执行一个回调函数来查看是否成功执行

    6、save(function(err, kitten){  }): 存储


四、Example

    1、查询

        async queryMonitorTask(){
            let monitorTaskList = await app.model.ReportWarningConfig.find();          // app.model.ReportWarningConfig 来指定用哪个文档
            return app.renderBody({
                statusType: app.statusType.success,
                data: {
                    list: monitorTaskList
                }
            });
        }


    2、更新

        更新需要先将文档查回来后，在修改某一个字段，如果一直更新会覆盖

        async updateMonitorTask(params){
            let response;
            let condition = {_id: params.id};
            let doc = await app.model.ReportWarningConfig.findOne(condition);       // 通过id来取到当前数据

            if(doc){
                doc.interval = params.interval;
                doc.emailConfig.recipient = params.emailRecipient;
                doc.smsConfig.recipient = params.smsRecipient;

                await doc.save();
                response = app.renderBody({
                    statusType: error,
                    error: error,
                });
            }
            else{
                response = app.renderBody({
                    statusType: app.statusType.error,
                    error: doc,
                });
            }

            return response;
        }


    3、插入数据

        插入数据将使用save()

         async insertMonitorTask(){
            const {ctx, app, service} = this;
            const {actionCode, interval, emailRecipient, smsRecipient} = ctx.request.body;

            // 将要插入的数据加到model中
            let monitorTask = new app.model.ReportWarningConfig({   // 注意这里使用new 
                actionCode,
                interval,
                emailConfig: {
                    recipient: emailRecipient
                },
                smsConfig: {
                    recipient: smsRecipient
                }
            })

            // 使用save()来插入
            let doc = await monitorTask.save();

            let response = app.renderBody({
                statusType: app.statusType.success,
                data: doc._id
            });
            ctx.body = response;
        }
</code></pre><h4 id="mongoose-积累"><a href="#mongoose-积累" class="headerlink" title="mongoose 积累"></a>mongoose 积累</h4><pre><code>一、查询出来的数据不能修改

    async getNewsContent(params){
        let doc = await app.model.News.findOne({_id: params.id});

        // 不能直接修改doc的对象，需要通过toObject()方法来转成对象的形势
        let newDoc = doc.toObject();
        newDoc.createdAt = app.dateFormat(new Date(newDoc.createdAt).getTime(), &apos;yyyy-MM-dd hh:mm:ss&apos;)
        newDoc.updatedAt = app.dateFormat(new Date(newDoc.updatedAt).getTime(), &apos;yyyy-MM-dd hh:mm:ss&apos;)
        console.log(`ResponseAAA ----- ${JSON.stringify(newDoc)}`)

        return {
            data: newDoc,
            message: &apos;获取成功&apos;,
            status: 0
        }
    }
</code></pre><p>unique</p>
<blockquote>
<p>参考资料<br><a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-第三方插件收集/">Egg.js</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-第三方插件收集/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| egg-validate POST参数规则校验  <a href="https://github.com/eggjs/egg-validate" target="_blank" rel="noopener">https://github.com/eggjs/egg-validate</a><br>| egg-mongoose Mongoose        <a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a></p>
<h4 id="egg-validate"><a href="#egg-validate" class="headerlink" title="egg-validate"></a>egg-validate</h4><pre><code>validate只用于post请求的参数校验，get请求取出的都是字符串

$ npm i egg-validate --save

一、在config/plugin.js配置中添加

    exports.validate = {
        enable: true,
        package: &apos;egg-validate&apos;,
    };

二、Exmaple

    async refundApply() {
        const { ctx, app, service } = this;
        const paramRule = {
            partnerUserId: { type: &apos;string&apos; },
            applyUserName: { type: &apos;string&apos; },
            amount: { type: &apos;string&apos; }, 
            sourceAccount: { type: &apos;string&apos; }, 
        };

        const paramErrors = app.validator.validate(paramRule, ctx.request.body);
        if (paramErrors) {
            ctx.body = app.renderBody({
                statusType: app.statusType.paramsError,
                error: paramErrors,
            });
            return;
        }

        const response = await service.payTool.billquery.refundApply(ctx.request.body);
        ctx.body = response;
    }


三、验证规则  

    1、required - 是否当前字段必须有，required: false 可以为空

    2、allowEmpty - 允许为空

    2、int - 只能为整数

    3、number - 可以是整数和浮点数

    4、date - 日期 &apos;YYYY-MM-DD&apos;     birthoday: &apos;date&apos;

    5、dateTime - 日期 YYYY-MM-DD HH:mm:ss

    6、boolean - 是否是布尔值        working: &apos;boolean&apos;

    7、string - 是否是字符串, 字符串的四个规则:            

        allowEmpty - 允许为空字符串

        format - 使用正则来验证字符串的格式

        max - 字符串最大长度

        min - 字符串最小长度

        const rule = {
                username: { allowEmpty: true, min: 10, max: 100, format: /^\d+$/ }
        }

    8、email - 是否是email格式

    9、password - 密码验证规则 max最大、min最小、compare比较  pass: {type: password, max: 32, min: 6}

    10、url - 是否是url

    11、enum - 如果是枚举需要加一个规则

        // operateType的值必须是values数组中的一项，values必须为数组
        const paramRule = {
                operateType: { type: &apos;enum&apos;, values: [&apos;REPAYMENT&apos;, &apos;CHARGE&apos;] },        
        }
        const paramErrors = app.validator.validate(paramRule, ctx.request.body);

    12、object - 如果是对象，需要加一个规则 

    13、array - 如果是数组，需要加一个规则

            itemType 数组中每一个元素的规则 
            rule - An object that validate the items of the array. Only work with itemType.
            max - 数组最大长度
            min - 数组最小长度

    https://github.com/node-modules/parameter#rule
    https://github.com/node-modules/parameter/blob/master/benchmark.js
    https://github.com/node-modules/parameter/blob/master/example.js

https://github.com/node-modules/parameter
</code></pre><h4 id="egg-mongoose"><a href="#egg-mongoose" class="headerlink" title="egg-mongoose"></a>egg-mongoose</h4><pre><code>$ npm i egg-mongoose --save

$ plugin.js

    exports.mongoose = {
        enable: true,
        package: &apos;egg-mongoose&apos;,
    };

$ config.default.js

    mongoose: {
  url: &apos;mongodb://127.0.0.1:27017/ibg_node_core&apos;,
  options: {},
}

$ 可以多数据库配置
</code></pre><h4 id="egg-mysql"><a href="#egg-mysql" class="headerlink" title="egg-mysql"></a>egg-mysql</h4><pre><code>$ npm i egg-mysql --save

$ plugin.js

    exports.mysql = {
        enable: true,
        package: &apos;egg-mysql&apos;,
    };

$ config.default.js

    mysql: {
        // database configuration
        client: {
            // host
            host: &apos;mysql.com&apos;,
            // port
            port: &apos;3306&apos;,
            // username
            user: &apos;test_user&apos;,
            // password
            password: &apos;test_password&apos;,
            // database
            database: &apos;test&apos;,    
        },
        // load into app, default is open
        app: true,
        // load into agent, default is close
        agent: false,
    }

$ app.mysql.query(sql, values)              获取sql

$ 可以多数据库配置
</code></pre><h4 id="ejs-后端模板"><a href="#ejs-后端模板" class="headerlink" title="ejs 后端模板"></a>ejs 后端模板</h4><pre><code>$ npm install ejs

https://segmentfault.com/a/1190000004286562
http://www.360doc.com/content/16/0115/10/597197_528136785.shtml
https://github.com/tj/ejs
</code></pre><h4 id="渲染模板nunjucks-后端模板"><a href="#渲染模板nunjucks-后端模板" class="headerlink" title="渲染模板nunjucks 后端模板"></a>渲染模板nunjucks 后端模板</h4><pre><code>$ npm i egg-view-nunjucks --save

一、tpl文件要放到view目录里

二、配置
// config/plugin.js
exports.nunjucks = {
    enable: true,
    package: &apos;egg-view-nunjucks&apos;
};

// config/config.default.js
exports.keys = &lt;此处改为你自己的 Cookie 安全字符串&gt;;

// 添加 view 配置
exports.view = {
    defaultViewEngine: &apos;nunjucks&apos;,
    mapping: {
        &apos;.tpl&apos;: &apos;nunjucks&apos;,
    },
};

三、Controller
module.exports = app =&gt; {
    class NewsController extends app.Controller {
        async newsList(){
            const { ctx } = this;
            const dataList = {
                list: [
                    { id: 1, title: &apos;this is news 1&apos;, url: &apos;/news/1&apos; },
                    { id: 2, title: &apos;this is news 2&apos;, url: &apos;/news/2&apos; }
                ]
            }
            await ctx.render(&apos;news/newsList.tpl&apos;, dataList);                // 注意这里dataList必须是一个对象
        }
    }

    return NewsController;
}

四、newsList.tpl

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hacker News&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;ul class=&quot;news-view view&quot;&gt;
            {% for item in list %}
					<li class="item">
						<a href="{{ item.url }}">{{ item.title }}</a>
					</li>
				{% endfor %}
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;

http://mozilla.github.io/nunjucks/cn/templating.html
https://github.com/eggjs/examples/tree/master/hackernews/app/view/news
</code></pre><h4 id="其它收集插件"><a href="#其它收集插件" class="headerlink" title="其它收集插件"></a>其它收集插件</h4><pre><code>1、ms返回时间 - https://github.com/zeit/ms       // ms用来返回一个时间  ms(&apos;2h&apos;) 返回 7200000  

2、MD5加密 - https://github.com/jkiss/crypto-js      npm i crypto-js --save  引用 const MD5 = require(&apos;crypto-js/md5&apos;);

3、文件上传 - https://github.com/node-modules/formstream

4、JSON串和对象互转 - https://github.com/ljharb/qs  // 可以根据key来进行排序 

5、验证码 - https://github.com/lemonce/svg-captcha/blob/master/README_CN.md
</code></pre><p>| 参考资料<br>| <a href="https://github.com/eggjs" target="_blank" rel="noopener">https://github.com/eggjs</a>        eggjs官方插件<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/MySQL/">MySQL</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/MySQL/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/MySQL/">MySQL</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>数据类型: 字符型、整型、浮点型、日期时间型<br>操作符: 算术运算符、比较运算符、逻辑运算符、位运算符<br>属性: 自动编号<br>约束: 主键、外键、表关连、索引<br>库操作: 创建库、修改库、删除库<br>表操作: 创建表、删除表、查看表结构、查看库中所有表<br>列操作: 添加列、删除列、修改列<br>记录操作: 插入记录、更新记录（单表、多表更新）、删除记录、查询记录（多列查询、分组、指定查询范围、使用别名）<br>子查询语句、例约束<br>运算符与函数: 字符函数、数值运算符、比较运算符、日期时间函数、信息函数、聚合函数、加密函数、自定义函数<br>存储过程: 创建（参数:IN、OUT、INOUT）、调用<br>其它概念: 存储引擎、并发控制(锁、锁颗粒)、事务</p>
</blockquote>
<h4 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h4><pre><code>一、MySQL介绍

    1、MySQL是关系型数据库

    2、安装后的有4个默认库 nformation_schem、performance_schema、test、mysql     

    3、Mysql 端口号 3306

    4、mac下mySQL的配置文件 /usr/local/mysql/my.cnf


二、MySQL 目录结构 

    mysql安装后的路径 /usr/local/mysql

    1、bin: 存储可执行文件

    2、data: 存储数据文件

    3、docs: 文档

    4、include: 存储包含头文件

    5、lib: 存储库文件

    6、share: 错误消息和字符集文件


三、停止和启动mysql服务

    关闭mysql服务    查看进程：ps -ef|grep mysql         杀进程和子进程：sudo kill -9 239 746

    启动mysql服务    sudo /usr/local/mysql/bin/mysqld_safe

    系统偏好设置 -&gt; mysql   启动


四、登录、退出mysql

    1、登录

        mysql -uroot -pssssss -h127.0.0.1          

        -u 用户名    -p 密码       -P 端口号       -h 数据库地址 

        隐藏密码输入 mysql -uroot -h127.0.0.1 -p    回车后在输入密码

    2、退出: exit;


五、语法规范

    1、关键字和函数名全部大写

    2、数据库名称、表名称、字段字都小写

    3、SQL语句必须以&quot;;&quot;分号结束

        修改结束符  DELIMITER  //        以 // 为结束


六、数据库概念

    1、库: 一些关联表的集合

    2、表: 行和列组成, 行一条数据

    3、主键: 可以唯一标识不会有重复, 可以通过主键来查询数据

    4、外键: 外键可以引用主键数据，用于关联


七、安装和卸载mysql

    1、homebrew安装mysql

        http://brew.sh/

        $ brew install mysql        // 安装mysql

        $ mysql.server start           // 启动

        $ mysql  -V            // 查看版本


    2、卸载mysql

        sudo rm /usr/local/mysql 

        sudo rm -rf /usr/local/var/mysql 

        sudo rm -rf /usr/local/mysql* 

        sudo rm -rf /Library/StartupItems/MySQLCOM 

        sudo rm -rf /Library/PreferencePanes/My* 

        vim /etc/hostconfig and removed the line MYSQLCOM=-YES- 

        rm -rf ~/Library/PreferencePanes/My* 

        sudo rm -rf /Library/Receipts/mysql* 

        sudo rm -rf /Library/Receipts/MySQL* 

        sudo rm -rf /var/db/receipts/com.mysql.*
</code></pre><h4 id="库服务命令"><a href="#库服务命令" class="headerlink" title="库服务命令"></a>库服务命令</h4><pre><code>1、启动和停止MySQL服务

    service stop mysql

    service start mysql

2、登录: mysql -uroot -p123456 -h127.0.0.1

3、退出: \q 、 exit、 quit
</code></pre><h4 id="库操作语句"><a href="#库操作语句" class="headerlink" title="库操作语句"></a>库操作语句</h4><pre><code>1、创建数据库       CREATE DATABASE 库名;

        创建一个指定字符集的数据库         CREATE DATABASE 库名 CHARACTER SET utf8;

2、修改数据库       ALTER  DATABASE 库名 CHARACTER SET = uft-8;   // 将库编码改成utf8

3、删除数据库     DROP database 库名;

4、查看所有数据库     SHOW databases;

5、打开数据库        USE 库名;

6、查看当前所在的数据库   SELECT database();

7、查看库的编码: SHOW CREATE DATABASE 库名;
</code></pre><h4 id="操作表语句"><a href="#操作表语句" class="headerlink" title="操作表语句"></a>操作表语句</h4><pre><code>1、创建表    CREATE TABLE  表名(字段名 数据类型, 字段名 数据类型);

        CREATE TABLE  表名(字段 数据类型  primary key,  username VARCHAR(20));        // 加主键 primary key 

2、查看库中所有表  SHOW TABLES [db_name] [where expr];

3、查看表结构    SHOW COLUMNS FROM 表名;         // 与 desc 表名;   相同

4、删除表        DROP TABLE 表名;

5、ALTER 列操作: 

    1）添加列: ALTER TABLE 表名 ADD 列名 varchar(20);

    2）删除列: ALTER TABLE 表名 DROP 列名;

    3）修改列的类型信息

        ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称（这里可以用和原来列同名即可）】 BIGINT NOT NULL  COMMENT &apos;注释说明&apos;

    4）重命名列

        ALTER TABLE 【表名】 CHANGE 【列名称】【新列名称】 BIGINT NOT NULL  COMMENT &apos;注释说明&apos;

    5）重命名表

        ALTER TABLE 【表名字】 RENAME 【表新名字】

    6）删除表中主键

        Alter TABLE 【表名字】 drop primary key

    7）添加主键

        ALTER TABLE sj_resource_charges ADD CONSTRAINT PK_SJ_RESOURCE_CHARGES PRIMARY KEY (resid,resfromid)

    8）添加索引

        ALTER TABLE sj_resource_charges add index INDEX_NAME (name);

    9）添加唯一限制条件索引

        ALTER TABLE sj_resource_charges add unique emp_name2(cardnumber);

    10）删除索引

        ALTER TABLE [表名] index emp_name;
</code></pre><h4 id="记录操作语句"><a href="#记录操作语句" class="headerlink" title="记录操作语句"></a>记录操作语句</h4><pre><code>1、插入记录     

    1) INFO 插入指定字段值:     INSERT INTO 表名(name, age) VALUES (name值, age值);

    2) SET  插入指定字段值:     INSERT 表名 SET name=&quot;sssss&quot;, age=&quot;lll&quot;;

    3）插入所有字段值:        INSERT 表名 VALUES (NULL, name值, age值)；        // 1、没有INFO  2、如果id为主键、自增涨，需要给一个默认传入NULL 或 DEFAULT

    4）INSERT ... SELECT 将查询结果写入数据表

        INSERT [INTO] 表名 FROM 列名   SELECT 

        // 将查询出restaurant表中的type进行分组内容，插入到rest_type表中的type字段中

        INSERT rest_type(type) SELECT type FROM restaurant GROUP BY type;    


2、更新数据     

    单表更新:  UPDATE 表名 SET 要更新字段名=新值, 要更新字段名=新值  WHERE  条件        // 如果省略where条件，将修改表中的所有记录

    多表更新:  

        UPDATE 表1  [JOIN | CROSS JOIN | INNER JOIN] 表2

        表连接类型，JOIN、CROSS JOIN、INNER JOIN

                   LEFT [OUTER] JOIN 左外连接

                   RIGHT [OUTER] JOIN 右外连接


3、删除记录     

    单表删除:  DELETE FROM  表名 WHERE id=2

    多表删除:  



4、查询记录    

    查询所有列: SELECT * FROM 表名;        // 查询所有列

    查询多列:   SELECT username, age, sex FROM 表名;

    条件查询:   SELECT * FROM 表名  WHERE  条件表达式(id&lt;100);        // 查询表中的id小于100的所有记录

    查询结果分组 GROUP BY: 返回一个列中所有不相同的类别

        SELECT * FROM 表名  GROUP BY  列名 [ASC | DESC];             // 分组以哪列进行返回 ASC | DESC 正、倒序

                例: SELECT * FROM users GROUP BY sex;            # 返回sex列的分组内容，结果为两类: &apos;男&apos; 和 &apos;女&apos;


    HAVING 分组条件: SELECT * FROM 表名  GROUP BY  列名  HAVING  version &lt; 100;   // 分组后进行过滤

    LIMIT 指定查询范围: SELECT * FROM 表名 LIMIT  5, 10;        // 从第5条数据开始，查找出10条数据，也就是查询出第5-15条数据

    AS 给予别名: 当名子太长可以定义一个名，输出的时候就是定义的名字

            SELECT person AS ps, username AS un FORM users;


    --------------- select 其它  ---------------

    SELECT COUNT(*) FROM 表名 WHERE (条件)         // 返回记录的总数，如果不加条件返回整个表的总记录

    SELECT AVG(price) FROM 表名;                    // AVG()来求一个字段的平均值

    SELECT ROUND(AVG(price), 2) FROM 表名;        // ROUND() 对数值进行四舍五入


小技巧:

    1、SELECT * FROM users\G;        // 加\G 以网格形势展示查询，格式化了数据方便来看


设置空值

    例 UPDATE tag SET label=&apos;折&apos; WHERE label=NULL;        // 将label列中所有空值更新成&apos;折&apos;，失效不会被

    MySQL: null值需要通过几种方式

    1、is null、is not null: UPDATE tag SET label=&apos;折&apos; WHERE label is null;

    2、ISNULL(): 与上面一样 UPDATE tag SET label=&apos;折&apos; WHERE ISNULL(label);
</code></pre><h4 id="子查询语句"><a href="#子查询语句" class="headerlink" title="子查询语句"></a>子查询语句</h4><pre><code>子查询指嵌套在查询内部，且必须始终出现在圆括号内

子查询包含关键字或条件: DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等

子查询外层查询可以是: SELECT、INSERT、UPDATE、SET、DO

1、按返回结果集分类

    http://www.cnblogs.com/herry52/p/5643986.html

    分为4种：表子查询，行子查询，列子查询和标量子查询

    1) 表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。

        示例: 获取编号小于10的男性球员的号码

        SELECT playerno FROM (SELECT playerno, sex FROM players WHERE playerno &lt; 10) AS players10 WHERE sex=&apos;M&apos;;

        分析: 

        // 查询players中playerno小于10的两个字段的记录，并起别名为player10
        SELECT playerno, sex FROM players WHERE playerno &lt; 10 AS players10;    

        // 显示playerno字段内容，条件是子表中的sex=&apos;M&apos;
        SELECT playerno FROM 查询出的内容 WHERE sex=&apos;M&apos;


    2) 行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。

        示例: players表中获取与100号球员性别相同并且居住在同一城市的球员号码。

        SELECT playerno, sex, town FROM players WHERE (sex, town) = (select sex, town FROM players where playerno = 100);


    3) 列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）

        列子查询可以使用 IN、ANY、SOME、ALL

        1、修饰的比较运算符: ANY、SOME、ALL

            如果子查询返回：Subquery returns more than 1 row   多于一行记录，使用上面运算符

            ANY和SOME是等价的意思只符合一个就可以

            ALL 需要符合全部


        2、IN、NOT IN 子查询



    4) 标量子查询：可以指定一个标量表达式的任何地方，几乎都可以使用一个标量子查询

        示例: 获取和27号球员出生在同一年的球员的号码

        SELECT playerno, name, birth_date FROM players WHERE YEAR(birth_date) = (SELECT YEAR(birth_date) FROM players WHERE playerno=100) AND playerno != 100;
</code></pre><p>—————————– 运算符与函数 —————————–</p>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><pre><code>1、CONCAT(): 字符连接    SELECT CONCAT(&apos;user&apos;, &apos;-&apos;, &apos;name&apos;);

    // 将tag表中value和label字段的值连接，并通过AS来返回一个别列名为tagName
    SELECT CONCAT(value, &apos;_&apos;, label) AS tagName FROM tag;


2、CONCAT_WS(): 使用指定的分隔符进行字符连接

    SELECT CONCAT_WS(&apos;|&apos;, name, user, id);        以&quot;|&quot;进行分隔


3、FORMAT(): 数据格式化

    SELECT FORMAT(132.34234, 2);        // 132.34


4、LOWER(): 将字符转成小写

5、UPPER(): 将字符转成大写

6、LEFT()、RIGHT(): 获取从左、右侧字符的几位

    SELECT LEFT(&apos;what are you doing.&apos;, 7);         // what ar

7、LENGTH(): 获取字符串长度

8、LTRIM()、RTRIM()、TRIM(): 删除前空格、删除后空格、删除前后空格

9、SUBSTRING(): 字符串的截取 substring();

        SELECT SUBSTRING(&apos;what are you doing.&apos;, 3, 7);        // at are

10、RESPLACE(): 字符替换 

        SELECT REPLACE(&apos;what are you doing.&apos;, &apos; &apos;, &apos;&apos;);      // whatareyoudoing.

11、LIKE(): 模式匹配

        %: 为任意字符            _: 任意一个字符

        ESCAPE: 使用哪个字符后的百分号

        SELECT * FROM sys_user WHERE username LIKE &apos;%@renrendai.com%&apos;\G;    // sys_user表中username字段匹配出 带有@renrendai.com的字符

        SELECT * FROM sys_user WHERE username LIKE &apos;%renren%%&apos; ESCAPE &apos;renren&apos;\G;    // 匹配出 renren%
</code></pre><h4 id="数值运算符"><a href="#数值运算符" class="headerlink" title="数值运算符"></a>数值运算符</h4><pre><code>1、CEIL(): 向上取整    SELECT CEIL(4.9);        // 5     SELECT CEIL(log) FROM office;

2、FLOOR(): 向下取整    SELECT FLOOR(4.2);        // 4

3、DIV(): 整数除法     SELECT 20 DIV 3;        // 6

4、MOD(): 取模

5、POWER(): 幂运算

6、ROUND(): 四舍五入        SELECT ROUND(2.3464, 2);    // 2.35

7、TEUNCATE(): 数字截取
</code></pre><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><pre><code>1、[NOT] BETWEEN ... AND ... :  在不在一个范围内

        // 查找出fruit表中fruit_price字段（价格）10元至30无之间的数据
        SELECT fruit_id, fruit_desc, fruit_price FROM  fruit WHERE fruit_price BETWEEN 10 AND 30;


2、[NOT] IN(): 在不在几个值的内

        SELECT 10 IN (5, 20, 40);        // 返回0

        SELECT 10 IN (2, 10, 30, 49);    // 返回1


3、IS [NOT] NULL: 返回为空， IS NOT NULL 返回不为空

    // 返回 fruit_dim_three 内容为空的值
    SELECT fruit_product_name, fruit_price,fruit_dim_three FROM fruit WHERE fruit_dim_three IS NULL;  
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>一、日期时间函数

    1、NOW(): 返回一个当前日期和时间

    2、CURDATE(): 当前日期

    3、CURTIME(): 当前时间

    4、DATE_ADD(): 在一个时间内添加多少时间

            SELECT DATE_ADD(&apos;2016-12-12&apos;, INTERVAL 365 DAY);        // 返回 2017-12-12 , -365就是减365天

    5、DATEDIFF(date1, date2): 两个日期的差值

            SELECT DATEDIFF(&apos;2018-12-12&apos;, NOW());        // 2018-12-12与今天相差多少天

    6、DATE_FORMAT(): 日期格式化

            SELECT DATE_FORMAT(&apos;2016-12-10&apos;, &apos;%Y/%m/%d&apos;);        // 转换成 2016/12/10 

            SELECT DATE_FORMAT(NOW(), &apos;%Y年-%m月-%d日 %H时:%i分:%s秒&apos;);


二、信息函数

    1、CONNECTION_ID(): 连接的ID（线程的ID）

    2、DATABASE(): 查看当前数据库     SELECT DATABASE();

    3、LAST_INSERT_ID(): 最后插入记录

    4、USER(): 当前用户

    5、VERSION(): 版本信息


三、聚合函数

    1、AVG(): 平均值的计算

            SELECT AVG(fruit_price) FROM fruit;        // 将水果的价格字段平均值返回

    2、COUNT(): 返回条件的行数

            SELECT COUNT(列名) FROM 表名;        // 返回数目(NULL 不计)

            SELECT COUNT(*) FROM 表名;        // 返回所有的记录数

    3、MAX(): 最大值

    4、MIN(): 最小值

    5、SUM(): 返回和


四、加密函数

    1、MD5(): 信息摘要算法

            MD5(&apos;adf234sdf2=-a1%af123#$&apos;);        // 16f7709af2898dd3c9f116d56ea93c82

    2、PASSWORD(): 密码算法

            PASSWORD(&apos;adf234sdf2=-a1%af123#$&apos;);    // *6D3B0C079BFF7DAD315D9AF131F0868939A74A8D
</code></pre><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><pre><code>一、创建自定函数:

    CREATE FUNCTION 函数名 RETURNS {STRING | INTERGER | REAL | DECIMAL} routine_body

    创建     函数      名    返回                    类型                     函数体          


    函数体: 由合法的SQL语句构成，可以是简单的SELECT 或 INSERT语句

    示例1 无参数:

        // 创建一个返回当前格式化的日期
        CREATE FUNCTION newDate() RETURNS VARCHAR(30) 

            RETURN  DATE_FORMAT(NOW(), &apos;%Y年-%m月-%d日 %H时:%i分:%s秒&apos;);

        // 调用
        SELECT newDate();        // 2016年-12月-12日 11时:31分:55秒


    示例2 有参数:

        CREATE FUNCTION fun2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) 

            RETURNS FLOAT(10,2) UNSIGNED  

            RETURN (num1+num2)/2;


        SELECT fun2(20, 30);        // 25.00


    示例3 返回语句

        # 需要修改结束符 “;”

        // 定义一个向users表中的username字段插入值

        DELIMITER //;

        CREATE FUNCTION addUser(username VARCHAR(20))

            RETURNS INT UNSIGNED

            BEGIN

            INSERT users(username) VALUES(username);

            RETURN LAST_INSERT_ID();

            END//


二、删除自定义函数: DROP FUNCTION 函数名;

ROW_COUNT(): 用于返回被 update, insert, delete 实际修改的行数

FOUND_ROWS(): 返回上一条执行语句，影响的行数
</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>一、int: 整型

二、浮点

    1、float: 单精度

    2、double: 双精度浮点

三、日期

    1、datetime: 日期

    2、timestamp: 日期

    3、year、month、date

四、字符型

    1、char: 定长字符类型

    2、varchar: 不定长字符

    3、tinytext:

    4、text: 

    5、medinmtext:

    6、longtext:

    7、enum: 

    8、set: 
</code></pre><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><pre><code>一、算术运算符

    +     加   SET var1=2+2;       4
    -     减   SET var2=3-2;       1
    *     乘   SET var3=3*2;       6
    /     除   SET var4=10/3;      3.3333
    DIV   整除 SET var5=10 DIV 3;  3
    %     取模 SET var6=10%3 ;     1


二、比较运算符

    &gt;            大于 1&gt;2 False
    &lt;            小于 2&lt;1 False
    &lt;=           小于等于 2&lt;=2 True
    &gt;=           大于等于 3&gt;=2 True
    BETWEEN      在两值之间 5 BETWEEN 1 AND 10 True
    NOT BETWEEN  不在两值之间 5 NOT BETWEEN 1 AND 10 False
    IN           在集合中 5 IN (1,2,3,4) False
    NOT IN       不在集合中 5 NOT IN (1,2,3,4) True
    =            等于 2=3 False
    &lt;&gt;, !=       不等于 2&lt;&gt;3 False
    &lt;=&gt;          严格比较两个NULL值是否相等 NULL&lt;=&gt;NULL True
    LIKE         简单模式匹配 &quot;Guy Harrison&quot; LIKE &quot;Guy%&quot; True
    REGEXP       正则式匹配 &quot;Guy Harrison&quot; REGEXP &quot;[Gg]reg&quot; False
    IS NULL      为空 0 IS NULL False
    IS NOT NULL  不为空 0 IS NOT NULL True


三、逻辑运算符

    与(AND) &amp;&amp;       或（OR）||        非（NOT）！


四、位运算符

    |   位或
    &amp;   位与
    &lt;&lt;  左移位
    &gt;&gt;  右移位
    ~   位非(单目运算，按位取反)
</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>1、AUTO_INCREMENT: 自动编号，必须与主键组合使用，起始值为1，每次增加1

2、primary key         主键约束 每张表只能存在一个主键，主键保证记录的唯一性, 主键自动为 NOT NULL

3、foreign            外键约束 保持数据的一致性, 实现一对一或一对多的关系约束
</code></pre><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><pre><code>2、PRIMARY KEY（主键约束）: 每张表只能存在一个主键，保证记录的唯一性，主键自动为NOT NULL

3、UNIQUE KEY（唯一约束）: 可以保证记录的唯一性，字段可以为空值（NULL），每张数据表可以存在多个唯一约束

4、DEFAULT（默认约束）: 默认值，插入记录时没有赋值，自动赋予默认值

    创建表时的性别字段，有三个值1，2，3 =&gt; 男，女，不男不女  如果insert插入未写入值，默认加入3
    sex ENUM(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;) DEFAULT &apos;3&apos;        

5、FOREIGN KEY（外键约束）: 保证数据一致性和完整性，实现一对一 或 一对多关系

5、NOT NULL（非空约束） 不能为空，必须写值要不报错

6、NULL 可以为空

# 约束分为表级约束 和 列级约束

    约束只针对一个字段来约束，叫列级约束

    约束针对两个或以上字段来约束，叫表级约束


# 外键约束的要求

    1、父表和子表必须使用相同的存储引擎，禁止使用临时表

    2、数据表存储只能为InnoDB

    3、外键列和参照必须有相似的数据类型，

CURRENT_TIMESTAMP
</code></pre><p>—————————– 存储过程 —————————–</p>
<h4 id="MySQL命令执行过程"><a href="#MySQL命令执行过程" class="headerlink" title="MySQL命令执行过程"></a>MySQL命令执行过程</h4><pre><code>SQL命令 -&gt; MySQL引擎 -&gt; 语法正确 -&gt; 可识别命令 -&gt; 执行结果 -&gt; 返回客户端

需要这一套流程才能跑完，如果使用存储过程会节省中间的一些步骤，可以节省性能.
</code></pre><h4 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h4><pre><code>存储过程: 是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理

存储过程存储在数据库内，可以通过应用程序调用和输出

存储过程的优点:

    1、增强SQL语句的功能和灵活性

    2、实现较快的执行速度

        存储过程是不需要语法解析等操作，预编译，所以速度上要快

    3、减少网络流量

        后端应用程序与数据库通信，需要传SQL语句，如果有存储过程就直接告诉执行哪个存储过程就可以了
</code></pre><h4 id="存储过程的使用"><a href="#存储过程的使用" class="headerlink" title="存储过程的使用"></a>存储过程的使用</h4><pre><code>一、创建存储过程

    CREATE 

    [DEFINER = {user | CURRENT_USER}]         // 如果省略就是默认走的当前登录客户端的用户

    PROCEDURE 存储过程名(参数)


    参数：

        1) IN: 表示该参数值必须在调用存储过程时指定，这个值不能返回只能进不能出

        2）OUT: 表示该参数值可以审美观点存储过程改变，并且可以返回，

        3）INOUT: 表示该参数调用时指定，并且可以被改变和返回


    过程体

        1）由合法的SQL语句构成

        2）可以是做任意的SQL语句

        3）复合结构则使用BEGIN...END语句，与函数相同，如果执行两个或两个以上语句需要使用BEGIN...END

        4）复合结构可以包含声明、循环、控制结构



    示例1: 无参数

        // 定义一个返回客户端信息的存储过程
        CREATE PROCEDURE sp1() SELEECT VERSION();

        // 调用存储过程
        CALL sp1();                // 如果没有参数可以去掉小括号  CALL sp1;


    示例2: 带参数 IN

        DELIMITER //

        CREATE PROCEDURE removeUserId(IN uid INT UNSIGNED)

        BEGIN

        DELETE FROM users WHERE id=uid;                    // 通过传入的id来删除users表中的一条记录

        END //

        // 调用存储过程
        CALL removeUserId(5);    


    示例3: OUT

        DELIMITER ;;

        CREATE PROCEDURE removeIdAndReturnUserCount(IN pid INT UNSIGNED, OUT userCount INT UNSIGNED)         // OUT 定义输出的变量

        BEGIN 

        DELETE FROM users WHERE id = pid;                      // 删除指定的记录

        SELECT count(id) FROM users INTO userCount;         // 查询id字段所有的记录数，并返回userCount变量中，注意结果返回使用INTO

        END;;


        // 调用
        CALL removeIdAndReturnUserCount(3, @count);        // 执行删除并返回记录数，存储在count变量中

        SELECT @count;                // 显示变量的值



二、删除存储过程: DROP PROCEDURE 存储过程名;
</code></pre><h4 id="常用概念"><a href="#常用概念" class="headerlink" title="常用概念"></a>常用概念</h4><pre><code>一、什么是存储引擎

    MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。

    每种存储引擎使用不同的存储机制、索引技术、锁定水平，最终提供广泛且不同的功能。


二、并发控制

    当多个连接对记录进行修改时保证数据的一致性和完整性

        例: 一个用户删除id=22的操作，另一个用户要读取id=22的操作，这样读取id=22就会报错

            解决这个问题就是使用并发，当迸发读或写时系统会使用锁系统，来控制读写


    1、锁

        共享锁（读锁）: 在同一时间段内，多个用户读取同一个资源，读取过程中数据不会发生任何变化.

        排他锁（写锁）: 在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其它的读锁或写锁操作.


    2、锁颗粒

        表锁: 开锁最小的锁策略

        行锁: 开锁最大的锁策略

三、事务

    事务的主要作用就是保证数据的完整性

四、外键

    保证数据一致性的策略

五、索引

    是对数据表中一列或多列进行排序的一种结构
</code></pre><h4 id="Navicat工具"><a href="#Navicat工具" class="headerlink" title="Navicat工具"></a>Navicat工具</h4><pre><code>一、导入、导出表数据

    1、导出，选择要导出的表右键 Dump SQL File 

    2、导入，选中Table右键 import Wizard...
</code></pre><p>| 使用工具<br>| Navicat</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/11/Gulp/">Gulp</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/11/Gulp/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-11T10:39:38.000Z" itemprop="datePublished">2016-11-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><pre><code>https://github.com/gulpjs

可以自动化执行任务的工具，主要用于生产环境和开发环境的文件处理

Gulp是一个新的基于流的管道式构建系统，需要很少的配置并且更快

主要作用:

    1、多个js或css文件合并、压缩

    2、Sass或Less的编译

    3、图像的压缩

    3、实时刷新页面的本地服务器

gulp对按需加载不好做到，如A和B页面都依赖base.js，但又各依赖a.js和b.js，这种情况gulp打包是将三个都包括了，所以css和html部分gulp来处理，js的webpack处理
</code></pre><h4 id="安装、使用"><a href="#安装、使用" class="headerlink" title="安装、使用"></a>安装、使用</h4><pre><code>$ npm install -g gulp     // 全局安装Gulp

$ npm init    // 创建package.json 项目描述文件

$ npm install --save-dev gulp    // 作为项目的开发依赖(只在开发时用，不会发布到线上)

$ touch gulpfile.js

    var gulp = require(&apos;gulp&apos;);
    gulp.task(&apos;default&apos;, function(){

    })

$ gulp     // 运行gulp
</code></pre><h4 id="gulp-方法"><a href="#gulp-方法" class="headerlink" title="gulp 方法"></a>gulp 方法</h4><pre><code>1、gulp.src(): 获取到想要处理的文件流，可以是一个字符串或者数组，返回一个stream

    1)、*.{png,jpg,gif,ico}      // 匹配文件

    2)、**/*.html        // 目录用**、文件名用*

    gulp.task(&apos;count&apos;, function(){
        gulp.src([&apos;aa.html&apos;, &apos;bb.html&apos;])    // 或 gulp.src(&apos;src/*.html&apos;);
            .pipe(gulp.uglify())
    })

2、gulp.pipe(): 将获取到的文件流通过pipe()导入到gulp的插件中进行处理

3、gulp.dest(): 用来写文件的，插件处理完，通过dest()处理完成后把流中的内容写到指定的文件中

    var gulp = require(&apos;gulp&apos;);
    gulp.src(&apos;js/main.js&apos;)                 // 获取文件的流的api
        .pipe(gulp.uglify())            // 文件进行压缩
        .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));     // 写文件的api


4、gulp.task(&apos;任务名&apos; [依赖任务], callback): 定义任务，依赖任务会在当前任务执行前完成

    gulp.task(&apos;test&apos;, [&apos;styles&apos;, &apos;task&apos;], function() {
        // 将你的默认的任务代码放在这
    });

    # gulp test     // 执行任务


5、gulp.watch(&apos;要监视文件的匹配模式&apos;, [要执行的task定义的任务], callback): 监视文件的变化，变化后来执行定义的任务
</code></pre><h4 id="gulp-执行命令"><a href="#gulp-执行命令" class="headerlink" title="gulp 执行命令"></a>gulp 执行命令</h4><pre><code>-v 或 --version 会显示全局和项目本地所安装的 gulp 版本号

--gulpfile 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录

--cwd dirpath 手动指定 CWD。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径

-T 或 --tasks 会显示所指定 gulpfile 的 task 依赖树

--tasks-simple 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表

--color 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持

--no-color 强制不显示颜色，即便检测到有颜色支持

--silent 禁止所有的 gulp 日志
</code></pre><h4 id="Gulp-扩散操作"><a href="#Gulp-扩散操作" class="headerlink" title="Gulp 扩散操作"></a>Gulp 扩散操作</h4><pre><code>1、复制单个文件task

    gulp.task(&apos;copy-html&apos;,function(){
        return gulp.src(&apos;app/index.html&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });


2、复制多个文件

    gulp.task(&apos;copy-images&apos;,function(){
        return gulp.src(&apos;app/imgs/**/*.{jpg,png}&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });

    gulp.task(&apos;copy-other&apos;,function(){
        return gulp.src([&apos;app/css/*.css&apos;,&apos;app/js/*.js&apos;],{base:&apos;app&apos;}).pipe(gulp.dest(&apos;dist&apos;));
    });
</code></pre><h4 id="gulp-插件"><a href="#gulp-插件" class="headerlink" title="gulp 插件"></a>gulp 插件</h4><pre><code>https://gulpjs.com/plugins/

$ gulp
$ gulp-babel babel-core babel-preset-env        // ES6转ES5
$ babel-plugin-transform-runtime        // ES6转ES5运行时转换
$ gulp-uglify            // 压缩js
$ gulp-concat            // 合并js
$ gulp-jshint            // js语法检测
$ gulp-less              // less编译
$ gulp-ruby-sass        // sass编译
$ gulp-minify-css        // css压缩
$ gulp-css-base64        // 生成64位图标
$ gulp-htmlmin           // html压缩
$ gulp-file-include        // includer嵌入到另一个html文件
$ gulp.spritesmith       // 雪碧图
$ gulp-imagemin          // 压缩图片
$ imagemin-pngquant      // 图片的深度压缩
$ gulp-cache             // 只压缩修改的图片
$ gulp-rev-append        // 加版本号，给页面文件引用的js和css资源
$ gulp-autoprefixer     // 自动补齐前缀，根据设置浏览器版本自动处理浏览器前缀 CSS3的前缀
$ gulp-react             // react区分jsx文件进行转换
$ gulp-webpack           // webpack
$ gulp-amd-optimizer     // requirejs 压缩
$ vinyl-buffer           // 流缓存
$ merge-stream           // 合并流
$ gulp-watch             // 侦听变化自动执行task
$ gulp-livereload        // 当监听文件发生变化时，浏览器自动刷新页面
$ gulp-header            // 注释自定义插件
$ gulp-rimraf            // 清除文件
$ gulp-clean             // 删除文件或目录
$ gulp-plumber           // 错误提示
$ gulp-notify            // 消息提示
$ gulp-rename            // 重命
$ gulp-connect           // gulp的服务器
$ gulp-browserify          // 
$ gulp-open                // 打开浏览器
$ gulp-md5-plus            // 生成md5码

一、gulpfile.js中引用插件   

    var uglify = require(&apos;gulp-uglify&apos;);


二、gulp-load-plugins 模块化管理插件

    1、一般情况下，gulpfile.js中的模块需要一个个加载。

        var gulp = require(&apos;gulp&apos;)
               jshint = require(&apos;gulp-jshint&apos;),
            uglify = require(&apos;gulp-uglify&apos;),
            concat = require(&apos;gulp-concat&apos;);

        gulp.task(&apos;js&apos;, function () {
               return gulp.src(&apos;js/*.js&apos;)
                  .pipe(uglify())
                  .pipe(concat(&apos;app.js&apos;))
                  .pipe(gulp.dest(&apos;build&apos;));
        });


    2、gulp-load-plugins 会加载 package.json中存在下面的插件依赖：

        &quot;devDependencies&quot;: {
            &quot;gulp&quot;: &quot;^3.9.0&quot;,
            &quot;gulp-uglify&quot;: &quot;^2.6.0&quot;,
            &quot;gulp-concat&quot;: &quot;^2.2.0&quot;
        }

        var gulp = require(&apos;gulp&apos;);
        var $ = require(&apos;gulp-load-plugins&apos;)();            // 加载gulp-load-plugins插件，并立刻运行

        使用：$.uglify  可以省去单个引入
        gulp.task(&apos;add&apos;, function(){
            gulp.src([&apos;js/main.js&apos;])
                .pipe($.concat)
                .pipe($.uglify)            // $.uglify就可以调用了
                .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));    // 如果不改变文件名就直接写成 dist/js/
        })
</code></pre><h4 id="gulp-webpack构建多页面"><a href="#gulp-webpack构建多页面" class="headerlink" title="gulp + webpack构建多页面"></a>gulp + webpack构建多页面</h4><pre><code>├── .DS_Store
├── src                // 生产目录
├── dist            // 发布目录
├── gulpfile.js
├── node_modules
└── package.json
</code></pre><p>| 参考资料<br>| <a href="http://www.gulpjs.com.cn/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/</a>   gulp中文网<br>| <a href="http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7</a><br>| <a href="http://www.gulpjs.com.cn/docs/recipes/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/recipes/</a>    gulp 技巧集<br>| <a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/api/</a>    gulp api<br>| <a href="http://www.techug.com/gulp" target="_blank" rel="noopener">http://www.techug.com/gulp</a>  gulp使用指南<br>| <a href="http://www.w3ctech.com/topic/134" target="_blank" rel="noopener">http://www.w3ctech.com/topic/134</a>    gulp开发教程<br>| <a href="http://www.qianduancun.com/nodejs/33.html" target="_blank" rel="noopener">http://www.qianduancun.com/nodejs/33.html</a>      gulp-load-plugins[模块化管理插件]<br>| <a href="http://segmentfault.com/a/1190000003098076#articleHeader0" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003098076#articleHeader0</a>        利用 gulp 处理前端工作流程<br>| <a href="http://www.cnblogs.com/2050/p/4198792.html" target="_blank" rel="noopener">http://www.cnblogs.com/2050/p/4198792.html</a>        前端构建工具gulpjs的使用介绍及技巧<br>| <a href="https://www.cnblogs.com/weixing/p/5474324.html" target="_blank" rel="noopener">https://www.cnblogs.com/weixing/p/5474324.html</a><br>|<br>| 多页面<br>| <a href="https://www.cnblogs.com/maskmtj/archive/2016/07/21/5597307.html" target="_blank" rel="noopener">https://www.cnblogs.com/maskmtj/archive/2016/07/21/5597307.html</a><br>| <a href="https://github.com/fwon/gulp-webpack-demo" target="_blank" rel="noopener">https://github.com/fwon/gulp-webpack-demo</a><br>|<br>| 文件流<br>| <a href="http://segmentfault.com/a/1190000000519006" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000519006</a>    nodejs中流(stream)的理解<br>| <a href="http://www.it165.net/pro/html/201406/15924.html" target="_blank" rel="noopener">http://www.it165.net/pro/html/201406/15924.html</a>    Node.js Stream（流）的学习笔记<br>| <a href="http://segmentfault.com/a/1190000000357044" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000357044</a>    Node 中的流（Stream）<br>|<br>| Promise<br>| <a href="http://segmentfault.com/a/1190000002591145" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002591145</a>    深入理解Promise实现细节<br>| <a href="http://www.tuicool.com/articles/fe6Jbyz" target="_blank" rel="noopener">http://www.tuicool.com/articles/fe6Jbyz</a>    Promise实现原理<br>| <a href="http://segmentfault.com/a/1190000003028634" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003028634</a>    异步编程 promise模式 的简单实现<br>| <a href="http://sentsin.com/web/861.html" target="_blank" rel="noopener">http://sentsin.com/web/861.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/02/webpack插件类/">webpack插件类</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/02/webpack插件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-02T03:06:16.000Z" itemprop="datePublished">2016-11-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><pre><code>1、自动刷新浏览器 - 修改代码编译后自动刷新浏览器

2、热替换 - 在不刷新整个网页的时候做到实时预览

    script: {
        &quot;server&quot;: &quot;webpack-dev-server --open --hot --inline&quot;
    }

    --hot 与在 new webpack.HotModuleReplacementPlugin() 相同

3、提取公用代码

    通过CommonsChunkPlugin插件来提取指定业务文件中的公用库

4、按需加载、首屏加载

    &lt;!-- 加载 import(/* webpackChunkName: &quot;show&quot; */&apos;./show&apos;, then((show) =&gt; {
        show(&apos;webpack&apos;)
    })) --&gt;
</code></pre><h4 id="将业务逻辑与其它组件库分离"><a href="#将业务逻辑与其它组件库分离" class="headerlink" title="将业务逻辑与其它组件库分离"></a>将业务逻辑与其它组件库分离</h4><pre><code>将业务逻辑和第三方代码分离，不能将他们都合并到一个文件内，使这个js文件比较大，并且跳转到另一个地址也还会重新加载这些公用的文件

Example: 

    对引用的jquery单独提取

    1、import $ from &apos;jquery&apos;;     // js中引用的jquery, 先npm i jquery下载包

    2、webpack.config.js

        // 入口文件
        entry: {
            app: path.resolve(__dirname, &apos;web/js/index.js&apos;),
            vendor: [&apos;jquery&apos;]
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;,
            chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        plugins: [
            // 将在html文件中添加&lt;script&gt;引用，并生创建到指定的目录中
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,
                filename: &apos;./web/index.html&apos;,
                template: &apos;./web/index.html&apos;,
                chunks: [&apos;app&apos;, &apos;vendor&apos;],            // 这里要把vendor依赖的文件加上，不然生成的html只有引用app.min.js，不会引用jquery.vendor.js
                inject: true,
                hash: true
            }),

            // 拆分插件
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendor&apos;,                            // 上面入口定义的节点组
                filename: &apos;jquery.vendor.js?[hash]&apos;     // 最后生成的文件名
            }),
        }
</code></pre><h4 id="require-ensure按需加载"><a href="#require-ensure按需加载" class="headerlink" title="require,ensure按需加载"></a>require,ensure按需加载</h4><pre><code>require()与require.ensure()加载的不同

1、require(): AMD加载规范，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数

2、require.ensure(): requi.ensure的依赖模块只会被先下载下来，但不会被执行，会将require.ensure()内加载的模块合成一个文件，在

    如果webpack打包会将所有资源加到一个文件中，这样会使这个文件变的很大，require.ensure()来对加载的资源单独打包

    require.ensure([], function(require) {
        var dialog = require(&apos;./components/dialog&apos;);
        // todo ...
    });

    CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好

    webpack.config.js中配置

        var chunks = Object.keys(entries);
        plugins: [
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendors&apos;,             // 将公共模块提取，生成名为`vendors`的chunk
                chunks: chunks,
                minChunks: chunks.length     // 提取所有entry共同依赖的模块
            })
        ]

http://blog.csdn.net/zhbhun/article/details/46826129
https://segmentfault.com/a/1190000007775743
</code></pre><h4 id="插件类详解"><a href="#插件类详解" class="headerlink" title="插件类详解"></a>插件类详解</h4><pre><code>* webpack-dev-server - webpack自带服务

webpack自带的插件
* CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin - 提取公用部分
* uglifyJsPlugin - js压缩

外部加载插件
* HotMooduleReplacementPlugin() - 热替换
* html-webpack-plugin - 解析html模板
* web-webpack-plugin - 与html-webpack-plugin类型国内人写的https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md
* extract-text-webpack-plugin - 单独打包css文件
* open-browser-webpack-plugin - 资源构建成功后自动打开浏览器 
* clean-webpack-plugin - 清除文件夹,添加hash后，会导致改变文件内容重新打包时文件名不同越来越多，使用clean-webpack-plugin

* babel-plugin-react-transform react-transform-hmr - react的热更新, 需要在配置bable.rc
* ExtractTextPlugin - 将js中引用的css文件抽取出一个单独的css文件
* webpack-merge - 合并数组、函数
* webpack-dev-middleware - devServer就是基于webpack-dev-middleware和ExpressJS来实现的
* imagemin-webpacl-plugin - 压缩图片
* webpack-spritesmith - 制作雪碧图
* HotModuleReplacementPlugin - devServer热更新

一、webpack-dev-server webpack自带服务

    webpack-dev-server有两种模式支持自动刷新——iframe模式和inline模式。

    1、iframe模式: 页面是嵌套在一个iframe下的，在代码发生改动的时候，这个iframe会重新加载;使用iframe模式无需额外的配置，只需在浏览器输入以下地址: http://localhost:8080/webpack-dev-server/index.html

    2、inline模式: 一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。

    以下三种配置都可以实现页面的刷新效果: 

        // 1.启动webpack-dev-server的时候带上inline参数
        webpack-dev-server --inline

        // 2.给HTML插入JS
        &lt;script src=&quot;http://localhost:3000/webpack-dev-server.js&quot;|&lt;/script|

        // 3.webpack配置
        entry: [
            &apos;webpack-dev-server/client?http://localhost:3000&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ]


二、HotMooduleReplacementPlugin() 热替换

    webpac-dev-server支持模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉。使用HMR功能也有两种方式: 命令行方式和Node.js API。

    1、cli命令行方式  webpack-dev-server --inline --hot

    2、Node.js API方式

        entry: [
            &apos;webpack/hot/dev-server&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ],
        devServer: {
            hot: true
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin(),
        ]


三、html-webpack-plugin 解析html模板

    插件将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

    $ npm i html-webpack-plugin

    $ const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);            // 引用插件

    1、单入口配置

        // 这里省略其他配置代码
        plugins: [
            // 使用这个plugin，这是最简单的一个配置，更多资料可到github查看
            new HtmlWebpackPlugin({
                title: &apos;zhufeng-react&apos;,
                template: &apos;./src/index.html&apos;,
            })
        ]

    2、多入口配置

        会将两个入口分别对html文件进行加载指定的入口js文件

        // 入口文件
        entry: {
            app: &apos;./web/js/index.js&apos;,
            list: &apos;./web/js/list.js&apos;
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;
        },

        plugins: [
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,                    // 生成html文档的标题
                filename: &apos;./web/index.html&apos;,    // 输出文件名称
                template: &apos;./web/index.html&apos;,    // 本地模板的位置，支持(handlebars、ejs、undersore、html)
                chunks: [&apos;app&apos;],                // 对应的入口entry, 也可以是数组[&apos;app&apos;, &apos;list&apos;]
                inject: true,                    // 向template中注入所有静态资源
                hash: true                        // 为静态资源添加webpack每次编译产生的唯一hash值， &lt;script type=&quot;text/javascript&quot; src=&quot;common.js?a3e1396b501cdd9041be&quot;&gt;&lt;/script&gt;
            }),
            new HtmlWebpackPlugin({
                title: &apos;list&apos;,
                filename: &apos;./web/list.html&apos;,
                template: &apos;./web/list.html&apos;,
                chunks: [&apos;list&apos;],
                inject: true,
                hash: true
            })
        ]

    https://segmentfault.com/q/1010000009810148
    https://www.cnblogs.com/wonyun/p/6030090.html


四、extract-text-webpack-plugin 单独打包css文件

    $ npm i extract-text-webpack-plugin


五、open-browser-webpack-plugin  资源构建成功后自动打开浏览器 --- 已可以在命令中配置

    1、package.json中加 --open，与使用此插件相同

        &quot;scripts&quot;: {
            &quot;start&quot;: &quot;webpack-dev-server --hot --inline --open&quot;,
        }


    2、$ npm install open-browser-webpack-plugin --save-dev

        var openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
            new openBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]


六、CSS Module

    webpack 的 css-loader 是解决这个问题的最好办法之一。简单配置一下: 
    module: {
      loaders: [{
        test: /\.css$/,
        loaders: [
          &apos;style-loader&apos;,
          &apos;css-loader?modules&amp;localIdentName=[name]__[local]___[hash:base64:5]&apos;,
          &apos;postcss-loader&apos;
        ]
      }]
    },
    postcss: [
      require(&apos;postcss-nested&apos;)(),
      require(&apos;cssnext&apos;)(),
      require(&apos;autoprefixer-core&apos;)({ browsers: [&apos;last 2 versions&apos;] })
    ]


七、UglifyJs Plugin 压缩资源

    var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;

    plugins: [
        new uglifyJsPlugin({
            compress: {
                warnings: false
            }
        }),
        new webpack.optimize.MinChunkSizePlugin({
            compress: {
                warnings: false
            }
        }),
        // 查找相等或近似的模块，避免在最终生成的文件中出现重复的模块
        new webpack.optimize.DedupePlugin(),
        // 按引用频度来排序 ID，以便达到减少文件大小的效果
        new webpack.optimize.OccurenceOrderPlugin(),
        new webpack.optimize.AggressiveMergingPlugin({
            minSizeReduce: 1.5,
            moveToParents: true
        })
    ]


八、clean-webpack-plugin 清除文件夹

    $ npm install clean-webpack-plugin --save-dev

    webpack.config.js:

        const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);

        plugins: [
            new CleanWebpackPlugin([&apos;dist&apos;]),
            new HtmlWebpackPlugin({
                title: &apos;Output Management&apos;
            })
        ]


九、react的热替换

    $ npm install --save-dev babel-plugin-react-transform react-transform-hmr

    .babelrc配置
        {
            &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
            &quot;env&quot;: {
                &quot;development&quot;: {
                &quot;plugins&quot;: [[&quot;react-transform&quot;, {
                    &quot;transforms&quot;: [{
                        &quot;transform&quot;: &quot;react-transform-hmr&quot;,

                        &quot;imports&quot;: [&quot;react&quot;],

                        &quot;locals&quot;: [&quot;module&quot;]
                    }]
                }]]
                }
            }
        }

十、ExtractTextPlugin 分享css和js文件

    $ npm install --save extract-text-webpack-plugin

    webpack.config.js

        const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

        module.exports = {
            entry: {},
            output: {},

            plugins:[
                new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
                new ExtractTextPlugin(&quot;style.css&quot;)
            ]

        }

十一、clean-webpack-plugin

    $ npm install clean-webpack-plugin --save

        const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);
        module.exports = {

            plugins: [
                &lt;!-- ...// 这里是之前配置的其它各种插件 --&gt;
                new CleanWebpackPlugin( &apos;build/*.*&apos;, {
                        root: __dirname,
                        verbose: true,
                        dry: false
                    }
                )
            ]
        }

十二、CommonsChunkPlugin

    const CommonsChunkPlugin = require(&apos;CommonsChunkPlugin&apos;);
    module.exports = {
        plugins: [
            new CommonsChunkPlugin({
                // 从哪些Chunk 中提取
                chunks: [&apos;a&apos;, &apos;b&apos;],
                // 提取的公共部分形成一个chunk
                name: &apos;common&apos;
            })
        ]
    }


十三、暴露全局对象

    如果想将report数据上报组件放到全局，有两种办法: 

    方法一: 
    在loader里使expose将report暴露到全局，然后就可以直接使用report进行上报
    {
        test: path.join(config.path.src, &apos;/js/common/report&apos;),
        loader: &apos;expose?report&apos;
    }

    方法二: 
    如果想用R直接代表report，除了要用expose loader之外，还需要用ProvidePlugin帮助，指向report，这样在代码中直接用R.tdw， R.monitor这样就可以
    new webpack.ProvidePlugin({
        &quot;R&quot;: &quot;report&quot;,
    })
</code></pre><h4 id="gulp与webpack构建单页面与多页面总结"><a href="#gulp与webpack构建单页面与多页面总结" class="headerlink" title="gulp与webpack构建单页面与多页面总结"></a>gulp与webpack构建单页面与多页面总结</h4><pre><code>1、gulp: 处理html、css都可以，对处理js依赖这块不占优势

2、webpack: 对js入口进行单页面构建和模块化开发，如果页面较多不占优势，多页面webpack也可以做到，不过将js合并并加载到html中配置比较麻烦，需要HtmlWebpackPlugin插件来完成，每一个页面都需要创建一次，也可以将公用进行提取chunks

3、gulp+webpck 构建多页面

    优点: gulp进行对html和css处理，webpack进行js的处理

    缺点: webpack如果需要合并js，还需要手动去改html的引用
</code></pre><h4 id="webpack踩坑"><a href="#webpack踩坑" class="headerlink" title="webpack踩坑"></a>webpack踩坑</h4><pre><code>一、安装完webpack后执行命令提示需要安装webpack

    webpack -h          // 提示没有装webpack-cli

    $ npm i webpack-cli --save-dev            // 如果全局没有安装就全局装一下 $ sudo npm i webpack-cli -g

    https://segmentfault.com/a/1190000013699050
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/02/webpack/">webpack</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/02/webpack/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-02T03:06:16.000Z" itemprop="datePublished">2016-11-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| AMD、CMD、CommonJS模式<br>| Source Map代码调试<br>| require()、define()、export()<br>| requires.ensure(): 用来按需加载，将文件使用时在进行加载<br>| Vendor: 将库、框架文件与业务分离分别打包<br>| Entry: 入口<br>| Chunk: 出输的名<br>| Output: 打包输出<br>| Loader: 模块转换器<br>| Module: 模块<br>| Reslove: 依赖文件<br>| Plugins: 扩展插件<br>| webpack-dev-server: 本地服务器，可以设置代理，用来前后端分离跨域</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><pre><code>模块化分为AMD、CMD、CommonJS、ES6四类

一、CommonJS 

    Node、webpack使用的CommonJS规范, require加载是同步的

    // 导入
    const moduleA = require(&apos;./moduleA&apos;);
    moduleA.someFun(1,2);            // 需要等moduleA加载后在执行，这里是同步

    // 导出
    module.exports = moduleA.someFunc


二、AMD 异步加载模块

    可异步加载依赖模块，可并行加载多个依赖，可以运行浏览器和node环境下，缺点是需要加载AMD的库才能使用，常用的require.js

    // 定义模块
    define(&apos;moduleA&apos;, [依赖文件], function(jquery){
            var someFun = (x, y) =&gt; { return x + y}
            return {
                someFun,
            }
    })

    // 导入和使用
    require([&apos;moduleA&apos;], function(moduleA){
        module.someFun(1,2);
    })


三、ES6

    JS的标准化模块加载，会逐渐的取代commonJS和AMD

    // 导入
    import React from &apos;react&apos;
    import ReactDOM, { render } from &apos;react-dom&apos;;

    // 导出
    export function hello(){ ... }
    export default {
        ...
    }
    export { fn1, fn2 }


四、CMD 同步加载模块

    代表seajs

    // 定义模块
    define(function(require,exports,module){
        var $ = require(&apos;jquery&apos;);        // 用来加载模块

        exports.sayHello = function(){    // 导出的接口
            ...
        }
    });
</code></pre><h4 id="构建工具的什么用"><a href="#构建工具的什么用" class="headerlink" title="构建工具的什么用"></a>构建工具的什么用</h4><pre><code>1、代码转换 - 将ES6转ES5, 将SCSS转成css

2、文件优化 - 压缩JS、CSS、HTML代码，压缩合并图片

3、代码分割 - 提取多个页面的公共代码，提取首屏不需要执行代码，其它的异步加载

4、模块合并 - 将多个模块合并成一个文件

5、自动刷新 - 监听本地代码变化，并自动构建和刷新浏览器

6、代码校验 - 校验代码是否符合规范

7、自动发布 - 自动构建出线上发布代码并传输给发布系统
</code></pre><h4 id="webpack安装和命令"><a href="#webpack安装和命令" class="headerlink" title="webpack安装和命令"></a>webpack安装和命令</h4><pre><code>$ npm i -D webpack webpack-cli             // 安装稳定版本，4版本以上需要装webpack-cli, -D是--save-dev的缩写

    npm i -D webpack@3.10.0                        // 安装指定版本


命令

    1、webpack            // 最基本的启动webpack命令

    2、webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包

    3、webpack -w         // watch方法，时实预览进行打包 相当于 --watch 

    4、webpack -p         // 对打包后的文件进行压缩

    5、webpack -d         // 提供SourceMaps，方便调试

    6、webpack --colors     // 输出结果带彩色，比如: 会用红色显示耗时较长的步骤

    7、webpack --profile // 输出性能数据，可以看到每一步的耗时

    8、webpack --display-modules     // 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块

    9、webpack --progress --colors   // 展示一些进度条，同时增加颜色

    10、webpack --display-error-details    // 打印出错在哪个文件和行
</code></pre><h4 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h4><pre><code>启动时需要加 --devtool source-map 参数重启DevServer后刷新页面，在chrome开发者工具就可以调试源码
</code></pre><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><pre><code>entry是配置模块的入口，执行构建最开始就递归解析所有的入口依赖，可以是 string | object | array

// 单入口
module.exports = {
    entry: &apos;./src/main.js&apos;
}

// 多入口
module.exports = {
    entry: {
        main: [&quot;./main.js&quot;, &quot;./list.js&quot;]
    }
}

// 多入口，app(应用主入口)，vendors(公共库)入口
module.exports = {
    entry: {
        main: &apos;./src/main.js&apos;,
        list: &apos;./src/list.js&apos;,
        vendors: &apos;./src/jquery.js&apos;
    }
}

一、chunk 名称

    如果入口是字符串或数组，output打包出来的都被合并成一个文件，如上（1、2），

    如果入口配置的是对象，打包出来的是以对象每个入口为一个文件，如上（3），打包会出来 main.min.js, list.min.js

    output: {
        path: path.resolve(__dirname, &apos;build/js&apos;),
        filename: &apos;[name].min.js?[hash]&apos;
    }
</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件

1、path: 输出的目录，绝对路径

2、filename: 用于输出文件的文件名

    变量: 1) id chunk的唯一标识从0开始      2）name chunk的名称        3）hash 输出hash值        4）chunkhash 内容的hash值

    filename: &apos;bundle.js&apos;

    filename: &apos;[name].js&apos;    // 用于多入口

    filename: &apos;[chunkhash].js&apos;    // 用于长效缓存，入口为entry chunk

    filename: &apos;[name].js[hash]&apos;    // 带hash值 [hash:8] 代表8位的hash,默认20位

3、publicPath: 复杂项目里会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的URL

    output: {
        filename: &apos;[name]_[chunkhash:8].js&apos;,
        publicPath: &apos;https://cdn.example.com/assets/&apos;
    }

    发布到线上的HTML &lt;script src=&quot;https://cdn.example.com/assets/main.12345678.js&quot;&lt;/script&gt;

4、chunkFilename: 配置无入口的Chunk在输出时文件名称

    const path = require(&apos;path&apos;);
    module.exports = {
        output: {
            path: path.resolve(__dirname, &apos;./dist&apos;),
            publicPath: &apos;/dist/&apos;,
            filename: &apos;my-first-bundle.js&apos; 
        }
    }
</code></pre><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><pre><code>rules配置模块的读取和解析，将所有引用资源(.css、.html、.scss、.jpg)作为模块处理

1、条件匹配: 通过test、include、exclude三个配置项来选中loader规则文件

    test: 匹配哪些文件

    include: 指定一个目录下的所有文件，可以加快webpack的搜索速度

    exclude: 排除某个目录，不在这个目录搜索文件

2、应用规则: 对选中的文件通过usr配置来应用loader

3、重置顺序: 默认从右向左执行, 通过enforce选项将其中一个loader的顺序放到最前或最后

module: {
rules: [
        {
    test: /(\.jsx|\.js)$/,
    use: {
      loader: &quot;babel-loader&quot;,        
                options: {
                    cacheDirectory: true,        // cacheDirectory用于缓存babel的编译结果，加快重新编译速度
                }
    },
            include: [path.resolve(__dirname, &apos;src)],        // 只在src目录下搜索js文件
  }
  {
    test: /\.css$/,
    use: [ &quot;style-loader&quot;, &quot;css-loader?minimize&quot;, &quot;sass-loader&quot; ],        // minimize 压缩css
            exclude: [/node_modules/]                // 除了node_modules目录不搜索
  }
]
</code></pre><p>  }</p>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><pre><code>webpack启动后会从入口找出所有的依赖模块，resolve配置如何寻找模块对应的文件

1、alias 让模块引入变得简单

    import $ from &apos;/js/lib/jquery.min.js&apos;;      开发中需要引入jquery就需要写这类路径

    通过alias来解决
    resolve: {
        alias: {
            jquery: path.resolve(__dirname, &quot;/js/lib/jquery.min.js&quot;),
        },
         extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.scss&apos;, &apos;.css&apos;]             //设置require或import的时候可以不需要带后缀
    }

    引用
    import $ from &apos;jquery&apos;;        // jquery就会被替换成依赖的路径
</code></pre><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><pre><code>plugins扩展webpack功能，在构建流程里演讲稿钩子

一、webpack自带插件，可以直接使用

    pulgins: [
        new webpack.optimize.CommonsChunkPlugin({    // webpack自带插件在webpack.optimize内
            name: &apos;vendor&apos;,                                // 上面入口定义的节点组
            filename: &apos;jquery.vendor.js?[hash]&apos;     // 最后生成的文件名
        })
    ]


二、非webpack插件，需要先调用插件

    例: main.js

        require(&apos;./main.css&apos;)
        const show = require(&apos;./show.js)
        show(1,2)

    webpack.config.js
    // 将引用的css文件提取出来 
    const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);        

    pulgins: [
        new ExtractTextPlugin({
            filename: &apos;[name].[contenthash:8].css&apos;,            // main.11ad8d2c.css
            allChunks: true,
        })
    ]
</code></pre><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><pre><code>webpack-dev-server - 创建一个本地服务，并能设置代理服务，并且能够实时重新加载

一、创建文件

    // 创建项目目录
    $ mkdir webpack_base_demo &amp;&amp; cd webpack_base_demo      

    // 创建配置文件
    $ touch README.md  .gitignore  .babelrc  webpack.config.js

    // 创建package.json
    $ npm init 

    // 配置.babelrc文件
    {
        &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
        &quot;env&quot;: {
            &quot;development&quot;: {
            &lt;!-- &quot;plugins&quot;: [[&quot;react-transform&quot;, {
                &quot;transforms&quot;: [{
                    &quot;transform&quot;: &quot;react-transform-hmr&quot;,
                    &quot;imports&quot;: [&quot;react&quot;],
                    &quot;locals&quot;: [&quot;module&quot;]
                }]
            }]] --&gt;
            }
        }
    }

二、安装webpack、webpack-dev-server

    $ npm i --save-dev webpack@3.10.0 webpack-dev-server            // webpack4.0 需要安装cli

三、安装loader

    // 如果使用react框架来做项目，先下载包
    $ npm i --save react react-dom

    $ npm i --save babel-plugin-react-transform react-transform-hmr   // babel的插件，在react热更新

        // .babelrc
        {
            &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
            &quot;env&quot;: {
                &quot;development&quot;: {
                    &quot;plugins&quot;: [
                        [
                            &quot;react-transform&quot;, {
                                &quot;transforms&quot;: [{
                                    &quot;transform&quot;: &quot;react-transform-hmr&quot;,
                                    &quot;imports&quot;: [&quot;react&quot;],
                                    &quot;locals&quot;: [&quot;module&quot;]
                                }]
                            }
                        ]
                    ]
                }
            }
        }

    // 使用Babel-loader来解析es6和react
    $ npm i --save babel-core babel-loader babel-preset-env babel-preset-react

    // vue-load - 解析和转换.vue文件，vue-template-compiler - 将vue-load提取出的HTML模板编译成可执行的JS代码，vue项目可直接安装vue-cli
    $ npm vue-load vue-template-compiler

    // jsx转换
    $ npm i --save jsx-loader

    // css模块化，可以在组件中引用指定模块的css文件， import &apos;./main.css&apos;
    $ npm i --save style-loader css-loader 

    // 可以将js和css中的导入的图片替换成正确的地址，同时将文件输出到对应的位置
    $ npm i --save file-loader

    // 将文件的图片经过base64编码后注入js或css中
    $ npm i --save url-loader    

    // 加载SVG
    $ npm i --save svg-loader

    // CSS预处理器  autoprefixer 自动加载前缀
    $ npm i --save less-loader sass-loader


四、安装插件

    1、html-webpack-plugin 解析html模板

        将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

        $ npm i --save html-webpack-plugin

    2、extract-text-webpack-plugin 单独打包css文件

        $ npm i --save extract-text-webpack-plugin

    3、open-browser-webpack-plugin   自动打开浏览器

        $ npm i --save open-browser-webpack-plugin

        var OpenBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
          new OpenBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]

    4、webpack-spritesmith   雪碧图

        $ npm i --save webpack-spritesmith

        https://www.cnblogs.com/weiweisuo/p/6912740.html

    『 更多插件见 webpack插件类.md 』


五、package.json配置

    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;webpack-dev-server --hot --inline --progress&quot;,
        &quot;build&quot;: &quot;webpack --progress --profile --colors --config&quot;
    },

    $ npm run start        // 启动开发环境


六、webpack.config.js、webpack.production.config 配置文件

    webpack.config.js 开发环境所用配置文件
    webpack.pub.config.js  生产环境所用配置文件

    /**
     * User: siguang
     * Date: 2016/12/28
     * Time: 15:04
     */
    const webpack = require(&apos;webpack&apos;);
    const path = require(&apos;path&apos;);
    const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)
    // const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); // 单独打包CSS
    const OpenBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
    // 清除目录
    const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);
    // 提取公用
    const CommonsChunkPlugin = require(&apos;webpack/lib/optimize/CommonsChunkPlugin&apos;);

    /*  文件路径配置 */
    const basePath = __dirname;
    const appPath = path.resolve(basePath, &apos;src&apos;);
    const buildPath = path.resolve(basePath, &apos;build&apos;);

    /* libs 目录下的库文件 */
    const libsPath = path.resolve(basePath, &apos;src/libs&apos;);
    const jquery = path.resolve(libsPath, &apos;jquery.min&apos;)

    // webpack配置对象
    module.exports = {

        // 入口文件
        entry: {
                app: path.resolve(appPath, &apos;js/index.js&apos;),
                list: path.resolve(appPath, &apos;js/list.js&apos;)
        },

        // 出口文件
        output: {
                path: buildPath,
                filename: &apos;/js/[name].min.js?[hash]&apos;,
                chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        // 加载器配置
        module: {
            loaders: [

                // 处理require()引入的css文件，并将代码显示到页面的&lt;style|中
                { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; },

                // 将jsx文件转成js文件
                { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},

                // 将scss文件转成css文件
                { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;},

                // ES6 转 ES5
                {    
                    test: /\.js?$/,
                    loader: &apos;babel-loader&apos;,
                    query: {
                        presets: [&apos;es2015&apos;]
                    }
                }   
            ]
        },

        // 插件
        plugins: [
            // 清空build目录
            new CleanWebpackPlugin(buildPath), 

            // 热启动
            new webpack.HotModuleReplacementPlugin(),

            // 自动开启浏览器
            new OpenBrowserWebpackPlugin({ url: &apos;http://localhost:5000&apos; })

            // 压缩打包的文件
            // new webpack.optimize.UglifyJsPlugin({
            //     compress: {
            //         //supresses warnings, usually from module minification
            //         warnings: false
            //     }
            // }),

            // 将vendor中的库合并到一起
            new CommonsChunkPlugin({
                // 从哪些Chunk 中提取
                chunks: [&apos;main&apos;, &apos;list&apos;],
                // 提取的公共部分形成一个chunk
                name: &apos;common&apos;
            }),     

            // html
            new HtmlWebpackPlugin({
                // 改变页面的&lt;title|标签的内容 
                title: &apos;Hello World app&apos;,                   // 页面调用&lt;%= htmlWebpackPlugin.options.title %|
                // 模版地址
                template: path.resolve(appPath, &apos;index.html&apos;),
                // 构建后的文件名和目录
                filename: &apos;index.html&apos;,
                //chunks这个参数告诉插件要引用entry里面的哪几个入口
                chunks:[&apos;app&apos;,&apos;vendor&apos;],
                //要把script插入标签里
                inject:&apos;body&apos;
            }),

            new HtmlWebpackPlugin({
                // 改变页面的&lt;title|标签的内容 
                title: &apos;Hello World appList&apos;, 
                // 模版地址
                template: path.resolve(appPath, &apos;list.html&apos;),
                // 构建后的文件名和目录
                filename: &apos;list.html&apos;,
                //chunks这个参数告诉插件要引用entry里面的哪几个入口
                chunks:[&apos;list&apos;,&apos;vendor&apos;],
                //要把script插入标签里
                inject:&apos;body&apos;
            }),                
        ],

        // 查找依赖
        resolve:{
            jquery: path.resolve(__dirname, &apos;src/utils/jquery.min.js&apos;), 
            // require或alias时不需要写后缀
            // extensions: [&quot;.js&quot;, &quot;.jsx&quot;, &quot;.css&quot;, &quot;.json&quot;],
        },

        // 启动文件侦听
        watch: true,      // 这里配置watch与在package.json中的script中设置 webpack --watch一样
        watchOptions: {
            // 不侦听的文件夹
            ignored: &apos;/node_modules/&apos;,  
            // 文件变化后300ms后在编译，防止更新太快导致重新编译太快
            aggregateTimeout: 300,
            // 判断文件变化 
            poll: 1000
        },

        devtool: &apos;source-map&apos;,

        // webpack-dev-server 配置
        devServer: {
        port: 8090,               // 端口
            contentBase: &apos;build&apos;,     // 内容目录
            hot: true,                    // 启用webpack热替换
            inline: true,
            compress: true,                  // 一切服务都启用gzip 压缩
            proxy: {
                &apos;/api/*&apos;: {                // 以api开头的走代理接口
                    target: &apos;http://wwww.we.com&apos;,
                    pathRewrite: {
                        &apos;^/api/&apos;: &apos;/&apos;    // api指向target的根目录
                    },
                    changeOrigin: true,
                    secure: false
                }
            },
            historyApiFallback:{
                rewrites:[        // 不存在的路由跳到404页面
                    {
                        from: /./,
                        to: &apos;404.html&apos;
                    }
                ]
            }
        }
    }


两套配置:

    webpack.development.config.js            // 开发配置
    webpack.production.config.js            // 生产配置

    script: {
        &quot;build&quot;: &quot;webpack --config production.config.js&quot;,
        &quot;dev&quot;: &quot;webpack --config development.config.js&quot;
    }
</code></pre><h4 id="webpack-dev-server-参数"><a href="#webpack-dev-server-参数" class="headerlink" title="webpack-dev-server 参数"></a>webpack-dev-server 参数</h4><pre><code>一、在webpack.config.js中配置

    // 生成Source Map
    devtool: &apos;source-map&apos;,

    devServer: {
        // 端口
        port: 8090,               

        // 默认目录
        contentBase: &apos;build&apos;,

        // 启用webpack热替换
        hot: true,                // 必须要有HotModuleReplacementPlugin插件才能完全启用HMR

        //           
        inline: true,

        // 启用gzip压缩
        compress: true,                  

        // 配置代理
        proxy: {
            &apos;/api/*&apos;: {                // 以api开头的走代理接口
                target: &apos;http://goucai.diyicai.com&apos;,
                pathRewrite: {
                    &apos;^/api/&apos;: &apos;/&apos;    // api指向target的根目录
                },
                changeOrigin: true,
                secure: false
            }
        },

        // 配置路由的跳转，404跳转
        historyApiFallback:{
            rewrites:[        // 不存在的路由跳到404页面
                {
                    from: /./,
                    to: &apos;404.html&apos;
                }
            ]
        }

        // 设置响应头
        headers: { &apos;X-Token&apos;: &apos;bar&apos; }

        // 设置https
        https: true    使用https，也可以配置证书，见资料第2章
    }


二、参数是加到package.json的script中的  &quot;start&quot;: &quot;webpack-dev-server --hot --inline --progress&quot;,

    webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器

    webpack-dev-server --devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号

    webpack-dev-server --progress - 显示合并代码进度

    webpack-dev-server --colors - 命令行中显示颜色

    webpack-dev-server --content-base build  // webpack-dev-server服务会默认以当前目录伺服文件，如果设置了content-base的话，服务的根路径则为build目录

    webpack-dev-server --inline  可以自动加上dev-server的管理代码，实现热更新

    webpack-dev-server --hot  开启代码热替换，可以加上HotModuleReplacementPlugin

    webpack-dev-server --port 3000 设置服务端口
</code></pre><p>| <a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">https://doc.webpack-china.org/concepts/</a>        webpack中文网 v3.10.0<br>| <a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a><br>| <a href="http://webpack.wuhaolin.cn/" target="_blank" rel="noopener">http://webpack.wuhaolin.cn/</a>                            // book<br>| <a href="https://webpack.js.org/plugins/" target="_blank" rel="noopener">https://webpack.js.org/plugins/</a>                // 自带插件<br>| <a href="https://zhuanlan.zhihu.com/p/32148338" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32148338</a><br>| <a href="https://blog.csdn.net/keliyxyz/article/details/51571386" target="_blank" rel="noopener">https://blog.csdn.net/keliyxyz/article/details/51571386</a><br>| <a href="http://react-china.org/t/webpack-output-filename-output-chunkfilename/2256/2" target="_blank" rel="noopener">http://react-china.org/t/webpack-output-filename-output-chunkfilename/2256/2</a>   // output.filename 和output.chunkFilename<br>| <a href="http://www.alloyteam.com/2016/02/code-split-by-routes/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/02/code-split-by-routes/</a>  按需加载<br>|<br>| 插件<br>| <a href="http://www.cnblogs.com/haogj/p/5160821.html" target="_blank" rel="noopener">http://www.cnblogs.com/haogj/p/5160821.html</a>     // html-webpack-plugin html多页面构建<br>|<br>| 热更新<br>| <a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">https://github.com/gaearon/react-hot-loader</a>    // react<br>| <a href="https://github.com/vuejs/vue-loader" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader</a>            // vue</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/26/VueJS之-“Vuex篇“（四）/">VueJS之-“Vuex篇“（四）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/26/VueJS之-“Vuex篇“（四）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-26T02:40:24.000Z" itemprop="datePublished">2016-10-26</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><pre><code>Vuex借鉴了Flux和Redux设计思想.

优点:

    Vue组件父子之间通过$on、$emit自定义事件来进行通信

    Vuex可以解决同级组件之间无法传递消息
</code></pre><h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h4><pre><code>Store: 数据仓库，包含state对象，组件通过getter从store读取数据，通过Getter

核心模块:

    1、state: 定义存储状态

    2、getter: 对数据进行过滤，获取state数据，在计算属性中获取state的值

    3、mutation: 同步操作，更改 Vuex 的 store 中的state值的唯一方法是提交 mutation

    4、action: 异步操作，Action通过commit()方法来调用mutation中的方法在改变来改变state的值，而不是直接改变state中的值

            分发Action: store.dispatch()方法触发

    5、modules: 如果应用过大，便可以使用 modules 来分割管理，不至于 store 变得非常臃肿


    调用同步的mutation  this.$store.commit(&apos;mutationName&apos;)

    调用异步的Action    this.$store.dispatch(&apos;mutationName&apos;)

        export default {
            insertMessage({commit}, insertData){
                fetch(&apos;/login&apos;,{
                    username,
                    password
                })
                .then((res)=&gt;{
                    return res.json();
                })
                .then((res) =&gt; {
                    // 调用mutation
                    commit(&apos;insertMessage&apos;, res.data);
                })
            }
        }
</code></pre><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><pre><code>用来存储数据，如果在组件中获取state中的数据，可以通过两种方法来获取: 计算属性computed 和 Getters
</code></pre><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><pre><code>在组件中用来获取Store中state，通过getter获取，组件中在通过computed来调用getter

getters.js
export const sideData = (state) =&gt; {
    return state.sideData;
} 

&lt;template&gt;
    &lt;div class=&quot;box&quot;&gt;
        {{ getSideData }}
    &lt;/div&gt;
&lt;/template&gt;

// 方法1: computed
computed: {
    getSideData () {
        return this.$store.state.sideData;            // 当getSideData的值改变就会显示出来
    }
}


// 方法2: mapState函数获取
import { mapState } from &apos;vuex&apos;;        // 引用mapState()
export default {
    name: &apos;side&apos;,
    computed: {
        ...mapState({    // 对象展开运算符
            getSideData: (state) =&gt; {
                return state.sideData
            }
        })
    }
}
</code></pre><h4 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h4><pre><code>用来更改Store中state的数据，它是同步的

1、commit()触发Action, 之后Action触发mutation来改变state的值

    // 定义mutations 
    export default {
        changeSideData(state, sideJson){
            state.sideData.push(sideJson)
        }
    }

    // 触发
    methods:{
        addSideData(){
            let side = {
                id: 1,
                name: this.name,
                introduce: this.introduce
            }
            this.$store.commit(&apos;changeSideData&apos;, side);
        }
    }

2、使用mapMutations() 来定义改变
</code></pre><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><pre><code>actions提交到 Mutations中，action而不能直接改变state的值

actions可以包含异步操作，mutations是同步的

// 定义action
export const holderSilde = ({commit}, {name, introduce}) =&gt; {    
    // {name, introduce} 这里注意一定对象传过来，这里为解析赋值写法，函数不接收第三个参数
    var side = {
        id: 1,
        name: name,
        introduce: introduce
    }
    commit(&apos;changeSideData&apos;, side)
}


// 调用 分发dispatch
methods:{
    addSideData(){
        // 第二个为传过去的参数
        this.$store.dispatch(&apos;holderSilde&apos;, {name: this.name, introduce: this.introduce});
    }
}
</code></pre><h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><pre><code>Vuex可以将Store分割到各模块，每个模块都有自己的store、mutations、actions、getters

const moduleA = {
    state: { ... },
    mutations: { ... },
    actions: { ... },
    getters: { ... }
}

const moduleB = {
    state: { ... },
    mutations: { ... },
    actions: { ... }
}

const store = new Vuex.Store({
    modules: {
        a: moduleA,
        b: moduleB
    }
})

store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态
</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>// store.js
import Vue from &apos;vue&apos;
import Vuex from &apos;vuex&apos;
import mutations from &apos;./mutations.js&apos;;
import actions from &apos;./actions.js&apos;;
import getters from &apos;./getters.js&apos;;
Vue.use(Vuex);

// 初始化数据
const state = {
    currentId: 0,
    currentUsername: &apos;&apos;,
    sideData: [
        {
            id: &apos;1&apos;,
            username: &apos;siguang&apos;,
            introduce: &apos;用户描述&apos;
        },
        {
            id: &apos;2&apos;,
            username: &apos;lulu&apos;,
            introduce: &apos;用户描述&apos;
        }
    ]
}

export default new Vuex.Store({
    state,
    getters,
    actions,
    mutations,
})


// main.js
import Vue from &apos;vue&apos;
import App from &apos;./App&apos;
import router from &apos;./router&apos;
import store from &apos;./store.js&apos;
Vue.config.productionTip = false;

let vm = new Vue({
    el: &apos;#app&apos;,
    router,
    store,
    components: { App },
    template: &apos;&lt;App/&gt;&apos;
})

window.vm = vm;
</code></pre><p>| <a href="https://vuex.vuejs.org/zh" target="_blank" rel="noopener">https://vuex.vuejs.org/zh</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/23/VueJS之-“插件篇“（三）/">VueJS 之 “插件篇“（三）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/23/VueJS之-“插件篇“（三）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-23T11:19:24.000Z" itemprop="datePublished">2016-10-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| vue-router 路由插件<br>| vue-validator 表单校验插件<br>| vue-resource ajax插件</p>
<h4 id="vue-cli3-脚手架"><a href="#vue-cli3-脚手架" class="headerlink" title="vue-cli3 脚手架"></a>vue-cli3 脚手架</h4><pre><code>一、安装

    $ npm install -g @vue/cli            // 最新版本3.0

    $ vue create hello-world            // 创建项目 vue create --help

        注意 如果安装sass选择手动

        1、&gt; default (babel, eslint)
         &gt; Manually select features

        2、选择预解释器
        &gt;    (*) CSS Pre-processors                // 空格选择

        // 如果安装2.0的模板
        $ vue init webpack my-project        // vue init webpack-simple#1.0 mynewproject

    $ cd hello-world

    $ yarn serve     // 启动服务

    $ yarn build  // 打包

    // 安装插件
    $ vue add router
    $ vue add vuex


二、package.json

    script: {
        &quot;serve&quot;: &quot;vue-cli-service serve --mode test231&quot;,
    }

    --mode        指定环境模式 (默认值：production)
    --dest        指定输出目录 (默认值：dist)
    --modern      面向现代浏览器带自动回退地构建应用
    --target      app | lib | wc | wc-async (默认值：app)
    --name        库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名)
    --no-clean    在构建项目之前不清除目标目录
    --report      生成 report.html 以帮助分析包内容
    --report-json 生成 report.json 以帮助分析包内容
    --watch       监听文件变化

    环境变量设置
    script: {
        &quot;serve&quot;: &quot;FOO=bar vue-cli-service serve --mode test231&quot;,
    }

    vue.config.js中获取
    console.log(process.env.FOO);        // bar


三、vue.config.js 配置

    &apos;use strict&apos;
    module.exports = {

        // 修改webpack配置的方式, 该对象会对webpack-merge合并
        configureWebpack: {
          optimization: {
            splitChunks: false
          }
        },
        // 修改 Loader选项
        chainWebpack: config =&gt; {
            config
                .plugin(&apos;html&apos;)
                .tap(args =&gt; {
                    // 防止 Cyclic dependency 错误
                    args[0].chunksSortMode = &apos;none&apos;
                    return args
                })
        },
        // 配置代理
        devServer: {
            // mock
            // 在这里定义mock需要重启server，改为在 utils/mock 中定义
            // https://webpack.js.org/configuration/dev-server/
            before: function (app) {
                app.get(&apos;/api/version&apos;, function (req, res) {
                    res.json({
                        data: &apos;V1.0.0&apos;,
                        message: &apos;&apos;,
                        status: 0,
                    });
                });
            },

            // 反向代理配置
            // https://github.com/chimurai/http-proxy-middleware#proxycontext-config
            proxy: {
                &apos;/api&apos;: {
                    target: &apos;http://172.13.3.232:12080&apos;,
                    // ws: true,
                    changeOrigin: true,
                    autoRewrite: true,
                    pathRewrite: {
                        &apos;^/api/&apos;: &apos;/&apos;
                    }
                },    
            },
            disableHostCheck: true
        }
    }


四、public目录、css样式

    public目录存放静态资源

    cli支持Sass、Less、Stylus预处理器


二、main.js 入口文件

    import Vue from &apos;vue&apos;
    import chat from &apos;./components/chat.vue&apos;;

    new Vue({
        el: &apos;#app&apos;,
        render: h =&gt; h(chat)         // 调用其它.vue文件必须这么写
    })

    render: h =&gt; h(chat) 相当于

    render: (function (h) {  
          return h(App);
    });  


三、不需要代码校验

    在webpack.base.conf.js里面删掉下面:

    preLoaders: [
        {
            test: /\.vue$/,
            loader: &apos;eslint&apos;,
            include: projectRoot,
            exclude: [/node_modules/, /ignore_lib/]
        },
        {
            test: /\.js$/,
            loader: &apos;eslint&apos;,
            include: projectRoot,
            exclude: [/node_modules/, /ignore_lib/]
        }
    ]


https://cli.vuejs.org/zh/
</code></pre><h4 id="vue-router-路由"><a href="#vue-router-路由" class="headerlink" title="vue-router 路由"></a>vue-router 路由</h4><pre><code>一、安装

    $ npm install vue-router --save-dev


二、引用路由:

    import Vue from &apos;vue&apos;
    import VueRouter from &apos;vue-router&apos;
    Vue.use(VueRouter)

    const routes = [
        { path: &apos;/foo&apos;, component: Foo },        // 一个路由对应一个组件
        { path: &apos;/bar&apos;, component: Bar }
    ]
    const route = new Router(    
        mode: &apos;history&apos;,
        routes,
    })

    let vm = new Vue({
        el: &apos;#app&apos;,
        route,
        components: { App },
        template: &apos;&lt;App/&gt;&apos;
    })


三、使用路由

    html:

        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;
            &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;

            &lt;!-- 加载路由视图 --&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
        &lt;/div&gt;

     router.js

        import Vue from &apos;vue&apos;
        import VueRouter from &apos;vue-router&apos;
        import login from &apos;./components/login&apos;

        // 将路由插件加载到Vue中
        Vue.use(VueRouter);

        // 路由映射配置
        const routes = [
            { 
                path: &apos;/login&apos;, 
                component: login
            },
            {
                path: &apos;/*&apos;,
                redirect: &apos;/404&apos;        // 重定向
            }
        ]

        // 创建路由实例
        const router = new VueRouter({
            routes        // 将定义的配置当参数注入路由
        })

        // 创建和挂载根实例
        const app = new Vue({
            router
        }).$mount(&apos;#app&apos;)


四、动态路由参数

    const router = new VueRouter({
        routes: [
            // 动态路径参数 以冒号开头
            { path: &apos;/user/:id&apos;, component: User }
        ]
    })

    // 路由参数  /user/:username     匹配/user/haha    $route.params 来取参数  { username: &apos;haha&apos; }
    mounted(){
        let usernmae = this.$route.params.username;
    }

    1、router-link 参数

        &lt;router-link :to=&quot;{ name: &apos;user&apos;, params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;

    2、this.$router.push中参数

        router.push({ name: &apos;user&apos;, params: { userId: 123 }})


五、路由跳转

    1、$router.push(location): js内加路由跳转

        // 字符串
        router.push(&apos;home&apos;)

        // 对象
        router.push({ path: &apos;home&apos; })

        // 命名的路由
        router.push({ name: &apos;user&apos;, params: { userId: 123 }})

        // 带查询参数，变成 /register?plan=private
        router.push({ path: &apos;register&apos;, query: { plan: &apos;private&apos; }})

    2、router.replace(): 与push很像，不同的是replace不会向history添加到新记录

    3、router.go(n): 指定向后跳几步，与window.history.go(n)相同，history历史记录跳转

    4、&lt;router-link to=&quot;home&quot;&gt;home&lt;/router-link&gt;            // 编辑出来是&lt;a&gt;标签


五、&lt;router-view&gt; 渲染路由视图组件

    &lt;router-view&gt;&lt;/router-view&gt;

    支持多个渲染:
    &lt;router-view&gt;&lt;/router-view&gt;
    &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;
    &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;

    const router = new VueRouter({
        routes: [
            {
                path: &apos;/&apos;,
                components: {
                    default: Foo,
                    a: Bar,
                    b: Baz
                }
            }
        ]
    })


六、捕获所有路由或 404 Not found路由

    {
        path: &apos;*&apos;,
        redirect: function () {
                return &apos;/admin&apos;;
        }
    }


七、History模式

    1、hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。

    2、history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式. （url不会带hash “#“）

    3、abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式

    export default new VueRouter({
        mode: &apos;history&apos;,
        routes: [...]
    })            


八、路由钩子

    1、beforeEach、afterEach 路由跳转前后的钩子

        var auth = {
            loggedIn: function () {
                return localStorage.getItem(KEY_OF_LOGGEDIN) === &apos;true&apos;; 
            }
        }

        router.beforeEach((to, from, next) =&gt; {
            if (to.matched.some(record =&gt; record.meta.requiresAuth)) {
                if (!auth.loggedIn()) {
                    next({
                        path: &apos;/login&apos;,
                        query: {redirect: to.fullPath},
                    });
                } else if (auth.requiresAlterPassword()){
                    next({
                        path: &apos;/firstLogin&apos;
                    });
                } else {
                    next();
                }
            } else {
                next();
            }
        });

    2、to: 要进入目录的路由对象

    3、from: 要离开的路由对象

    4、next: function, 用该方法来resolve这个钩子

        next({
            path: &apos;/login&apos;,        // 跳转的
            query: {redirect: to.fullPath},                // to.fullPath是当前的路径
        });


九、meta 定义路由的时候可以配置meta字段

    1、设置meta属性，可以通过它来设置不需要判断登录的路由，在beforeEach的时候进行处理

        {
            path: &apos;/firstLogin&apos;,
            name: &apos;firstLogin&apos;,
            meta: {
                requiresAuth: false
            },
            component: (resolve) =&gt; require([&apos;../views/firstLogin.vue&apos;], resolve),
        }

    2、matched来访问meta属性


十、路由对象

    1、$route.path: 当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;

    2、$route.params: 获取动态路由的参数

    3、$route.query:  URL 查询参数, 例如，对于路径 /foo?user=1，则有 $route.query.user == 1

    4、$route.hash: 路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。

    5、$route.matched: 

    6、$route.name: 路由的名称
</code></pre><h4 id="vue-resource-ajax插件"><a href="#vue-resource-ajax插件" class="headerlink" title="vue-resource ajax插件"></a>vue-resource ajax插件</h4><pre><code>一、它提供了两种方式来处理HTTP请求: 

    使用Vue.http或this.$http

    使用Vue.resource或this.$resource


二、特点: 支持拦截器

    拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。

    拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。


三、使用方式: 

    1、拦截器  使用inteceptor

    Vue.http.interceptors.push((request, next) =&gt; {
        // 请求发送前的处理逻辑
        next((response) =&gt; {
            // 请求发送后的处理逻辑
            // 根据请求的状态，response参数会返回给successCallback或errorCallback
            return response
        })
    })


四、请求类型

    get(url, [options])
    head(url, [options])
    delete(url, [options])
    jsonp(url, [options])
    post(url, [body], [options])
    put(url, [body], [options])
    patch(url, [body], [options])

    &lt;script&gt;
        var demo = new Vue({
            el: &apos;#app&apos;,
            data: {
                gridColumns: [&apos;customerId&apos;, &apos;companyName&apos;, &apos;contactName&apos;, &apos;phone&apos;],
                gridData: [],
                apiUrl: &apos;http://211.149.193.19:8080/api/customers&apos;
            },
            ready: function() {
                this.getCustomers();
            },
            methods: {
                getCustomers: function() {
                    // get请求
                    // then方法只提供了successCallback，而省略了errorCallback。
                    // catch方法用于捕捉程序的异常，catch方法和errorCallback是不同的，errorCallback只在响应失败时调用，而catch则是在整个请求到响应过程中，只要程序出错了就会被调用。

                    this.$http.get(this.apiUrl)
                        .then((response) =&gt; {
                            // Vue实例方法，设置gridData属性赋值，并触发视图更新
                            this.$set(&apos;gridData&apos;, response.data)
                        })
                        .catch(function(response) {
                            console.log(response)
                        })
                }
            }
        })
    &lt;/script&gt;

5、options对象

    发送请求时的options选项对象包含以下属性: 

    参数             类型                                    描述
    url             string                      请求的URL

    method        string                请求的HTTP方法，例如: &apos;GET&apos;, &apos;POST&apos;或其他HTTP方法
    body            Object                 FormData string    request body
    params        Object                请求的URL参数对象
    headers        Object                request header
    timeout        number                单位为毫秒的请求超时时间 (0 表示无超时时间)
    before        function(request)    请求发送前的处理函数，类似于jQuery的beforeSend函数
    progress     function(event)      ProgressEvent回调处理函数
    credientials    boolean      表示跨域请求时是否需要使用凭证
    emulateHTTP        boolean      发送PUT, PATCH, DELETE请求时以HTTP POST的方式发送，并设置请求头的X-HTTP-Method-Override
    emulateJSON        boolean      将request body以application/x-www-form-urlencoded content type发送
</code></pre><p>| <a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/</a><br>| <a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh-cn/</a><br>| <a href="https://github.com/dai-siki/vue-image-crop-upload" target="_blank" rel="noopener">https://github.com/dai-siki/vue-image-crop-upload</a>   头像上传组件<br>| <a href="http://www.cnblogs.com/pandabunny/p/5417938.html" target="_blank" rel="noopener">http://www.cnblogs.com/pandabunny/p/5417938.html</a>     // vue引用jquery<br>| <a href="http://router.vuejs.org/zh-cn/installation.html" target="_blank" rel="noopener">http://router.vuejs.org/zh-cn/installation.html</a>     // 路由插件<br>| <a href="http://yuche.github.io/vue-strap/" target="_blank" rel="noopener">http://yuche.github.io/vue-strap/</a>                    // vueStrap<br>| <a href="http://bootstrap-table.wenzhixin.net.cn/zh-cn/" target="_blank" rel="noopener">http://bootstrap-table.wenzhixin.net.cn/zh-cn/</a>    // bootstrap Table<br>| <a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">https://github.com/PanJiaChen/vue-element-admin</a><br>| <a href="https://github.com/opendigg/awesome-github-vue?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">https://github.com/opendigg/awesome-github-vue?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a>      // vue项目汇总</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/22/VueJS之-“组件篇“（二）/">VueJS 之 “组件篇“（二）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/22/VueJS之-“组件篇“（二）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-22T06:02:01.000Z" itemprop="datePublished">2016-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 全局、局部组件<br>| 数据传递（props、组件通信、slot）<br>| props、sync双向绑定、once单次绑定<br>| 组件之间通信，$dispatch() 派发事件、 $broadcast() 广播事件，事件向下传导给所有后代<br>| slot 内容分发<br>| 组件是Vue的最强大功能之一，组件可以扩展html元素，封装可复用代码</p>
<h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><pre><code>全局组件在任何组件内都可以调用，无需引用或通过component加载

main.js

    // 定义一个全局的组件
    var myComponent = Vue.extend({
        template: &apos;&lt;div&gt; 组件已经渲染出来 &lt;/div&gt;&apos;
    })

    // 全局注册
    Vue.component(&apos;crm-component&apos;, myComponent);

    let vm = new Vue({
        ...
    }}


main.vue 子组件

    &lt;templte&gt;
        &lt;div class=&quot;welcome&quot;&gt;
            &lt;h1&gt;视图列表页面&lt;/h1&gt;
            &lt;crm-component&gt;&lt;/crm-component&gt;            &lt;!-- 调用 --&gt;
        &lt;/div&gt;
    &lt;/template&gt;
</code></pre><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h4><pre><code>必须使用components对象来引用组件

&lt;div id=&quot;appA&quot;&gt;
    &lt;User&gt;&lt;/User&gt;
&lt;/div&gt;

&lt;script&gt;
    import User import &apos;./user&apos;;

    var vmA = new Vue({
        el: &quot;#appA&quot;,
        components: {        // 局部的写法
            User
        }
    })
&lt;/script&gt;
</code></pre><p>————— 父与子组件之间的数据传递 —————</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>父组件将数据传给子组件通过props，子组件通过自定义事件$on、$emit来挂参数传递给父组件

一、props

    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 这里的两个属性值通过props传到组件中 --&gt;
        &lt;component-parent my-name=&quot;siguang&quot; my-age=&apos;33&apos;&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var componentCrm = Vue.extend({
            props: [&apos;myName&apos;, &apos;myAge&apos;],
            template: &apos;&lt;h2&gt;{{ myName }} {{ myAge }}&lt;/h2&gt;&apos;
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: componentCrm
            }
        })
    &lt;/script&gt;

    注意: my-name=&quot;siguang&quot; 自定义属性以“-”分割

         props: [&apos;myName&apos;, &apos;myAge&apos;]        // props 定义的必须以驼峰形势


二、props动态值

    parent.vue:

        &lt;div id=&quot;app&quot;&gt;
            &lt;child-component :user-name=&quot;uname&quot;&gt;&lt;/child-component&gt;
        &lt;/div&gt;

        &lt;script&gt;
            import childComponent from &apos;childComponent.vue&apos;;

            export default{
                data(): {
                    return{
                        uname: &apos;siguang&apos;
                    }
                },
                components:{
                    childComponent
                }
            }
        &lt;/script&gt;


    childComponent.vue:

        &lt;div&gt;
            {{ userName }}        &lt;!-- siguang --&gt;
        &lt;/div&gt;

        &lt;script&gt;
            export default{
                propos: [&apos;userName&apos;],
            }
        &lt;/script&gt;


三、once 将渲染的结果缓存

    不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来

    &lt;div id=&quot;app&quot;&gt;
        &lt;component-parent&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;

        var childrenComponent = Vue.extend({
            template: &apos;&lt;div v-once&gt;&apos;+
                &apos;&lt;h3&gt;这里是子组件的内容: {{ myMsg }}&lt;/3&gt;&apos;+
                &apos;&lt;p&gt;这里输入不会影响父组件: &lt;input type=&quot;text&quot; v-model=&quot;myMsg&quot; /&gt;&lt;/p&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            data: function(){
                return {
                    myMsg: &apos;&apos;
                }
            },
            props: [&apos;myMsg&apos;]
        })

        var parentComponent = Vue.extend({
            template: &apos;&lt;div v-once&gt;&apos;+
                &apos;&lt;p&gt;&lt;input text=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;/p&gt;&apos;+
                &apos;&lt;p&gt;父组件的值 {{ msg }}&lt;/p&gt;&apos;+
                &apos;&lt;/div&gt;&apos;+
                &apos;&lt;childen-component v-bind:my-msg.once=&quot;msg&quot;&gt;&lt;/childen-component&gt;&apos;,
            data: function(){
                return {
                    msg: &apos;这里值只传给子组件一次&apos;
                }
            },
            components: {
                &apos;childen-component&apos;: childrenComponent
            }
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: parentComponent
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="组件之间通信"><a href="#组件之间通信" class="headerlink" title="组件之间通信"></a>组件之间通信</h4><pre><code>props是单向数据流父向子组件传递数据，子向父组件传递可以通过自定义事件来处理

$on(eventName) 监听事件    、$emit(eventName) 触发事件

一、子向父组件发消息

    parent.vue: 

        &lt;template&gt;
            &lt;div class=&quot;login&quot;&gt;
                &lt;div class=&quot;parent-box&quot;&gt;
                    &lt;p&gt;显示子组件数据: {{ childrenText }}&lt;/p&gt;
                &lt;/div&gt;
                &lt;children-component ref=&quot;childrenRef&quot; v-on:showChildrenVal=&quot;childrenVal&quot;&gt;&lt;/children-component&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            import ChildrenComponent from &apos;./children.vue&apos;
            export default{
                data(){
                    return {
                        childrenText: &apos;&apos;
                    }
                },
                methods:{
                    childrenVal(val){
                        this.childrenText = val;
                    }
                },
                components:{
                    ChildrenComponent
                }
            }
        &lt;/script&gt;

    children.vue:

        &lt;template&gt;
            &lt;div class=&quot;children&quot; style=&quot;padding-top: 50px; border-top: 1px #ccc solid&quot;&gt;
                &lt;p&gt;&lt;input type=&quot;text&quot; v-model=&quot;childrenInp&quot; id=&quot;&quot;&gt;&lt;/p&gt;
                &lt;p&gt;&lt;input type=&quot;button&quot; @click=&quot;toParentData&quot; value=&quot;提交到父组件中&quot;&gt;&lt;/p&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            export default{
                data(){
                    return {
                        childrenInp: &apos;&apos;
                    }
                },
                methods:{
                    toParentData(){
                        this.$emit(&quot;showChildrenVal&quot;, this.childrenInp);
                    }
                }
            }
        &lt;/script&gt;


二、父向子发消息

    parent.vue:

        &lt;template&gt;
            &lt;div class=&quot;login&quot;&gt;
                &lt;div class=&quot;parent-box&quot;&gt;
                    &lt;p&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;inputParent&quot; &gt;&lt;br&gt;&lt;/p&gt;
                    &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;值传给父组件&quot; @click=&quot;sendChildren&quot;&gt;&lt;br&gt;&lt;/p&gt;
                    &lt;p&gt;显示子组件数据: {{ childrenText }}&lt;/p&gt;
                &lt;/div&gt;

                &lt;children-component ref=&quot;childrenRef&quot;&gt;&lt;/children-component&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            import ChildrenComponent from &apos;./children.vue&apos;
            export default{
                data(){
                    return {
                        inputParent: &apos;&apos;,
                        childrenText: &apos;&apos;
                    }
                },
                methods:{
                    sendChildren(){
                        this.$refs.childrenRef.$emit(&apos;showText&apos;, this.inputParent);        // 也可以用props
                    }
                },
                components:{
                    ChildrenComponent
                }
            }
        &lt;/script&gt;


    children.vue:

        &lt;template&gt;
            &lt;div class=&quot;children&quot; style=&quot;padding-top: 50px; border-top: 1px #ccc solid&quot;&gt;
                这里是父组件传递的值: {{transmitVal}}
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            export default{
                created(){
                    this.$on(&apos;showText&apos;, function(val){
                        this.transmitVal = val;
                    })
                },
                data(){
                    return {
                        transmitVal: &apos;&apos;
                    }
                }
            }
        &lt;/script&gt;


三、v-ref 直接访问到组件

    &lt;div id=&quot;app&quot;&gt;
        &lt;span ref=&quot;msg&quot;&gt; hello &lt;/span&gt;
        &lt;span ref=&quot;other-msg&quot;&gt; world &lt;/span&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                someProp: &apos;idName&apos;,
                otherProp: &apos;prop&apos;
            }
        })

        console.log(vm.$refs.msg.textContent);        // hello
        console.log(vm.$refs.otherMsg.textContent);    // world
    &lt;/script&gt;
</code></pre><h4 id="slot-分发内容"><a href="#slot-分发内容" class="headerlink" title="slot 分发内容"></a>slot 分发内容</h4><pre><code>parent.vue:
    &lt;template&gt;
        &lt;div class=&quot;login&quot;&gt;
            &lt;children-component&gt;
                &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;
                &lt;div class=&quot;tag&quot;&gt;
                    这里是没有定义slot名称走的默认的slot
                    &lt;div class=&quot;tag-til&quot;&gt;标题&lt;/div&gt;
                    &lt;div class=&quot;tag-content&quot;&gt;内容部分&lt;/div&gt;
                &lt;/div&gt;
            &lt;/children-component&gt;
        &lt;/div&gt;
    &lt;/template&gt;

children.vue:
    &lt;template&gt;
        &lt;div class=&quot;children&quot;&gt;
            &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
            &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
    &lt;/template&gt;
</code></pre><h4 id="组件化的css"><a href="#组件化的css" class="headerlink" title="组件化的css"></a>组件化的css</h4><pre><code>可以通过scoped属性来控制样式是否是只在当前组件下使用

&lt;style&gt;
    /* 全局下的样式 */
&lt;/style&gt;

&lt;style scoped&gt;
    /* 当前组件下使用的样式 */
&lt;/style&gt;
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/22/VueJS之-“基础篇“（一）/">VueJS 之 “基础篇“（一）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/22/VueJS之-“基础篇“（一）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-22T03:06:51.000Z" itemprop="datePublished">2016-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| style与class<br>| computed、directive、filter<br>| watch 侦听Data数据的变化<br>| 生命周期: beforeCreate、create、beforeMount、mounted、beforeUpdate、updated、destroyed<br>| this.$refs、$el、$data、$watch<br>| v-bind缩写:、v-on缩写@</p>
<h4 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h4><pre><code>一、Vue的MVVM实现的原理

    ViewModel是Vue.js的核心，Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素

    DOM Listeners 和 Data Bindings看作两个工具，它们是实现双向绑定的关键。

    从view层来看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；

    从Model层来看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。


二、安装

    $ npm i vue --save-dev

    $ npm i vue-cli 脚手架
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>一、构造器

    1、每个构造器都是通过创建一个Vue的实例启动的

        var vm = new Vue({
            // ...    
        })

    2、扩展构造器

        通过扩展构造器可以创建可复用的组件构造器

        var MyComponent = Vue.extend({
            // 扩展选项
        })


二、生命周期

    1、beforeCreate(): 实例初始化，数据观测(data observer)和事件（event/watcher）配置之前被调用

    2、created(): 实例创建完后被调用，完成了数据观测(data observer)和事件（event/watcher）回调，但还挂载还没开始$el属性不可见

    3、beforeMount(): 在挂载开始之前调用，render()函数被调用

    4、mounted(): el被创建的vm.$el替换，挂载到实例上调用钩子

    5、beforeUpdate(): 数据更新时调用，在虚拟DOM重新渲染

    6、updated(): 数据更改导致虚拟DOM重新渲染

    7、destroyed(): 卸载组件
</code></pre><h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><pre><code>一、文本绑定:  &lt;p&gt;{{ data.name }}&lt;/p&gt;

二、html绑定:  &lt;p v-html=&quot;data&quot;&gt;&lt;/p&gt;

三、绑定属性的值 

    &lt;div id=&quot;item-{{id}}&quot;&gt;&lt;/div&gt;

    &lt;div :id=&quot;userId&quot;&gt;&lt;/div&gt;

四、表达式:  {{ dat.num == 1 }}、 {{ num ? 'yes' : 'no' }}、 {{if(ok) {return message} }}

五、过滤器:  {{ message | capitalize }}

    连续过滤器:  {{ message | filterA | filterB }}
</code></pre><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><pre><code>指令: 以 v- 开头

    &lt;div v-if=&quot;greeting == 1&quot;&gt;&lt;/div&gt;

    带参数: &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;

一、v-if、v-else-if、v-else条件渲染:

    &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;A&lt;/div&gt;
    &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;B&lt;/div&gt;
    &lt;div v-else&gt;Not A/B/C&lt;/div&gt;

二、v-show: 显示还是隐藏元素，用的display

三、v-for 循环

    $index: 索引        $key: 

    * 数组
        &lt;li v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;{{ item.message }}&lt;/li&gt;

    * 数组对象
        &lt;li v-for=&quot;(val, index) in objList&quot; :key=&quot;index&quot;&gt;
            {{index}}. {{key}} : {{val.type}}
        &lt;/li&gt;

        ** 注意:key，如果key没有改变不会重新渲染组件，问题在于子组件中存在于绑定

    * filterBy()、orderBy()过滤器

四、v-model: 绑定值，这也是MVVM的关键点

    可以对文本表单、单选框 、多选框、下拉菜单进行绑定值

        1、lazy: 不是输入时就进行同步而是在change的时候才对数据进行同步

            &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; lazy /&gt; {{msg}}

        2、number: 将用户输入的转成Number型，如果返回NaN那就返回原值

        3、debounce: 设置一个最小延时，否则如果输入是ajax请求，每次敲击都会去请求

            &lt;input type=&quot;text&quot; debounce=&quot;500&quot; v-model=&quot;msg&quot;&gt;        // 按完键500毫秒后在进行

    获取checkbox值:

        &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt;

        // 当选中时
        vm.toggle === vm.a

        // 当没有选中时
        vm.toggle === vm.b

五、v-bind: 绑定到HTML元素上，v-bind:class=&quot;active&quot;，缩写 &quot;:&quot; &lt;a :href=&apos;url&apos;&gt;&lt;/a&gt;

六、v-on: 监听DOM事件 v-on缩写: &quot;@&quot; &lt;div @click=&quot;doSomeing&quot;&gt;&lt;/div&gt;

七、ref: 访问子组件

    &lt;div ref=&quot;box&quot;&gt;xxxx&lt;/div&gt;
    &lt;el-button type=&quot;primary&quot; slot=&quot;append&quot; @click=&quot;getRefs&quot;&gt;发送&lt;/el-button&gt;
    &lt;/div&gt;

    {
        methods:{
            getRefs(){
                console.log(this.$refs.box.innerHTML);        // 获取 $refs
            }
        }
    }

    如果绑定一个元素使用 :ref=&apos;item&apos;
    &lt;p v-for=&quot;item in items&quot; :ref=&quot;item&quot;&gt;&lt;/p&gt;

八、v-pre: 跳过这个元素和它的子元素的编译过程，这样加快了编译的速度

    &lt;div v-pre&gt;{{ 这里不用框架来编译 }}&lt;/div&gt;

九、v-cloak:

十、v-once: 只渲染元素和组件一次，之后的渲染都会跳过次元素

    &lt;span v-once&gt;xxxxx&lt;/span&gt;
</code></pre><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><pre><code>过滤器，对绑定值进行处理

一、自定义过滤器

    在一个组件中定义过滤器：
        &lt;span v-text=&quot;message | reverse &apos;addText&apos; &quot;&gt;&lt;/span&gt;
        export default {
            filters: {
                capitalize: function (value) {
                    value = value.toString();
                    return value.charAt(0).toUpperCase() + value.slice(1)
                }
            }
        }

    定义全局过滤器：
        filters.js
        Vue.filter(&apos;datetime&apos;, function (value, format) {
            if (!value) {
                return 
            }
            return moment(value).format(format || &apos;YYYY-MM-DD HH:mm:ss&apos;);
        });

        main.js
        import &apos;./filters.js&apos;        // 引用


二、内置过滤器

    1、uppercase: 字母转成大写

    2、lowercase: 字母转成小写

    3、capitalize: 首字母转成大写

    4、filterBy: 过滤内容

    5、limitBy: 过滤数据从开始到指定位置结束的内容

    6、orderBy: 过滤排序

    7、currency: 货币过滤

    8、debounce: 延迟过滤


三、双向过滤器

    模型的值显示在视图之前转换它

    &lt;input v-mode=&quot;money | formatMoney&quot;&gt;
    &lt;div&gt;{{ money | formatMoney }}&lt;/div&gt;

    Vue.filter(&apos;formatMoney&apos;, {

        // model -&gt; vlew过程  在更新&lt;input&gt; 元素之初化值
        read: function(val){
            return &apos;$&apos; + val.toFixed(2);
        },

        // vlew -&gt; model过程 在写回数据之前格式化值
        write: function(val){
            var number = +val.replace(/[^\d.]/g, &apos;&apos;);
            return isNaN(number) ? 0 : parseFloat(number.toFixed(2));
        }
    })


四、动态参数

    参数用空格格开
    &lt;input type=&quot;text&quot; v-model=&quot;userInput&quot;&gt;
    &lt;span&gt;{{msg | concat userInput}}&lt;/span&gt;

    Vue.filter(&apos;concat&apos;, function (value, input) {
        // `input` === `this.userInput`
        return value + input;
    })


五、filterBy过滤器

    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;过滤数据里包含 蛋糕 字符 &lt;/div&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | filterBy &apos;蛋糕&apos; &quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top: 30px&quot; &gt;过滤出输入的字符&lt;/div&gt;
        &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;searchKey&quot; /&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | filterBy searchKey in &apos;name&apos;&quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                searchKey: &apos;&apos;,
                users:[
                    {
                        name: &apos;外卖&apos;,
                        tag: 1
                    },
                    {
                        name: &apos;鲜花&apos;,
                        tag: 5
                    },
                    {
                        name: &apos;蛋糕&apos;,
                        tag: 4
                    },
                    {
                        name: &apos;水果&apos;,
                        tag: 2
                    },
                    {
                        name: &apos;茶点&apos;,
                        tag: 3
                    }
                ]
            }
        })
    &lt;/script&gt;


六、orderBy排序

    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;searchKey&quot; /&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | orderBy &apos;tag&apos;&quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                searchKey: &apos;&apos;,
                users:[
                    {
                        name: &apos;外卖&apos;,
                        tag: 1
                    },
                    {
                        name: &apos;咖啡&apos;,
                        tag: 5
                    },
                    {
                        name: &apos;餐厅订座&apos;,
                        tag: 4
                    },
                    {
                        name: &apos;蛋糕&apos;,
                        tag: 2
                    },
                    {
                        name: &apos;票务&apos;,
                        tag: 3
                    }
                ]
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><pre><code>一、钩子函数

    el：指令所绑定的元素，可以用来直接操作 DOM 。
    binding：一个对象，包含以下属性：
    name：指令名，不包括 v- 前缀。
    value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。
    oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
    expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。
    arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。
    modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
    vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
    oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

二、对象字面量

    &lt;div v-demoA=&quot;{ color: &apos;white&apos;, text: &apos;hello&apos;}&quot;&gt;&lt;/div&gt;

    Vue.directive(&apos;demoA&apos;, function(el, value){
        console.log(value.color);
        console.log(value.text);
    })

三、元素指令，相当于angular的E指令

    Vue.elementDirective(&apos;my-directive&apos;, {
        bind: function(){
            // 操作this.el
        }
    })

    &lt;my-directive&gt;&lt;/my-directive&gt;            // 不能这么写&lt;div v-my-directive&gt;&lt;/div&gt;

四、高级选项

    params: 自动提取绑定元素的这些特性.

    &lt;div v-example a=&quot;hi&quot;&gt;&lt;/div&gt;
    Vue.directive(&apos;example&apos;, {
        params: [&apos;a&apos;],
        bind: function () {
            console.log(this.params.a);         // -&gt; &quot;hi&quot;
        }
    })
</code></pre><h4 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h4><pre><code>计算属性当依赖属性发生变化时，属性的值会自动更新，相关的DOM也会同步更新

一、计算属性的getter

    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;user_inof={{ userInfo }}&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                &quot;user_name&quot;: &quot;lulu&quot;,
                &quot;user_age&quot;: &quot;20&quot;
            },
            computed: {
                // 一个计算属性getter
                userInfo: function(){
                    return &apos;姓名: &apos;+ this.user_name +&apos; 年龄: &apos;+ this.user_age;
                }
            }
        })
    &lt;/script&gt;

二、计算属性的setter

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            &quot;user_name&quot;: &quot;lulu&quot;,
            &quot;user_age&quot;: &quot;20&quot;
        },
        computed: {
            userInfo: function(){
                get: function(){
                    return &apos;姓名: &apos;+ this.user_name +&apos; 年龄: &apos;+ this.user_age;
                },
                set: function(newValue){        // 这里当
                    this.userInfo = newValue;
                }
            }
        }
    })
</code></pre><h4 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h4><pre><code>watch 侦听data下指定数据的变化 

watch:{
    message: function(newValue){
        return newValue + 1;        // 如果message变化值加1
    }
}

// 写在实例化下侦听数据变化
// vm.$watch(&apos;message&apos;, function(newVal, oldVal){
//    console.log(newVal, oldVal);
//    this.message = newVal.replace(/s|g/g, &apos;*&apos;);
// })
</code></pre><h4 id="class和style的绑定"><a href="#class和style的绑定" class="headerlink" title="class和style的绑定"></a>class和style的绑定</h4><pre><code>一、class

    // 对象
    &lt;div :class=&quot;{ &apos;active&apos;: isActive }&quot;&gt;&lt;/div&gt;
    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            isActive: true
        }
    })

    // 数组
    &lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;        // 三元 &lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;
    data: {
        activeClass: &apos;active&apos;,
        errorClass: &apos;text-danger&apos;
    }    

二、style

    &lt;div :style=&quot;[crm, hk]&quot;&gt; 或 &lt;div :style=&quot;{color: activeColor, fontSize: fontSize+&apos;px&apos;}&quot;&gt;

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            activeColor: &apos;red&apos;,
            fontSize: 30,
            crm: {
                color: &apos;#000&apos;,
                fontSize: &apos;16px&apos;
            },
            hk: {
                color: &apos;#fff&apos;,
                fontSize: &apos;18px&apos;
            }
        }
    })
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>一、@click

    &lt;div @click=&quot;say&quot;&gt;&lt;/div&gt;
    &lt;div @click=&quot;say(&apos;hi&apos;)&quot;&gt;&lt;/div&gt;
    &lt;div @click=&quot;content + 1&quot;&gt;&lt;/div&gt;

    &lt;!-- 阻止单击事件冒泡 --&gt;
    &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

    &lt;!-- 提交事件不再重载页面 --&gt;
    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

    &lt;!-- 修饰符可以串联  --&gt;
    &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

    &lt;!-- 只有修饰符 --&gt;
    &lt;form v-on:submit.prevent&gt;&lt;/form&gt;

    &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;
    &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

    &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;
    &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;

二、按键别名

    .enter、.tab、.delete (捕获 “删除” 和 “退格” 键)、.esc、.space、.up、.down、.left、.right、.ctrl、.alt、.shift、.meta

三、once: 只处理一次点击  &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;

四、修饰符 &lt;input v-on:keyup.13=&quot;submit&quot;&gt;
</code></pre><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><pre><code>Vue在底层将模板编译成虚拟DOM渲染函数，也可以不用模板直接写render函数，可选JSX语法
</code></pre><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><pre><code>一、props传值子元素不会接收

    问题1: 封装tab标签来加载不同子组件，当同一组件重新被打开时，应先消毁之前的相同组件在加载新的组件，但在子组件中destroyed()来侦听消毁缺没有回调

     // 打开新页面
    openTabPage(tabPage, cb) {
        // 先关闭存在的同名的，再打开
        if (this.pages.some(item =&gt; item.name === tabPage.name)) {
            this.handleRemove(tabPage.name);
        }
        this.$nextTick(()=&gt;{                // 使用$nextTick 进行重新渲染
            this.pages.push(tabPage);
            this.activeName = tabPage.name;
        })

        if (cb &amp;&amp; typeof cb === &apos;function&apos;) {
            cb(this.activeName)
        }

        if (this.tabCreate) {
            this.tabCreate(tabPage)
        }
    },

    问题2: 这种加了一层会对相同子组件进行消毁在重建

        &lt;template slot=&quot;tabcreate&quot;&gt;
    &lt;create-data-config ref=&quot;createDataConfig&quot; :create-prop=&quot;createProp&quot;&gt;&lt;/create-data-config&gt;
  &lt;/template&gt;

        openTab(tabName, row){
            // this.createProp[&apos;detailInfo&apos;] = row || &apos;&apos;;            这种写法子组件watch不到createProp的变化 

            this.createProp = {
                detailInfo: row || &apos;&apos;
            }
  }

        子组件
        watch:{
            createProp: function(){
                debugger;
            }
        }


二、v-bind 内联字符串连接

    data(){
        return {
            addString: &apos;加入内容&apos;
        }
    }

    1.x版本 写法  &lt;div attr=&quot;xxxx{{addString}}&quot;&gt;
    2.x版本 写法  &lt;div v-bind=&quot;&apos;xxxx&apos;+ addString&quot;&gt;


三、checkbox动态创建绑定

    // v-model=&quot;item.check&quot; 绑定的值要相同
    &lt;p v-for=&quot;item in checkList&quot;&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;cb&quot; v-model=&quot;item.check&quot; /&gt; {{item.name}}
    &lt;/p&gt;

    data(){
        return{
            checkList:[
                {check: false, name: &apos;aa&apos;},
                {check: false, name: &apos;bb&apos;},
                {check: false, name: &apos;cc&apos;}
            ]
        }
    }


四、vue使用jxs语法

    new Vue({
        el: &apos;#demo&apos;,
        render (h) {
            return (    // 使用这种jsx语法
                &lt;AnchoredHeading level={1}&gt;
                    &lt;span&gt;Hello&lt;/span&gt; world!
                &lt;/AnchoredHeading&gt;
            )
        }
    })

    安装插件
    $ npm install babel-plugin-syntax-jsx babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props babel-preset-en   --save-dev

    .babelrc:
        {
            &quot;presets&quot;: [&quot;env&quot;],
            &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]
        }

    https://github.com/vuejs/babel-plugin-transform-vue-jsx


五、vue键盘事件不起作用

    @keyup.enter.native=&quot;login&quot;   // 如果不加.native是不起作用有


六、$nextTick 页面某一块数据渲染完成后在执行其它操作

    queryBindBank(){
        let that = this;

        common.ajax({
            url: &apos;/business/web/v1/paytool/payCardList&apos;,
            method: &apos;post&apos;,
            data: {},
            dataType: &apos;json&apos;,
            success: function(res) {
                that.showLoading = false;
                if (res &amp;&amp; res.data) {

                    // 渲染数据表
                    that.bindBankData = res.data.list;

                    // 需要数据表渲染完后在执行其它操作
                    that.$nextTick(function(){
                        cardList.forEach(function(item, idx, arr){                    
                            if(item.designAbled){
                                that.$refs.multipleTable.toggleRowSelection(item);
                            }
                        })
                    })

                    that.bindBankData.forEach((bank, idx, arr) =&gt; {
                        if(bank.designAbled){
                            that.selectedRadio = bank.bankCard;
                        }
                    })
                }
      }
        });
    }
</code></pre><p>| <a href="http://www.jianshu.com/p/95b2caf7e0da" target="_blank" rel="noopener">http://www.jianshu.com/p/95b2caf7e0da</a>     // vue-cli<br>| <a href="http://cn.vuejs.org/guide/" target="_blank" rel="noopener">http://cn.vuejs.org/guide/</a>                                // Vue中文官网<br>| <a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a>                            // github<br>| <a href="http://vuefe.cn/guide/installation.html" target="_blank" rel="noopener">http://vuefe.cn/guide/installation.html</a>   // 2.0<br>| <a href="http://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">http://router.vuejs.org/zh-cn/</a>                        // vue-router2.0<br>| <a href="https://github.com/vuejs" target="_blank" rel="noopener">https://github.com/vuejs</a>                                     // Vue组件列表<br>| <a href="http://www.cnblogs.com/dh-dh/p/5606596.html" target="_blank" rel="noopener">http://www.cnblogs.com/dh-dh/p/5606596.html</a>        // binding原理，vue的数据<br>| <a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">https://github.com/vuejs/awesome-vue#libraries--plugins</a><br>| <a href="http://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">http://vuex.vuejs.org/zh-cn/</a>                             // Vuex 2.0文档<br>| <a href="https://github.com/vuejs/vuex/blob/1.0/docs/zh-cn/intro.md" target="_blank" rel="noopener">https://github.com/vuejs/vuex/blob/1.0/docs/zh-cn/intro.md</a><br>| <a href="http://www.cnblogs.com/keepfool/category/845804.html" target="_blank" rel="noopener">http://www.cnblogs.com/keepfool/category/845804.html</a><br>| <a href="http://www.jianshu.com/p/f8e21d87a572" target="_blank" rel="noopener">http://www.jianshu.com/p/f8e21d87a572</a><br>| <a href="https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91</a>      // Vue代码规范<br>| <a href="https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64" target="_blank" rel="noopener">https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64</a>     源码</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Précédent</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">Suivant &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
