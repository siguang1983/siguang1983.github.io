<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-第三方插件收集/">Egg.js</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-第三方插件收集/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| egg-validate POST参数规则校验  <a href="https://github.com/eggjs/egg-validate" target="_blank" rel="noopener">https://github.com/eggjs/egg-validate</a><br>| egg-mongoose Mongoose        <a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a></p>
<h4 id="egg-validate"><a href="#egg-validate" class="headerlink" title="egg-validate"></a>egg-validate</h4><pre><code>验证 Request Body的参数

$ npm i egg-validate --save  安装

// {app_root}/config/plugin.js
exports.validate = {
    package: &apos;egg-validate&apos;,
};

// 校验规则 post
async fromRule(){
    const {ctx, app} = this;

    // Request 参数规则
    const paramRule = {
        username: {type: &apos;string&apos;},
        password: {type: &apos;string&apos;},
        rememberMe: {type: &apos;boolean&apos;, required: false},
    };
    const paramErrors = app.validator.validate(paramRule, ctx.request.body);

    if(paramErrors){    // 如果为真说明校验不通过
        ctx.body = `校验失败`;
    }   
    else{
        ctx.body = `校验成功, ${ctx.request.body.username}`;
    }
}
</code></pre><h4 id="ejs-后端模板"><a href="#ejs-后端模板" class="headerlink" title="ejs 后端模板"></a>ejs 后端模板</h4><pre><code>$ npm install ejs

https://segmentfault.com/a/1190000004286562
http://www.360doc.com/content/16/0115/10/597197_528136785.shtml
https://github.com/tj/ejs
</code></pre><h4 id="nunjucks-后端模板"><a href="#nunjucks-后端模板" class="headerlink" title="nunjucks 后端模板"></a>nunjucks 后端模板</h4><pre><code>http://mozilla.github.io/nunjucks/cn/templating.html
https://github.com/eggjs/examples/tree/master/hackernews/app/view/news
</code></pre><h4 id="其它收集插件"><a href="#其它收集插件" class="headerlink" title="其它收集插件"></a>其它收集插件</h4><pre><code>1、ms返回时间 - https://github.com/zeit/ms       // ms用来返回一个时间  ms(&apos;2h&apos;) 返回 7200000  

2、MD5加密 - https://github.com/jkiss/crypto-js      npm i crypto-js --save  引用 const MD5 = require(&apos;crypto-js/md5&apos;);

3、文件上传 - https://github.com/node-modules/formstream

4、JSON串和对象互转 - https://github.com/ljharb/qs  // 可以根据key来进行排序 

5、验证码 - https://github.com/lemonce/svg-captcha/blob/master/README_CN.md
</code></pre><p>| 参考资料<br>| <a href="https://github.com/eggjs" target="_blank" rel="noopener">https://github.com/eggjs</a><br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/11/Gulp/">Gulp</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/11/Gulp/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-11T10:39:38.000Z" itemprop="datePublished">2016-11-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><pre><code>https://github.com/gulpjs

可以自动化执行任务的工具，主要用于生产环境和开发环境的文件处理

Gulp是一个新的基于流的管道式构建系统，需要很少的配置并且更快

主要作用:

    1、多个js或css文件合并、压缩

    2、Sass或Less的编译

    3、图像的压缩

    3、实时刷新页面的本地服务器

gulp对按需加载不好做到，如A和B页面都依赖base.js，但又各依赖a.js和b.js，这种情况gulp打包是将三个都包括了，所以css和html部分gulp来处理，js的webpack处理
</code></pre><h4 id="安装、使用"><a href="#安装、使用" class="headerlink" title="安装、使用"></a>安装、使用</h4><pre><code>$ npm install -g gulp     // 全局安装Gulp

$ npm init    // 创建package.json 项目描述文件

$ npm install --save-dev gulp    // 作为项目的开发依赖(只在开发时用，不会发布到线上)

$ touch gulpfile.js

    var gulp = require(&apos;gulp&apos;);
    gulp.task(&apos;default&apos;, function(){

    })

$ gulp     // 运行gulp
</code></pre><h4 id="gulp-方法"><a href="#gulp-方法" class="headerlink" title="gulp 方法"></a>gulp 方法</h4><pre><code>1、gulp.src(): 获取到想要处理的文件流，可以是一个字符串或者数组，返回一个stream

    1)、*.{png,jpg,gif,ico}      // 匹配文件

    2)、**/*.html        // 目录用**、文件名用*

    gulp.task(&apos;count&apos;, function(){
        gulp.src([&apos;aa.html&apos;, &apos;bb.html&apos;])    // 或 gulp.src(&apos;src/*.html&apos;);
            .pipe(gulp.uglify())
    })

2、gulp.pipe(): 将获取到的文件流通过pipe()导入到gulp的插件中进行处理

3、gulp.dest(): 用来写文件的，插件处理完，通过dest()处理完成后把流中的内容写到指定的文件中

    var gulp = require(&apos;gulp&apos;);
    gulp.src(&apos;js/main.js&apos;)                 // 获取文件的流的api
        .pipe(gulp.uglify())            // 文件进行压缩
        .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));     // 写文件的api


4、gulp.task(&apos;任务名&apos; [依赖任务], callback): 定义任务，依赖任务会在当前任务执行前完成

    gulp.task(&apos;test&apos;, [&apos;styles&apos;, &apos;task&apos;], function() {
        // 将你的默认的任务代码放在这
    });

    # gulp test     // 执行任务


5、gulp.watch(&apos;要监视文件的匹配模式&apos;, [要执行的task定义的任务], callback): 监视文件的变化，变化后来执行定义的任务
</code></pre><h4 id="gulp-执行命令"><a href="#gulp-执行命令" class="headerlink" title="gulp 执行命令"></a>gulp 执行命令</h4><pre><code>-v 或 --version 会显示全局和项目本地所安装的 gulp 版本号

--gulpfile 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录

--cwd dirpath 手动指定 CWD。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径

-T 或 --tasks 会显示所指定 gulpfile 的 task 依赖树

--tasks-simple 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表

--color 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持

--no-color 强制不显示颜色，即便检测到有颜色支持

--silent 禁止所有的 gulp 日志
</code></pre><h4 id="Gulp-扩散操作"><a href="#Gulp-扩散操作" class="headerlink" title="Gulp 扩散操作"></a>Gulp 扩散操作</h4><pre><code>1、复制单个文件task

    gulp.task(&apos;copy-html&apos;,function(){
        return gulp.src(&apos;app/index.html&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });


2、复制多个文件

    gulp.task(&apos;copy-images&apos;,function(){
        return gulp.src(&apos;app/imgs/**/*.{jpg,png}&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });

    gulp.task(&apos;copy-other&apos;,function(){
        return gulp.src([&apos;app/css/*.css&apos;,&apos;app/js/*.js&apos;],{base:&apos;app&apos;}).pipe(gulp.dest(&apos;dist&apos;));
    });
</code></pre><h4 id="gulp-插件"><a href="#gulp-插件" class="headerlink" title="gulp 插件"></a>gulp 插件</h4><pre><code>https://gulpjs.com/plugins/

$ gulp
$ gulp-babel babel-core babel-preset-env        // ES6转ES5
$ babel-plugin-transform-runtime        // ES6转ES5运行时转换
$ gulp-uglify            // 压缩js
$ gulp-concat            // 合并js
$ gulp-jshint            // js语法检测
$ gulp-less              // less编译
$ gulp-ruby-sass        // sass编译
$ gulp-minify-css        // css压缩
$ gulp-css-base64        // 生成64位图标
$ gulp-htmlmin           // html压缩
$ gulp-file-include        // includer嵌入到另一个html文件
$ gulp.spritesmith       // 雪碧图
$ gulp-imagemin          // 压缩图片
$ imagemin-pngquant      // 图片的深度压缩
$ gulp-cache             // 只压缩修改的图片
$ gulp-rev-append        // 加版本号，给页面文件引用的js和css资源
$ gulp-autoprefixer     // 自动补齐前缀，根据设置浏览器版本自动处理浏览器前缀 CSS3的前缀
$ gulp-react             // react区分jsx文件进行转换
$ gulp-webpack           // webpack
$ gulp-amd-optimizer     // requirejs 压缩
$ vinyl-buffer           // 流缓存
$ merge-stream           // 合并流
$ gulp-watch             // 侦听变化自动执行task
$ gulp-livereload        // 当监听文件发生变化时，浏览器自动刷新页面
$ gulp-header            // 注释自定义插件
$ gulp-rimraf            // 清除文件
$ gulp-clean             // 删除文件或目录
$ gulp-plumber           // 错误提示
$ gulp-notify            // 消息提示
$ gulp-rename            // 重命
$ gulp-connect           // gulp的服务器
$ gulp-browserify          // 
$ gulp-open                // 打开浏览器
$ gulp-md5-plus            // 生成md5码

一、gulpfile.js中引用插件   

    var uglify = require(&apos;gulp-uglify&apos;);


二、gulp-load-plugins 模块化管理插件

    1、一般情况下，gulpfile.js中的模块需要一个个加载。

        var gulp = require(&apos;gulp&apos;)
               jshint = require(&apos;gulp-jshint&apos;),
            uglify = require(&apos;gulp-uglify&apos;),
            concat = require(&apos;gulp-concat&apos;);

        gulp.task(&apos;js&apos;, function () {
               return gulp.src(&apos;js/*.js&apos;)
                  .pipe(uglify())
                  .pipe(concat(&apos;app.js&apos;))
                  .pipe(gulp.dest(&apos;build&apos;));
        });


    2、gulp-load-plugins 会加载 package.json中存在下面的插件依赖：

        &quot;devDependencies&quot;: {
            &quot;gulp&quot;: &quot;^3.9.0&quot;,
            &quot;gulp-uglify&quot;: &quot;^2.6.0&quot;,
            &quot;gulp-concat&quot;: &quot;^2.2.0&quot;
        }

        var gulp = require(&apos;gulp&apos;);
        var $ = require(&apos;gulp-load-plugins&apos;)();            // 加载gulp-load-plugins插件，并立刻运行

        使用：$.uglify  可以省去单个引入
        gulp.task(&apos;add&apos;, function(){
            gulp.src([&apos;js/main.js&apos;])
                .pipe($.concat)
                .pipe($.uglify)            // $.uglify就可以调用了
                .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));    // 如果不改变文件名就直接写成 dist/js/
        })
</code></pre><h4 id="gulp-webpack构建多页面"><a href="#gulp-webpack构建多页面" class="headerlink" title="gulp + webpack构建多页面"></a>gulp + webpack构建多页面</h4><pre><code>├── .DS_Store
├── src                // 生产目录
├── dist            // 发布目录
├── gulpfile.js
├── node_modules
└── package.json
</code></pre><p>| 参考资料<br>| <a href="http://www.gulpjs.com.cn/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/</a>   gulp中文网<br>| <a href="http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7</a><br>| <a href="http://www.gulpjs.com.cn/docs/recipes/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/recipes/</a>    gulp 技巧集<br>| <a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/api/</a>    gulp api<br>| <a href="http://www.techug.com/gulp" target="_blank" rel="noopener">http://www.techug.com/gulp</a>  gulp使用指南<br>| <a href="http://www.w3ctech.com/topic/134" target="_blank" rel="noopener">http://www.w3ctech.com/topic/134</a>    gulp开发教程<br>| <a href="http://www.qianduancun.com/nodejs/33.html" target="_blank" rel="noopener">http://www.qianduancun.com/nodejs/33.html</a>      gulp-load-plugins[模块化管理插件]<br>| <a href="http://segmentfault.com/a/1190000003098076#articleHeader0" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003098076#articleHeader0</a>        利用 gulp 处理前端工作流程<br>| <a href="http://www.cnblogs.com/2050/p/4198792.html" target="_blank" rel="noopener">http://www.cnblogs.com/2050/p/4198792.html</a>        前端构建工具gulpjs的使用介绍及技巧<br>| <a href="https://www.cnblogs.com/weixing/p/5474324.html" target="_blank" rel="noopener">https://www.cnblogs.com/weixing/p/5474324.html</a><br>|<br>| 多页面<br>| <a href="https://www.cnblogs.com/maskmtj/archive/2016/07/21/5597307.html" target="_blank" rel="noopener">https://www.cnblogs.com/maskmtj/archive/2016/07/21/5597307.html</a><br>| <a href="https://github.com/fwon/gulp-webpack-demo" target="_blank" rel="noopener">https://github.com/fwon/gulp-webpack-demo</a><br>|<br>| 文件流<br>| <a href="http://segmentfault.com/a/1190000000519006" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000519006</a>    nodejs中流(stream)的理解<br>| <a href="http://www.it165.net/pro/html/201406/15924.html" target="_blank" rel="noopener">http://www.it165.net/pro/html/201406/15924.html</a>    Node.js Stream（流）的学习笔记<br>| <a href="http://segmentfault.com/a/1190000000357044" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000357044</a>    Node 中的流（Stream）<br>|<br>| Promise<br>| <a href="http://segmentfault.com/a/1190000002591145" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002591145</a>    深入理解Promise实现细节<br>| <a href="http://www.tuicool.com/articles/fe6Jbyz" target="_blank" rel="noopener">http://www.tuicool.com/articles/fe6Jbyz</a>    Promise实现原理<br>| <a href="http://segmentfault.com/a/1190000003028634" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003028634</a>    异步编程 promise模式 的简单实现<br>| <a href="http://sentsin.com/web/861.html" target="_blank" rel="noopener">http://sentsin.com/web/861.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/02/webpack插件类/">webpack插件类</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/02/webpack插件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-02T03:06:16.000Z" itemprop="datePublished">2016-11-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><pre><code>1、自动刷新浏览器 - 修改代码编译后自动刷新浏览器

2、热替换 - 在不刷新整个网页的时候做到实时预览

    script: {
        &quot;server&quot;: &quot;webpack-dev-server --open --hot --inline&quot;
    }

    --hot 与在 new webpack.HotModuleReplacementPlugin() 相同

3、提取公用代码

    通过CommonsChunkPlugin插件来提取指定业务文件中的公用库

4、按需加载、首屏加载

    &lt;!-- 加载 import(/* webpackChunkName: &quot;show&quot; */&apos;./show&apos;, then((show) =&gt; {
        show(&apos;webpack&apos;)
    })) --&gt;
</code></pre><h4 id="将业务逻辑与其它组件库分离"><a href="#将业务逻辑与其它组件库分离" class="headerlink" title="将业务逻辑与其它组件库分离"></a>将业务逻辑与其它组件库分离</h4><pre><code>将业务逻辑和第三方代码分离，不能将他们都合并到一个文件内，使这个js文件比较大，并且跳转到另一个地址也还会重新加载这些公用的文件

Example: 

    对引用的jquery单独提取

    1、import $ from &apos;jquery&apos;;     // js中引用的jquery, 先npm i jquery下载包

    2、webpack.config.js

        // 入口文件
        entry: {
            app: path.resolve(__dirname, &apos;web/js/index.js&apos;),
            vendor: [&apos;jquery&apos;]
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;,
            chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        plugins: [
            // 将在html文件中添加&lt;script&gt;引用，并生创建到指定的目录中
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,
                filename: &apos;./web/index.html&apos;,
                template: &apos;./web/index.html&apos;,
                chunks: [&apos;app&apos;, &apos;vendor&apos;],            // 这里要把vendor依赖的文件加上，不然生成的html只有引用app.min.js，不会引用jquery.vendor.js
                inject: true,
                hash: true
            }),

            // 拆分插件
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendor&apos;,                            // 上面入口定义的节点组
                filename: &apos;jquery.vendor.js?[hash]&apos;     // 最后生成的文件名
            }),
        }
</code></pre><h4 id="require-ensure按需加载"><a href="#require-ensure按需加载" class="headerlink" title="require,ensure按需加载"></a>require,ensure按需加载</h4><pre><code>require()与require.ensure()加载的不同

1、require(): AMD加载规范，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数

2、require.ensure(): requi.ensure的依赖模块只会被先下载下来，但不会被执行，会将require.ensure()内加载的模块合成一个文件，在

    如果webpack打包会将所有资源加到一个文件中，这样会使这个文件变的很大，require.ensure()来对加载的资源单独打包

    require.ensure([], function(require) {
        var dialog = require(&apos;./components/dialog&apos;);
        // todo ...
    });

    CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好

    webpack.config.js中配置

        var chunks = Object.keys(entries);
        plugins: [
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendors&apos;,             // 将公共模块提取，生成名为`vendors`的chunk
                chunks: chunks,
                minChunks: chunks.length     // 提取所有entry共同依赖的模块
            })
        ]

http://blog.csdn.net/zhbhun/article/details/46826129
https://segmentfault.com/a/1190000007775743
</code></pre><h4 id="插件类详解"><a href="#插件类详解" class="headerlink" title="插件类详解"></a>插件类详解</h4><pre><code>* webpack-dev-server - webpack自带服务

webpack自带的插件
* CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin - 提取公用部分
* uglifyJsPlugin - js压缩

外部加载插件
* HotMooduleReplacementPlugin() - 热替换
* html-webpack-plugin - 解析html模板
* web-webpack-plugin - 与html-webpack-plugin类型国内人写的https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md
* extract-text-webpack-plugin - 单独打包css文件
* open-browser-webpack-plugin - 资源构建成功后自动打开浏览器 
* clean-webpack-plugin - 清除文件夹,添加hash后，会导致改变文件内容重新打包时文件名不同越来越多，使用clean-webpack-plugin

* babel-plugin-react-transform react-transform-hmr - react的热更新, 需要在配置bable.rc
* ExtractTextPlugin - 将js中引用的css文件抽取出一个单独的css文件
* webpack-merge - 合并数组、函数
* webpack-dev-middleware - devServer就是基于webpack-dev-middleware和ExpressJS来实现的
* imagemin-webpacl-plugin - 压缩图片
* webpack-spritesmith - 制作雪碧图
* HotModuleReplacementPlugin - devServer热更新

一、webpack-dev-server webpack自带服务

    webpack-dev-server有两种模式支持自动刷新——iframe模式和inline模式。

    1、iframe模式: 页面是嵌套在一个iframe下的，在代码发生改动的时候，这个iframe会重新加载;使用iframe模式无需额外的配置，只需在浏览器输入以下地址: http://localhost:8080/webpack-dev-server/index.html

    2、inline模式: 一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。

    以下三种配置都可以实现页面的刷新效果: 

        // 1.启动webpack-dev-server的时候带上inline参数
        webpack-dev-server --inline

        // 2.给HTML插入JS
        &lt;script src=&quot;http://localhost:3000/webpack-dev-server.js&quot;|&lt;/script|

        // 3.webpack配置
        entry: [
            &apos;webpack-dev-server/client?http://localhost:3000&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ]


二、HotMooduleReplacementPlugin() 热替换

    webpac-dev-server支持模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉。使用HMR功能也有两种方式: 命令行方式和Node.js API。

    1、cli命令行方式  webpack-dev-server --inline --hot

    2、Node.js API方式

        entry: [
            &apos;webpack/hot/dev-server&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ],
        devServer: {
            hot: true
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin(),
        ]


三、html-webpack-plugin 解析html模板

    插件将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

    $ npm i html-webpack-plugin

    $ const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);            // 引用插件

    1、单入口配置

        // 这里省略其他配置代码
        plugins: [
            // 使用这个plugin，这是最简单的一个配置，更多资料可到github查看
            new HtmlWebpackPlugin({
                title: &apos;zhufeng-react&apos;,
                template: &apos;./src/index.html&apos;,
            })
        ]

    2、多入口配置

        会将两个入口分别对html文件进行加载指定的入口js文件

        // 入口文件
        entry: {
            app: &apos;./web/js/index.js&apos;,
            list: &apos;./web/js/list.js&apos;
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;
        },

        plugins: [
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,                    // 生成html文档的标题
                filename: &apos;./web/index.html&apos;,    // 输出文件名称
                template: &apos;./web/index.html&apos;,    // 本地模板的位置，支持(handlebars、ejs、undersore、html)
                chunks: [&apos;app&apos;],                // 对应的入口entry, 也可以是数组[&apos;app&apos;, &apos;list&apos;]
                inject: true,                    // 向template中注入所有静态资源
                hash: true                        // 为静态资源添加webpack每次编译产生的唯一hash值， &lt;script type=&quot;text/javascript&quot; src=&quot;common.js?a3e1396b501cdd9041be&quot;&gt;&lt;/script&gt;
            }),
            new HtmlWebpackPlugin({
                title: &apos;list&apos;,
                filename: &apos;./web/list.html&apos;,
                template: &apos;./web/list.html&apos;,
                chunks: [&apos;list&apos;],
                inject: true,
                hash: true
            })
        ]

    https://segmentfault.com/q/1010000009810148
    https://www.cnblogs.com/wonyun/p/6030090.html


四、extract-text-webpack-plugin 单独打包css文件

    $ npm i extract-text-webpack-plugin


五、open-browser-webpack-plugin  资源构建成功后自动打开浏览器 --- 已可以在命令中配置

    1、package.json中加 --open，与使用此插件相同

        &quot;scripts&quot;: {
            &quot;start&quot;: &quot;webpack-dev-server --hot --inline --open&quot;,
        }


    2、$ npm install open-browser-webpack-plugin --save-dev

        var openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
            new openBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]


六、CSS Module

    webpack 的 css-loader 是解决这个问题的最好办法之一。简单配置一下: 
    module: {
      loaders: [{
        test: /\.css$/,
        loaders: [
          &apos;style-loader&apos;,
          &apos;css-loader?modules&amp;localIdentName=[name]__[local]___[hash:base64:5]&apos;,
          &apos;postcss-loader&apos;
        ]
      }]
    },
    postcss: [
      require(&apos;postcss-nested&apos;)(),
      require(&apos;cssnext&apos;)(),
      require(&apos;autoprefixer-core&apos;)({ browsers: [&apos;last 2 versions&apos;] })
    ]


七、UglifyJs Plugin 压缩资源

    var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;

    plugins: [
        new uglifyJsPlugin({
            compress: {
                warnings: false
            }
        }),
        new webpack.optimize.MinChunkSizePlugin({
            compress: {
                warnings: false
            }
        }),
        // 查找相等或近似的模块，避免在最终生成的文件中出现重复的模块
        new webpack.optimize.DedupePlugin(),
        // 按引用频度来排序 ID，以便达到减少文件大小的效果
        new webpack.optimize.OccurenceOrderPlugin(),
        new webpack.optimize.AggressiveMergingPlugin({
            minSizeReduce: 1.5,
            moveToParents: true
        })
    ]


八、clean-webpack-plugin 清除文件夹

    $ npm install clean-webpack-plugin --save-dev

    webpack.config.js:

        const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);

        plugins: [
            new CleanWebpackPlugin([&apos;dist&apos;]),
            new HtmlWebpackPlugin({
                title: &apos;Output Management&apos;
            })
        ]


九、react的热替换

    $ npm install --save-dev babel-plugin-react-transform react-transform-hmr

    .babelrc配置
        {
            &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
            &quot;env&quot;: {
                &quot;development&quot;: {
                &quot;plugins&quot;: [[&quot;react-transform&quot;, {
                    &quot;transforms&quot;: [{
                        &quot;transform&quot;: &quot;react-transform-hmr&quot;,

                        &quot;imports&quot;: [&quot;react&quot;],

                        &quot;locals&quot;: [&quot;module&quot;]
                    }]
                }]]
                }
            }
        }

十、ExtractTextPlugin 分享css和js文件

    $ npm install --save extract-text-webpack-plugin

    webpack.config.js

        const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

        module.exports = {
            entry: {},
            output: {},

            plugins:[
                new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
                new ExtractTextPlugin(&quot;style.css&quot;)
            ]

        }

十一、clean-webpack-plugin

    $ npm install clean-webpack-plugin --save

        const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);
        module.exports = {

            plugins: [
                &lt;!-- ...// 这里是之前配置的其它各种插件 --&gt;
                new CleanWebpackPlugin( &apos;build/*.*&apos;, {
                        root: __dirname,
                        verbose: true,
                        dry: false
                    }
                )
            ]
        }

十二、CommonsChunkPlugin

    const CommonsChunkPlugin = require(&apos;CommonsChunkPlugin&apos;);
    module.exports = {
        plugins: [
            new CommonsChunkPlugin({
                // 从哪些Chunk 中提取
                chunks: [&apos;a&apos;, &apos;b&apos;],
                // 提取的公共部分形成一个chunk
                name: &apos;common&apos;
            })
        ]
    }


十三、暴露全局对象

    如果想将report数据上报组件放到全局，有两种办法: 

    方法一: 
    在loader里使expose将report暴露到全局，然后就可以直接使用report进行上报
    {
        test: path.join(config.path.src, &apos;/js/common/report&apos;),
        loader: &apos;expose?report&apos;
    }

    方法二: 
    如果想用R直接代表report，除了要用expose loader之外，还需要用ProvidePlugin帮助，指向report，这样在代码中直接用R.tdw， R.monitor这样就可以
    new webpack.ProvidePlugin({
        &quot;R&quot;: &quot;report&quot;,
    })
</code></pre><h4 id="gulp与webpack构建单页面与多页面总结"><a href="#gulp与webpack构建单页面与多页面总结" class="headerlink" title="gulp与webpack构建单页面与多页面总结"></a>gulp与webpack构建单页面与多页面总结</h4><pre><code>1、gulp: 处理html、css都可以，对处理js依赖这块不占优势

2、webpack: 对js入口进行单页面构建和模块化开发，如果页面较多不占优势，多页面webpack也可以做到，不过将js合并并加载到html中配置比较麻烦，需要HtmlWebpackPlugin插件来完成，每一个页面都需要创建一次，也可以将公用进行提取chunks

3、gulp+webpck 构建多页面

    优点: gulp进行对html和css处理，webpack进行js的处理

    缺点: webpack如果需要合并js，还需要手动去改html的引用
</code></pre><h4 id="webpack踩坑"><a href="#webpack踩坑" class="headerlink" title="webpack踩坑"></a>webpack踩坑</h4><pre><code>一、安装完webpack后执行命令提示需要安装webpack

    webpack -h          // 提示没有装webpack-cli

    $ npm i webpack-cli --save-dev            // 如果全局没有安装就全局装一下 $ sudo npm i webpack-cli -g

    https://segmentfault.com/a/1190000013699050
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/02/webpack/">webpack</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/02/webpack/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-02T03:06:16.000Z" itemprop="datePublished">2016-11-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| AMD、CMD、CommonJS模式<br>| Source Map代码调试<br>| require()、define()、export()<br>| requires.ensure(): 用来按需加载，将文件使用时在进行加载<br>| Vendor: 将库、框架文件与业务分离分别打包<br>| Entry: 入口<br>| Chunk: 出输的名<br>| Output: 打包输出<br>| Loader: 模块转换器<br>| Module: 模块<br>| Reslove: 依赖文件<br>| Plugins: 扩展插件<br>| webpack-dev-server: 本地服务器，可以设置代理，用来前后端分离跨域</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><pre><code>模块化分为AMD、CMD、CommonJS、ES6四类

一、CommonJS 

    Node、webpack使用的CommonJS规范, require加载是同步的

    // 导入
    const moduleA = require(&apos;./moduleA&apos;);
    moduleA.someFun(1,2);            // 需要等moduleA加载后在执行，这里是同步

    // 导出
    module.exports = moduleA.someFunc


二、AMD 异步加载模块

    可异步加载依赖模块，可并行加载多个依赖，可以运行浏览器和node环境下，缺点是需要加载AMD的库才能使用，常用的require.js

    // 定义模块
    define(&apos;moduleA&apos;, [依赖文件], function(jquery){
            var someFun = (x, y) =&gt; { return x + y}
            return {
                someFun,
            }
    })

    // 导入和使用
    require([&apos;moduleA&apos;], function(moduleA){
        module.someFun(1,2);
    })


三、ES6

    JS的标准化模块加载，会逐渐的取代commonJS和AMD

    // 导入
    import React from &apos;react&apos;
    import ReactDOM, { render } from &apos;react-dom&apos;;

    // 导出
    export function hello(){ ... }
    export default {
        ...
    }
    export { fn1, fn2 }


四、CMD 同步加载模块

    代表seajs

    // 定义模块
    define(function(require,exports,module){
        var $ = require(&apos;jquery&apos;);        // 用来加载模块

        exports.sayHello = function(){    // 导出的接口
            ...
        }
    });
</code></pre><h4 id="构建工具的什么用"><a href="#构建工具的什么用" class="headerlink" title="构建工具的什么用"></a>构建工具的什么用</h4><pre><code>1、代码转换 - 将ES6转ES5, 将SCSS转成css

2、文件优化 - 压缩JS、CSS、HTML代码，压缩合并图片

3、代码分割 - 提取多个页面的公共代码，提取首屏不需要执行代码，其它的异步加载

4、模块合并 - 将多个模块合并成一个文件

5、自动刷新 - 监听本地代码变化，并自动构建和刷新浏览器

6、代码校验 - 校验代码是否符合规范

7、自动发布 - 自动构建出线上发布代码并传输给发布系统
</code></pre><h4 id="webpack安装和命令"><a href="#webpack安装和命令" class="headerlink" title="webpack安装和命令"></a>webpack安装和命令</h4><pre><code>$ npm i -D webpack webpack-cli             // 安装稳定版本，4版本以上需要装webpack-cli, -D是--save-dev的缩写

    npm i -D webpack@3.10.0                        // 安装指定版本


命令

    1、webpack            // 最基本的启动webpack命令

    2、webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包

    3、webpack -w         // watch方法，时实预览进行打包 相当于 --watch 

    4、webpack -p         // 对打包后的文件进行压缩

    5、webpack -d         // 提供SourceMaps，方便调试

    6、webpack --colors     // 输出结果带彩色，比如: 会用红色显示耗时较长的步骤

    7、webpack --profile // 输出性能数据，可以看到每一步的耗时

    8、webpack --display-modules     // 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块

    9、webpack --progress --colors   // 展示一些进度条，同时增加颜色

    10、webpack --display-error-details    // 打印出错在哪个文件和行
</code></pre><h4 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h4><pre><code>启动时需要加 --devtool source-map 参数重启DevServer后刷新页面，在chrome开发者工具就可以调试源码
</code></pre><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><pre><code>entry是配置模块的入口，执行构建最开始就递归解析所有的入口依赖，可以是 string | object | array

// 单入口
module.exports = {
    entry: &apos;./src/main.js&apos;
}

// 多入口
module.exports = {
    entry: {
        main: [&quot;./main.js&quot;, &quot;./list.js&quot;]
    }
}

// 多入口，app(应用主入口)，vendors(公共库)入口
module.exports = {
    entry: {
        main: &apos;./src/main.js&apos;,
        list: &apos;./src/list.js&apos;,
        vendors: &apos;./src/jquery.js&apos;
    }
}

一、chunk 名称

    如果入口是字符串或数组，output打包出来的都被合并成一个文件，如上（1、2），

    如果入口配置的是对象，打包出来的是以对象每个入口为一个文件，如上（3），打包会出来 main.min.js, list.min.js

    output: {
        path: path.resolve(__dirname, &apos;build/js&apos;),
        filename: &apos;[name].min.js?[hash]&apos;
    }
</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件

1、path: 输出的目录，绝对路径

2、filename: 用于输出文件的文件名

    变量: 1) id chunk的唯一标识从0开始      2）name chunk的名称        3）hash 输出hash值        4）chunkhash 内容的hash值

    filename: &apos;bundle.js&apos;

    filename: &apos;[name].js&apos;    // 用于多入口

    filename: &apos;[chunkhash].js&apos;    // 用于长效缓存，入口为entry chunk

    filename: &apos;[name].js[hash]&apos;    // 带hash值 [hash:8] 代表8位的hash,默认20位

3、publicPath: 复杂项目里会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的URL

    output: {
        filename: &apos;[name]_[chunkhash:8].js&apos;,
        publicPath: &apos;https://cdn.example.com/assets/&apos;
    }

    发布到线上的HTML &lt;script src=&quot;https://cdn.example.com/assets/main.12345678.js&quot;&lt;/script&gt;

4、chunkFilename: 配置无入口的Chunk在输出时文件名称

    const path = require(&apos;path&apos;);
    module.exports = {
        output: {
            path: path.resolve(__dirname, &apos;./dist&apos;),
            publicPath: &apos;/dist/&apos;,
            filename: &apos;my-first-bundle.js&apos; 
        }
    }
</code></pre><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><pre><code>rules配置模块的读取和解析，将所有引用资源(.css、.html、.scss、.jpg)作为模块处理

1、条件匹配: 通过test、include、exclude三个配置项来选中loader规则文件

    test: 匹配哪些文件

    include: 指定一个目录下的所有文件，可以加快webpack的搜索速度

    exclude: 排除某个目录，不在这个目录搜索文件

2、应用规则: 对选中的文件通过usr配置来应用loader

3、重置顺序: 默认从右向左执行, 通过enforce选项将其中一个loader的顺序放到最前或最后

module: {
rules: [
        {
    test: /(\.jsx|\.js)$/,
    use: {
      loader: &quot;babel-loader&quot;,        
                options: {
                    cacheDirectory: true,        // cacheDirectory用于缓存babel的编译结果，加快重新编译速度
                }
    },
            include: [path.resolve(__dirname, &apos;src)],        // 只在src目录下搜索js文件
  }
  {
    test: /\.css$/,
    use: [ &quot;style-loader&quot;, &quot;css-loader?minimize&quot;, &quot;sass-loader&quot; ],        // minimize 压缩css
            exclude: [/node_modules/]                // 除了node_modules目录不搜索
  }
]
</code></pre><p>  }</p>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><pre><code>webpack启动后会从入口找出所有的依赖模块，resolve配置如何寻找模块对应的文件

1、alias 让模块引入变得简单

    import $ from &apos;/js/lib/jquery.min.js&apos;;      开发中需要引入jquery就需要写这类路径

    通过alias来解决
    resolve: {
        alias: {
            jquery: path.resolve(__dirname, &quot;/js/lib/jquery.min.js&quot;),
        },
         extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.scss&apos;, &apos;.css&apos;]             //设置require或import的时候可以不需要带后缀
    }

    引用
    import $ from &apos;jquery&apos;;        // jquery就会被替换成依赖的路径
</code></pre><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><pre><code>plugins扩展webpack功能，在构建流程里演讲稿钩子

一、webpack自带插件，可以直接使用

    pulgins: [
        new webpack.optimize.CommonsChunkPlugin({    // webpack自带插件在webpack.optimize内
            name: &apos;vendor&apos;,                                // 上面入口定义的节点组
            filename: &apos;jquery.vendor.js?[hash]&apos;     // 最后生成的文件名
        })
    ]


二、非webpack插件，需要先调用插件

    例: main.js

        require(&apos;./main.css&apos;)
        const show = require(&apos;./show.js)
        show(1,2)

    webpack.config.js
    // 将引用的css文件提取出来 
    const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);        

    pulgins: [
        new ExtractTextPlugin({
            filename: &apos;[name].[contenthash:8].css&apos;,            // main.11ad8d2c.css
            allChunks: true,
        })
    ]
</code></pre><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><pre><code>webpack-dev-server - 创建一个本地服务，并能设置代理服务，并且能够实时重新加载

一、创建文件

    // 创建项目目录
    $ mkdir webpack_base_demo &amp;&amp; cd webpack_base_demo      

    // 创建配置文件
    $ touch README.md  .gitignore  .babelrc  webpack.config.js

    // 创建package.json
    $ npm init 

    // 配置.babelrc文件
    {
        &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
        &quot;env&quot;: {
            &quot;development&quot;: {
            &lt;!-- &quot;plugins&quot;: [[&quot;react-transform&quot;, {
                &quot;transforms&quot;: [{
                    &quot;transform&quot;: &quot;react-transform-hmr&quot;,
                    &quot;imports&quot;: [&quot;react&quot;],
                    &quot;locals&quot;: [&quot;module&quot;]
                }]
            }]] --&gt;
            }
        }
    }

二、安装webpack、webpack-dev-server

    $ npm i --save-dev webpack@3.10.0 webpack-dev-server            // webpack4.0 需要安装cli

三、安装loader

    // 如果使用react框架来做项目，先下载包
    $ npm i --save react react-dom

    $ npm i --save babel-plugin-react-transform react-transform-hmr   // babel的插件，在react热更新

        // .babelrc
        {
            &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
            &quot;env&quot;: {
                &quot;development&quot;: {
                    &quot;plugins&quot;: [
                        [
                            &quot;react-transform&quot;, {
                                &quot;transforms&quot;: [{
                                    &quot;transform&quot;: &quot;react-transform-hmr&quot;,
                                    &quot;imports&quot;: [&quot;react&quot;],
                                    &quot;locals&quot;: [&quot;module&quot;]
                                }]
                            }
                        ]
                    ]
                }
            }
        }

    // 使用Babel-loader来解析es6和react
    $ npm i --save babel-core babel-loader babel-preset-env babel-preset-react

    // vue-load - 解析和转换.vue文件，vue-template-compiler - 将vue-load提取出的HTML模板编译成可执行的JS代码，vue项目可直接安装vue-cli
    $ npm vue-load vue-template-compiler

    // jsx转换
    $ npm i --save jsx-loader

    // css模块化，可以在组件中引用指定模块的css文件， import &apos;./main.css&apos;
    $ npm i --save style-loader css-loader 

    // 可以将js和css中的导入的图片替换成正确的地址，同时将文件输出到对应的位置
    $ npm i --save file-loader

    // 将文件的图片经过base64编码后注入js或css中
    $ npm i --save url-loader    

    // 加载SVG
    $ npm i --save svg-loader

    // CSS预处理器  autoprefixer 自动加载前缀
    $ npm i --save less-loader sass-loader


四、安装插件

    1、html-webpack-plugin 解析html模板

        将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

        $ npm i --save html-webpack-plugin

    2、extract-text-webpack-plugin 单独打包css文件

        $ npm i --save extract-text-webpack-plugin

    3、open-browser-webpack-plugin   自动打开浏览器

        $ npm i --save open-browser-webpack-plugin

        var OpenBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
          new OpenBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]

    4、webpack-spritesmith   雪碧图

        $ npm i --save webpack-spritesmith

        https://www.cnblogs.com/weiweisuo/p/6912740.html

    『 更多插件见 webpack插件类.md 』


五、package.json配置

    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;webpack-dev-server --hot --inline --progress&quot;,
        &quot;build&quot;: &quot;webpack --progress --profile --colors --config&quot;
    },

    $ npm run start        // 启动开发环境


六、webpack.config.js、webpack.production.config 配置文件

    webpack.config.js 开发环境所用配置文件
    webpack.pub.config.js  生产环境所用配置文件

    /**
     * User: siguang
     * Date: 2016/12/28
     * Time: 15:04
     */
    const webpack = require(&apos;webpack&apos;);
    const path = require(&apos;path&apos;);
    const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)
    // const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); // 单独打包CSS
    const OpenBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
    // 清除目录
    const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);
    // 提取公用
    const CommonsChunkPlugin = require(&apos;webpack/lib/optimize/CommonsChunkPlugin&apos;);

    /*  文件路径配置 */
    const basePath = __dirname;
    const appPath = path.resolve(basePath, &apos;src&apos;);
    const buildPath = path.resolve(basePath, &apos;build&apos;);

    /* libs 目录下的库文件 */
    const libsPath = path.resolve(basePath, &apos;src/libs&apos;);
    const jquery = path.resolve(libsPath, &apos;jquery.min&apos;)

    // webpack配置对象
    module.exports = {

        // 入口文件
        entry: {
                app: path.resolve(appPath, &apos;js/index.js&apos;),
                list: path.resolve(appPath, &apos;js/list.js&apos;)
        },

        // 出口文件
        output: {
                path: buildPath,
                filename: &apos;/js/[name].min.js?[hash]&apos;,
                chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        // 加载器配置
        module: {
            loaders: [

                // 处理require()引入的css文件，并将代码显示到页面的&lt;style|中
                { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; },

                // 将jsx文件转成js文件
                { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},

                // 将scss文件转成css文件
                { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;},

                // ES6 转 ES5
                {    
                    test: /\.js?$/,
                    loader: &apos;babel-loader&apos;,
                    query: {
                        presets: [&apos;es2015&apos;]
                    }
                }   
            ]
        },

        // 插件
        plugins: [
            // 清空build目录
            new CleanWebpackPlugin(buildPath), 

            // 热启动
            new webpack.HotModuleReplacementPlugin(),

            // 自动开启浏览器
            new OpenBrowserWebpackPlugin({ url: &apos;http://localhost:5000&apos; })

            // 压缩打包的文件
            // new webpack.optimize.UglifyJsPlugin({
            //     compress: {
            //         //supresses warnings, usually from module minification
            //         warnings: false
            //     }
            // }),

            // 将vendor中的库合并到一起
            new CommonsChunkPlugin({
                // 从哪些Chunk 中提取
                chunks: [&apos;main&apos;, &apos;list&apos;],
                // 提取的公共部分形成一个chunk
                name: &apos;common&apos;
            }),     

            // html
            new HtmlWebpackPlugin({
                // 改变页面的&lt;title|标签的内容 
                title: &apos;Hello World app&apos;,                   // 页面调用&lt;%= htmlWebpackPlugin.options.title %|
                // 模版地址
                template: path.resolve(appPath, &apos;index.html&apos;),
                // 构建后的文件名和目录
                filename: &apos;index.html&apos;,
                //chunks这个参数告诉插件要引用entry里面的哪几个入口
                chunks:[&apos;app&apos;,&apos;vendor&apos;],
                //要把script插入标签里
                inject:&apos;body&apos;
            }),

            new HtmlWebpackPlugin({
                // 改变页面的&lt;title|标签的内容 
                title: &apos;Hello World appList&apos;, 
                // 模版地址
                template: path.resolve(appPath, &apos;list.html&apos;),
                // 构建后的文件名和目录
                filename: &apos;list.html&apos;,
                //chunks这个参数告诉插件要引用entry里面的哪几个入口
                chunks:[&apos;list&apos;,&apos;vendor&apos;],
                //要把script插入标签里
                inject:&apos;body&apos;
            }),                
        ],

        // 查找依赖
        resolve:{
            jquery: path.resolve(__dirname, &apos;src/utils/jquery.min.js&apos;), 
            // require或alias时不需要写后缀
            // extensions: [&quot;.js&quot;, &quot;.jsx&quot;, &quot;.css&quot;, &quot;.json&quot;],
        },

        // 启动文件侦听
        watch: true,      // 这里配置watch与在package.json中的script中设置 webpack --watch一样
        watchOptions: {
            // 不侦听的文件夹
            ignored: &apos;/node_modules/&apos;,  
            // 文件变化后300ms后在编译，防止更新太快导致重新编译太快
            aggregateTimeout: 300,
            // 判断文件变化 
            poll: 1000
        },

        devtool: &apos;source-map&apos;,

        // webpack-dev-server 配置
        devServer: {
        port: 8090,               // 端口
            contentBase: &apos;build&apos;,     // 内容目录
            hot: true,                    // 启用webpack热替换
            inline: true,
            compress: true,                  // 一切服务都启用gzip 压缩
            proxy: {
                &apos;/api/*&apos;: {                // 以api开头的走代理接口
                    target: &apos;http://wwww.we.com&apos;,
                    pathRewrite: {
                        &apos;^/api/&apos;: &apos;/&apos;    // api指向target的根目录
                    },
                    changeOrigin: true,
                    secure: false
                }
            },
            historyApiFallback:{
                rewrites:[        // 不存在的路由跳到404页面
                    {
                        from: /./,
                        to: &apos;404.html&apos;
                    }
                ]
            }
        }
    }


两套配置:

    webpack.development.config.js            // 开发配置
    webpack.production.config.js            // 生产配置

    script: {
        &quot;build&quot;: &quot;webpack --config production.config.js&quot;,
        &quot;dev&quot;: &quot;webpack --config development.config.js&quot;
    }
</code></pre><h4 id="webpack-dev-server-参数"><a href="#webpack-dev-server-参数" class="headerlink" title="webpack-dev-server 参数"></a>webpack-dev-server 参数</h4><pre><code>一、在webpack.config.js中配置

    // 生成Source Map
    devtool: &apos;source-map&apos;,

    devServer: {
        // 端口
        port: 8090,               

        // 默认目录
        contentBase: &apos;build&apos;,

        // 启用webpack热替换
        hot: true,                // 必须要有HotModuleReplacementPlugin插件才能完全启用HMR

        //           
        inline: true,

        // 启用gzip压缩
        compress: true,                  

        // 配置代理
        proxy: {
            &apos;/api/*&apos;: {                // 以api开头的走代理接口
                target: &apos;http://goucai.diyicai.com&apos;,
                pathRewrite: {
                    &apos;^/api/&apos;: &apos;/&apos;    // api指向target的根目录
                },
                changeOrigin: true,
                secure: false
            }
        },

        // 配置路由的跳转，404跳转
        historyApiFallback:{
            rewrites:[        // 不存在的路由跳到404页面
                {
                    from: /./,
                    to: &apos;404.html&apos;
                }
            ]
        }

        // 设置响应头
        headers: { &apos;X-Token&apos;: &apos;bar&apos; }

        // 设置https
        https: true    使用https，也可以配置证书，见资料第2章
    }


二、参数是加到package.json的script中的  &quot;start&quot;: &quot;webpack-dev-server --hot --inline --progress&quot;,

    webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器

    webpack-dev-server --devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号

    webpack-dev-server --progress - 显示合并代码进度

    webpack-dev-server --colors - 命令行中显示颜色

    webpack-dev-server --content-base build  // webpack-dev-server服务会默认以当前目录伺服文件，如果设置了content-base的话，服务的根路径则为build目录

    webpack-dev-server --inline  可以自动加上dev-server的管理代码，实现热更新

    webpack-dev-server --hot  开启代码热替换，可以加上HotModuleReplacementPlugin

    webpack-dev-server --port 3000 设置服务端口
</code></pre><p>| <a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">https://doc.webpack-china.org/concepts/</a>        webpack中文网 v3.10.0<br>| <a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a><br>| <a href="http://webpack.wuhaolin.cn/" target="_blank" rel="noopener">http://webpack.wuhaolin.cn/</a>                            // book<br>| <a href="https://webpack.js.org/plugins/" target="_blank" rel="noopener">https://webpack.js.org/plugins/</a>                // 自带插件<br>| <a href="https://zhuanlan.zhihu.com/p/32148338" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32148338</a><br>| <a href="https://blog.csdn.net/keliyxyz/article/details/51571386" target="_blank" rel="noopener">https://blog.csdn.net/keliyxyz/article/details/51571386</a><br>| <a href="http://react-china.org/t/webpack-output-filename-output-chunkfilename/2256/2" target="_blank" rel="noopener">http://react-china.org/t/webpack-output-filename-output-chunkfilename/2256/2</a>   // output.filename 和output.chunkFilename<br>| <a href="http://www.alloyteam.com/2016/02/code-split-by-routes/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/02/code-split-by-routes/</a>  按需加载<br>|<br>| 插件<br>| <a href="http://www.cnblogs.com/haogj/p/5160821.html" target="_blank" rel="noopener">http://www.cnblogs.com/haogj/p/5160821.html</a>     // html-webpack-plugin html多页面构建<br>|<br>| 热更新<br>| <a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">https://github.com/gaearon/react-hot-loader</a>    // react<br>| <a href="https://github.com/vuejs/vue-loader" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader</a>            // vue</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/26/VueJS之-“Vuex篇“（四）/">VueJS之-“Vuex篇“（四）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/26/VueJS之-“Vuex篇“（四）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-26T02:40:24.000Z" itemprop="datePublished">2016-10-26</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><pre><code>Vuex借鉴了Flux和Redux设计思想.

优点:
    Vue组件父子之间通过$on、$emit自定义事件来进行通信
    Vuex可以解决同级组件之间无法传递消息
</code></pre><h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h4><pre><code>Store: 定义仓库，包含state对象，组件通过getter从store读取数据，通过Getter

核心模块:

    1、state: 定义存储状态

    2、getter: 对数据进行过滤，获取state数据，在计算属性中获取state的值

    3、mutation: 更改 Vuex 的 store 中的state值的唯一方法是提交 mutation

    4、action: 类似于 mutation，不同在于可以包含任意异步操作，Action通过commit()方法来调用mutation中的方法在改变来改变state的值，而不是直接改变state中的值

            分发Action: store.dispatch()方法触发

    5、modules: 如果应用过大，便可以使用 modules 来分割管理，不至于 store 变得非常臃肿


模块示例详解:

一、state: 

    用来存储数据，如果在组件中获取state中的数据，可以通过两种方法来获取: 计算属性computed 和 Getters

    在组件中显示state值可以通过computed来获取:

        &lt;template&gt;
            &lt;div class=&quot;box&quot;&gt;
                {{getSideData}}
            &lt;/div&gt;
        &lt;/template&gt;

        方法1: 计算属性中获取

        computed: {
            getSideData () {
                return this.$store.state.sideData;            // 当getSideData的值改变就会显示出来
            }
        }


        方法2: mapState函数获取

        import { mapState } from &apos;vuex&apos;;        // 引用mapState()

        export default {
            name: &apos;side&apos;,
            computed: {
                ...mapState({    // 对象展开运算符
                    getSideData: (state) =&gt; {
                        return state.sideData
                    }
                })
            }
        }

        getters.js
            export const sideData = (state) =&gt; {
                return state.sideData;
            } 


2、Getter

    获取state中数据的第二种方法

    getters.js中定义获取state的方法: 

        export const sideData = (state) =&gt; {
            return state.sideData;
        }

    组件中调用

        1）computed方式

            computed: {
                getSideData(){
                    return this.$store.getters.sideData;        // $store.getters下找到定义的sideDap
                }
            }

        2）通过mapGetters获取

            &lt;template&gt;
                &lt;div&gt;{{ getSideData }}&lt;/div&gt;
            &lt;/tempate&gt;

            import { mapState, mapGetters } from &apos;vuex&apos;;

            computed: {
                ...mapGetters({
                    getSideData: &quot;sideData&quot;            // 映射到getters.js中定义的sideData, 并将数据返回给getSideData
                })
            }

3、Mutations

    用来更改Vuex中state的数据，它是同步的

    1、commit()触发Action, Action触发mutation

        定义mutations 

            export default {
                changeSideData(state, sideJson){
                    state.sideData.push(sideJson)
                }
            }

        触发
            methods:{
                addSideData(){
                    let side = {
                        id: 1,
                        name: this.name,
                        introduce: this.introduce
                    }
                    this.$store.commit(&apos;changeSideData&apos;, side);
                }
            }


    2、使用mapMutations() 来定义改变


4、Actions

    Actions提交到 Mutations中，而不能直接改变state的值

    Actions可以包含异步操作，Mutations是同步的

    1）Example

        定义actions

            export const holderSilde = ({commit}, {name, introduce}) =&gt; {    
                // {name, introduce} 这里注意一定对象传过来，这里为解析赋值写法，函数不接收第三个参数
                var side = {
                    id: 1,
                    name: name,
                    introduce: introduce
                }
                commit(&apos;changeSideData&apos;, side)
            }


        调用 分发dispatch

            methods:{
                addSideData(){
                    // 第二个为传过去的参数
                    this.$store.dispatch(&apos;holderSilde&apos;, {name: this.name, introduce: this.introduce});
                }
            }


5、Modules

    Vuex可以将Store分割到各模块，每个模块都有自己的store、mutations、actions、getters

    const moduleA = {
        state: { ... },
        mutations: { ... },
        actions: { ... },
        getters: { ... }
    }

    const moduleB = {
        state: { ... },
        mutations: { ... },
        actions: { ... }
    }

    const store = new Vuex.Store({
        modules: {
            a: moduleA,
            b: moduleB
        }
    })

    store.state.a // -&gt; moduleA 的状态
    store.state.b // -&gt; moduleB 的状态
</code></pre><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><pre><code>1、App.vue:

    &lt;template&gt;
        &lt;div&gt;
            &lt;Display&gt;&lt;/Display&gt;
            &lt;Increment&gt;&lt;/Increment&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import Display from &apos;./components/Display.vue&apos;
        import Increment from &apos;./components/Increment.vue&apos;
        import store from &apos;./vuex/store&apos;

        export default {
            components: {
                Display,
                Increment
            },
            store           // 在根组件加入store
        }
    &lt;/script&gt;

    &lt;style&gt;
    body {
        font-family: Helvetica, sans-serif;
    }
    &lt;/style&gt;


2、Display.vue:

    &lt;template&gt;
        &lt;div&gt;
            &lt;h3&gt;Count is {{ counterValue }}&lt;/h3&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import { getCount } from &apos;../vuex/getters&apos;

        export default {
            vuex: {
                getters: {
                    counterValue: getCount
                }
            }
        }
    &lt;/script&gt;


3、Increment.vue

    &lt;template&gt;
        &lt;div&gt;
        &lt;button @click=&quot;increment&quot;&gt;Increment +1&lt;/button&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import { incrementCounter } from &apos;../vuex/action&apos;

        export default {

            vuex: {
                actions: {
                    increment: incrementCounter
                }
            }

        }
    &lt;/script&gt;


4、main.js

    import Vue from &apos;vue&apos; 
    import App from &apos;./App.vue&apos;

    new Vue({
        el: &apos;body&apos;,
        components: { 
            App
        }
    })


5、store.js

    import Vue from &apos;vue&apos;
    import Vuex from &apos;vuex&apos;

    // 引用vuex
    Vue.use(Vuex);

    // 启动时的初始状态
    const state = {
        // 放置初始化状态
        count: 0
    }

    const mutations = {
        // 放置要变更的函数
        INCREMENT(state, amount){
            state.count = state.count + amount;
        }
    }

    export default new Vuex.Store({
        state,
        mutations
    })


6、action.js

    // action 会收到 store 作为它的第一个参数
    // 既然我们只对事件的分发（dispatch 对象）感兴趣。（state 也可以作为可选项放入）
    // 我们可以利用 ES6 的解构（destructuring）功能来简化对参数的导入
    export const incrementCounter = function ({ dispatch, state }) {
        console.log(dispatch, state)
        dispatch(&apos;INCREMENT&apos;, 1)
    }


7、getter.js

    // 这个 getter 函数会返回 count 的值
    // 在 ES6 里你可以写成: 
    // export const getCount = state =&gt; state.count
    export function getCount(state){
        return state.count;
    }
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/23/VueJS之-“插件篇“（三）/">VueJS 之 “插件篇“（三）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/23/VueJS之-“插件篇“（三）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-23T11:19:24.000Z" itemprop="datePublished">2016-10-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>vue-router 路由插件<br>vue-validator 表单校验插件<br>vue-resource ajax插件</p>
</blockquote>
<h4 id="外部插件的加载方式"><a href="#外部插件的加载方式" class="headerlink" title="外部插件的加载方式"></a>外部插件的加载方式</h4><pre><code>import Vue from &apos;vue&apos;;                        // 不使用ES6写法: var Vue require(&apos;vue&apos;);      由webpack来解析
import VueValidator from &apos;vue-validator&apos;    // 引用插件

// 注册插件
Vue.use(VueValidator);
</code></pre><h4 id="vue-cli-脚手架"><a href="#vue-cli-脚手架" class="headerlink" title="vue-cli 脚手架"></a>vue-cli 脚手架</h4><pre><code>一、下载 

    https://cli.vuejs.org/guide/creating-a-project.html

    $ yarn add @vue/cli                // 最新版本 3.0 npm install -g vue-cli 这种可能是下2.0的

    $ vue create hello-world    // 创建项目 vue create --help

        // 如果安装2.0的模板
        $ vue init webpack my-project        // vue init webpack-simple#1.0 mynewproject

    // 下载依赖包
    $ cd my-project 
    $ yarn
    $ yarn serve     // 启动服务


二、main.js 入口文件

    import Vue from &apos;vue&apos;
    import chat from &apos;./components/chat.vue&apos;;

    new Vue({
        el: &apos;#app&apos;,
        render: h =&gt; h(chat)         // 调用其它.vue文件必须这么写
    })

    render: h =&gt; h(chat) 相当于

    render: (function (h) {  
          return h(App);
    });  


三、不需要代码校验

    在webpack.base.conf.js里面删掉下面:

    preLoaders: [
        {
            test: /\.vue$/,
            loader: &apos;eslint&apos;,
            include: projectRoot,
            exclude: [/node_modules/, /ignore_lib/]
        },
        {
            test: /\.js$/,
            loader: &apos;eslint&apos;,
            include: projectRoot,
            exclude: [/node_modules/, /ignore_lib/]
        }
    ]


四、配置代理服务器进行跨域

    config/index.js

    proxyTable: {
        &apos;/operate&apos;:{
            target:&apos;http://192.168.2.155:8079&apos;,
            changeOrigin: true,            // 只能设置changeOrigin本地会虚拟一个代理服务端，来解决跨域问题
            pathRewrite:{
                &apos;^/operate&apos;:&apos;/&apos;
            }
        }
    }

    代码里调用的url，例如 /operate/getUsername 就相当于通过代理调用到 http://192.168.2.155:8079/getUsername


五、常用及目录命令

        npm run dev  启动服务   

        npm run build  将开发环境打包到一个dist目录下，用于生产环境

        src: 开发环境目录    static: 静态文件目录
</code></pre><h4 id="vue-router-路由"><a href="#vue-router-路由" class="headerlink" title="vue-router 路由"></a>vue-router 路由</h4><pre><code>一、安装

    $ npm install vue-router


二、引用路由:

        import Vue from &apos;vue&apos;
        import VueRouter from &apos;vue-router&apos;

        Vue.use(VueRouter)

        const routes = [
            { path: &apos;/foo&apos;, component: Foo },        // 一个路由对应一个组件
            { path: &apos;/bar&apos;, component: Bar }
        ]


三、使用方法

    html:

        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;
            &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;

            &lt;!-- 加载路由视图 --&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
        &lt;/div&gt;

     router.js

        import Vue from &apos;vue&apos;
        import VueRouter from &apos;vue-router&apos;
        import login from &apos;./components/login&apos;

        // 将路由插件加载到Vue中
        Vue.use(VueRouter);

        // 路由映射配置
        const routes = [
            { 
                path: &apos;/login&apos;, 
                component: login
            },
            {
                path: &apos;/*&apos;,
                redirect: &apos;/404&apos;        // 重定向
            }
        ]

        // 创建路由实例
        const router = new VueRouter({
            routes        // 将定义的配置当参数注入路由
        })

        // 创建和挂载根实例
        const app = new Vue({
            router
        }).$mount(&apos;#app&apos;)


四、动态路由

    $route.params  获取参数

    const router = new VueRouter({
        routes: [
            // 动态路径参数 以冒号开头
            { path: &apos;/user/:id&apos;, component: User }
        ]
    })

    // 路由参数  /user/:username     匹配/user/haha    $route.params 来取参数  { username: &apos;haha&apos; }
    mounted(){
        let usernmae = this.$route.params.username;
    }

    1、router-link 参数

        &lt;router-link :to=&quot;{ name: &apos;user&apos;, params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;

    2、this.$router.push中参数

        router.push({ name: &apos;user&apos;, params: { userId: 123 }})


五、路由跳转

    1、$router.push(location): js内加路由跳转

            // 字符串
            router.push(&apos;home&apos;)

            // 对象
            router.push({ path: &apos;home&apos; })

            // 命名的路由
            router.push({ name: &apos;user&apos;, params: { userId: 123 }})

            // 带查询参数，变成 /register?plan=private
            router.push({ path: &apos;register&apos;, query: { plan: &apos;private&apos; }})

    2、router.replace(): 与push很像，不同的是replace不会向history添加到新记录

    3、router.go(n): 指定向后跳几步，与window.history.go(n)相同，history历史记录跳转

    4、&lt;router-link to=&quot;home&quot;&gt;home&lt;/router-link&gt;            // 编辑出来是&lt;a&gt;标签


五、&lt;router-view&gt; 渲染路由视图组件

    &lt;router-view&gt;&lt;/router-view&gt;

    支持多个渲染:

        &lt;router-view&gt;&lt;/router-view&gt;
        &lt;router-view name=&quot;ac&quot;&gt;&lt;/router-view&gt;
        &lt;router-view name=&quot;bc&quot;&gt;&lt;/router-view&gt;


六、重命定向 redirect

    {
        path: &apos;*&apos;,
        redirect: function () {
                return &apos;/admin&apos;;
        }
    }


七、History模式

    1、hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。

    2、history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式. （url不会带hash “#“）

    3、abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式

    export default new VueRouter({
        mode: &apos;history&apos;,
        routes: [...]
    })            


八、router 钩子

    1、beforeEach、afterEach 路由跳转前后的钩子

        var auth = {
            loggedIn: function () {
                return localStorage.getItem(KEY_OF_LOGGEDIN) === &apos;true&apos;;
            }
        }

        router.beforeEach((to, from, next) =&gt; {
            if (to.matched.some(record =&gt; record.meta.requiresAuth)) {
                if (!auth.loggedIn()) {
                            next({
                                path: &apos;/login&apos;,
                                query: {redirect: to.fullPath},
                            });
                } else if (auth.requiresAlterPassword()){
                            next({
                                path: &apos;/firstLogin&apos;
                            });
                } else {
                            next();
                }
            } else {
                next();
            }
        });

    2、to: 要进入目录的路由对象

    3、from: 要离开的路由对象

    4、next: function, 用该方法来resolve这个钩子

        next({
            path: &apos;/login&apos;,        // 跳转的
            query: {redirect: to.fullPath},                // to.fullPath是当前的路径
        });


九、meta 定义路由的时候可以配置meta字段

    1、设置meta属性，可以通过它来设置不需要判断登录的路由，在beforeEach的时候进行处理

        {
            path: &apos;/firstLogin&apos;,
            name: &apos;firstLogin&apos;,
            meta: {
                    requiresAuth: false
            },
            component: (resolve) =&gt; require([&apos;../views/firstLogin.vue&apos;], resolve),
        }

    2、matched来访问meta属性





九、路由对象

    1、$route.path: 当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;

    2、$route.params: 获取动态路由的参数

    3、$route.query:  URL 查询参数, 例如，对于路径 /foo?user=1，则有 $route.query.user == 1

    4、$route.hash: 路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。

    5、$route.matched: 

    6、$route.name: 路由的名称
</code></pre><h4 id="表单校验插件-vue-validator"><a href="#表单校验插件-vue-validator" class="headerlink" title="表单校验插件 vue-validator"></a>表单校验插件 vue-validator</h4><h4 id="vue-resource-ajax插件"><a href="#vue-resource-ajax插件" class="headerlink" title="vue-resource ajax插件"></a>vue-resource ajax插件</h4><pre><code>一、它提供了两种方式来处理HTTP请求: 

    使用Vue.http或this.$http

    使用Vue.resource或this.$resource


二、特点: 支持拦截器

    拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。

    拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。


三、使用方式: 

    1、拦截器  使用inteceptor

    Vue.http.interceptors.push((request, next) =&gt; {

        // 请求发送前的处理逻辑
        next((response) =&gt; {
            // 请求发送后的处理逻辑
            // 根据请求的状态，response参数会返回给successCallback或errorCallback
            return response
        })
    })


四、请求类型

    get(url, [options])
    head(url, [options])
    delete(url, [options])
    jsonp(url, [options])
    post(url, [body], [options])
    put(url, [body], [options])
    patch(url, [body], [options])

    &lt;script&gt;

        var demo = new Vue({
            el: &apos;#app&apos;,
            data: {
                gridColumns: [&apos;customerId&apos;, &apos;companyName&apos;, &apos;contactName&apos;, &apos;phone&apos;],
                gridData: [],
                apiUrl: &apos;http://211.149.193.19:8080/api/customers&apos;
            },
            ready: function() {
                this.getCustomers();
            },
            methods: {
                getCustomers: function() {

                    // get请求
                    // then方法只提供了successCallback，而省略了errorCallback。
                    // catch方法用于捕捉程序的异常，catch方法和errorCallback是不同的，errorCallback只在响应失败时调用，而catch则是在整个请求到响应过程中，只要程序出错了就会被调用。

                    this.$http.get(this.apiUrl)
                        .then((response) =&gt; {

                            // Vue实例方法，设置gridData属性赋值，并触发视图更新
                            this.$set(&apos;gridData&apos;, response.data)
                        })
                        .catch(function(response) {
                            console.log(response)
                        })
                }
            }
        })

    &lt;/script&gt;

5、options对象

    发送请求时的options选项对象包含以下属性: 

    参数             类型                                描述
    url            string            请求的URL

    method        string            请求的HTTP方法，例如: &apos;GET&apos;, &apos;POST&apos;或其他HTTP方法

    body        Object             FormData string    request body

    params        Object            请求的URL参数对象

    headers        Object            request header

    timeout        number            单位为毫秒的请求超时时间 (0 表示无超时时间)

    before        function(request)    请求发送前的处理函数，类似于jQuery的beforeSend函数

    progress     function(event)      ProgressEvent回调处理函数

    credientials    boolean          表示跨域请求时是否需要使用凭证

    emulateHTTP        boolean          发送PUT, PATCH, DELETE请求时以HTTP POST的方式发送，并设置请求头的X-HTTP-Method-Override

    emulateJSON        boolean          将request body以application/x-www-form-urlencoded content type发送
</code></pre><blockquote>
<p><a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/</a><br><a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh-cn/</a><br><a href="https://github.com/dai-siki/vue-image-crop-upload" target="_blank" rel="noopener">https://github.com/dai-siki/vue-image-crop-upload</a>   头像上传组件<br><a href="http://www.cnblogs.com/pandabunny/p/5417938.html" target="_blank" rel="noopener">http://www.cnblogs.com/pandabunny/p/5417938.html</a>     // vue引用jquery<br><a href="http://router.vuejs.org/zh-cn/installation.html" target="_blank" rel="noopener">http://router.vuejs.org/zh-cn/installation.html</a>     // 路由插件<br><a href="http://yuche.github.io/vue-strap/" target="_blank" rel="noopener">http://yuche.github.io/vue-strap/</a>                    // vueStrap<br><a href="http://bootstrap-table.wenzhixin.net.cn/zh-cn/" target="_blank" rel="noopener">http://bootstrap-table.wenzhixin.net.cn/zh-cn/</a>    // bootstrap Table<br><a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">https://github.com/PanJiaChen/vue-element-admin</a><br><a href="https://github.com/opendigg/awesome-github-vue?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">https://github.com/opendigg/awesome-github-vue?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a>      // vue项目汇总</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/22/VueJS之-“组件篇“（二）/">VueJS 之 “组件篇“（二）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/22/VueJS之-“组件篇“（二）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-22T06:02:01.000Z" itemprop="datePublished">2016-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 涉及知识点:<br>| 1、全局组件、局部组件<br>| 2、数据传递（props、组件通信、slot）<br>| 3、props、sync双向绑定、once单次绑定<br>| 4、组件之间通信，$dispatch() 派发事件、 $broadcast() 广播事件，事件向下传导给所有后代<br>| 4、slot 内容分发<br>| 组件是Vue的最强大功能之一，组件可以扩展html元素，封装可复用代码</p>
<h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><pre><code>全局组件在任何组件内都可以调用，无需引用或通过component加载

main.js

    // 定义一个全局的组件
    var myComponent = Vue.extend({
        template: &apos;&lt;div&gt; 组件已经渲染出来 &lt;/div&gt;&apos;
    })

    // 全局注册
    Vue.component(&apos;crm-component&apos;, myComponent);

    new Vue({
        ...
    }}


main.vue 子组件

    &lt;templte&gt;
        &lt;div class=&quot;welcome&quot;&gt;
            &lt;h1&gt;视图列表页面&lt;/h1&gt;
            &lt;crm-component&gt;&lt;/crm-component&gt;            &lt;!-- 直接调用 --&gt;
        &lt;/div&gt;
    &lt;/template&gt;
</code></pre><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h4><pre><code>必须使用components对象来引用组件

&lt;div id=&quot;appA&quot;&gt;
    &lt;component-parent&gt;&lt;/component-parent&gt;
&lt;/div&gt;

&lt;script&gt;
    var vmA = new Vue({
        el: &quot;#appA&quot;,
        components: {        // 局部的写法
            &apos;crm-component&apos;: {
                 template: &apos;&lt;div&gt;这里component&lt;/div&gt;&apos;
            }
        }
    })
&lt;/script&gt;

注意: &lt;component-parent&gt; 自定义元素以“-”分割

    &apos;crm-component&apos;: {        // 这里定义的组件名可以是以“-”分割，也可以驼峰方式 crmComponent
         template: &apos;&lt;div&gt;这里component&lt;/div&gt;&apos;
    }
</code></pre><p>————— 父与子组件之间的数据传递 —————</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>父组件将数据传给子组件通过props，子组件通过自定义事件$on、$emit来挂参数传递给父组件.

2.0版本之后 props为单向数据流，父组件属性变化，将传给子组件

一、props字面量

    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 这里的两个属性值通过props传到组件中 --&gt;
        &lt;component-parent my-name=&quot;siguang&quot; my-age=&apos;33&apos;&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var componentCrm = Vue.extend({
            props: [&apos;myName&apos;, &apos;myAge&apos;],
            template: &apos;&lt;h2&gt;{{ myName }} {{ myAge }}&lt;/h2&gt;&apos;
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: componentCrm
            }
        })
    &lt;/script&gt;

    注意: my-name=&quot;siguang&quot; 自定义属性以“-”分割

         props: [&apos;myName&apos;, &apos;myAge&apos;]        // props 定义的必须以驼峰形势


二、props动态值

    parent.vue:

        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- 通过父组件传到子组件中 --&gt;
            &lt;child-component :user-name=&quot;uname&quot;&gt;&lt;/child-component&gt;
        &lt;/div&gt;

        &lt;script&gt;
            import childComponent from &apos;childComponent.vue&apos;;

            export default{
                data(): {
                    return{
                        uname: &apos;siguang&apos;
                    }
                },
                components:{
                    childComponent
                }
            }
        &lt;/script&gt;


    childComponent.vue:

        &lt;div&gt;
            {{userName}}        &lt;!-- siguang --&gt;
        &lt;/div&gt;

        &lt;script&gt;
            export default{
                propos: [&apos;userName&apos;],
                data(){
                    return {

                    }
                }
            }
        &lt;/script&gt;


三、once 将渲染的结果缓存

    不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来

    &lt;div id=&quot;app&quot;&gt;
        &lt;component-parent&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;

        var childrenComponent = Vue.extend({
            template: &apos;&lt;div v-once&gt;&apos;+
                &apos;&lt;h3&gt;这里是子组件的内容: {{ myMsg }}&lt;/3&gt;&apos;+
                &apos;&lt;p&gt;这里输入不会影响父组件: &lt;input type=&quot;text&quot; v-model=&quot;myMsg&quot; /&gt;&lt;/p&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            data: function(){
                return {
                    myMsg: &apos;&apos;
                }
            },
            props: [&apos;myMsg&apos;]
        })

        var parentComponent = Vue.extend({
            template: &apos;&lt;div v-once&gt;&apos;+
                &apos;&lt;p&gt;&lt;input text=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;/p&gt;&apos;+
                &apos;&lt;p&gt;父组件的值 {{ msg }}&lt;/p&gt;&apos;+
                &apos;&lt;/div&gt;&apos;+
                &apos;&lt;childen-component v-bind:my-msg.once=&quot;msg&quot;&gt;&lt;/childen-component&gt;&apos;,
            data: function(){
                return {
                    msg: &apos;这里值只传给子组件一次&apos;
                }
            },
            components: {
                &apos;childen-component&apos;: childrenComponent
            }
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: parentComponent
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="组件之间通信"><a href="#组件之间通信" class="headerlink" title="组件之间通信"></a>组件之间通信</h4><pre><code>props是父向子组件传递数据，子向父组件传递可以通过自定义事件来完成，从而现实组件的数据双向绑定

$on(eventName) 监听事件    、$emit(eventName) 触发事件

一、子向父组件发消息

    parent.vue: 

        &lt;template&gt;
            &lt;div class=&quot;login&quot;&gt;
                &lt;div class=&quot;parent-box&quot;&gt;
                    &lt;p&gt;显示子组件数据: {{ childrenText }}&lt;/p&gt;
                &lt;/div&gt;

                &lt;children-component ref=&quot;childrenRef&quot; v-on:showChildrenVal=&quot;childrenVal&quot;&gt;&lt;/children-component&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            import ChildrenComponent from &apos;./children.vue&apos;
            export default{
                data(){
                    return {
                        childrenText: &apos;&apos;
                    }
                },
                methods:{
                    childrenVal(val){
                        this.childrenText = val;
                    }
                },
                components:{
                    ChildrenComponent
                }
            }
        &lt;/script&gt;

    children.vue:

        &lt;template&gt;
            &lt;div class=&quot;children&quot; style=&quot;padding-top: 50px; border-top: 1px #ccc solid&quot;&gt;
                &lt;p&gt;&lt;input type=&quot;text&quot; v-model=&quot;childrenInp&quot; id=&quot;&quot;&gt;&lt;/p&gt;
                &lt;p&gt;&lt;input type=&quot;button&quot; @click=&quot;showChildrenVal&quot; value=&quot;提交到父组件中&quot;&gt;&lt;/p&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            export default{
                data(){
                    return {
                        childrenInp: &apos;&apos;
                    }
                },
                methods:{
                    showChildrenVal(){
                        this.$emit(&quot;showChildrenVal&quot;, this.childrenInp);
                    }
                }
            }
        &lt;/script&gt;


二、父向子发消息

    parent.vue:

        &lt;template&gt;
            &lt;div class=&quot;login&quot;&gt;
                &lt;div class=&quot;parent-box&quot;&gt;
                    &lt;p&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;inputParent&quot; &gt;&lt;br&gt;&lt;/p&gt;
                    &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;值传给父组件&quot; @click=&quot;sendChildren&quot;&gt;&lt;br&gt;&lt;/p&gt;
                    &lt;p&gt;显示子组件数据: {{ childrenText }}&lt;/p&gt;
                &lt;/div&gt;

                &lt;children-component ref=&quot;childrenRef&quot;&gt;&lt;/children-component&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            import ChildrenComponent from &apos;./children.vue&apos;
            export default{
                data(){
                    return {
                        inputParent: &apos;&apos;,
                        childrenText: &apos;&apos;
                    }
                },
                methods:{
                    sendChildren(){
                        debugger;
                        this.$refs.childrenRef.$emit(&apos;showText&apos;, this.inputParent);        // 也可以用props
                    }
                },
                components:{
                    ChildrenComponent
                }
            }
        &lt;/script&gt;


    children.vue:

        &lt;template&gt;
            &lt;div class=&quot;children&quot; style=&quot;padding-top: 50px; border-top: 1px #ccc solid&quot;&gt;
                这里是父组件传递的值: {{transmitVal}}
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            export default{
                created(){
                    this.$on(&apos;showText&apos;, function(val){
                        this.transmitVal = val;
                    })
                },
                data(){
                    return {
                        transmitVal: &apos;&apos;
                    }
                }
            }
        &lt;/script&gt;


三、v-ref 直接访问到组件

    &lt;div id=&quot;app&quot;&gt;
        &lt;span ref=&quot;msg&quot;&gt; hello &lt;/span&gt;
        &lt;span ref=&quot;other-msg&quot;&gt; world &lt;/span&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                someProp: &apos;idName&apos;,
                otherProp: &apos;prop&apos;
            }
        })

        console.log(vm.$refs.msg.textContent);        // hello
        console.log(vm.$refs.otherMsg.textContent);    // world
    &lt;/script&gt;



以下是1.* 版本
1、$broadcast 广播事件 父组件发消息给所有子组件

    &lt;div id=&quot;app&quot;&gt;
        &lt;component-parent&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // 子组件接收消息
        var childrenComponent = Vue.extend({
            template: &apos;&lt;div style=&quot;border: 1px #42b983 solid;padding: 10px; margin-top:10px;&quot;&gt;&apos;+
                &apos;&lt;h3&gt;显示父组件广播的消息: {{ showMessage }}&lt;/h3&gt;&lt;/div&gt;&apos;,
            data: function(){
                return {
                    showMessage: &apos;&apos;
                }
            },
            events: {
                messageEvent: function(val){        // messageEvent 接收
                    this.showMessage = val;
                }
            }
        })

        // 父组件广播消息
        var parentComponent = Vue.extend({
            template: &apos;&lt;div&gt;这里是父组件: &apos;+
                &apos;&lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;&lt;input type=&quot;button&quot; @click=&quot;sendMessage&quot; value=&quot;通知&quot; /&gt;&apos;+
                &apos;&lt;children-component&gt;&lt;/children-component&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            components: {
                &apos;children-component&apos;: childrenComponent
            },
            data: function(){
                return {
                    message: &apos;&apos;
                }
            },
            methods: {
                sendMessage: function(){
                    this.$broadcast(&apos;messageEvent&apos;, this.message);        // 定义事件名为messageEenent， 将message值广告给所有子组件
                }
            }
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: parentComponent
            }
        })
    &lt;/script&gt;


2、$dispatch: 派发事件 子组件向上传消息给父组件

    &lt;div id=&quot;app&quot;&gt;
        &lt;component-parent&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // 子组件 派发消息
        var childrenComponent = Vue.extend({
            template: &apos;&lt;div style=&quot;border: 1px #42b983 solid;padding: 10px; margin-top:10px;&quot;&gt;&apos;+
                &apos;&lt;h3&gt;显示父组件广播的消息: {{ showMessage }}&lt;/h3&gt;&apos;+
                &apos;&lt;input type=&quot;text&quot; v-model=&quot;showMessage&quot; /&gt;&lt;input type=&quot;button&quot; @click=&quot;sendMessage&quot; value=&quot;向父组件派发消息&quot; /&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            data: function(){
                return {
                    showMessage: &apos;&apos;
                }
            },
            methods: {
                sendMessage: function(){
                    this.$dispatch(&apos;messageEvent&apos;, this.showMessage);        
                }
            }
        })

        // 父组件
        var parentComponent = Vue.extend({
            template: &apos;&lt;div&gt;收到了子组件的派发消息: {{ message }}&apos;+
                &apos;&lt;children-component&gt;&lt;/children-component&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            components: {
                &apos;children-component&apos;: childrenComponent
            },
            data: function(){
                return {
                    message: &apos;&apos;
                }
            },
            events: {
                messageEvent: function(val){
                    this.message = val;
                }
            }
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: parentComponent
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="slot-分发内容"><a href="#slot-分发内容" class="headerlink" title="slot 分发内容"></a>slot 分发内容</h4><pre><code>parent.vue:

    &lt;template&gt;
        &lt;div class=&quot;login&quot;&gt;
            &lt;children-component&gt;
                &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;

                &lt;div class=&quot;tag&quot;&gt;
                    这里是没有定义slot名称走的默认的slot
                    &lt;div class=&quot;tag-til&quot;&gt;标题&lt;/div&gt;
                    &lt;div class=&quot;tag-content&quot;&gt;内容部分&lt;/div&gt;
                &lt;/div&gt;
            &lt;/children-component&gt;
        &lt;/div&gt;
    &lt;/template&gt;

children.vue:

    &lt;template&gt;
        &lt;div class=&quot;children&quot;&gt;
            &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;

            &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
    &lt;/template&gt;
</code></pre><h4 id="vueify-开发外部独立"><a href="#vueify-开发外部独立" class="headerlink" title="vueify 开发外部独立"></a>vueify 开发外部独立</h4><pre><code>使用.vue格式的文件定义组件，一个.vue就是一个组件

一、.vue组件包括3部分: 

    &lt;style&gt;&lt;/style&gt; 定义组件样式

    &lt;template&gt;&lt;/template&gt; 定义组件模板

    &lt;script&gt;&lt;/script&gt; 定义组件选项，如data, methods等


二、在定义组件的选项时，data和el选项必须使用函数

    &lt;script&gt;
        export default {
            data(){                // 数据，相当于 data: function(){}
                return {
                    msg: &quot;hello Vue&quot;
                }
            }
        }
    &lt;/script&gt;

Example: 

    App.vue:
        &lt;style&gt;
            h1 { color: #cc33ff; font-size: 30px;}
        &lt;/style&gt;

        &lt;template&gt;
            &lt;div class=&quot;box&quot;&gt;
                &lt;h1&gt;{{message}}&lt;/h1&gt;
                &lt;message&gt;&lt;/message&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;

            import message from &apos;./message.vue&apos;

            export default {
                data(){                // 数据
                    return {
                        msg: &quot;hello Vue&quot;
                    }
                },
                components: {
                    message         // 这里ES6的简写，message: message
                },
                methods:{
                    showMessage(){
                        console.log(this.msg);
                    }
                }
            }
        &lt;/script&gt;

    HTML: 
        &lt;div id=&quot;app&quot;&gt;
        &lt;app&gt;&lt;/app&gt;

    main.js:

        // ES6导入模块
        import Vue form &apos;vue&apos;
        import App form &apos;App.vue&apos;

        // 可以使用CMD模式
        /*
            var vue = require(&apos;vue&apos;);
            var app = reuqire(&apos;App.vue&apos;)
        */

        new Vue({
            el:&apos;#app&apos;,
            components: { App }
        })

https://github.com/vuejs/vueify
</code></pre><h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><pre><code>Vue.component(&apos;async-webpack-example&apos;, function (resolve) {
    // 这个特殊的 require 语法告诉 webpack
    // 自动将编译后的代码分割成不同的块，
    // 这些块将通过 Ajax 请求自动下载。
    require([&apos;./my-async-component&apos;], resolve)
})

https://segmentfault.com/a/1190000012138052
</code></pre><h4 id="组件化的css"><a href="#组件化的css" class="headerlink" title="组件化的css"></a>组件化的css</h4><pre><code>可以通过scoped属性来控制样式是否是只在当前组件下使用

&lt;style&gt;
    /* 全局下的样式 */
&lt;/style&gt;

&lt;style scoped&gt;
    /* 当前组件下使用的样式 */
&lt;/style&gt;
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/22/VueJS之-“基础篇“（一）/">VueJS 之 “基础篇“（一）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/22/VueJS之-“基础篇“（一）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-22T03:06:51.000Z" itemprop="datePublished">2016-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| style与class<br>| computed、directive、filter<br>| watch 侦听Data数据的变化<br>| 生命周期: beforeCreate、create、beforeMount、mounted、beforeUpdate、updated、destroyed<br>| this.$refs、$el、$data、$watch<br>| v-bind缩写:、v-on缩写@</p>
<h4 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h4><pre><code>一、Vue的MVVM实现的原理？

    ViewModel是Vue.js的核心，Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素

    DOM Listeners 和 Data Bindings看作两个工具，它们是实现双向绑定的关键。

    从view层来看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；

    从Model层来看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。


二、Vue使用

    1、页面加载vue.js文件  &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;

    2、$ npm install vue --save-dev

    3、vue-cli 脚手架
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>一、构造器

    1、每个构造器都是通过创建一个Vue的实例启动的

        var vm = new Vue({
            // ...    
        })

    2、扩展构造器

        通过扩展构造器可以创建可复用的组件构造器

        var MyComponent = Vue.extend({
            // 扩展选项
        })


二、生命周期

    1、beforeCreate(): 实例初始化，数据观测(data observer)和事件（event/watcher）配置之前被调用

    2、create(): 实例创建完后被调用，完成了数据观测(data observer)和事件（event/watcher）回调，但还挂载还没开始$el属性不可见

    3、beforeMount(): 在挂载开始之前调用，render()函数被调用

    4、mounted(): el被创建的vm.$el替换，挂载到实例上调用钩子

    5、beforeUpdate(): 数据更新时调用，在虚拟DOM重新渲染

    6、updated(): 数据更改导致虚拟DOM重新渲染

    7、destroyed(): 卸载组件

    &lt;script&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                message: &apos;siguang&apos;
            },
            methods: {
                showMessage: function(){
                    console.log(this.message);
                },
                deleteVue: function(){
                    vm.$destroy();          // 消毁Vue实例
                }
            },

            // new Vue后执行开始
            beforeCreate: function(){
                console.log(&apos;beforeCreate&apos;);
            },

            // Vue实例创建被调用
            create: function(){
                console.log(&apos;create&apos;);
            },


            mounted: function(){
                console.log(&apos;mounted&apos;);
            },

            // 数据更新后执行的回调
            beforeUpdate: function(){    
                console.log(&apos;beforeUpdate&apos;);     
            },
            updated: function(){    
                console.log(&apos;updated&apos;);     
            },

            // 消毁时触发
            destroyed: function(){
                console.log(&apos;destroyed&apos;);
            }
        });
    &lt;/script&gt;
</code></pre><h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><pre><code>一、文本绑定:  &lt;p&gt;{{ data.name }}&lt;/p&gt;    与 &lt;p v-text=&quot;data.name&quot;&gt;&lt;/p&gt; 相同

二、html绑定:  &lt;p v-html=&quot;data.strHtml&quot;&gt;&lt;/p&gt;

三、绑定的值可以html中: 

    &lt;div id=&quot;item-{{id}}&quot;&gt;&lt;/div&gt;

    &lt;div :id=&quot;userId&quot;&gt;&lt;/div&gt;

四、表达式:  {{ dat.num == 1 }}、 {{ num ? 'yes' : 'no' }}、 {{if(ok) {return message} }}

五、过滤器:  {{ message | capitalize }}

    连续过滤器:  {{ message | filterA | filterB }}
</code></pre><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><pre><code>指令: 以 v- 开头

    &lt;div v-if=&quot;greeting == 1&quot;&gt;&lt;/div&gt;

    带参数: &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;

一、v-if、v-else-if、v-else条件渲染:

    &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;A&lt;/div&gt;
    &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;B&lt;/div&gt;
    &lt;div v-else&gt;Not A/B/C&lt;/div&gt;

二、v-show: 显示还是隐藏元素，用的display

三、v-for 循环

    $index: 索引        $key: 

    * 数组/数组对象循环: 

        &lt;li v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;{{ item.message }}&lt;/li&gt;

        或者:
        &lt;li v-for=&quot;(val, index) in objList&quot; :key=&quot;index&quot;&gt;
                {{index}}. {{key}} : {{val.type}}
        &lt;/li&gt;

    * filterBy()、orderBy()过滤器

四、v-model: 绑定值，这也是MVVM的关键点

    可以对文本表单、单选框 、多选框、下拉菜单进行绑定值

        1、lazy: 不是输入时就进行同步而是在change的时候才对数据进行同步

            &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; lazy /&gt; {{msg}}

        2、number: 将用户输入的转成Number型，如果返回NaN那就返回原值

        3、debounce: 设置一个最小延时，否则如果输入是ajax请求，每次敲击都会去请求

            &lt;input type=&quot;text&quot; debounce=&quot;500&quot; v-model=&quot;msg&quot;&gt;        // 按完键500毫秒后在进行

    获取checkbox值:

        &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt;

        // 当选中时
        vm.toggle === vm.a

        // 当没有选中时
        vm.toggle === vm.b

五、v-bind: 绑定到HTML元素上，v-bind:class=&quot;active&quot;，缩写: &quot;:&quot; &lt;a :href=&apos;url&apos;&gt;&lt;/a&gt;

六、v-on: 用于监听DOM事件 v-on缩写: &quot;@&quot; &lt;div @click=&quot;doSomeing&quot;&gt;&lt;/div&gt;

七、ref: 访问子组件

    &lt;div ref=&quot;box&quot;&gt;xxxx&lt;/div&gt;
    &lt;el-button type=&quot;primary&quot; slot=&quot;append&quot; @click=&quot;getRefs&quot;&gt;发送&lt;/el-button&gt;
    &lt;/div&gt;

    {
        methods:{
            getRefs(){
                console.log(this.$refs.box.innerHTML);        // 获取 $refs
            }
        }
    }

    如果绑定一个元素使用 :ref=&apos;item&apos;
    &lt;p v-for=&quot;item in items&quot; :ref=&quot;item&quot;&gt;&lt;/p&gt;

八、v-pre: 跳过这个元素和它的子元素的编译过程，这样加快了编译的速度

    &lt;div v-pre&gt;{{ 这里不用框架来编译 }}&lt;/div&gt;

九、v-cloak:

十、v-once: 只渲染元素和组件一次，之后的渲染都会跳过次元素

    &lt;span v-once&gt;xxxxx&lt;/span&gt;
</code></pre><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><pre><code>过滤器，对绑定值进行处理

一、内置过滤器

    1、uppercase: 字母转成大写

    2、lowercase: 字母转成小写

    3、capitalize: 首字母转成大写

    4、filterBy: 过滤内容

    5、limitBy: 过滤数据从开始到指定位置结束的内容

    6、orderBy: 过滤排序

    7、currency: 货币过滤

    8、debounce: 延迟过滤


二、自定义过滤器和带参数

    &lt;span v-text=&quot;message | reverse &apos;addText&apos; &quot;&gt;&lt;/span&gt;

    // 创建自己定义过滤器 value值 addText参数
    Vue.filter(&apos;reverse&apos;, function(value, addText){
        return value.split(&apos;&apos;).remove().join() + addText:
    })


三、双向过滤器

    模型的值显示在视图之前转换它

    &lt;input v-mode=&quot;money | formatMoney&quot;&gt;
    &lt;div&gt;{{ money | formatMoney }}&lt;/div&gt;

    Vue.filter(&apos;formatMoney&apos;, {

        // model -&gt; vlew过程  在更新&lt;input&gt; 元素之初化值
        read: function(val){
            return &apos;$&apos; + val.toFixed(2);
        },

        // vlew -&gt; model过程 在写回数据之前格式化值
        write: function(val){
            var number = +val.replace(/[^\d.]/g, &apos;&apos;);
            return isNaN(number) ? 0 : parseFloat(number.toFixed(2));
        }
    })


四、动态参数

    参数用空格格开

    &lt;input type=&quot;text&quot; v-model=&quot;userInput&quot;&gt;
    &lt;span&gt;{{msg | concat userInput}}&lt;/span&gt;

    Vue.filter(&apos;concat&apos;, function (value, input) {
        // `input` === `this.userInput`
        return value + input;
    })


五、filterBy过滤器

    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;过滤数据里包含 蛋糕 字符 &lt;/div&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | filterBy &apos;蛋糕&apos; &quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top: 30px&quot; &gt;过滤出输入的字符&lt;/div&gt;
        &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;searchKey&quot; /&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | filterBy searchKey in &apos;name&apos;&quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                searchKey: &apos;&apos;,
                users:[
                    {
                        name: &apos;外卖&apos;,
                        tag: 1
                    },
                    {
                        name: &apos;鲜花&apos;,
                        tag: 5
                    },
                    {
                        name: &apos;蛋糕&apos;,
                        tag: 4
                    },
                    {
                        name: &apos;水果&apos;,
                        tag: 2
                    },
                    {
                        name: &apos;茶点&apos;,
                        tag: 3
                    }
                ]
            }
        })
    &lt;/script&gt;

六、orderBy排序

    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;searchKey&quot; /&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | orderBy &apos;tag&apos;&quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                searchKey: &apos;&apos;,
                users:[
                    {
                        name: &apos;外卖&apos;,
                        tag: 1
                    },
                    {
                        name: &apos;咖啡&apos;,
                        tag: 5
                    },
                    {
                        name: &apos;餐厅订座&apos;,
                        tag: 4
                    },
                    {
                        name: &apos;蛋糕&apos;,
                        tag: 2
                    },
                    {
                        name: &apos;票务&apos;,
                        tag: 3
                    }
                ]
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><pre><code>一、钩子函数

    el：指令所绑定的元素，可以用来直接操作 DOM 。
    binding：一个对象，包含以下属性：
    name：指令名，不包括 v- 前缀。
    value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。
    oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
    expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。
    arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。
    modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
    vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
    oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

二、对象字面量

    &lt;div v-demoA=&quot;{ color: &apos;white&apos;, text: &apos;hello&apos;}&quot;&gt;&lt;/div&gt;

    Vue.directive(&apos;demoA&apos;, function(el, value){
        console.log(value.color);
        console.log(value.text);
    })


三、元素指令，相当于angular的E指令

    Vue.elementDirective(&apos;my-directive&apos;, {
        bind: function(){
            // 操作this.el
        }
    })

    &lt;my-directive&gt;&lt;/my-directive&gt;            // 不能这么写&lt;div v-my-directive&gt;&lt;/div&gt;

四、高级选项

    params: 自动提取绑定元素的这些特性.

    &lt;div v-example a=&quot;hi&quot;&gt;&lt;/div&gt;
    Vue.directive(&apos;example&apos;, {
        params: [&apos;a&apos;],
        bind: function () {
            console.log(this.params.a);         // -&gt; &quot;hi&quot;
        }
    })
</code></pre><h4 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h4><pre><code>计算属性就是当依赖属性发生变化时，属性的值会自动更新，相关的DOM也会同步更新

一、计算属性的getter

    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;user_inof={{ userInfo }}&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                &quot;user_name&quot;: &quot;lulu&quot;,
                &quot;user_age&quot;: &quot;20&quot;
            },
            computed: {
                // 一个计算属性getter
                userInfo: function(){
                    return &apos;姓名: &apos;+ this.user_name +&apos; 年龄: &apos;+ this.user_age;
                }
            }
        })
    &lt;/script&gt;


二、计算属性的setter

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            &quot;user_name&quot;: &quot;lulu&quot;,
            &quot;user_age&quot;: &quot;20&quot;
    },
        computed: {
            userInfo: function(){
                get: function(){
                    return &apos;姓名: &apos;+ this.user_name +&apos; 年龄: &apos;+ this.user_age;
                },
                set: function(newValue){        // 这里当
                    this.userInfo = newValue;
                }
            }
        }
    })
</code></pre><h4 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h4><pre><code>watch 侦听data下指定数据的变化 

watch:{
    message: function(newValue){
        return newValue + 1;        // 如果message变化值加1
    }
}

// 写在实例化下侦听数据变化
// vm.$watch(&apos;message&apos;, function(newVal, oldVal){
//    console.log(newVal, oldVal);
//    this.message = newVal.replace(/s|g/g, &apos;*&apos;);
// })
</code></pre><h4 id="class和style的绑定"><a href="#class和style的绑定" class="headerlink" title="class和style的绑定"></a>class和style的绑定</h4><pre><code>一、class

    // 对象
    &lt;div :class=&quot;{ &apos;active&apos;: isActive }&quot;&gt;&lt;/div&gt;
    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            isActive: true
        }
    })

    // 数组
    &lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;        // 三元 &lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;
    data: {
        activeClass: &apos;active&apos;,
        errorClass: &apos;text-danger&apos;
    }    


二、style

    &lt;div :style=&quot;[crm, hk]&quot;&gt; 或 &lt;div :style=&quot;{color: activeColor, fontSize: fontSize+&apos;px&apos;}&quot;&gt;

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            activeColor: &apos;red&apos;,
            fontSize: 30,
            crm: {
                color: &apos;#000&apos;,
                fontSize: &apos;16px&apos;
            },
            hk: {
                color: &apos;#fff&apos;,
                fontSize: &apos;18px&apos;
            }
        }
    })
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>一、@click

    &lt;div @click=&quot;say&quot;&gt;&lt;/div&gt;
    &lt;div @click=&quot;say(&apos;hi&apos;)&quot;&gt;&lt;/div&gt;
    &lt;div @click=&quot;content + 1&quot;&gt;&lt;/div&gt;


    &lt;!-- 阻止单击事件冒泡 --&gt;
    &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

    &lt;!-- 提交事件不再重载页面 --&gt;
    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

    &lt;!-- 修饰符可以串联  --&gt;
    &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

    &lt;!-- 只有修饰符 --&gt;
    &lt;form v-on:submit.prevent&gt;&lt;/form&gt;

    &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;
    &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

    &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;
    &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;

二、按键别名

    .enter、.tab、.delete (捕获 “删除” 和 “退格” 键)、.esc、.space、.up、.down、.left、.right、.ctrl、.alt、.shift、.meta

三、once: 只处理一次点击  &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;

四、修饰符 &lt;input v-on:keyup.13=&quot;submit&quot;&gt;
</code></pre><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><pre><code>Vue在底层将模板编译成虚拟DOM渲染函数，也可以不用模板直接写render函数，可选JSX语法
</code></pre><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><pre><code>一、props传值子元素不会接收

    问题1: 封装tab标签来加载不同子组件，当同一组件重新被打开时，应先消毁之前的相同组件在加载新的组件，但在子组件中destroyed()来侦听消毁缺没有回调

     // 打开新页面
    openTabPage(tabPage, cb) {
        // 先关闭存在的同名的，再打开
        if (this.pages.some(item =&gt; item.name === tabPage.name)) {
            this.handleRemove(tabPage.name);
        }
        this.$nextTick(()=&gt;{                // 使用$nextTick 进行重新渲染
            this.pages.push(tabPage);
            this.activeName = tabPage.name;
        })

        if (cb &amp;&amp; typeof cb === &apos;function&apos;) {
            cb(this.activeName)
        }

        if (this.tabCreate) {
            this.tabCreate(tabPage)
        }
    },

    问题2: 这种加了一层会对相同子组件进行消毁在重建，

        &lt;template slot=&quot;tabcreate&quot;&gt;
    &lt;create-data-config ref=&quot;createDataConfig&quot; :create-prop=&quot;createProp&quot;&gt;&lt;/create-data-config&gt;
  &lt;/template&gt;

        openTab(tabName, row){
            // this.createProp[&apos;detailInfo&apos;] = row || &apos;&apos;;            这种写法子组件watch不到createProp的变化 

            this.createProp = {
                detailInfo: row || &apos;&apos;
            }
  }

        子组件
        watch:{
            createProp: function(){
                debugger;
            }
        }


一、v-bind 内联字符串连接

    data(){
        return {
            addString: &apos;加入内容&apos;
        }
    }

    1.x版本 写法  &lt;div attr=&quot;xxxx{{addString}}&quot;&gt;

    2.x版本 写法  &lt;div v-bind=&quot;&apos;xxxx&apos;+ addString&quot;&gt;


二、checkbox动态创建绑定

    // v-model=&quot;item.check&quot; 绑定的值要相同

    &lt;p v-for=&quot;item in checkList&quot;&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;cb&quot; v-model=&quot;item.check&quot; /&gt; {{item.name}}
    &lt;/p&gt;

    data(){
        return{
            checkList:[
                {check: false, name: &apos;aa&apos;},
                {check: false, name: &apos;bb&apos;},
                {check: false, name: &apos;cc&apos;}
            ]
        }
    }

三、vue使用jxs语法

    new Vue({
        el: &apos;#demo&apos;,
        render (h) {
            return (    // 使用这种jsx语法
                &lt;AnchoredHeading level={1}&gt;
                    &lt;span&gt;Hello&lt;/span&gt; world!
                &lt;/AnchoredHeading&gt;
            )
        }
    })

    需要安装插件

    $ npm install babel-plugin-syntax-jsx babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props babel-preset-en   --save-dev

    .babelrc:
        {
            &quot;presets&quot;: [&quot;env&quot;],
            &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]
        }

    https://github.com/vuejs/babel-plugin-transform-vue-jsx


四、vue键盘事件不起作用

    @keyup.enter.native=&quot;login&quot;   如果不加.native是不起作用有
</code></pre><p>| <a href="http://www.jianshu.com/p/95b2caf7e0da" target="_blank" rel="noopener">http://www.jianshu.com/p/95b2caf7e0da</a>              // vue-cli<br>| <a href="http://cn.vuejs.org/guide/" target="_blank" rel="noopener">http://cn.vuejs.org/guide/</a>                        // Vue中文官网<br>| <a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a>                        // github<br>| <a href="http://vuefe.cn/guide/installation.html" target="_blank" rel="noopener">http://vuefe.cn/guide/installation.html</a>            // 2.0<br>| <a href="http://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">http://router.vuejs.org/zh-cn/</a>                    // vue-router2.0<br>| <a href="https://github.com/vuejs" target="_blank" rel="noopener">https://github.com/vuejs</a>                             // Vue组件列表<br>| <a href="http://www.cnblogs.com/dh-dh/p/5606596.html" target="_blank" rel="noopener">http://www.cnblogs.com/dh-dh/p/5606596.html</a>        // binding原理，vue的数据<br>| <a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">https://github.com/vuejs/awesome-vue#libraries--plugins</a><br>| <a href="http://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">http://vuex.vuejs.org/zh-cn/</a>                         // Vuex 2.0文档<br>| <a href="https://github.com/vuejs/vuex/blob/1.0/docs/zh-cn/intro.md" target="_blank" rel="noopener">https://github.com/vuejs/vuex/blob/1.0/docs/zh-cn/intro.md</a><br>| <a href="http://www.cnblogs.com/keepfool/category/845804.html" target="_blank" rel="noopener">http://www.cnblogs.com/keepfool/category/845804.html</a><br>| <a href="http://www.jianshu.com/p/f8e21d87a572" target="_blank" rel="noopener">http://www.jianshu.com/p/f8e21d87a572</a><br>| <a href="https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91</a>      // Vue代码规范<br>| <a href="https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64" target="_blank" rel="noopener">https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64</a>     源码</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/17/前端优化/">前端优化</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/17/前端优化/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-17T08:54:51.000Z" itemprop="datePublished">2016-10-17</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端优化/">前端优化</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h4><pre><code>1、减少HTTP请求: 合并图片(如css sprites，内置图片使用数据)、合并CSS、JS    

2、CDN(内容分发网络): 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定

    通过在各地放置节点服务器，CDN可以根据用户的连接距离、负载状况、响应时间等，来为用户选择一个最近的服务器

3、为文件头指定Expires或Cache-Control: 设置资源的缓存时间

4、避免空的src和href: 这两个属性的标签如link，script，img，iframe等    

5、Gzip压缩内容: 服务器对文件进行Gzip压缩，浏览器拿到资源对文件进行解压缩，来减少文件体积

6、CSS放到顶部: 在网速慢的情况会出现，DOM加载完成，没有渲染css，加载到样式的时候才进行重新渲染样式    

7、JS放到底部: 避免脚本阻塞文档的展示，document.wirte()可以阻止文档的展示

8、避免使用CSS表达式: CSS表达式的计算频率会影响前端的性能    

9、将CSS和JS使用外部文件引用: 减少请求数量、利用性、可被缓存，对代码的维护性

10、减少DNS查询: 一个网站有多域，如图片、css、js各存在不同域，这种访问的时候就会存在多域的DNS查询

    缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出IP地址，可以对DNS先进行缓存 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http//t1.we.com&quot;&gt;

11、对CSS和JS代码进行压缩合并: 目的是减少文件体积，gulp、webpack前端构建工具来进行压缩和合并    

12、避免重定向: 对搜索引擎不友好

    301: 永久重定向，访问文件A的资源的位置，服务器指向了另一个位置来找到A

    302: 临时重定向，请求文件被找到了，但不在这个位置，服务器会发给浏览器所在的位置，之后浏览器会重发取到位置的请求

13、移除重复的脚本: 

14、配置ETags: 服务器会产成一个MD5值，当请求服务器时，服务器的ETags与客户端的值相比较，如果相同说明文件没有被修改过使用缓存文件，返回304状态码

15、AJAX可缓存: jQuery有一个 cache参数，利用时间戳来绕开缓存，更精巧的实现响应可缓存与服务器数据同步更新。

        post请求不能被缓存，get可以缓存
</code></pre><h4 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h4><pre><code>1、延迟加载: 确定页面运行正常后，再加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等

2、预加载: 关注下无条件加载，有条件加载和有预期的加载

3、减少查询DOM元素个数: 使用更适合或者在语意是更贴切的标签，要考虑大量DOM元素中循环的性能开销    

4、尽量减少iframe的个数: 优点: 是脚本可以并行下载，适合加载外部广告，浏览器可以对其安全控制。  缺点: 即使内容为空，加载也需要时间，会阻止页面加载，没有语义不会被seo收录

5、减少Cookie的大小: 去除不必要的coockie，使coockie体积尽量小以减少对用户响应的影响，注意在适应级别的域名上设置coockie以便使子域名不受影响，设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间

6、使用无cookie的域: 确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容    

7、用&lt;link&gt;代替@import: 在IE中，页面底部@import和使用&lt;link&gt;作用是一样的，因此最好不要使用它    

8、避免使用滤镜: 完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。

9、优化图像: 尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush(或者其它PNG优化工具)    

10、优化CSS Spirite: 在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小

　　Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式

　　便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100×100的图片为1万像素，而1000×1000就是100万像素    

11、不要在HTML中缩放图像: 不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要: 

　　&lt;img width=&quot;100″ height=&quot;100″ src=&quot;mycat.jpg” alt=&quot;My Cat” /&gt;

　　那么你的图片(mycat.jpg)就应该是100×100像素而不是把一个500×500像素的图片缩小使用。这里在下文有更有趣的分析

12、favicon.ico 需要缓存: favicon.ico是位于服务器根目录下的一个图片文件。浏览器会对它发出请求，因此最好不要返回一 个404 Not Found的响应

13、保持单个内容小于25K: 因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要

14、避免页面的重排、重绘: 
</code></pre><h4 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h4><pre><code>1、HTML文档结构层次尽量少，最好不深于六层

2、脚本尽量后放，放在&lt;/body&gt;前即可

3、少量首屏样式内联放在标签内

4、样式结构层次尽量简单

5、在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流

6、减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画

7、动画尽量使用在绝对定位或固定定位的元素上

8、隐藏在屏幕外，或在页面滚动时，尽量停止动画

9、尽量缓存DOM查找，查找器尽量简洁

10、涉及多域名的网站，可以开启域名预解析
</code></pre><h4 id="页面中图片加载的两种效果"><a href="#页面中图片加载的两种效果" class="headerlink" title="页面中图片加载的两种效果"></a>页面中图片加载的两种效果</h4><pre><code>一种是回去加载先模糊然后清晰，另一种是很清晰但逐行加载显示，原因是他们的压缩算法不同

1、逐行加载
</code></pre><p><img src="images/逐行.png" alt="逐行"></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/17/浏览器内核/">浏览器内核</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/17/浏览器内核/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-17T08:54:51.000Z" itemprop="datePublished">2016-10-17</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/浏览器内核/">浏览器内核</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="URL到页面加载发生了什么"><a href="#URL到页面加载发生了什么" class="headerlink" title="URL到页面加载发生了什么"></a>URL到页面加载发生了什么</h4><pre><code>1、DNS解析 - 将域名转换IP的过程，先看是否有DNS缓存来找到url的IP，操作系统自身的DNS缓存，读取host文件是否域名到IP地址映射关系，如果都有没就向宽带运营商或域名服务器发起一个DNS解析请求，

2、TCP连接 - 拿到IP，浏览器向该IP所在的服务器建立TCP连接（三次握手）

3、发送HTTP请求 - 请求报名和报文  

    常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。

    报文: Content-Type: application/json。

4、服务器处理响应HTTP请求

5、浏览器解析渲染页面 - 创建DOM树、渲染DOM树、JS引擎解析、重排重绘

6、连接结束

https://zhuanlan.zhihu.com/p/24913080
https://zhuanlan.zhihu.com/p/24944905
</code></pre><h4 id="浏览器的基础结构"><a href="#浏览器的基础结构" class="headerlink" title="浏览器的基础结构"></a>浏览器的基础结构</h4><pre><code>一、浏览器基础结构主要包括如下7部分: 

    1、用户界面(User Interface): 用户所看到及与之交互的功能组件，如地址栏，返回，前进按钮等

    2、浏览器引擎(Browser engine): 负责控制和管理下一级的渲染引擎

    3、渲染引擎(Rendering engine): 负责解析用户请求的内容(如HTML或XML，渲染引擎会解析HTML或XML，以及相关CSS，然后返回解析后的内容)

    4、网络(Networking): 负责处理网络相关的事务，如HTTP请求等

    5、UI后端(UI backend): 负责绘制提示框等浏览器组件，其底层使用的是操作系统的用户接口

    6、JavaScript解释器(JavaScript interpreter): 负责解析和执行JavaScript代码

    7、数据存储(Data storage): 负责持久存储Stroage诸如cookie和缓存等应用数据
</code></pre><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><pre><code>一、大致可以分为以下几类: 

    1、Trident内核:  IE

    2、Webkit内核: Chrome,Safari

    3、Gecko内核: FireFox
</code></pre><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><pre><code>一、用户访问页面，浏览器需要获取用户的请求内容，主要涉及浏览器网络模块:

    1、用户在地址栏输入域名, DNS根据域名查找对应的ip, 并发起请求

    2、浏览器获得并解析服务器的返回内容(HTTP response)

    3、浏览器加载HTML文件及文件内包含的外部引用文件及图片，多媒体等资源

二、DNS预解析

    浏览器DNS解析大多时候较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出IP地址，

    希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的域名，如: 

    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http//t1.we.com&quot;&gt;
</code></pre><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><pre><code>浏览器加载资源一般会并行进程同时加载，限制一般在2-6个
</code></pre><h4 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h4><pre><code>一、访问一个页面执行流程

    1、发起请求        2、解析HTML        3、解析样式        4、执行JavaScript        5、布局        6、绘制


二、通过网络模块加载到HTML文件后渲染引擎渲染流程如下，这也通常被称作关键渲染路径(Critical Rendering Path):

    1、构建DOM树(DOM tree): 从上到下解析HTML文档生成DOM节点树(DOM tree), 也叫内容树(content tree)

    2、构建CSSOM(CSS Object Model)树: 加载解析样式生成CSSOM树

    3、执行JavaScript: 加载并执行JavaScript代码(包括内联代码或外联JavaScript文件)

    4、构建渲染树(render tree): 根据DOM树和CSSOM树, 生成渲染树(render tree) 渲染树: 按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性

    5、布局(layout): 根据渲染树将节点树的每一个节点布局在屏幕上的正确位置

    6、绘制(painting): 遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成


三、解析样式和脚本

    1、脚本是可能存在改变DOM结构，于是浏览器以同步方式解析，加载和执行脚本，浏览器遇到script标签就选择js代码，现在HTML5提供defer和async两个属性支持延迟和异步加载JavaScript文件

        &lt;script defer src=&quot;script.js&quot;&gt;

    2、样式不同于脚本，浏览器对样式处理并不会阻塞文档解析，因为样式不会改变DOM结构


四、重绘、重排

    尽量减少reflow:

    重排: 当页面结构发生改变，渲染树重新组装，如块级元素的（margin、padding）当前元素位置发生改变会影响下面所有元素的位置需要重排，position: absolute不会引发重排

    重绘: 就是不改变页面的结构，只改变一些颜色，如(文字颜色、边框颜色)
</code></pre><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><pre><code>一、访问域名

    访问京东域名时，会发现有Remote Address，这里是在访问域名时并不会直接访问服务器而是在中间过了一层，目的是为当前用户找到离他最近的一台服务来进行跳转，可以让最快速度来访问
</code></pre><p><img src="images/jd_ip.png" alt="jd_ip"> </p>
<p>| <a href="http://blog.codingplayboy.com/2017/03/29/webpage_render/" target="_blank" rel="noopener">http://blog.codingplayboy.com/2017/03/29/webpage_render/</a><br>| <a href="https://www.webpagetest.org/" target="_blank" rel="noopener">https://www.webpagetest.org/</a>         // 网站的性能评估</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
