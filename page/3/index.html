<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之九）Connect中间件/">nodeJS（之九）Connect中间件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之九）Connect中间件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><pre><code>Connect是HTTP服务的中间件

$ 安装 npm i connect --save


// 引用模块
var connect = require(&apos;connect&apos;);

// 创建服务器
var server = connect.createServer();

// 处理静态文件
server.use(connect.static(__dirname + &apos;/statice&apos;));     // connect.static 静态文件目录

// 监听
server.listen(3000);
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>1、静态目录设置 -  server.use(connect.static(__dirname + &apos;/statice&apos;));

2、客户端缓存时间 -  server.use(connect.static(__dirname + &apos;/statice&apos;), {maxAge: 100000});

3、静态文件以&quot;.&quot;开始都认为是隐藏文件 - server.use(connect.static(__dirname + &apos;/statice&apos;), {hidden: true});

4、query中间件，解析字符串  &apos;/posts?page=5&apos;

    server.use(connect.query);
    server.use(function(req, res){
        let page = req.query.page;
    })

5、logger，打印日志，四种日志格式，default/dev/short/tiny

    connect.createServer(
        connect.logger(&apos;dev&apos;),
        function(req, res){
            res.writeHead(200);
            res.end(&apos;hello);
        }
    )

7、body parser  文件上传
</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><pre><code>使用cookieParser()

// cookie: secret1=val1; secret2=val2

server.use(cookieParser());
server.use(function(req, res){
    let ser1 = req.cookies.secret1;
    let ser2 = req.cookies.secret2;
})
</code></pre><h4 id="session-会话"><a href="#session-会话" class="headerlink" title="session 会话"></a>session 会话</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/01/10/Sass/">Sass</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/01/10/Sass/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-01-10T10:10:21.000Z" itemprop="datePublished">2017-01-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Sass/">Sass</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>知识点</p>
<p>变量 - $声明  !default默认值  全局和局部变量<br>嵌套 - 选择器嵌套、属性嵌套、伪类嵌套<br>宏 - @mixin声明宏、@include调用宏、宏可以加参数<br>继承 - @extend来承继一个class<br>占位符 - %mt5定义，@extend来调用<br>插值 - #{}<br>函数<br>Sass规则 - @imponrt，@media<br>自定义函数 - @function 函数名<br>Sass语句 - @if、@else，@for，@while<br>运算 - +、-、*、/</p>
</blockquote>
<h4 id="关于SASS"><a href="#关于SASS" class="headerlink" title="关于SASS"></a>关于SASS</h4><pre><code>Sass是CSS预处理器定义了一种新的语言

sass的扩展名为 .sass 老版本 控制缩进不需要使用 {} 或 ;     // 类似jade

sass的扩展名为 .scss 新版本 与正常css写法相同

其它预处理:

    Sass（SCSS）
    LESS
    Stylus
    Turbine
    Swithch CSS
    CSS Cacheer
    DT CSS
</code></pre><h4 id="一、变量声明"><a href="#一、变量声明" class="headerlink" title="一、变量声明"></a>一、变量声明</h4><pre><code>1、$ 声明变量

    1）作为值使用
        $color: &apos;#ccc&apos;;
        .test{
            background-color: $color;        // 调用
        }

    2）作为属性名使用
        $side : left;
        .rounded {
            border-#{$side}-radius: 5px;    // 输出 border-left-radius: 5px
        }

2、!default 默认变量使用 

    默认值在组件中很有作用

    $baseLineHeight: 2;
    $baseLineHeight: 1.5 !default;            // 在没有定义baseLineHeight值时，执行1.5的默认值
    body{
        line-height: $baseLineHeight;    // line-hgiht: 2;
    }


3、全局变量和局布变量

    // 全局变量定义
    $color: orange !default;        
    .block {
        color: $color;
    }

    // 局部变量定义
    em {
        $color: red;
        a {
            color: $color;
        }
    }
</code></pre><h4 id="二、嵌套"><a href="#二、嵌套" class="headerlink" title="二、嵌套"></a>二、嵌套</h4><pre><code>1、选择器嵌套

    nav {
        a {
            color: red;

            header &amp; {
                color:green;
            }
        }  
    }
    输出:
        nav a { color: red; }
        header nav a { color: green; }


    nav {
        a {
            color: red;

            header &amp; {
                color:green;
            }
        }  
    }
    输出:
        .nav a { color: red }
        .header .nav a { color:green }


2、属性嵌套

    .box {
        border: {
            top: 1px solid red;
            bottom: 1px solid green;
        }
    }
    输出: .box {  border-top: 1px solid red; border-bottom: 1px solid green; }


3、伪类嵌套

    .clearfix{
        &amp;:before,
        &amp;:after {
            content:&quot;&quot;;
            display: table;
        }
        &amp;:after {
            clear:both;
            overflow: hidden;
        }
    }

    输出
    clearfix:before, .clearfix:after {
        content: &quot;&quot;;
        display: table;
    }
    .clearfix:after {
        clear: both;
        overflow: hidden;
    }
</code></pre><h4 id="三、混合宏和声明混合宏"><a href="#三、混合宏和声明混合宏" class="headerlink" title="三、混合宏和声明混合宏"></a>三、混合宏和声明混合宏</h4><pre><code>宏相当将一些属性封装到一个宏中，类似函数可重复利用

1、使用“@mixin”声明一个混合宏

    @mixin border-radius {
        -webkit-border-radius: 5px;
        border-radius: 5px;
    }

    .text { 
        @include border-radius            /* 调用宏 */
    }


2、定义带参数的宏

    @mixin border-radius($radius:5px){        // 定义一个默认值为5px
        -webkit-border-radius: $radius;
        border-radius: $radius;
    }

    .text { 
        @include border-radius(10px)         // 调用
    }


带逻辑运算符

    @mixin box-shadow($shadow...) {
        @if length($shadow) &gt;= 1 {
            @include prefixer(box-shadow, $shadow);
        } 
        @else{
            $shadow:0 0 4px rgba(0,0,0,.3);
            @include prefixer(box-shadow, $shadow);
        }
    }
</code></pre><h4 id="四、扩展和继承"><a href="#四、扩展和继承" class="headerlink" title="四、扩展和继承"></a>四、扩展和继承</h4><pre><code>继承是可以直接继承一个class类下所有的属性,

@extend .className;

.btn {
    border: 1px solid #ccc;
    padding: 6px 10px;
    font-size: 14px;
}

.btn-primary {
    background-color: #f36;
    color: #fff;
    @extend .btn;
}

.btn-primary-2 {
    background-color: #f36;
    color: #fff;
    font-size: 16px;
    @extend .btn;
}


结果:
.btn, .btn-primary, .btn-primary-2 {
    border: 1px solid #ccc;
    padding: 6px 10px;
    font-size: 14px; 
}

.btn-primary {
    background-color: #f36;
    color: #fff; 
}

.btn-primary-2 {
    background-color: #f36;
    color: #fff;
    font-size: 16px; 
}
</code></pre><h4 id="五、占位符"><a href="#五、占位符" class="headerlink" title="五、占位符"></a>五、占位符</h4><pre><code>定义占位符 %名称 , 调用使用@extend

%mt5 {
    margin-top: 5px;
}
%pt5{
    padding-top: 5px;
}

.btn {
    @extend %mt5;
    @extend %pt5;
}
.block {
    @extend %mt5;

    span {
        @extend %pt5;
    }
}

结果
.btn, .block {
    margin-top: 5px; 
}
.btn, .block span {
    padding-top: 5px; 
}
</code></pre><h4 id="六、插值"><a href="#六、插值" class="headerlink" title="六、插值#{}"></a>六、插值#{}</h4><pre><code>可以将变量与属性结合

$properties: (margin, padding);
@mixin set-value($side, $value) {
    @each $prop in $properties {
        #{$prop}-#{$side}: $value;
    }
}
.login-box {
    @include set-value(top, 14px);
}

结果：
.login-box {
    margin-top: 14px;
    padding-top: 14px;
}
</code></pre><h4 id="七、注释"><a href="#七、注释" class="headerlink" title="七、注释"></a>七、注释</h4><pre><code>// 不会被显示到代码中

/* */  显示到代码中
</code></pre><h4 id="八、数据类型"><a href="#八、数据类型" class="headerlink" title="八、数据类型"></a>八、数据类型</h4><pre><code>1、数字: 如，1、 2、 13、 10px；

2、字符串：有引号字符串或无引号字符串，如，&quot;foo&quot;、 &apos;bar&apos;、 baz；

3、颜色：如，blue、 #04a3f9、 rgba(255,0,0,0.5)；

4、布尔型：如，true、 false；

5、空值：如，null；

6、值列表：用空格或者逗号分开，如，1.5em 1em 0 2em 、 Helvetica, Arial, sans-serif。
</code></pre><h4 id="九、函数"><a href="#九、函数" class="headerlink" title="九、函数"></a>九、函数</h4><pre><code>1、字符串函数

    1）unquote(str): 删除字符串中的引号

    2) quote(str): 给字符添加引号

        .test1 {
            content:  unquote(&apos;Hello Sass!&apos;) ;        // 输出 content: Hello Sass
        }

        .test3 {
            content: quote(ImWebDesigner);        // 输出 content: &apos;ImWebDesigner&apos;;
        }

    3）to-upper-case(): 转大写

    4）to-lower-case(): 转小写


2、数字函数

    1）percentage($value)：将一个不带单位的数转换成百分比值；

        .footer{  width : percentage(5px / 10px)  }      // width: 50%

    2）round($value)：将数值四舍五入，转换成一个最接近的整数；

    3）ceil($value)：将大于自己的小数转换成下一位整数；

    4）floor($value)：将一个数去除他的小数部分；

    5）abs($value)：返回一个数的绝对值；

    6）min($numbers…)：找出几个数值之间的最小值；

    7）max($numbers…)：找出几个数值之间的最大值；

    8）random(): 获取随机数


3、列表函数

    1) nth函数（nth function） 可以直接访问值列表中的某一项；

    2) join函数（join function） 可以将多个值列表连结在一起；

    3) append函数（append function） 可以在值列表中添加值； 

    4) @each规则（@each rule） 则能够给值列表中的每个项目添加样式。


4、判断函数类型

    1) type-of($value)：返回一个值的类型

    2) unit($number)：返回一个值的单位

    3) unitless($number)：判断一个值是否带有单位

    4) comparable($number-1, $number-2)：判断两个值是否可以做加、减和合并


5、unitless(): 用来判断一个值是否带有单位，如果不带单位返回的值为 true，带单位返回的值为 false

    @mixin adjust-location($x, $y) {
        @if unitless($x) {    
            $x: 1px * $x;
        }
        @if unitless($y) {    
            $y: 1px * $y;
        }
        position: relative; 
        left: $x; 
        top: $y;
    }

    .botton{
        @include adjust-location(20px, 30);
    }


6、comparable(): 用来判断两个数是否可以进行“加，减”以及“合并”, 返回true/false

     comparable(2px,1rem)


7、三元函数: if(true,8em,20em);        // 第一个参数为


8、map 在Sass中，maps代表一种数据类型，可以包含若干键值对的对象类型

    创建一个map数据:

        $color: (
            default: #fff,
            primary: #222,
            negative: #333
        );        // 注意必须加 “;” 号 

        .box {
            color: map-get($color, default);
        }


    获取map数据的函数:

    1) map-get($map,$key)：根据给定的 key 值，返回 map 中相关的值。

    2) map-merge($map1,$map2)：将两个 map 合并成一个新的 map。

    3) map-remove($map,$key)：从 map 中删除一个 key，返回一个新 map。

    4) map-keys($map)：返回 map 中所有的 key。

    5) map-values($map)：返回 map 中所有的 value。

    6) map-has-key($map,$key)：根据给定的 key 值判断 map 是否有对应的 value 值，如果有返回 true，否则返回 false。

        @function colors($color){
            @if not map-has-key($social-colors,$color){
                @warn &quot;No color found for `#{$color}` in $social-colors map. Property omitted.&quot;;
            }
            @return map-get($social-colors,$color);
        }

    7) keywords($args)：返回一个函数的参数，这个参数可以动态的设置 key 和 value。


9、REG

    rgb($red,$green,$blue)：根据红、绿、蓝三个值创建一个颜色；

    rgba($red,$green,$blue,$alpha)：根据红、绿、蓝和透明度值创建一个颜色；

    red($color)：从一个颜色中获取其中红色值；

    green($color)：从一个颜色中获取其中绿色值；

    blue($color)：从一个颜色中获取其中蓝色值；

    mix($color-1,$color-2,[$weight])：把两种颜色混合在一起。
</code></pre><h4 id="十、Sass规则"><a href="#十、Sass规则" class="headerlink" title="十、Sass规则"></a>十、Sass规则</h4><pre><code>1、@import: 用于引用scss或sass文件

2、@media: 媒体查询功能

    .sidebar {
        width: 300px;
        @media screen and (orientation: landscape) {
            width: 500px;
        }
    }

    输出:
    .sidebar {
        width: 300px; 
    }
    @media screen and (orientation: landscape) {
        .sidebar {
            width: 500px; 
        }
    }
</code></pre><h4 id="十一、自定义函数"><a href="#十一、自定义函数" class="headerlink" title="十一、自定义函数"></a>十一、自定义函数</h4><pre><code>SASS允许用户编写自己的函数。

// 定义函数
</code></pre><p>　　@function double($n) {<br>　　　　@return $n * 2;<br>　　}</p>
<pre><code>// 调用函数
</code></pre><p>　　#sidebar {<br>　　　　width: double(5px);<br>　　}</p>
<h4 id="十二、高级语句"><a href="#十二、高级语句" class="headerlink" title="十二、高级语句"></a>十二、高级语句</h4><pre><code>1、条件语句

    @if lightness($color) &gt; 30% {
　　　　background-color: #000;
　　} 
    @else {
　　　　background-color: #fff;
　　}


2、循环语句

    @for $i from 1 to 10 {
　　　　.border-#{$i} {
　　　　　　border: #{$i}px solid blue;
　　　　}
　　}


　　$i: 6;
　　@while $i &gt; 0 {
　　　　.item-#{$i} { width: 2em * $i; }
　　　　$i: $i - 2;
　　}


    $list: adam john wynn mason kuroir;        //$list 就是一个列表
    @mixin author-images {
        @each $author in $list {
            .photo-#{$author} {
                background: url(&quot;/images/avatars/#{$author}.png&quot;) no-repeat;
            }
        }
    }
</code></pre><h4 id="十三、运算"><a href="#十三、运算" class="headerlink" title="十三、运算"></a>十三、运算</h4><pre><code>+、-、*、/

$container: 960px;
$sidebar-width: 220px;
$gap-width: 20px;
.content{
    width: $container - $sidebar-width;
    float: left;
}

结果:
.content {
    width: 740px;
    float: left; 
}

颜色计算
p {
    color: #010203 + #040506;
}
</code></pre><h4 id="十四、Sass的目录结构"><a href="#十四、Sass的目录结构" class="headerlink" title="十四、Sass的目录结构"></a>十四、Sass的目录结构</h4><p>  sass/<br>    |<br>    |– base/<br>    |   |– reset.scss       # Reset/normalize<br>    |   |– typography.scss  # Typography rules<br>    |   …                  # Etc…<br>    |<br>    |– components/<br>    |   |– buttons.scss     # Buttons<br>    |   |– carousel.scss    # Carousel<br>    |   |– cover.scss       # Cover<br>    |   |– dropdown.scss    # Dropdown<br>    |   |– navigation.scss  # Navigation<br>    |   …                  # Etc…<br>    |<br>    |– helpers/<br>    |   |– functions.scss   # Sass Functions<br>    |   |– mixins.scss      # Sass Mixins<br>    |   |– helpers.scss     # Class &amp; placeholders helpers<br>    |   …                  # Etc…<br>    |<br>    |– layout/<br>    |   |– grid.scss        # Grid system<br>    |   |– header.scss      # Header<br>    |   |– footer.scss      # Footer<br>    |   |– sidebar.scss     # Sidebar<br>    |   |– forms.scss       # Forms<br>    |   …                  # Etc…<br>    |<br>    |– pages/<br>    |   |– home.scss        # Home specific styles<br>    |   |– contact.scss     # Contact specific styles<br>    |   …                  # Etc…<br>    |<br>    |– themes/<br>    |   |– theme.scss       # Default theme<br>    |   |– admin.scss       # Admin theme<br>    |   …                  # Etc…<br>    |<br>    |– vendors/<br>    |   |– bootstrap.scss   # Bootstrap<br>    |   |– jquery-ui.scss   # jQuery UI<br>    |   …                  # Etc…<br>    |<br>    |- variables.scss   # 存储Sass变量文件<br>    |<br>    `– main.scss             # primary Sass file </p>
<blockquote>
<p>参考资料</p>
<p><a href="http://www.w3cplus.com/preprocessor/organize-that-sass.html" target="_blank" rel="noopener">http://www.w3cplus.com/preprocessor/organize-that-sass.html</a>                  # 组织Sass文件<br><a href="http://www.w3cplus.com/preprocessor/architecture-sass-project.html" target="_blank" rel="noopener">http://www.w3cplus.com/preprocessor/architecture-sass-project.html</a>        # SASS的目录结构<br><a href="http://www.w3cplus.com/blog/tags/302.html" target="_blank" rel="noopener">http://www.w3cplus.com/blog/tags/302.html</a>             </p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/01/10/nodeJS基础用法/">nodeJS基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/01/10/nodeJS基础用法/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-01-10T10:10:21.000Z" itemprop="datePublished">2017-01-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| nodeJS<br>|<br>| buffer: 处理二进制, 对字符串与二进制进行转换 (done)<br>| fs: 文件系统操作 (done)<br>| http: 处理http请求, 创建服务器, 和处理客户端与服务器之间的数据传递request、response (done)<br>| stream: 文件流<br>| path: 文件路径的处理 (done)<br>| URL: 网络地址解析 (done)<br>| querystring: URL查询字符串 (done)<br>| Cookie、Session、Token (done)<br>| event: 事件机制<br>|<br>| DNS: 域名解析<br>| net: TCP网络<br>| dgram: UDP网络<br>| crypto: 数据加密<br>| process: 进程<br>| childe_process: 子进程<br>| cluster: 集群<br>| global: 全局<br>|<br>| Express<br>| Template 模板 jade、<br>| Mysql (done)<br>| MongoDB<br>| redis<br>| RESTful 架构<br>| </p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>优点:
    前端的局限性，可以对文件、进程、数据库等进操作，是一门纯后端
    处理高并发  程序异步执行不会阻塞

缺点: nodejs是单线程

1、nodeJS安装，mac或windows系统需要到官网下载安装包，自带npm包管理器

2、安装express框架：npm install -g express

        $ express       // 执行命令

3、更新node版本

    node需要下载一个n模块，是用来专门管理nodejs的版本

    1、npm install -g n             # 安装n模块

    2、n stable                    # 升级到稳定版，也可以指定版本号 n v0.10.26


4、其它命令

    npm -v                  # 显示版本，检查npm 是否正确安装。

    npm install express      # 安装express模块

    npm install -g express  # 全局安装express模块

    npm list                 # 列出已安装模块

    npm show express         # 显示模块详情

    npm update                # 升级当前目录下的项目的所有模块

    npm update express        # 升级当前目录下的项目的指定模块

    npm update -g express      # 升级全局安装的express模块

    npm uninstall express      # 删除指定的模块
</code></pre><h4 id="NPM与包"><a href="#NPM与包" class="headerlink" title="NPM与包"></a>NPM与包</h4><pre><code>NodeJS以CommonJS的包规范来制订，由包结构和包描述文件两部分组件

1、包结构

    npm 下载完包存储到 node_modules 目录中，包含:

    1）package.json: 包描述

    2）bin: 存放可执行的二进制文件

    3）lib: 存储javascript代码目录

    4）doc: 用于存放文档的目录

    5）test: 存放单元测试用例代码
</code></pre><h4 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h4><pre><code>Node采用了Google的V8引擎，作为javascript语言的解释器，Node是基于事件驱动和异步I/O的服务器环境

1、JS与node的区别

    1）JS中顶层对象是 window，nodeJS中的顶层对象是 global

    2）JS中 var a = 10; window.a; 可以访问到，但在node中global.a是访问不到的，因为node有模块的概念

        node中一个文件就是珍上模块，每个模块有自己的作用域

2、REPL环境

    在命令行输入node, 可以直接运行node命令
</code></pre><h4 id="模块系统-require、exports"><a href="#模块系统-require、exports" class="headerlink" title="模块系统 require、exports"></a>模块系统 require、exports</h4><pre><code>1、模块分为

    模块加载：require(&apos;2.js&apos;);

    1）内置模块:  var fs = require(&apos;fs&apos;);        // 加载Node的内置模块 fs文件系统

    2）文件模块: 自己定义的业务模块

        定义一个food.common.js

        var food = reuqire(&apos;./js/food.common&apos;);        // 加载业务模块

    3）加载第三方模块

        require(&apos;./2&apos;);        // 先按照加载的模块文件进行查找，如果没有找到会在文件名加上.js


2、绝对和相对路径

    var fs = require(&apos;fs&apos;);        // 绝对路径，是在Node通过内部的node_modules查找到的模块

    var moduleA = reuqire(&apos;./lib/moduleA&apos;);        // 相对路径


2、npm 全局安装和局部安装

    1）全局安装会安装到Node目录中，各项目都可以使用 npm install -g gulp

    2）局部安装，将一个模块安装到node_modules中，只在当前和子目录中使用


3、模块化

    module和exports两个全局变量

    1）module：每个模块下都包括module对象

        Module {
            id: &apos;.&apos;,
            exports: {},
            parent: null,
            filename: &apos;/Users/apple/siguang.liu/nodeProject/server.js&apos;,
            loaded: false,
            children: [],
            paths: [
                &apos;/Users/apple/siguang.liu/nodeProject/node_modules&apos;,
                &apos;/Users/apple/siguang.liu/node_modules&apos;,
                &apos;/Users/apple/node_modules&apos;,
                &apos;/Users/node_modules&apos;,
                &apos;/node_modules&apos;
            ]
         }

     2）exports外部接口，通过require就可以调用这个接口

         其实exports就是module.exports的引用

        exports.name = &apos;siguang&apos;;
        exports.getPrivate = function(){
            return &apos;haha&apos;;
        }
</code></pre><h4 id="事件-EventEmitter"><a href="#事件-EventEmitter" class="headerlink" title="事件 EventEmitter"></a>事件 EventEmitter</h4><pre><code>var EventEmitter = require(&apos;events&apos;).EventEmitter,
    a = new EventEmitter;

a.on(&apos;event&apos;, function(){
    console.log(&apos;event called&apos;);
})
a.emit(&apos;event&apos;);
</code></pre><p>—————————- Node API 文档 —————————-</p>
<h4 id="process-进程对象"><a href="#process-进程对象" class="headerlink" title="process 进程对象"></a>process 进程对象</h4><pre><code>1、pid：进程id，也就是进程名

2、kill(pid)：杀掉进程

3、nextTick(callback): 会在第一次事件环中最末尾执行，setTimeout和setImmediate属于第二事件环

    console.log(&apos;开始&apos;);

    setImmediate(function(){
        console.log(&apos;setImmediate&apos;)
    });

    setTimeout(function(){
        console.log(&apos;setTimeout&apos;);
    }, 0);

    process.nextTick(function(){
        console.log(&apos;nextTick&apos;);
    })

    console.log(&apos;结束&apos;);


    output:

        ---------------  第一次 ----------------
        开始
        结束
        nextTick

        ---------------  第二次 ----------------
        setTimeout
        setImmediate
</code></pre><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><pre><code>传输控制协议TCP是一个面向连接的协议，保证两台计算机之间数据传输的可靠性和顺序

它可以将数据从一台计算机完整有序的传到另一台计算机，http模块就是继承了net（TCP）模块

var net = require(&apos;net&apos;);        // 引用TCP模块

telnet系统嵌套的客户端，端口23, 用来连接服务器

退出TCP连接 alt+[, 退出telnet quit命令
</code></pre><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><pre><code>基于HTTP服务器的工具, 提供新的组织代码的方式来与请求响应对象进行交互，称为中间件

引用模块 var connect = require(&apos;connect&apos;);

connect作用: 

    1、托管静态文件

    2、处理错误及不存在的url

    3、处理不同类型的请求
</code></pre><h4 id="utils-工具"><a href="#utils-工具" class="headerlink" title="utils 工具"></a>utils 工具</h4><pre><code>var utils = reuqire(&apos;utils&apos;);
</code></pre><h4 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h4><pre><code>EventEmitter 类

var EventEmitter = require(&apos;events&apos;);
var emitter = new EventEmitter();

1、addListener(event, listener): 创建事件，客户端通过事件来调用，而服务端通过代码来调用事件侦听

       on(event, listener):

       //  addListener 事件
    var EventEmitter = require(&apos;events&apos;).EventEmitter;
    var emitter = new EventEmitter();

    emitter.addListener(&apos;some_events&apos;, function(foo, bar){
        console.log(foo, bar);
    })

    emitter.emit(&apos;some_events&apos;, &apos;helloA&apos;, &apos;world&apos;);         // helloA world
    emitter.emit(&apos;some_events&apos;, &apos;helloB&apos;, &apos;world&apos;);         // helloB world


    // on 可以
    emitter.on(&apos;message&apos;, function(mes, name, age){
        console.log(mes +&quot; name:&quot;+ name +&quot; age:&quot;+ age);
    })

    emitter.emit(&apos;message&apos;, &apos;消息1&apos;, &apos;siguang&apos;, &apos;32&apos;);       // 消息1 name:siguang age:32
    emitter.emit(&apos;message&apos;, &apos;消息2&apos;, &apos;lulu&apos;, &apos;30&apos;);          // 消息2 name:lulu age:30


2、once()：只执行一次

    emitter.once(&apos;onceEvent&apos;, function(age){
        console.log(age);
    })

    emitter.emit(&apos;onceEvent&apos;, &apos;1&apos;);        // 只执行此次事件
    emitter.emit(&apos;onceEvent&apos;, &apos;2&apos;);
    emitter.emit(&apos;onceEvent&apos;, &apos;3&apos;);


3、removeListener(): 删除listener

4、removeAllListeners(): 删除所有

5、setMaxListeners(num): 正常事件的个数为10个, 如果超出通过此方法来改变限制的个数

6、setMaxListeners(): 每个emitter实例的最大监听数

7、listeners(event): 返回指琮事件的数组

8、emit(事件名, 参数): 执行事件

9、listenerCount(emitter, event): 返回事件个数
</code></pre><h4 id="cookie-和-Session"><a href="#cookie-和-Session" class="headerlink" title="cookie 和 Session"></a>cookie 和 Session</h4><pre><code>https://cnodejs.org/topic/55f8d70a20d84f3d377582a3

1、cookie和session的区别

    cookie存放在客户端 session存放到服务器上

    cookie不安全，客户端可以修改, session不会被修改

    session会保存在一定时间内保存在服务器端, 当访问增多, 会影响性能


2、cookie

    存储到客户端的信息

3、session

    # npm install express-session --save       // 安装

    session原理

        1）服务器端有一个对象专门存session的对象或库 如sessions={};

        2）通过req.session.sign来检查是否为已登录状态

        3）如果没有登录，第一次访问会生成一个sid，Date.now()+Math.random(); 将sid存储到sessions中

        4）把这个sid发送到浏览器端, 通过请求头中会有一个set-cookie, 将session中存到cookie中

            set-cookie:connect.sid=s%3AjDb0ns6Ekas3I7ll3tm9Bxg_wd4WjBJY.wL8VyIWdHQNFWt%2ByE%2BjAV30r4M7ZQdVIXgeKBOzx5iY; Path=/; Expires=Fri, 25 Nov 2016 03:27:38 GMT; HttpOnly

            HttpOnly 不能读不能写


    session(options): 选项内容

        1）name: session名称，设置cookie中，默认为connect.sid

        2）stroe: session存储方式，默认存在内存中，也可以存储到redis、mongodb

        3）secret: 通过设置secret字符串，来计算hash值并放在cookie产生的signedCookie防篡改

        4) cookie: 存放session id 的cookie

        5) genid: 产生一个新的session_id时，所使用的函数，默认使用uid2这个npm包

        6）rolling: 每个请求都重新设置一个cookie

        7）resave: 即使session没有被修改也保存session值

        8）saveUnintialized: 保存新创建但未修改的session


    示例:

        router.get(&apos;/&apos;, function (req, res) {

            if (req.session.sign) { // 检查用户是否已经登录
                console.log(req.session);//打印session的值
                res.send(&apos;welecome &lt;strong&gt;&apos; + req.session.name + &apos;&lt;/strong&gt;, 欢迎你再次登录&apos;);
            }
            else {      // 否则展示index页面
                req.session.sign = true;
                req.session.name = &apos;haha&apos;;
                res.end(&apos;欢迎登陆！&apos;);
            }

        });
</code></pre><h4 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h4><pre><code>轮循: 隔多长时间ajax发一次请求, 不间隔的去发

长轮循: 隔多长时间ajax发一次请求，接到结果后在发出下一次请求


webScoket: 长连接，浏览器和服务器只需要一次握手，浏览器就和服务器形成一个快速通道，两者之间相互传送数据

    1、节省资源: Header只有2 Bytes，1字节8位   1kb = 1024 bytes

    2、推送消息: 不需要客户端发请求


1、安装

    # npm install ws

2、socket.io库

    Socket.IO是websocket库，包括客户端的js和服务器端的nodejs，目标是构建可以在不同浏览器和移动设备上使用实时应用.

    # npm install socket.io


    https://www.zhihu.com/question/20831000         // scoketIO最大连接数和并发数
</code></pre><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>1、同步方法 try catch

2、异步 判断回调函数error对象

3、流里判断错误，监听error事件

    rs.on(&apos;error&apos;, function(error){
        console.log(error);
    })
</code></pre><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><pre><code>content-type 的一些参数值: http://blog.csdn.net/blueheart20/article/details/45174399

request请求头: 客户端请求服务器的请求头

    1、host: 主机地址

    2、connection: 客户端与服务器的连接选项

    3、accept: 服务器处理内容的优先级, q是权重 0-1之间范围

    4、user-agent: 用户代理，发送浏览器的硬件、系统等信息, 可以通过些选择来收集用户的pc端还是moblie端访问的多少

    5、accept-encoding: 告诉服务器所支持的编码

    6、accept-language: 告诉服务器所使用的语言, 用于判断中文站还是英文站


response响应: 服务器向客户端响应

    1、statusCode: 状态码

    2、resonPhrase: 状态码描述

    3、headers: 响应头信息

        1) content-Type: 内容类型

        2) location: 重定向url

        3) content-disposition: 下载文件名

        4) content-length: 响应内容的字节数

        5) set-cookie: 写入客户端cookie

        6) content-encoding: 响应内容编码

        7) cache-Control: 缓存

        8) Expires: 指定缓存过期时间

        9) Etag: 服务器响应内容没有变化重新下载数据

        10) connection: 默认keep-alive 保持连接，断开使用close
</code></pre><blockquote>
<p>参考资料</p>
<p><a href="https://thinkjs.org/" target="_blank" rel="noopener">https://thinkjs.org/</a><br><a href="https://chyingp.gitbooks.io/nodejs/content/%E8%BF%9B%E9%98%B6/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%88%90datauri.html" target="_blank" rel="noopener">https://chyingp.gitbooks.io/nodejs/content/%E8%BF%9B%E9%98%B6/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%88%90datauri.html</a>    ***<br><a href="http://nodeapi.ucdok.com/api/" target="_blank" rel="noopener">http://nodeapi.ucdok.com/api/</a>                    // API中文文档<br><a href="https://github.com/wangxueliang/node-api/blob/master/doc/fs.md" target="_blank" rel="noopener">https://github.com/wangxueliang/node-api/blob/master/doc/fs.md</a>   API中文部分<br><a href="https://nodejs.xiangfa.org/documentation/" target="_blank" rel="noopener">https://nodejs.xiangfa.org/documentation/</a>        // API中文文档<br><a href="https://cnodejs.org/getstart" target="_blank" rel="noopener">https://cnodejs.org/getstart</a>                     // node入门<br><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="noopener">http://nqdeng.github.io/7-days-nodejs/</a><br><a href="http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb" target="_blank" rel="noopener">http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb</a><br><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="noopener">http://nqdeng.github.io/7-days-nodejs/</a>        // 7天会Node<br><a href="https://www.gitbook.com/@chyingp" target="_blank" rel="noopener">https://www.gitbook.com/@chyingp</a><br><a href="http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb" target="_blank" rel="noopener">http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb</a><br><a href="https://cnodejs.org/topic/56ef3edd532839c33a99d00e" target="_blank" rel="noopener">https://cnodejs.org/topic/56ef3edd532839c33a99d00e</a><br><a href="https://github.com/leizongmin/node123" target="_blank" rel="noopener">https://github.com/leizongmin/node123</a>        // 资料导航</p>
<p>Express框架</p>
<p><a href="http://www.expressjs.com.cn/starter/hello-world.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/starter/hello-world.html</a><br><a href="https://github.com/expressjs?page=2" target="_blank" rel="noopener">https://github.com/expressjs?page=2</a>        express下的插件<br><a href="https://github.com/nodejs" target="_blank" rel="noopener">https://github.com/nodejs</a>     nodeJS插件</p>
</blockquote>
<p>插件:</p>
<p><a href="http://node.zhufengpeixun.cn/" target="_blank" rel="noopener">http://node.zhufengpeixun.cn/</a><br><a href="https://github.com/node-modules?page=1" target="_blank" rel="noopener">https://github.com/node-modules?page=1</a></p>
<p><a href="https://github.com/keepfool/node-lessons" target="_blank" rel="noopener">https://github.com/keepfool/node-lessons</a></p>
<p>1、cookie: <a href="https://github.com/expressjs/cookie-parser" target="_blank" rel="noopener">https://github.com/expressjs/cookie-parser</a>    // cookie-parser  </p>
<pre><code>http://www.cnblogs.com/coolicer/p/4191548.html
</code></pre><p>2、express-session: session的处理</p>
<p>3、cookie、sesssion加密的包 cookie-signature:    <a href="https://github.com/visionmedia/node-cookie-signature" target="_blank" rel="noopener">https://github.com/visionmedia/node-cookie-signature</a></p>
<pre><code>https://segmentfault.com/q/1010000000392851
</code></pre><p>4、token: express-jwt         <a href="https://www.npmjs.com/package/express-jwt" target="_blank" rel="noopener">https://www.npmjs.com/package/express-jwt</a></p>
<pre><code>http://ninghao.net/blog/2834
</code></pre><p>5、socket.io:  npm install socket.io             <a href="https://github.com/socketio/socket.io" target="_blank" rel="noopener">https://github.com/socketio/socket.io</a></p>
<p>2、mysql: <a href="https://www.npmjs.com/package/mysql" target="_blank" rel="noopener">https://www.npmjs.com/package/mysql</a>         // 连接和处理mysql</p>
<p>3、ws安装socket/IO服务包: npm install ws</p>
<p>4、mime:  <a href="https://github.com/broofa/node-mime" target="_blank" rel="noopener">https://github.com/broofa/node-mime</a>        // 响应css、js文件的请求</p>
<pre><code>http://blog.csdn.net/zgljl2012/article/details/44700953
</code></pre><p>5、body-parser: <a href="https://github.com/expressjs/body-parser" target="_blank" rel="noopener">https://github.com/expressjs/body-parser</a>  // json  </p>
<pre><code>https://segmentfault.com/a/1190000003061925
</code></pre><p>6、superagent: <a href="http://visionmedia.github.io/superagent/" target="_blank" rel="noopener">http://visionmedia.github.io/superagent/</a></p>
<pre><code>http://www.codesec.net/view/183926.html
</code></pre><p>7、node-images:  <a href="https://github.com/zhangyuanwei/node-images" target="_blank" rel="noopener">https://github.com/zhangyuanwei/node-images</a>     // 图片转换</p>
<p>8、node-xlsx: <a href="https://github.com/mgcrea/node-xlsx" target="_blank" rel="noopener">https://github.com/mgcrea/node-xlsx</a>      // 处理xlsx文件</p>
<p>9、multer: <a href="https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md" target="_blank" rel="noopener">https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md</a>    // 处理文件上传</p>
<pre><code>req.body存储表单内容

req.file存储上传控制的内容

multer({dest: &apos;./public/upfile&apos;});    设置图片文件存储的路径

upload.single(&apos;sendUpfile&apos;);        // 上传单个文件 file的name=&quot;sendUpfile&quot;
</code></pre><p>11、multiparty 文件上传: <a href="https://github.com/expressjs/node-multiparty" target="_blank" rel="noopener">https://github.com/expressjs/node-multiparty</a></p>
<p>10、formidable: <a href="https://cnodejs.org/topic/4f5c62932373009b5c0b027b" target="_blank" rel="noopener">https://cnodejs.org/topic/4f5c62932373009b5c0b027b</a> // 文件上传</p>
<p>11、up工具用于重启服务器, 每次代码修改不需要重启服务器，通过up来完成</p>
<pre><code>安装 sudo npm install up -g

运行 到项目目录 up -watch -port 8080 server.js
</code></pre><p>模板:</p>
<p>1、handlebars  <a href="http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html</a></p>
<pre><code>http://www.ghostchina.com/introducing-the-handlebars-js-templating-engine/
hbs:  http://www.cnblogs.com/chyingp/p/hbs-getting-started.html
</code></pre><p>1、Jade</p>
<p>2、ejs</p>
<p>3、Haml</p>
<p>4、CoffeeKup</p>
<p>MD5 JS <a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5</a></p>
<p>HTML5  new FormData()   <a href="http://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html" target="_blank" rel="noopener">http://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/01/10/Less/">Less</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/01/10/Less/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-01-10T10:10:21.000Z" itemprop="datePublished">2017-01-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Less/">Less</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h4><pre><code>@nice: #5b83ad
@light-blue: @nice + #111;

#header {
    background-color: @nice;
}
</code></pre><h4 id="二、混合"><a href="#二、混合" class="headerlink" title="二、混合"></a>二、混合</h4><pre><code>定义一个类的样式

示例1：
    .bordered {
        border-top: 1px black solid;
        border-bottom: 1px black solid;
    }

    加载到#menu a内
    #menu a {
      color: #111;
      .bordered;
    }

    .post a {
      color: red;
      .bordered;
    }


示例2：混合带参数
    .border-radius(@values) {
          -webkit-border-radius: @values;
        -moz-border-radius: @values;
        border-radius: @values;
    }

    .box-radius{ width: @filler; heigth: 30px; border: 1px #ccc solid; .border-radius(4px) }


示例3：
    .a, #b {
        color: red;
    }
    .mixin-class {
        .a();
    }

    输出：
    .a, #b {
        color: red;
    }
    .mixin-class {
        color: red;
    }


示例4：
    .my-mixin {
        color: black;
    }
    .my-other-mixin() {
        background: white;
    }
    .class {
        .my-mixin;
        .my-other-mixin;
    }

    输出：
    .my-mixin {
        color: black;
    }
    .class {
        color: black;
        background: white;
    }
</code></pre><h4 id="三、嵌套"><a href="#三、嵌套" class="headerlink" title="三、嵌套"></a>三、嵌套</h4><pre><code>示例1：

    #header{
        color: black;

        .navigation {
            font-size: 12px;
        }
    }

    output：

        #header {
            color: black;
        }
        #header .navigation {
            font-size: 12px;
    }

示例2：a 的 hover

    .box {
        a {
            color: red;
            $:hover {
                color: green;
            }
        }
    }

    output:
    .box a { color: red; }
    .box a:hover { color: green; }


示例3：arguments 可以将所有参数显示到值中

    .border-arg(@width, @color, @style){
        border: @arguments;            // 这里使用@arguments就相当于 @width @color @style
    }
</code></pre><h4 id="四、运算"><a href="#四、运算" class="headerlink" title="四、运算"></a>四、运算</h4><pre><code>@base: 5%;
@filler: @base * 2;
.boxA { width: @filler; height: 20px; background-color: #c3c3c3; }
</code></pre><h4 id="五、匹配模式"><a href="#五、匹配模式" class="headerlink" title="五、匹配模式"></a>五、匹配模式</h4><pre><code>// 设置匹配
.trangle(top, @width, @color){
    border-width: @width; 
    border-color: transparent transparent @color transparent;
    border-style: dashed dashed solid dashed
}

.trangle(left, @width, @color){
    border-width: @width; 
    border-color: transparent @color transparent transparent;
    border-style: dashed dashed solid dashed
}

.trangle(right, @width, @color){
    border-width: @width; 
    border-color: transparent transparent transparent @color;
    border-style: dashed dashed solid dashed
}

.trangle(bottom, @width, @color){
    border-width: @width; 
    border-color: @color transparent transparent transparent;
    border-style: dashed dashed solid dashed
}

/* 匹配模式 */
.trangleL {
    width: 0; height: 0; overflow: hidden;
    .trangle(right, 18px, red)        /* 这里调用的right 就是右三角 */
}
&lt;div class=&quot;trangleL&quot;&gt;&lt;/div&gt;
</code></pre><h4 id="六、作用域-Scope"><a href="#六、作用域-Scope" class="headerlink" title="六、作用域 Scope"></a>六、作用域 Scope</h4><pre><code>@var: red;
#page {
    @var: white;
    #header {
        color: @var; // white
    }
}

编译后：
#page .header {
    color: white;
}
</code></pre><h4 id="七、注释"><a href="#七、注释" class="headerlink" title="七、注释"></a>七、注释</h4><pre><code>/* */    会被编译，输出会显示注释
//         不会被编译，输出不会显示注释
</code></pre><h4 id="八、importe"><a href="#八、importe" class="headerlink" title="八、importe"></a>八、importe</h4><pre><code>导入less文件： @import &apos;libary&apos;;        不用加.less
导入css文件：     @import &apos;typo.css&apos;;    
</code></pre><h4 id="九、url"><a href="#九、url" class="headerlink" title="九、url"></a>九、url</h4><pre><code>@images: &quot;../img&quot;;

// 用法
body {
    color: #444;
    background: url(&quot;@{images}/white-sand.png&quot;);
}
</code></pre><h4 id="十、循环"><a href="#十、循环" class="headerlink" title="十、循环"></a>十、循环</h4><pre><code>.loop(@counter) when (@counter &gt; 0) {        // 循环使用 定义函数名(参数) when (条件）
    .loop((@counter - 1));        // 每一次减1
    width: (10px * @counter);     // code for each iteration
}
div {
    .loop(3); // launch the loop
}

output:
div {
    width: 10px;
    width: 20px;
    width: 30px;
}
</code></pre><h4 id="十一、合并"><a href="#十一、合并" class="headerlink" title="十一、合并"></a>十一、合并</h4><pre><code>.mixin() {
    box-shadow+: inset 0 0 10px #555;
}
.myclass {
    .mixin();
    box-shadow+: 0 0 20px black;
}


.myclass {
    box-shadow: inset 0 0 10px #555, 0 0 20px black;
}
</code></pre><h4 id="十二、避免编译使用-“-”"><a href="#十二、避免编译使用-“-”" class="headerlink" title="十二、避免编译使用 “~”"></a>十二、避免编译使用 “~”</h4><pre><code>.text {
    width: ~(30px + 30px);        // 这里就不会被计算，而直接输出width: 30px + 30px;
}
</code></pre><h4 id="十三、与构建工具结合"><a href="#十三、与构建工具结合" class="headerlink" title="十三、与构建工具结合"></a>十三、与构建工具结合</h4><pre><code>可以使用gulp 或 webpack 来进行编译
</code></pre><blockquote>
<p>参考资料</p>
<p><a href="http://less.bootcss.com" target="_blank" rel="noopener">http://less.bootcss.com</a><br><a href="http://www.wtoutiao.com/p/15bzfg3.html" target="_blank" rel="noopener">http://www.wtoutiao.com/p/15bzfg3.html</a><br><a href="http://www.w3cplus.com/css/sass-vs-less-vs-stylus-a-preprocessor-shootout.html" target="_blank" rel="noopener">http://www.w3cplus.com/css/sass-vs-less-vs-stylus-a-preprocessor-shootout.html</a><br><a href="http://www.w3cplus.com/preprocessor/architecture-sass-project.html" target="_blank" rel="noopener">http://www.w3cplus.com/preprocessor/architecture-sass-project.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/26/handlebars模板/">Hanlebars.js 模板引擎</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/26/handlebars模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-26T07:45:55.000Z" itemprop="datePublished">2016-12-26</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 涉及知识点<br>|<br>|</p>
<h4 id="headlebars介绍"><a href="#headlebars介绍" class="headerlink" title="headlebars介绍"></a>headlebars介绍</h4><pre><code>Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。它采用&quot;Logic-less template&quot;（无逻辑模版）的思路，在加载时被预编译，而不是到了客户端执行到代码时再去编译， 这样可以保证模板加载和运行的速度。Handlebars兼容Mustache，你可以在Handlebars中导入Mustache模板。
</code></pre><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><pre><code>1、下载handlebars.js文件在页面中直接引用

2、通过npm下载，require(&apos;handlebars&apos;)直接引用
</code></pre><h4 id="使用Handlebars"><a href="#使用Handlebars" class="headerlink" title="使用Handlebars"></a>使用Handlebars</h4><pre><code>&lt;!-- 编译模板后输出的位置 --&gt;    
  &lt;div id=&quot;tableList&quot;&gt;&lt;/div&gt;

&lt;!-- 定义的模板 --&gt;
&lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    {{date.year}} 年 {{date.month}} 月 {{date.day}} 日 &lt;br&gt;
    &lt;table&gt;
      {{#each person}}
           &lt;tr&gt;
          &lt;td&gt;姓名:{{name}}, 年龄:{{age}}&lt;/td&gt;
        &lt;/tr&gt; 
      {{/each}}
      &lt;/table&gt;
&lt;/script&gt;

&lt;!--插件引用--&gt;
&lt;script src=&quot;js/lib/zepto.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/lib/handlebars.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  $(document).ready(function() {

    // 模拟的json对象
    var data = {
        date: {
            year: &apos;2016&apos;,
            month: &apos;12&apos;,
            day: &apos;26&apos;
        },
        person: [
            {name: &apos;siguang&apos;, age: 20},
            {name: &apos;lulu&apos;, age: 20},
            {name: &apos;haha&apos;, age: 20},
            {name: &apos;heihei&apos;, age: 20}
        ]
    }

     // 预编译模板
    var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());

    //将json对象用刚刚注册的Handlebars模版封装，得到最终的html，插入到基础table中。
    $(&apos;#tableList&apos;).html(myTemplate(data));

  });
&lt;/script&gt;
</code></pre><h4 id="handlebars语句"><a href="#handlebars语句" class="headerlink" title="handlebars语句"></a>handlebars语句</h4><pre><code>1、{{#each 对象 }}  循环数据

&lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
  {{#each student}}
    &lt;tr&gt;
      &lt;td&gt;{{name}}&lt;/td&gt;
      &lt;td&gt;{{sex}}&lt;/td&gt;
      &lt;td&gt;{{age}}&lt;/td&gt;
    &lt;/tr&gt; 
  {{/each}}
&lt;/script&gt;


2、{{#each }} 嵌套

    {{#each this}} each中的this

    &lt;!-- 定义的模板 --&gt;
    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        {{#each this}}
            {{#each info}}
                &lt;!-- 这里取name 使用../到上一层来取， info数组内容使用this来输出 --&gt;
                {{../name}}的{{this}}&lt;br&gt;
            {{/each}}
        {{/each}}
    &lt;/script&gt;


    &lt;script src=&quot;js/lib/zepto.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/lib/handlebars.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() {
        //模拟的json对象
        var data = [
             {
                &quot;name&quot;:&quot;张三&quot;,
                &quot;info&quot;:[
                    &quot;眼睛&quot;,
                    &quot;耳朵&quot;,
                    &quot;鼻子&quot;
                ]
            },
            {
                &quot;name&quot;:&quot;李四&quot;,
                &quot;info&quot;:[
                    &quot;爸爸&quot;,
                    &quot;妈妈&quot;,
                    &quot;妻子&quot;
                ]
            }
        ];

        var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());
        $(&apos;#dataList&apos;).html(myTemplate(data));
      });
    &lt;/script&gt;


3、@index 访问父级索引

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        &lt;table&gt;
        {{#each this}}
            &lt;tr&gt;
                &lt;td&gt;{{addOne @index}}.&lt;/td&gt;
                &lt;td&gt;{{name}}&lt;/td&gt;
                &lt;td&gt;{{sex}}&lt;/td&gt;
                &lt;td&gt;{{age}}&lt;/td&gt;
            &lt;/tr&gt;
        {{/each}}
        &lt;/table&gt;
    &lt;/script&gt;

    &lt;!--进行数据处理、html构造--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var data = [
            {
                name: &quot;张三&quot;,
                sex: &quot;男&quot;,
                age: 35
            },{
                name: &quot;李四&quot;,
                sex: &quot;男&quot;,
                age: 23
            },{
                name: &quot;甜妞&quot;,
                sex: &quot;女&quot;,
                age: 18
            }
        ];

        // 注册索引+1的helper
        var handleHelper = Handlebars.registerHelper(&quot;addOne&quot;,function(index){
            //返回+1之后的结果
            return index+1;
        });

        //解析模版
        var handle = Handlebars.compile($(&quot;#table-template&quot;).html());
        //生成html
        var html = handle(data);
        //插入到页面
        $(&quot;#dataList&quot;).append(html);
    &lt;/script&gt;


4、#with 循环时进行到某一个上下文

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    &lt;table&gt;
        {{#each this}}
        &lt;tr&gt;
            &lt;td&gt;{{name}}&lt;/td&gt;
            &lt;td&gt;{{sex}}&lt;/td&gt;
            &lt;td&gt;{{age}}&lt;/td&gt;
            &lt;td&gt;
                &lt;!-- 这里通过 #with 直接找到favorite数组 --&gt;
                {{#with favorite}}
                {{#each this}}
                &lt;p&gt;{{name}}&lt;/p&gt;
                {{/each}}
                {{/with}}
            &lt;/td&gt;
        &lt;/tr&gt; 
        {{/each}}
    &lt;/table&gt;

    &lt;/script&gt;

    &lt;!--进行数据处理、html构造--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() {
        //模拟的json对象
        var data = [
                {
                    &quot;name&quot;: &quot;张三&quot;,
                    &quot;sex&quot;: &quot;0&quot;,
                    &quot;age&quot;: 18,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;唱歌&quot;
                      },{
                        &quot;name&quot;:&quot;篮球&quot;
                      }
                    ]
                },
                {
                    &quot;name&quot;: &quot;李四&quot;,
                    &quot;sex&quot;: &quot;0&quot;,
                    &quot;age&quot;: 22,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;上网&quot;
                      },{
                        &quot;name&quot;:&quot;足球&quot;
                      }
                    ]
                },
                {
                    &quot;name&quot;: &quot;妞妞&quot;,
                    &quot;sex&quot;: &quot;1&quot;,
                    &quot;age&quot;: 18,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;电影&quot;
                      },{
                        &quot;name&quot;:&quot;旅游&quot;
                      }
                    ]
                }
            ];

        // 注册一个Handlebars模版，通过id找到某一个模版，获取模版的html框架
        var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());

        // 将json对象用刚刚注册的Handlebars模版封装，得到最终的html，插入到基础table中。
        $(&apos;#dataList&apos;).html(myTemplate(data));
    });
    &lt;/script&gt;

5、{{#if }} 判断

     &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        {{#each student}}
            {{#if name}}
                &lt;tr&gt;
                    &lt;td&gt;{{name}}&lt;/td&gt;
                    &lt;td&gt;{{sex}}&lt;/td&gt;
                    &lt;td&gt;{{age}}&lt;/td&gt;
                &lt;/tr&gt;
            {{/if}}
        {{/each}}
    &lt;/script&gt;


6、registerHelper() 注册handlebars

    需要用到js处理并返回数据需要用到注册，类似过滤器

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    {{#each student}}
        {{#if name}}

            &lt;!-- compare 注册名， age 20 为参数 --&gt;
            {{#compare age 20}}
                &lt;tr&gt;
                    &lt;td&gt;{{name}}&lt;/td&gt;
                    &lt;td&gt;{{sex}}&lt;/td&gt;
                    &lt;td&gt;{{age}}&lt;/td&gt;
                &lt;/tr&gt;
            {{else}}
                &lt;tr&gt;
                    &lt;td&gt;?&lt;/td&gt;
                    &lt;td&gt;?&lt;/td&gt;
                    &lt;td&gt;?&lt;/td&gt;
                &lt;/tr&gt;
            {{/compare}}
        {{/if}}
    {{/each}}
    &lt;/script&gt;

    //注册一个比较大小的Helper,判断v1是否大于v2
    Handlebars.registerHelper(&quot;compare&quot;,function(v1,v2,options){
        if(v1&gt;v2){
            //满足添加继续执行
            return options.fn(this);
        }
        else{
            //不满足条件执行{{else}}部分
            return options.inverse(this);
        }
    });
</code></pre><p>| 参考资料<br>| <a href="http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之三)Redux/">React（之三）Redux</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之三)Redux/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createStroe() - 创建一个store<br>| getState() -  获取state值<br>| dispatch() -  执行action<br>| action  要执行的事件<br>| subscribe() - 侦听state的变化<br>| reducer 用来改变state的值，结合了action的动作来分别处理<br>| combineReducers - 将多个reducer合到一起赋给createStroe()<br>|<br>| React-redux - 让react与redux结合<br>| provider - 将redux的Store传到内部的其它组件，内部都可以对state更新<br>| connect - react与redux连接<br>|<br>| applyMiddleware() - 加载中间件<br>| bindActionCreators() - 直接调用dispatch(action)()<br>| compose</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>Facebook官方提出了Flux思想管理数据流，同时也给出了自己的实现方案Flux来管理React应用

实现Flux思想的类库 Redux、Flux、reflux

$ npm i --save redux        // 安装redux

$ npm i react-redux --save    // redux与react结合

$ npm i redux-devtools --save        // 查看调试

$ npm i redux-thunk --save

$ npm i redux-logger --save

$ import { createStore } from &apos;redux&apos;;    // 引用redux

一、Redux流程:

    1、view直接触发dispatch

    2、dispatch将action发送到reducer中后，根节点上会更新props，改变全局view

    3、redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中    
</code></pre><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><pre><code>Store 保存数据的容器， createStroe(reducer, applyMiddleware)

import { createStore } from &apos;redux&apos;;
import counter from &apos;./reducers&apos;        // 获取定义的reducer

let stroe = createStroe(counter);    // 使用createStore(reducer, initialState初始化state, 中间件传入)来创建一个数据仓库
store.dispatch();

方法:

    1、store.getState(): 获取State值

    2、store.dispatch(action): 将一个 action 对象发送给 reducer

    3、store.subscribe(listener)，用来订阅状态的变化
</code></pre><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><pre><code>state用于存储数据，state是只读的，改变需要触发action

state树就是一个对象，所有的reducer的都会加到state中，取state值，store.getState().
</code></pre><h4 id="dispatch-触发action的变化"><a href="#dispatch-触发action的变化" class="headerlink" title="dispatch() 触发action的变化"></a>dispatch() 触发action的变化</h4><pre><code>store.dispatch(actionJson);
</code></pre><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><pre><code>定义Action指令并不能直接改变state，action必须是json

Action函数和Action不相同

{
    type: &apos;ADD_TODO&apos;,
    text: &apos;hhh&apos;
}

function addTodo(text) {
    return {
        type: ADD_TODO,
        text
    }
}
通过 store.dispatch(action): 来派发到reducer中来改变state的值
</code></pre><h4 id="Reducer-rɪ’dju-sə-瑞丢ser"><a href="#Reducer-rɪ’dju-sə-瑞丢ser" class="headerlink" title="Reducer [rɪ’dju:sə][瑞丢ser]"></a>Reducer [rɪ’dju:sə][瑞丢ser]</h4><pre><code>接收一个action值，根据定义的action名对应处理state，并改变state值

let comput = (state=0, action) =&gt; {
    switch(action.type){
        case &apos;add&apos;:
            return state + 1;
            break;

        case &apos;sub&apos;:
            return state - 1;
            break;

        default: break;
    }
}

let store = createStore(comput);
store.dispatch({type: add});
</code></pre><h4 id="combineReducers-kəmˈbaɪn-rɪ’dju-səre-将所有的reducer合成一个"><a href="#combineReducers-kəmˈbaɪn-rɪ’dju-səre-将所有的reducer合成一个" class="headerlink" title="combineReducers [kəmˈbaɪn rɪ’dju:səre]  将所有的reducer合成一个"></a>combineReducers [kəmˈbaɪn rɪ’dju:səre]  将所有的reducer合成一个</h4><pre><code>import {combineReducers} from &quot;redux&quot;; 
import chatIndex from &quot;./Chat&quot;;

export default combineReducers({
    chatIndex,
});
</code></pre><h4 id="subscribe-səbˈskraɪb-订阅-监听器"><a href="#subscribe-səbˈskraɪb-订阅-监听器" class="headerlink" title="subscribe()[səbˈskraɪb]订阅  监听器"></a>subscribe()[səbˈskraɪb]订阅  监听器</h4><pre><code>添加一个变化的监听器，每当dispatch action的时候就会执行

// App组件
class App extends Component {
    constructor(props){
        super(props);
        this.state = {
            num: 0
        }
    }

    componentDidMount() {
        store.subscribe(this.handleChange.bind(this));
    }

    handleChange(){
        this.setState({num: store.getState()})
    }

    addClick(){
        store.dispatch({type: &apos;add&apos;});
    }

    subClick(){
        store.dispatch({type: &apos;sub&apos;});
    }

    showState(){
        debugger;
        console.log(store.getState())
    }

    render() {
        return (
            &lt;div className = &quot;box&quot; &gt;
                {this.state.num}
                &lt;input type=&quot;button&quot; onClick={this.addClick} value=&quot;+&quot; /&gt;
                &lt;input type=&quot;button&quot; onClick={this.subClick} value=&quot;-&quot; /&gt;
                &lt;input type=&quot;button&quot; onClick={this.showState} value=&quot;查看state&quot; /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h4><pre><code>一、provider(store, children) - 将Store传到子组件中，一般用在入口文件

    import React from &apos;react&apos;;
    import ReactDOM from &apos;react-dom&apos;;
    import {Provider} from &quot;react-redux&quot;;
    import Store from &quot;src/store&quot;;
    import App from &apos;src/components/app&apos;;
    import Chat from &apos;src/pages/Chat/Index&apos;;

    ReactDOM.render(
        &lt;Provider store={Store}&gt;
            &lt;App&gt;
                &lt;Chat /&gt;
            &lt;/App&gt;
        &lt;/Provider&gt;,
        document.getElementById(&apos;app&apos;)
    );

    如果使用路由
    &lt;Provider store={store}&gt;
        &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
            &lt;Route path=&apos;/&apos; component={Index}&gt;
                &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;


二、connect(mapStateToProps, mapDispatchToProps) - 连接react组件与redux store

    1、mapStateToProps - 把状态绑定到组件的props中

    2、mapDispatchToProps - 相当于用store.dispatch(actionType) 来发出操作指令，来改变state值


example

// app.jsx
&lt;Provider store={store}&gt;
    &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
        &lt;Route path=&apos;/&apos; component={Index}&gt;
            &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
        &lt;/Route&gt;
    &lt;/Router&gt;
&lt;/Provider&gt;

// Index.jsx
import React, { Component } from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;
import { bindActionCreators } from &quot;redux&quot;;
import { connect } from &quot;react-redux&quot;;
import actions from &quot;src/actions&quot;;

class wechat extends Component {
    constructor(props){
        super(props);
        this.state = {

        }
    }

    componentDidMount(){
        let { ACTIONS } = this.props;
        ACTIONS.chat_init();
    }

    render(
        // ...
    )
}

let mapStateToProps=(state)=&gt;{
    let {sessions,user} = state.chatIndex;
    return {
        _sessions:sessions,
        _user:user
    };
}; 

let mapDispatchToProps=(dispatch)=&gt;{
    return {
        ACTIONS:bindActionCreators(actions,dispatch)
    };
};

export default connect(mapStateToProps,mapDispatchToProps)(wechat);
</code></pre><h4 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators()"></a>bindActionCreators()</h4><pre><code>是通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用）

import * as oldActionCreator from &apos;./action.js&apos;

let newAction = bindActionCreators(oldActionCreator,dispatch)
</code></pre><h4 id="redux-thunk-中间件"><a href="#redux-thunk-中间件" class="headerlink" title="redux-thunk 中间件"></a>redux-thunk 中间件</h4><pre><code>可以action创建子函数先不返回active对象，

http://blog.csdn.net/kuangshp128/article/details/67632683
</code></pre><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><pre><code>两种方法 1、下载redux-devtools包      2、chrome or Firfix 下载 Redux DevTools插件

1、使用Redux DevTools插件 代码中需要加配置

    https://github.com/zalmoxisus/redux-devtools-extension

    /* eslint-disable no-underscore-dangle */        // +
    let store = createStore(
        comput,
        window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()        // +
    )
    /* eslint-enable */                                // +


2、redux-devtool 包的使用 https://github.com/gaearon/redux-devtools
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>|- src
|-- reduxs     // redux
|------ actions
|------ reducers
|-- router    // 路由
|-- util    // 工具
</code></pre><p>| <a href="https://www.jianshu.com/p/bccca5bb6338" target="_blank" rel="noopener">https://www.jianshu.com/p/bccca5bb6338</a>        // react－router－redux 保持路由与应用状态（state）同步<br>| <a href="http://cn.redux.js.org/index.html" target="_blank" rel="noopener">http://cn.redux.js.org/index.html</a><br>| <a href="https://github.com/GuoYongfeng/redux-complete-sample" target="_blank" rel="noopener">https://github.com/GuoYongfeng/redux-complete-sample</a><br>| <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">https://github.com/gaearon/redux-devtools</a><br>| <a href="http://www.aliued.com/?p=3204" target="_blank" rel="noopener">http://www.aliued.com/?p=3204</a><br>| <a href="https://www.jianshu.com/p/1a2f3db4af61" target="_blank" rel="noopener">https://www.jianshu.com/p/1a2f3db4af61</a>        // react-redux<br>| <a href="https://www.jianshu.com/p/9873d4ccb891" target="_blank" rel="noopener">https://www.jianshu.com/p/9873d4ccb891</a>        // connect 原理<br>| <a href="http://blog.csdn.net/liwusen/article/details/54138854" target="_blank" rel="noopener">http://blog.csdn.net/liwusen/article/details/54138854</a>         // bindActionCreators<br>| <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之二)组件类/">React（之二）组件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之二)组件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| Router、Route<br>| Link、Links  router的导航组件，用来切换路由<br>| browserHistory、hashHistory<br>| activeStyle、activeClassName  路由设置样式<br>| IndexRoute<br>| component、components<br>| query<br>| params 变量<br>| Redirect<br>| setRouteLeaveHook</p>
<h4 id="react-router安装"><a href="#react-router安装" class="headerlink" title="react-router安装"></a>react-router安装</h4><pre><code>$ npm install react-router history --save        // 安装

import React, { Component } from &apos;react&apos;;
import { Router, Route, hashHistory, Link } from &apos;react-router&apos;;
</code></pre><h4 id="Router和Route"><a href="#Router和Route" class="headerlink" title="Router和Route"></a>Router和Route</h4><pre><code>Router是一个容器，路由要通过Route组件定义

import { Router, Route, hashHistory } from &apos;react-router&apos;;
render((
    &lt;Router history={hashHistory}&gt;
        &lt;Route path=&quot;/&quot; component={App}/&gt;
    &lt;/Router&gt;
), document.getElementById(&apos;app&apos;));
</code></pre><h4 id="browserHistory-和-hashHistory"><a href="#browserHistory-和-hashHistory" class="headerlink" title="browserHistory 和 hashHistory"></a>browserHistory 和 hashHistory</h4><pre><code>import React, { Component } from &apos;react&apos;;
import { Router, Route, browserHistory, Link } from &apos;react-router&apos;;

class App extends Component {
    render() {
        return (
            &lt;Router history={browserHistory}&gt;            // 这里要加
                &lt;Route path=&quot;/&quot; component={Home} /&gt;
                &lt;Route path=&quot;/about&quot; component={About} /&gt;
                &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
            &lt;/Router&gt;
        );
    }
}

二者区别:

    hashHistory: 带有&apos;#/&apos; http://localhost:5001/#/About

    browserHistory: 不会带有&apos;#/&apos; http://localhost:5001/List   生产环境使用  --history-api-fallback

    注意:

    使用browserHistory，正常点击路由切换没有问题，但是重新刷新URL就会报找不到路由，
    需要在webpack-dev-server启动的时候需要加上参数--history-api-fallback。

    或者在webpack.config.js配置中 

        devServer: {
            port: 5000,                 // 端口
            contentBase: &apos;build&apos;,       // 内容目录
            hot: true,                    // 热刷新
            inline: true,
            historyApiFallBack: true,   // react路由历史管理使用
        }
</code></pre><h4 id="Link、Links、IndexLink"><a href="#Link、Links、IndexLink" class="headerlink" title="Link、Links、IndexLink"></a>Link、Links、IndexLink</h4><pre><code>是router的导航组件，用来切换路由

1、Example:

    import React, { Component } from &apos;react&apos;;
    import { Router, Route, hashHistory, Link } from &apos;react-router&apos;;

    const Home = () =&gt; &lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const About = () =&gt; &lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const Contact = () =&gt; &lt;div&gt;&lt;h1&gt;Contact&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;

    // 相当于一个导航将Link包装成一个
    const Links = () =&gt;
        &lt;nav&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
            &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;
            &lt;Link to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt;
        &lt;/nav&gt;

    class App extends Component {
        render() {
            return (
                &lt;Router history={hashHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/about&quot; component={About} /&gt;
                    &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
                &lt;/Router&gt;
            );
        }
    }

    export default App;

2、IndexLink

    如果是根路由&quot;/&quot;，不要使用link组件，需要使用IndexLink，因为如果是根路由activeStyle和activeClassName都会失效
</code></pre><h4 id="子路由、IndexRoute-路由初始的默认"><a href="#子路由、IndexRoute-路由初始的默认" class="headerlink" title="子路由、IndexRoute 路由初始的默认"></a>子路由、IndexRoute 路由初始的默认</h4><pre><code>一、子路由的显示

    在加载子路由的组件中的位置使用 {this.props.children}, 如果子路由没有设置IndexRoute默认路由 this.props.children返回undefined

    let IndexPage = funciton(){
        return (
            &lt;div&gt;
                &lt;div className=&quot;side&quot;&gt;&lt;/side&gt;
                &lt;div className=&quot;content&quot;&gt;
                    {this.props.children}
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    home页面加载显示子路由方式:

        vue使用的是&lt;router-view&gt;&lt;/router-view&gt;显示

        react 显示子路由  {this.props.children}


二、IndexRouter

    import { Router, Route, browserHistory, Link, IndexRoute } from &apos;react-router&apos;;
    class RouterConfig extends Component {
        render() {
            return (
                &lt;Router history={browserHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home}&gt;            // localhost:8080/        调用的是Home
                        &lt;IndexRoute component={About} /&gt;         // 子路由，默认路由
                        &lt;Route path=&quot;contact&quot; component={Contact} /&gt;
                    &lt;/Route&gt;
                &lt;/Router&gt;
            );
        }
    }
    export defualt RouterConfig;
</code></pre><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><pre><code>一、路由变量

    定义变量: &lt;Route path=&quot;/(:msg)&quot; component={Message} /&gt;

    获取变量: props.params 来获取

    &lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan
    &lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan
    &lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg

    Example:

        import React, { Component } from &apos;react&apos;;
        import { Router, Route, hashHistory, Link, IndexRoute } from &apos;react-router&apos;;

        class Message extends Component {
            constructor(props){
                super();
                debugger
                console.log(props);
            }

            render(props){
                return (
                    &lt;div&gt;
                        // 这里this.props.params.msg 接收的是to的名字

                        &lt;h1&gt;{this.props.params.msg || &apos;hello&apos;}&lt;/h1&gt;
                        &lt;Links /&gt;
                    &lt;/div&gt;
                )
            }
        }

        const Links = () =&gt;
            &lt;nav&gt;
                &lt;Link to=&quot;/&quot;&gt;Hello&lt;/Link&gt;
                &lt;Link to=&quot;/yong&quot;&gt;Yong&lt;/Link&gt;
                &lt;Link to=&quot;/feng&quot;&gt;Feng&lt;/Link&gt;
            &lt;/nav&gt;

        class ParamsRoute extends Component {
            render() {
                return (
                    &lt;Router history={hashHistory}&gt;
                        &lt;Route path=&quot;/(:msg)&quot; component={Message} /&gt;
                    &lt;/Router&gt;
                );
            }
        }
        export default ParamsRoute;


二、query: 获取URL中的参数

    1、获取参数

        http://localhost:8080/#/?message=ssssss

        const Page = (props) =&gt;
            &lt;div&gt;
                &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;            // props.location.query.message输出 ssssss
            &lt;/div&gt;


    2、请求时带参数

        const Page = (props) =&gt;
            &lt;div&gt;
                &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;
            &lt;/div&gt;

        const Links = () =&gt;
            &lt;nav&gt;
                &lt;Link to={{ pathname: "/", query: {message: "ssssss"} }} /&gt;         
            &lt;/nav&gt;


    Example:

        import React, {Component} from &apos;react&apos;
        import { Router, Route, Link, browserHistory } from &apos;react-router&apos;

        class Page extends Component {
            constructor(props){
                super();
                console.log(props);
            }
            render(){
                return (
                    &lt;div&gt;
                        &lt;h1&gt;{this.props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;      // url带有message参数就输出, 否则输出Hello
                    &lt;/div&gt;
                )
            }
        }

        class QueryRoute extends Component {
            render() {
                return (
                    &lt;Router history={browserHistory}&gt;
                        &lt;Route path=&quot;/(message)&quot; component={Page} /&gt;        // http://localhost:5001/?message=12312312
                    &lt;/Router&gt;
                );
            }
        }
        export default QueryRoute;
</code></pre><h4 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h4><pre><code>return false  可以取消此次跳转

方法一、onEnter、onLeave事件绑定到Route上

    const backLogin = (nextState, replace) =&gt; {
        console.log(nextState)
        debugger;
    }

    class App extends Component {
        render() {
            return (
                &lt;Router history={hashHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/about&quot; component={About} /&gt;
                    &lt;Route path=&quot;/contact&quot; component={Contact} onEnter={backLogin} /&gt;
                    &lt;Route path=&quot;*&quot; onEnter={backLogin} /&gt;
                &lt;/Router&gt;
            );
        }
    }


方法二、setRouteLeaveHook(单条路由， 要处理的函数) 路由钩子，切换路由时操作，可以用于对登录判断进行操作

    import React, { Component, PropTypes } from &apos;react&apos;;
    import { Router, Route, hashHistory, Link } from &apos;react-router&apos;;

    class Home extends Component {
        componentWillMount(){

            console.log(this.context);

            this.context.router.setRouteLeaveHook(
                this.props.route,
                this.routerWillLeave
            )
        }

        routerWillLeave( nextLocation ){
            alert(`页面即将从Home切换到${nextLocation.pathname}`);
        }

        render(){
            return &lt;div&gt;
                &lt;h1&gt;Home&lt;/h1&gt;
                &lt;Links /&gt;
            &lt;/div&gt;
        }
    }

    Home.contextTypes = {
        router: PropTypes.object.isRequired
    };
    const Contact = () =&gt; &lt;div&gt;&lt;h1&gt;Contact&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const Links = () =&gt; {
        &lt;nav&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
            &lt;Link to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt;
        &lt;/nav&gt;
    }

    class SetRouteLeaveHookDemo extends Component {
        render() {
            return (
                &lt;Router history={hashHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
                &lt;/Router&gt;
            );
        }
    }
    export default SetRouteLeaveHookDemo;    
</code></pre><h4 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向:"></a>Redirect重定向:</h4><pre><code>如果一个路由不存在就通过设置Redirect来跳转到指定的路由，用于404的跳转 定义&lt;Redirect from=&quot;/contact&quot; to=&quot;/contact-us&quot; /&gt;

一、Redirect

    import React, { Component } from &apos;react&apos;;
    import { Router, Route, browserHistory, Link, Redirect } from &apos;react-router&apos;;

    const Home = () =&gt; &lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const Links = () =&gt; {
        &lt;nav&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
        &lt;/nav&gt;
    }

    class RedirectRoute extends Component {
        render() {
            return (
                &lt;Router history={browserHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Redirect from=&quot;*&quot; to=&quot;/&quot; /&gt;
                &lt;/Router&gt;
            );
        }
    }
    export default RedirectRoute;


2、IndexRedirect: 用于访问根路由重定向到某个子路由 ＜IndexRedirect to=&quot;/welcome&quot; /&gt;

    &lt;Route path=&quot;/&quot; component={App}&gt;
        ＜IndexRedirect to=&quot;/welcome&quot; /&gt;
        &lt;Route path=&quot;welcome&quot; component={Welcome} /&gt;
        &lt;Route path=&quot;about&quot; component={About} /&gt;
    &lt;/Route&gt;
</code></pre><h4 id="js跳转路由"><a href="#js跳转路由" class="headerlink" title="js跳转路由"></a>js跳转路由</h4><pre><code>方法一、browserHistory.push(要路转路由)

方法二、context对象

    export default React.createClass({

        // ask for `router` from context
        contextTypes: {
            router: React.PropTypes.object
        },

        handleSubmit(event) {
            // ...
            this.context.router.push(path)
        }
    })
</code></pre><h4 id="activeStyle-activeClassName"><a href="#activeStyle-activeClassName" class="headerlink" title="activeStyle, activeClassName"></a>activeStyle, activeClassName</h4><pre><code>当前路由被点击处于触发显示状态的时候，使用activeStyle来设置颜色，atciveClassName来设置class的名

import React, { Component } from &apos;react&apos;;
import { Router, Route, browserHistory, Link } from &apos;react-router&apos;;

const Home = () =&gt; &lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
const About = () =&gt; &lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
const Contact = () =&gt; &lt;div&gt;&lt;h1&gt;Contact&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;

const Links = () =&gt;
    &lt;nav&gt;
        &lt;Link activeStyle={{color: 'red'}} to=&quot;/&quot;&gt;Home&lt;/Link&gt;
        &lt;Link activeStyle={{color: 'red'}} to=&quot;/about&quot;&gt;About&lt;/Link&gt;
        &lt;Link activeStyle={{color: 'red'}} to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt;
    &lt;/nav&gt;

// className的写法 &lt;Link activeClassName=&quot;active&quot; to=&quot;/&quot;&gt;Home&lt;/Link&gt;

class App extends Component {
    render() {
        return (
            &lt;Router history={browserHistory}&gt;
                &lt;Route path=&quot;/&quot; component={Home} /&gt;
                &lt;Route path=&quot;/about&quot; component={About} /&gt;
                &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
            &lt;/Router&gt;
        );
    }
}

export default App;
</code></pre><h4 id="component、components"><a href="#component、components" class="headerlink" title="component、components"></a>component、components</h4><pre><code>component来指定一个路由对应加载的组件

// 可以加载两个组件，并要指定组件中对应
&lt;Route Componets={{ header: AppHeader, body: AppBody }}&gt;

import React, { Component } from &apos;react&apos;;
import { Router, Route, hashHistory, Link, IndexRoute } from &apos;react-router&apos;;

const HomeHeader = () =&gt; &lt;h1&gt;HomeHeader&lt;/h1&gt;
const HomeBody = () =&gt; &lt;h1&gt;HomeBody&lt;/h1&gt;
const AboutHeader = () =&gt; &lt;h1&gt;AboutHeader&lt;/h1&gt;
const AboutBody = () =&gt; &lt;h1&gt;AboutBody&lt;/h1&gt;

const Container = (props) =&gt;
    &lt;div&gt;
        {props.header}
        {props.body}
        &lt;Links /&gt;
    &lt;/div&gt;

const Links = () =&gt;
    &lt;nav&gt;
        &lt;Link to=&quot;/&quot;&gt;Hello&lt;/Link&gt;
        &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;
    &lt;/nav&gt;

class App extends Component {
    render() {
        return (
            &lt;Router history={hashHistory}&gt;
                &lt;Route path=&quot;/&quot; component={Container}&gt;
                    &lt;IndexRoute components={{ header:HomeHeader, body:HomeBody }} /&gt;
                    &lt;Route path=&quot;about&quot; components={{ header:AboutHeader, body:AboutBody }} /&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        );
    }
}

export default App;
</code></pre><h4 id="react-router-redux路由"><a href="#react-router-redux路由" class="headerlink" title="react-router-redux路由"></a>react-router-redux路由</h4><pre><code>保持路由与应用状态（state）同步

$ npm install --save react-router-redux        // 安装

原理：允许使用react router库中的api，使用redux一样去管理应用状态state

https://www.jianshu.com/p/bccca5bb6338
http://blog.csdn.net/isaisai/article/details/78086913
https://segmentfault.com/a/1190000007862103
</code></pre><h4 id="dva-react-Ant-蚂蚁金服脚手架"><a href="#dva-react-Ant-蚂蚁金服脚手架" class="headerlink" title="dva + react + Ant 蚂蚁金服脚手架"></a>dva + react + Ant 蚂蚁金服脚手架</h4><pre><code>单独加载ant UI框架，也可以使用dva-cli蚂蚁提供的脚手架，支持IE9及以上版本

一、单独添加ant  

    $ cnpm i antd --save

    import &apos;antd/dist/antd.css&apos;;         // 引入样式
    import { DatePicker } from &apos;antd&apos;;    // 这种方法的引用必须要添加babel-plugin-import的按需加载组件
    ReactDOM.render(&lt;DatePicker /&gt;, mountNode);            

二、按需加载插件 babel-plugin-import

    $ cnpm i babel-plugin-import --save

    .babelrc添加参数:
    {
        &quot;plugins&quot;: [
            [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }] // `style: true` 会加载 less 文件
        ]
    }

三、dva-cli安装

    $ cnpm i dva-cli    

    $ dva new [项目名] &amp;&amp; cd [项目名]        // 创建项目

    $ cnpm install antd babel-plugin-import --save        // 安装 ant 和 babel插件（用来按需加载 antd 的脚本和样式的）

        .webpackrc文件加参数
        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ]  
        }

四、运行

    $ npm start         // 生产环境运行

    $ npm run build        // 打包项目，发布线上环境在Dist目录下生成静态文件，js、css压缩

五、redux的使用

    有两个目录，models和components, model来定义state和action的，components来编写组件

    dva提供conect方法，将model和component串联起来

    import { connect } from &apos;dva&apos;;

    const Products = ({ dispatch, products }) =&gt; { ... }
    export default connect(({ products }) =&gt; ({
        products,
    }))(Products);

六、配置

    1、 .roadhogrc.mock.js  用于mock数据的配置

        export default {
            // 支持值为 Object 和 Array
            &apos;GET /api/users&apos;: { users: [1,2] },

            // GET POST 可省略
            &apos;/api/users/1&apos;: { id: 1 },

            // 支持自定义函数，API 参考 express@4
            &apos;POST /api/users/create&apos;: (req, res) =&gt; { res.end(&apos;OK&apos;); },
        };

    2、.webpackrc  

        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ],
            &quot;entry&quot;: &quot;src/index.js&quot;,        // 可以配置webpack的选项，参数见面下roadhog的文档连接
            &quot;proxy&quot;: {                        // 设置代理
                &quot;/api&quot;: {
                    &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;,
                    &quot;changeOrigin&quot;: true,
                    &quot;pathRewrite&quot;: { &quot;^/api&quot; : &quot;&quot; }
                }
            }
        }

    3、设置端口

        默认是8000，可以在package.json中设置
        &quot;scripts&quot;: {
               &quot;start&quot;: &quot;PORT=3000 roadhog server&quot;,        // windowns设置 set PORT=3000&amp;&amp;roadhog dev
        }

    4、public目录会在build的copy到dist目录下，存放一些静态文件

https://github.com/sorrycc/blog/issues/18            // dva
https://github.com/sorrycc/roadhog/blob/master/README_zh-cn.md    // roadhog


七、fatch请求

    dva-cli中utils目录中request.js中定义了一个通过fatch来发ajax请求的方法

    业务中调用:
    function IndexPage() {
        var getUser = () =&gt; {
            Request(&apos;/api/posts&apos;, {method: &apos;GET&apos;})
            .then((data)=&gt;{
                debugger;
            })
        }
        getUser()

        return (
            &lt;div className={styles.normal}&gt;
                ...
            &lt;/div&gt;
        );
    }
    exports default IndexPage;
</code></pre><h4 id="ant内还介绍了另一个脚手架-create-react-app"><a href="#ant内还介绍了另一个脚手架-create-react-app" class="headerlink" title="ant内还介绍了另一个脚手架 create-react-app"></a>ant内还介绍了另一个脚手架 create-react-app</h4><pre><code>https://ant.design/docs/react/use-with-create-react-app-cn
</code></pre><p>| <a href="http://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">http://react-guide.github.io/react-router-cn/</a>             React-router 中文网<br>| <a href="https://github.com/reactjs/react-router-redux" target="_blank" rel="noopener">https://github.com/reactjs/react-router-redux</a><br>| <a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</a><br>| <a href="https://github.com/react-guide/react-router-cn" target="_blank" rel="noopener">https://github.com/react-guide/react-router-cn</a><br>| <a href="https://github.com/ReactTraining/react-router/tree/master/examples" target="_blank" rel="noopener">https://github.com/ReactTraining/react-router/tree/master/examples</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之一)基础/">React（之一）基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之一)基础/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 创建组件<br>| render<br>| props、propType、state、setState()、replaceState()<br>| 获取DOM this.refs.xxx 或 ReactDOM.findDOMNode(this.refs.xxx)<br>| React.Children 获取父组件传的DOM<br>| mixin</p>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><pre><code>安装react-cli 见的README.md

React包括几个概念: 1、组件       2、JSX     3、虚拟DOM     4、单向数据绑定

1、核心是封装组件，只关注UI，状态变更重新渲染整个组件

2、JSX: HTML代码可以直接嵌到JS代码中，这就是React提出的叫JSX的语法，原来前端以表现和逻辑层分离为主，但HTML是组件的一部分所以不能分割，JSX 将动态值放到 { ... }

3、单向数据绑定: 当数据更新会渲染整个app

    修改DOM树、修改数据、以旧换新用户输入、异步API数据

    React的渲染方式: 用户输入、从API获取数据、将数据传给顶层组件、React将每个组件渲染出来

        不会象MVC一样的双向数据绑定、和数据模型的脏值检测、不会有确切的DOM操作

4、虚拟DOM树: React重建一个DOM树，找到与上一个版本的DOM的差异，计算出新的DOM更新操作，从操作队列中指执行DOM更新操作

    http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/      // 前沿技术解密——VirtualDOM

5、工具: sublime或Atom

    sublime插件安装: 

    ReactJS  https://packagecontrol.io/packages/ReactJS   用来提示编码还有快捷键

    babel-sublime: https://github.com/babel/babel-sublime   用来语法颜色

    javascriptNext: https://github.com/Benvie/JavaScriptNext.tmLanguage 
</code></pre><h4 id="react引用方式"><a href="#react引用方式" class="headerlink" title="react引用方式"></a>react引用方式</h4><pre><code>1、页面直接加载

    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;

2、ES5的写法

    var React = require(&apos;react&apos;);
    var ReactDOM = require(&apos;react-dom&apos;);

    // 定义组件
    var HelloMessage = React.createClass({
      render: function() {
        return &lt;div&gt; React，我们来了... &lt;/div&gt;;
      }
    });

    // 组件渲染
    ReactDOM.render(&lt;HelloMessage /&gt;, rootElement);

3、ES6的写法

    import React, { Component } from &apos;react&apos;;
    import { render } from &apos;react-dom&apos;;

    // 定义组件
    class SimpleComponent extends Component {
        render(){
            return &lt;div&gt; React，我们来了... &lt;/div&gt;;
        }
    }
    export default SimpleComponent;

    // 组件渲染
    render(&lt;HelloMessage /&gt;, rootElement);
</code></pre><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><pre><code>var HelloMessage = React.createClass({
    render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
    }
});
React.render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode);

如果不使用JSX，就需要使用createElement()来创建元素

render: function() {
    return React.createElement(&quot;div&quot;, null, &quot;Hello &quot;, this.props.name);
}

一、注释

    {/* 一般注释, 用 {} 包围 */}

    /* 多
     行
     注释 */

二、根元素只能有一个

     class ComponentDemo extends Component {
        render(){
            // 以下写法直接报错
            return (
                &lt;div&gt;
                hello
                &lt;/div&gt;
                &lt;h1&gt; hello h1 &lt;/h1&gt;
            );
        }
    }

三、styles 写法

    class StyleDemo extends Component {
        render(){
            // 在JS文件里面给组件定义样式
            var MyComponentStyles = {
                color: &apos;blue&apos;,
                fontSize: &apos;28px&apos;
            };

            return (
                &lt;div style={MyComponentStyles}&gt;
                  可以直接这样写行内样式
                &lt;/div&gt;
            )
        }
    }

四、属性名不能和 js 关键字冲突

    class =&gt; className 

    read =&gt; readOnly 

    for =&gt; htmlfor

五、JSX spread

    {...spreadObj} 可以直接将spreadObj的对象传递过去

    Spread Demo组件:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;

        class SpreadDemo extends Component{
            render(){
                return &lt;div&gt;姓名: {this.props.name}  车型: {this.props.carType}&lt;/div&gt;
            }
        }
        export default SpreadDemo;

    main.js:

        import SpreadDemo from &apos;./components/spread&apos;;
        const spreadObj = {
            name: &apos;siguang&apos;,
            carType: &apos;卡宴&apos;
        }
        // render(&lt;SpreadDemo name={spreadObj.name} carType={spreadObj.carType} /&gt;, document.querySelector(&apos;#app&apos;));
        render(&lt;SpreadDemo {...spreadObj} /&gt;, document.querySelector(&apos;#app&apos;));
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>创建组件: React.createClass() 或 React.Component()

渲染组件: ReactDOM.render(&lt;组件名/&gt;, 放到哪个位置, 渲染完成的回调);

一、组件创建三种方法

    1、ES5 创建组件: 

        let React = require(&apos;react&apos;);
        let ReactDOM = require(&apos;react-dom&apos;);

        let Message = React.createClass({
            render: function(){
                return (
                    &lt;div&gt;
                        &lt;ul&gt;
                            &lt;li&gt;Hello World {this.props.personName}&lt;/li&gt;
                        &lt;/ul&gt;
                    &lt;/div&gt;
                )
            }
        })

        module.exports = Message;        // ES5导出组件

        // ReactDOM.render(
        //        &lt;Message personName=&quot;siguang&quot; /&gt;
        //         , document.querySelector(&apos;#app&apos;)
        // );


    2、ES6 创建组件方法

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;

        // 所有创建的组件都继承于Component对象
        class ShowMessage extends Component{
            render(){
                return &lt;div&gt;Hello name {this.props.name}&lt;/div&gt;
            }
        }

        export default ShowMessage;        // ES6导出组件

        // render(&lt;ShowMessage name=&quot;siguang.liu&quot; /&gt;, document.querySelector(&apos;#app&apos;));


    3、函数式组件

        是组件没有状态的时候（相当不需要设置state, 不能使用this、可以写成函数式

        const ShowMessage = () =&gt; &lt;div&gt;Hello name haha&lt;/div&gt;
        render(&lt;ShowMessage /&gt;, document.querySelector(&apos;#app&apos;));

        可以使用props

        const ShowMessage = function(props){
            return &lt;div&gt;Hello name {props.name}&lt;/div&gt;
        }


二、组件的注意地方

    1、组件名首字母必须大写

    2、根元素的个数只能是一个

        class ComponentDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;boxA&quot;&gt;            {/* 根元素只能有一个 */}
                        aaaaaaaa

                        &lt;div class=&quot;boxB&quot;&gt;
                            bbbbbb
                        &lt;/div&gt;
                    &lt;/div&gt;
                )
            }
        }
        export default ComponentDemo;

    3、spread变量传递可以使用es6的 {...obj}

        let person = &lt;Person name={window.isLoggedIn ? window.name : &apos;&apos;} /&gt;

    4、获取真实的DOM节点

        组件并不是真实的DOM节点，而是在内存中的一种数据结构叫虚拟DOM，如果要从组件内获取真实的DOM节点，需要用到refs属性
</code></pre><h4 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h4><pre><code>childList.jsx:

    import React, { Component } from &apos;react&apos;
    import ReactDom, { render } from &apos;react-dom&apos;

    class ChildrenA extends Component{
        constructor(props){
            super(props);
        }
        render(){
            return (&lt;div&gt;
                {/* 这里是子组件A   this.props.children获取组件的内容，相当前于vue中的solt */}
                {
                    React.Children.map(this.props.children, function(c){        // React.Children是获取组件中的元素
                        return &lt;p&gt;{c}&lt;/p&gt;
                    })
                }
            &lt;/div&gt;)
        }
    }

    class ParentComponent extends Component{
        render(){
            return &lt;div&gt;
                &lt;ChildrenA&gt;
                    &lt;p&gt;福特&lt;/p&gt;
                    &lt;p&gt;丰田&lt;/p&gt;
                    &lt;p&gt;本田&lt;/p&gt;
                &lt;/ChildrenA&gt;
            &lt;/div&gt;
        }
    }
    export default ParentComponent;

index.js:

    import React, { Component } from &apos;react&apos;
    import ReactDom, { render } from &apos;react-dom&apos;
    import ParentComponent from &apos;./components/ParentComponent&apos;

    render(&lt;ParentComponent /&gt;, docuemnt.querySelector(&apos;#box&apos;));
</code></pre><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><pre><code>React是单向数据流，数据从父组件传到子组件，子组件通过props获取数据，顶层组件改变了props，React会遍历整个组件树，重新渲染整个组件

数据流包括: Props 和 State
</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>从最顶层逐级向下传递，从父组件将数据传到子组件，单向数据流

{this.props.name} 读取props的值

1、props API:

    this.props.children

    this.props.map

    this.props.filter 


2、getDefaultProps() 设置一个默认的props

    ES5写法

        var ComponentWithDefaultProps = React.createClass({
            // 初始化设置props值
            getDefaultProps: function() {
                return {
                    value: &apos;default value&apos;
                };
            }
        });

    ES6写法 

        /* 通过 defaultProps 来定义 */
        class PropsDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}
                    &lt;/div&gt;
                )
            }
        }

        PropsDemo.defaultProps = {
            name: &apos;123123&apos;        // 默认一个name值，如果父组件没有传值就会取默认值
        }


3、propsType 校验props规则

    import React, { Component, PropTypes } from &apos;react&apos;;

    class PropTypesDemo extends Component {
        render(){
            return &lt;b&gt;{this.props.title}&lt;/b&gt;
        }
    }

    // 静态属性定义propTypes, title只能为string
    PropTypesDemo.propTypes = {
        title: React.PropTypes.string.isRequired
    }

    export default PropTypesDemo;


4、Example

    PropsComponent组件:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;

        class PropsComponent extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}         {/* 这里接收props值 */}
                    &lt;/div&gt;
                )
            }
        }

        // 输出组件接口
        export default PropsComponent;


    index.js:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;
        import PropsComponent from &apos;../components/props&apos;;

        // 要传的值
        let obj = {
            name: &apos;haha&apos;,
            age: &apos;300&apos;
        }

        // 方法1、直接传给属性
        render(&lt;PropsComponent name={obj.name} age={obj.age} /&gt;, document.querySelector(&apos;body&apos;));

        // ...obj 来对多值进行解析赋值
        render(&lt;PropsComponent {...obj} /&gt;, document.querySelector(&apos;body&apos;));


5、this.props.children 访问自定义子节点

    // 将组件下的所有子节点通过map获取到，并重新包装
    import React, { Component } from &apos;react&apos;;

    class UseChildren extends Component {
        render(){
            return  &lt;ul&gt;
                {
                    // 会将UseChildren组件下所有的元素取出
                    React.Children.map(this.props.children, function(c){
                        return &lt;li&gt; {c} &lt;/li&gt;
                    })
                }
            &lt;/ul&gt;
        }
    }

    class ChildrenDemo extends Component {
        render(){
            return (
                &lt;UseChildren&gt;
                    &lt;a href=&quot;#&quot;&gt;Facebook&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Google&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Space&lt;/a&gt;
                &lt;/UseChildren&gt;
            )
        }
    }

    export default ChildrenDemo;
</code></pre><h4 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h4><pre><code>每一个React组件都有一个自己的state对象，与props区别在于，state只能在当前组件内部使用

1、初始化state

    ES5: 通过getInitialState()

        var Component = React.createClass({
            // getInitialState()方法 初始化 state值
            getInitialState: function() {
                return { userName: &apos;siguang&apos; };
            },

            render: function(){
                return (
                    &lt;div&gt; {this.state.userName} &lt;/div&gt;
                )
            }
        }

    ES6: 通过类的constructor()来初始化

        class StateDemo extends Component {
            constructor(){
                super();            // 继承Component

                // 这里初始化state
                this.state = { 
                    userName: &apos;siguang&apos; 
                }
            }

            render(){
                return (
                    &lt;div&gt; {this.state.username}
                )
            }
        }


2、setState({改变的值}, 回调函数)来设置state的值, RN中是异步所以这块需要注意

    // 改变已有的值
    this.setState({username: &apos;haha&apos;})

    // 替换所有值
    this.replaceState()  


3、获取state值 { this.state.属性名 }

    改变值: this.setState()每当state更新组件就会重新渲染自己

    var Component = React.createClass({

        // 1 初始化 state值
        getInitialState: function() {
            return {userName: &apos;siguang&apos;};
        },
        setUserName: function(){
            this.setState({userName: &apos;lulu&apos;});        // 2 修改state值
        },
        render: function(){
            return (
                &lt;div&gt;
                    这里是props获取的值 {this.state.userName}    // 3 获取state的值
                    &lt;input type=&quot;button&quot; onClick={this.setUserName.bind(this)} value=&quot;点击修改state&quot; /&gt;
                &lt;/div&gt;
            )
        }
    })


4、state示例

    class StateDemo extends Component {
        constructor(){
            super();

            this.state = {
                secondsElapsed: 0
            }
        }

        tick(){
            this.setState({ secondsElapsed: this.state.secondsElapsed + 1 });
        }

        componentDidMount(){
            var that = this;
            this.interval = setInterval(function(){
                debugger;
                that.tick();
            }, 1000);
        }

        componentWillUnmount(){
            clearInterval(this.interval);
        }

        render(){
            return (
                &lt;div&gt;目前已经计时: {this.state.secondsElapsed}秒&lt;/div&gt;
            )
        }
    }

    export default StateDemo;


5、this的指向

    class StateDemo extends Component{
        constructor(props){
            super(props);
            this.state = {
                name: &apos;siguagn&apos;
            }
        }

        // 如果onClick=&quot;this.clickSelectBtn&quot; 这么写，this指向的是p, 所以this.setState()报错
        clickSelectBtn(){
            this.setState({name: &apos;lulu&apos;})
        }

        render(){
            return &lt;div&gt;
                &lt;p&gt;{this.state.name}&lt;/p&gt;
                &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;修改&quot; onClick=&quot;this.clickSelectBtn.bind(this)&quot;&gt;&lt;/p&gt;
            &lt;/div&gt;
        }
    }

    解决方法: 

    1、onClick=&quot;this.clickSelectBtn.bind(this)&quot;         // bind()改变this指向

    2、使用箭头函数

        clickSelectBtn = (event) =&gt; {
            this.setState({name: &apos;lulu&apos;})
        }
</code></pre><h4 id="react操作DOM"><a href="#react操作DOM" class="headerlink" title="react操作DOM"></a>react操作DOM</h4><pre><code>两种获取方法

    1、ReactDOM.findDOMNode(this.refs.xxxx);

    2、this.refs.xxx

Example:

    import React, { Component } from &apos;react&apos;;
    import ReactDOM, { findDOMNode } from &apos;react-dom&apos;;
    import $ from &apos;jquery&apos;;

    class RefsDemo extends Component {
        componentDidMount(){

            // findDOMNode()来获取DOM
            let contentA = findDOMNode(this.refs.content);

            // refs直接获取
            let contentB = this.refs.content;

            // jQuery来操作DOM
            console.log($(contentA).html());

            console.log( contentA.innerHTML );
            console.log( contentB.innerHTML );
        }

        render(){
            return(
                &lt;div&gt;
                    &lt;h3&gt;React操作DOM&lt;/h3&gt;
                    &lt;p ref=&quot;content&quot;&gt;这里是DOM元素的内容&lt;/p&gt;        // 这里定义ref访问的名
                &lt;/div&gt;
            )
        }
    }
</code></pre><h4 id="React表单组件操作"><a href="#React表单组件操作" class="headerlink" title="React表单组件操作"></a>React表单组件操作</h4><pre><code>1、react表单组件与html的不同

    1）value、checked: 属性设置值后，用户输入无效

    2) textarea: 的值要设置在value属性

        &lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt;

    3）select: value属性可以是数据，不建使用option的selected属性

        &lt;select multiple={true} value={[&apos;B&apos;, &apos;C&apos;]}&gt;
            &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt;
            &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt;
            &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt;
        &lt;/select&gt;

    4) input/textarea 的 onChange 用户每次输入都会触发（即使不失去焦点）

    5) radio/checkbox/option 点击后触发 onChange
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>通过mixin可以将组件间共享代码，将两个组件共同的属性、方法存储到mixin对象中

mixin不支持ES6的声明组件方式

ES5写法

    import React from &apos;react&apos;;

    // 抽取出的公用方法
    var SetIntervalMixin = {
        componentWillMount: function() {
            this.intervals = [];
        },
        setInterval: function() {
            this.intervals.push(setInterval.apply(null, arguments));
        },
        componentWillUnmount: function() {
            this.intervals.forEach(clearInterval);
        }
    };

    var MixinDemo = React.createClass({

        // 这里加载mixin
        mixins: [SetIntervalMixin],

        getInitialState: function() {
            return {seconds: 0};
        },

        componentDidMount: function() {
            // Call a method on the mixin
            this.setInterval(this.tick, 1000);
        },

        tick: function() {
            this.setState({seconds: this.state.seconds + 1});
        },

        render: function() {
            return (
                &lt;p&gt;
                    计时器已经运行了:  {this.state.seconds} 秒.
                &lt;/p&gt;
            );
        }
    });

    export default MixinDemo;
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>一、创建组件时:

    1、getDefaultProps - 设置默认的props

    2、getInitialState() - 定义state，【因内受】

    3、componentWillMount() - 组件挂载前，只调用一次，在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次

    4、render() - 创建虚拟dom，进行diff算法，更新dom树

    5、componentDidMount() - 组件渲染后，可以使用refs操作获取或操作DOM节点

二、更新组件时:

    1、componentWillReceiveProps() - props是父组件传递给子组件的，父组件发生render的时候子组件就会调用componentWillReceiveProps(不管props有没有更新)  receive[rɪˈsiv]

    2、shouldComponentUpdata(nextProps, nextState) - react性能环节，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件，前后两个props、state相同返回false阻止更新，不需要在创建新的dom树在进行diff算法，默认为true

    3、componentWillUpdata(nextProps, nextState) - shouldComponentUpdata为true时调用

    4、render() - 

    5、componentDidUpdate() - 

三、卸载组件

    1、componentWillUnmount() - 卸载前调用

https://www.jianshu.com/p/4784216b8194
</code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code>一、react.js

    React.Children: Object
    React.Component: ReactComponent(props, context, updater)
    React.DOM: Object
    React.PropTypes: Object
    React.cloneElement: (element, props, children)
    React.createClass: (spec)
    React.createElement: (type, props, children)
    React.createFactory: (type)
    React.createMixin: (mixin)
    React.isValidElement: (object)

二、Component

    this.context: Object              // DOM元素的内容
    this.props: Object              // 获取props对象
    this.refs: Object                // 通过ref获取指定的DOM
    this.state: Object                // 获取state对象
    this.setState: Object            // 设置state值

三、react-dom.js

    ReactDOM.findDOMNode: findDOMNode(componentOrElement)         // 获取DOM
    ReactDOM.render: ()                                    // 返回组件树
    ReactDOM.unmountComponentAtNode: (container)

四、react-dom-server.js

    ReactDOMServer.renderToString
    ReactDOMServer.renderToStaticMarkup
</code></pre><h4 id="PropTypes验证"><a href="#PropTypes验证" class="headerlink" title="PropTypes验证"></a>PropTypes验证</h4><pre><code>React.PropTypes 提供很多验证器来验证传入数据的有效性

当向 props 传入无效数据时，JavaScript 控制台会抛出警告。注意为了性能考虑，只在开发环境验证 propTypes。下面用例子来说明不同验证器的区别: 

&lt;script type=&quot;text/babel&quot;&gt;
    var data = 123;

    var MyTitle = React.createClass({
        propTypes: {
            title: React.PropTypes.string.isRequired
        },

        render: function() {
            return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
        }
    });

    ReactDOM.render(
        &lt;MyTitle title={data} /&gt;,
        document.querySelector(&apos;#app&apos;)
    );
&lt;/script&gt;

React.createClass({
    propTypes: {

        // 可以声明 prop 为指定的 JS 基本类型。默认
        // 情况下，这些 prop 都是可传可不传的。
        optionalArray: React.PropTypes.array,
        optionalBool: React.PropTypes.bool,
        optionalFunc: React.PropTypes.func,
        optionalNumber: React.PropTypes.number,
        optionalObject: React.PropTypes.object,
        optionalString: React.PropTypes.string,

        // 所有可以被渲染的对象: 数字，
        // 字符串，DOM 元素或包含这些类型的数组。
        optionalNode: React.PropTypes.node,

        // React 元素
        optionalElement: React.PropTypes.element,

        // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
        optionalMessage: React.PropTypes.instanceOf(Message),

        // 用 enum 来限制 prop 只接受指定的值。
        optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),

        // 指定的多个对象类型中的一个
        optionalUnion: React.PropTypes.oneOfType([
            React.PropTypes.string,
            React.PropTypes.number,
            React.PropTypes.instanceOf(Message)
        ]),

        // 指定类型组成的数组
        optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

        // 指定类型的属性构成的对象
        optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

        // 特定形状参数的对象
        optionalObjectWithShape: React.PropTypes.shape({
            color: React.PropTypes.string,
            fontSize: React.PropTypes.number
        }),

        // 以后任意类型加上 `isRequired` 来使 prop 不可空。
        requiredFunc: React.PropTypes.func.isRequired,

        // 不可空的任意类型
        requiredAny: React.PropTypes.any.isRequired,

        // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接
        // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
        customProp: function(props, propName, componentName) {
            if (!/matchme/.test(props[propName])) {
                return new Error(&apos;Validation failed!&apos;);
            }
        }
    }
});
</code></pre><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><pre><code>1、defaultValue 与 value 的区别

    &lt;input type=&quot;text&quot; Value={this.state.inputValue} /&gt;

    如果使用 value来绑定state的值，输入值时不会被改变

    使用 defaultValue 值会被改变

    var FromApp = React.createClass({
        getInitialState: function(){
            return {
                inputValue: &apos;input value&apos;
            }
        },

        handleSubmit: function(e){
            this.refs[&apos;goodInput&apos;]
        },

        render: function(){
            return (
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;input type=&quot;text&quot; defaultValue={this.state.inputValue} ref=&quot;goodInput&quot; /&gt;
                &lt;/form&gt;
            )
        }
    })
</code></pre><h4 id="React构建配置"><a href="#React构建配置" class="headerlink" title="React构建配置"></a>React构建配置</h4><pre><code>使用的JSX和ES6所以需要转换，通过webpack + babel插件

1、$ npm install webpack

2、安装插件

    $ npm install babel --save-dev

    $ npm install babel-loader --save-dev

    $ npm install babel-core --save-dev

    $ npm install babel-preset-es2015 --save-dev            # ES6转ES5

    $ npm install babel-preset-react --save-dev            # JSX转码

3、webpack.config.js

    var path = require(&apos;path&apos;);
    module.exports = {
        entry: &apos;./src/app.js&apos;,
        output: {
            path: path.join(__dirname, &apos;/dist&apos;),
            filename: &apos;app.min.js&apos;
        },
        resolve: {
            extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]
        },
        module: {
            loaders:  [
                {
                    include: /\.js?$/,
                    exclude: /node_modules/,
                    loader: &apos;babel&apos;,
                    query: {
                        presets: [&apos;react&apos;, &apos;es2015&apos;]
                    }
                  }
            ]
        }
    }

4、使用gulp来进行分别打包
</code></pre><h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><pre><code>当组件更新时候，react会创建一个新的虚拟dom树并会和之前的dom树进行比较，这个过程就用到了diff算法
</code></pre><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><pre><code>https://github.com/enaqx/awesome-react#boilerplates

1、路由 - react-router

2、布局 - react-blocks     http://whoisandie.github.io/react-blocks/

3、拖拽 - react-dnd        https://github.com/react-dnd/react-dnd

4、代码编辑器 - react-codemirror        https://github.com/JedWatson/react-codemirror

5、富文本编辑器 - react-quill react-draft-wysiwyg        https://github.com/jpuri/react-draft-wysiwyg

6、拾色器 - rc-color-picker、react-color        https://github.com/react-component/color-picker        http://casesandberg.github.io/react-color/

7、响应式 - react-responsive、react-media        https://github.com/contra/react-responsive        https://github.com/ReactTraining/react-media

8、复制到剪贴板 - react-copy-to-clipboard       https://github.com/nkbt/react-copy-to-clipboard

9、管理 document head - react-helmet          https://github.com/nfl/react-helmet

10、Font Awesome 图标 - react-fa        https://github.com/andreypopp/react-fa

11、二维码 -  qrcode.react         https://ant.design/docs/react/recommendation-cn

12、不在使用className - styled-components     

    http://www.alloyteam.com/2017/05/guide-styled-components/
    https://github.com/styled-components/styled-components

13、react写动画效果 - css3transform-react

    $ npm install css3transform-react
    http://www.alloyteam.com/2016/12/react-animations-difficult-to-write-try-react-transformjs/
</code></pre><p>| 参考资料<br>| <a href="https://doc.react-china.org/docs/hello-world.html" target="_blank" rel="noopener">https://doc.react-china.org/docs/hello-world.html</a>            中文官网<br>| <a href="https://github.com/BruceCham/react-cli" target="_blank" rel="noopener">https://github.com/BruceCham/react-cli</a>            // 全家桶<br>| <a href="https://guoyongfeng.github.io/book/" target="_blank" rel="noopener">https://guoyongfeng.github.io/book/</a><br>| <a href="http://uprogrammer.cn/react-tutorial-cn/" target="_blank" rel="noopener">http://uprogrammer.cn/react-tutorial-cn/</a><br>| <a href="http://huziketang.com/books/react/lesson1" target="_blank" rel="noopener">http://huziketang.com/books/react/lesson1</a><br>|<br>| <a href="https://github.com/hyy1115/react-redux-webpack2" target="_blank" rel="noopener">https://github.com/hyy1115/react-redux-webpack2</a><br>| <a href="https://github.com/zhbhun/react-learning/tree/master/boilerplate" target="_blank" rel="noopener">https://github.com/zhbhun/react-learning/tree/master/boilerplate</a><br>| <a href="http://blog.csdn.net/u013063153/article/details/52497271" target="_blank" rel="noopener">http://blog.csdn.net/u013063153/article/details/52497271</a>      事件<br>| <a href="https://github.com/gaearon/babel-plugin-react-transform#transforms" target="_blank" rel="noopener">https://github.com/gaearon/babel-plugin-react-transform#transforms</a>   babel-plugin-react-transform 相关插件<br>| <a href="http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/ES6/">ES6</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/ES6/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| let块级作用域、 const常量<br>| 解构赋值<br>| 箭头函数、default、rest、spread<br>| 模板字符串<br>| class: extends、super、constructor、静态属性和方法、实例属性<br>| Proxy 对象的拦截器<br>| Promise、Generator、async<br>| 模块化: import、export、as、*、default export<br>| 数据结构: Set不重复值的集合、Map<br>| symbol 独一无二的值</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><pre><code>一、let 声明变量

    let完全可以取代var, 特性: 1、let不允许重复声明        2、没有预解析功能        3、块级作用域

    1、预解析功能

        console.log(a);        // 报错, 如果是原来的var声明这里会是undeined, 所以let没有预解析功能
        let a = 20;

    2、块级作用域 在{ }中声明的变量只能在括号里使用

        var name = &apos;lulu&apos;;
        function prsone(){
            let name = &apos;siguang&apos;;
        }

        prsone();
        console.log(name);            // &apos;lulu&apos;

        // 输出的都是10
        for(var i=0; i&lt;10; i++){
            setTimeout(function(){
                console.log(i);        // 使用var声明的i都会打印出9，如果使用let输出的就是0到10
            })
        }

二、const常量

    1、常量不能被修改        2、常量声明都为大写        3、与let相当只在块级作用域有效

    const NAME = &apos;siguang&apos;;        // 不能变化的值
    NAME = &apos;lulu&apos;;                // 报错
</code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><pre><code>允许从数组和对象中提取的值，对变量进行赋值，被称为解构赋值

一、数组解构使用[]

    # 数组是按顺序来进行解构赋值
    let [a, b, c] = [1,2,3];    // a=1, b=2, c=3

    let [foo = true] = [];        // true

    let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];    // x=&apos;a&apos;, y=&apos;b&apos;

    let [head, ...tail] = [1, 2, 3, 4];        // head=1, tail=[2,3,4]

    # 默认值
    let [x, y = &apos;b&apos;] = [&apos;a&apos;];     // x=&apos;a&apos;, y=&apos;b&apos;


二、对象解构使用{}

    # 对象是按名字来解析赋值
    let obj = {
        getName: function(){}, 
        foo: &apos;aaa&apos;, 
        bar: &apos;bbb&apos;
    };
    let {foo, bar} = obj        // foo=&apos;aaa&apos;, bar=&apos;bbb&apos;


    # 对象的解构赋值，先找到同名，在将值赋给对应的变量
    let { foo: val, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };  
    console.log(val, bar)        // foo=&apos;undefined&apos;, val=&apos;aaa&apos;, bar=&apos;bbb&apos;


三、字符串的解构赋值

    const [a, b, c, d, e] = &apos;hello&apos;;    // a=h, b=e, c=l, d=l, e=o
    const [...tail] = &apos;hello&apos;;            // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]

    # length属性
    let {length: len} = &apos;hello&apos;;        // length = 5


四、函数参数的解构赋值

    # 参数作为数组
    function add([x, y]){
        return x * y
    }
    add([3,2]);        // 6

    # 参数作为对象，对x、y的默认初始值
    function move({x = 0, y = 0}) {
        return [x, y];
    }
    move({x: 3, y: 8}); // [3, 8] 


五、解构赋值用于

    1、值的交换  let [x, y] = [y, x];

    2、从函数返回多个值

        # 返回一个数组
        function example() {
            return [1, 2, 3];
        }
        var [a, b, c] = example();

        # 返回一个对象
        function example() {
            return {
                foo: 1,
                bar: 2
            };
        }
        var { foo, bar } = example();

    3、加载模块时指定要显示哪些接口

        const { sourceMap, sourceNode } from &apos;source-map&apos;
</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>一、写到`...`之间，值的输出使用 ${...} 

二、可以写多行字符串，只写到`...`之间就可以

二、${...}可以解析变量、对象的值、表达式、函数返回

    let name = &apos;siguang&apos;;
    let obj = {
        age: 33
    }
    console.log(`你的名字是: ${ name } 你的年龄是:  ${ obj.age }`)

三、标签模板

    let a=10, b=20;
    dialog`Hello ${a+b} world ${a*b}`;        // 等同于 dialog()
</code></pre><h4 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h4><pre><code>一、箭头函数

    1、箭头函数的注意问题: 

        * 箭头函数里的this不是指向调用者，而指向对象
        * 不能当构造函数来用
        * 函数内不存在arguments对象
        * 不可以使用yield命令，箭头函数不能用作Generator函数

        arr.sort(function(){  ...  }) 相当于 arr.sort((a, b) =&gt; a-b);

        // 箭头函数的this，不是指向调用者
        const Template = {
            test(){
                console.log(this);        // this指向Template

                document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                    /* 如果非箭头函数this应该指向 #showThis */
                    /* 这里箭头函数不是指向调用者，所以指向了 Template */
                    console.log(this);    
                }
            }
        }
        Template.test();


    2、var f = function(v){
            return v;
        }

        // ES6写法
        var f = v =&gt; v;


    3、var sum = function(num1, num2){
            return num1 + num2;
        }

        // ES6写法
        var sum = (num1, num2) =&gt; {
            return num1 + num2;
        }


    4、对象中方法的简写

        var obj = {
            name: &apos;haha&apos;,
            getName(){                // 是getName: function(){}的简写
                console.log(this.name);
            },
            setName(name){
                this.name = name;
                console.log(this.name);
            }
        }


    5、参数的解构赋值

        const full = ({ first, last }) =&gt; first + &apos; &apos; + last;    
        full({first: 20, last: 30})

        // 等同于
        // function full(person) {
        //      return person.first + &apos; &apos; + person.last;
        // }        


    6、[1,2,3].map(function (x) {
            return x * x;
        });

        // ES6写法
        [1,2,3].map( (x) =&gt; x * x);


二、函数参数默认值

    function fn(a, b=2){
        // b如果不传相当于2，等同于 var b = arguments.length &gt; 1 &amp;&amp; arguments[1] == undefined ? arguments[1] : 2;
        return {a, b}
    }
    console.log(fn(10));        // 返回{a: 10, b: 2}

    // 如果没有参数默认值时还需要在函数体内做兼容
    function fn(name){
        var getName = name || 20;
    }
    fn();


三、rest 参数  获取多余参数

    以&apos;...变量名&apos; 来获取多余的参数，返回一个数组，这样就不需要arguments对象了

    function person(...rest){
        console.log(rest);        // [1,2,3,4,5]
    }
    person(1,2,3,4,5);

    function person(a, ...rest){
        console.log(a);            // 1
        console.log(rest);        // [2,3,4,5]
    }
    person(1,2,3,4,5);


四、spread 扩展操作符 ...  与rest相反

    function add(x, y) {
        return x + y;        // 4+38
    }
    var numbers = [4, 38];
    add(...numbers)         // 42


    # 可以将字符串转成数组
    let arr = [...&apos;hello&apos;];        // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]


五、name属性

    funciton foo(){ ... }
    foo.name;        // &apos;foo&apos; 返回函数名


六、绑定this

    箭头函数可以绑定this对象，减少显式this对象的写法(call、apply、bind)

    ES7提出了函数绑定来取代&quot;call、apply、bind&quot;调用，使用两个&quot;::&quot;

    Example

        foo::bar        // 等同于 bar.bind(foo)
</code></pre><h4 id="对象扩展-Object"><a href="#对象扩展-Object" class="headerlink" title="对象扩展 Object"></a>对象扩展 Object</h4><pre><code>一、简写

    1、对象属性和值相同可以写成一个

        var foo = { name: &apos;siguang&apos;};
        var baz = {
            foo            // 与 foo: foo 相同
        };
        console.log(baz.foo.name);    // siguang


    2、对象中函数的简写

        var o = {
            name: &apos;momo&apos;,
            getName(){            // 等同于 getName: function(){}
                retrun this.name;
            }
        }


    3、示例1 参数作为对象返回

        function f(x, y) {
            return {x, y};
        }

        // 等同于
        function f(x, y) {
            return {x: x, y: y};
        }
        f(1, 2) // Object {x: 1, y: 2}

    // 示例2 CommonJS模块输出变量
        const getItem = function(){ ... }
        const setItem = function(){ ... }
        const clear = function(){ ... }
        module.exports = { getItem, setItem, clear };

        // 等同于
        // module.exports = {
        //   getItem: getItem,
        //   setItem: setItem,
        //   clear: clear
        // };


二、[] 属性名表达式

    // 对象的属性名可以用&apos;[]&apos;字符串拼接
    var sex = &apos;男&apos;;
    var obj = {
        name: &apos;momo&apos;,
        [sex]: false,
        [&apos;get&apos;+&apos;Name&apos;](){
            console.log(this.name, this[&apos;男&apos;]);        // 返回 momo false
        }
    }

    obj.getName();


三、getter 赋值器、setter 取值器

    let cat = { 
        name: &apos;喵喵&apos;, 
        get name(){ return this.name },   
        set name(value){
            if(Object.prototype.toString.call(&apos;xxx&apos;) == &apos;[object String]&apos;){
                this.name += value
            }
        }
    }


四、Object.is(): 用于对比是否相等，相当于 === ，可以正确比较 -0和0，NaN和

    &apos;==&apos;与&apos;===&apos;的缺点:

        相等运算符（==）缺点: 自动转换数据类型
        和严格相等运算符（===）缺点: NaN不等于自身，以及+0等于-0

    Objetc.is(0, -0);        // false
    Object.is(NaN, NaN);    // true


五、Object.assign(全并目标对象， 被合并对象B, 被合并对象C): 合并到第一个参数上，不是深度拷贝，所以还存在引用关系

    /* 注意: 如果后面的对象与前面对象的属性相同会赋盖掉前面的对象的值 */

    var objA = {a: 1, b:2}, objB = {b: 3, c: 4}; 
    let req = Object.assign(objA, objB);         // {a:1, b:3, c:4}

    添加对象的方法: 
        Object.assign(SomeClass.prototype, {
            someMethod(arg1, arg2){
                // ...
            },
            anotherMethod(){
                // ...
            }
        })

        相当于
        SomeClass.prototype.someMethod = function(arg1, arg2){ // ... }
        SomeClass.prototype.anotherMethod = function(){ // ... }

    克隆对象: 
        function clone(obj){
            return Object.assign({}, obj);
        }


六、getPrototypeOf(object)、setPrototype(object, 谁的prototype): 获取、设置对象的prototype

    var Cat = function(name){
        this.name = name;
    }

    Cat.prototype.showName = function(){
        return this.name;
    }

    var c1 = new Cat(&apos;momo&apos;);
    c1.showName();

    console.log(Object.getPrototypeOf(c1))

    // 设置prototype
    var Person = function(nationality){
        this.nationality = nationality;
    }
    Person.prototype = {
        showNationality: function(){
            return this.nationality;
        }
    }
    Object.setPrototypeOf(c1, Person.prototype);
    console.log(Object.getPrototypeOf(c1));


七、keys()、values()

    获取对象的所有keys或所有值, 并返回一个数组

    var obj = {name: &apos;siguang&apos;, age: 33};
    console.log(Object.keys(obj));        // [name, age]
    console.log(Object.values(obj));    // [&apos;siguang&apos;, 33]


八、__proto__属性

    用来读取或设置当前对象的prototype对象

    var Person = function(name){
        this.name = name;
    }
    Person.prototype = {
        constructor: Person,
        getName(){
            console.log(this.name);
        }
    }
    var op = new Person(&apos;lulu&apos;);

    // 继承
    var PersonChilder = function(){}; 
    PersonChilder.__proto__ = op;
    var opc = new PersonChilder(); 
    console.log(opc.getName())


    增强的对象字面量

    // 通过对象字面量创建对象
    var human = {
        breathe() {
            console.log(&apos;breathing...&apos;);
        }
    };

    var worker = {
        __proto__: human, //设置此对象的原型为human,相当于继承human
        company: &apos;freelancer&apos;,
        work() {
            console.log(&apos;working...&apos;);
        }
    };

    human.breathe();//输出 ‘breathing...’

    //调用继承来的breathe方法
    worker.breathe();//输出 ‘breathing...’


九、遍历属性的方法

    1) for...in 循环

    2）Object.keys(obj): 返回obj对象的所有key, 返回是一个数组
</code></pre><h4 id="类、继承"><a href="#类、继承" class="headerlink" title="类、继承"></a>类、继承</h4><pre><code>一、类的一些特性

    1、对象方法的简写方法
        class Cat{
            getName(){        // 老写法 getName: function(){}

            }
        }

    2、通过__proto__属性可以直接调用父类
        var parent = {
            getParentName(){
                console.log(&apos;parent&apos;)
            }
        }

        var childer = {
            __proto__: parent,            // 通过__proto__指向parent, 就可以直接调用parent类中的方法
            getChildeName(){
                console.log(&apos;childer&apos;);
            }
        }

        childer.getChildeName();    // childer
        childer.getParentName();    // parent


二、创建类

    class Cat {

        // ES6中新型构造器, 用来初始化时这里接收参数
        constructor(name){ 
            this.name = name;
        }

        getName(){        // 公有方法
            console.log(this.name);
        }

        _bar(baz){        // 私有方法
            return this.sfn = baz;
        }
    }

    Cat.userName = &apos;siguang&apos;;

    var oCat = new Cat(&apos;哈哈&apos;);
    oCat.getName();


三、继承 extends

    // 创建一个类
    class Person {
        constructor(name){
            this.name = name;
        }

        getName(){
            console.log(this.name);
        }
    }

    // 继承这个类
    class Children extends Person {
        constructor(name, color){
            super(name);                // super指向继承的构造函数Person的constructor
            this.color = color;
        }

        getColor(){
            console.log(this.name, this.color);
        }
    }

    // 实例化
    var op = new Person(&apos;siguang&apos;);
    op.getName();        // output &apos;siguang&apos;

    var oc = new Children(&apos;lulu&apos;, &apos;red&apos;);        
    oc.getColor();        // output &apos;red&apos;
    oc.getName();        // output &apos;lulu&apos;


四、static 静态属性和方法

    类似构造函数，直接挂载到函数下的叫对象的属性和方法，而写到构造函数内部的叫构造函数的属性和方法

    1、静态方法前面需要加上&apos;static&apos;关键字，相当于只是函数下的方法而不是prototype的方法，静态方法可以被子类继承，

        class Foo{
            static methodName(){
                return &apos;hello&apos;
            }
        }

        Foo.methodName();    // hello

        var foo = new Foo();
        foo.methodName();    // 报错

    2、静态属性

        ES6中没有静态属性，只能声明静态方法，ES7中可以直接写到类内在进行转码

        class Foo {
            constructor(...args) {
                this.args = args;
            } 
            outputUserName(){
                console.log(this.username);    // 这里username未定义，除非在constructor中定义 this.username
            }
        }
        Foo.username = &apos;siguang&apos;;       // 类的静态属性

        var foo = new Foo();
        console.log(foo.personName);    // undefined
        foo.outputUserName();   // undefined 


五、实例属性

    注意: 一定要将实例属性和静态属性区分，实例属性写到constructor中this.username, new后的实例时候可以被实例方法调用，而静态属性只挂到了类下直接通过类来调取，Foo.username

    class Foo{
        constructor(){
            this.username = &apos;siguang&apos;;
        }
        showName(){
            console.log(this.username);     // siguang
            console.log(Foo.username);      // lulu
        }
    }
    Foo.username = &apos;lulu&apos;;

    var foo = new Foo();
    foo.showName();

    ****** ES7 中静态属性和实例属性的定义 ******
    class MyClass{
        usernameA = &apos;siguang&apos;;        // 实例属性

        showName(){
            console.log(this.usernameA);
        }
    }


六、super()方法

    继承时必须调用super方法，否则constructor中的this为undefined，调用父类的构造器进行初始化, 子类调用父类的构造函数

    class BaseModel {
        constructor(options, data) { // class constructor，node.js 5.6暂时不支持options = {}, data = []这样传参
            this.name = &apos;Base&apos;;
            this.url = &apos;http://azat.co/api&apos;;
            this.data = data;
            this.options = options;
        }
        getName() { // class method
            console.log(`Class name: ${this.name}`);
        }
    }

    class AccountModel extends BaseModel {
        constructor(options, data) {
            super({private: true}, [&apos;3333&apos;, &apos;4444&apos;]); 
            this.name = &apos;Account Model&apos;;
            this.url +=&apos;/accounts/&apos;;
        }
        getAccountsData() {
            return this.data;
        }
    }

    let accounts = new AccountModel(5);
    accounts.getName();         // Account Model
    console.log(&apos;Data is %s&apos;, accounts.getAccountsData);        // {private: true}

    let base = new BaseModel({public: true}, [&apos;111&apos;, &apos;2222&apos;]);
    console.log(base.getName());        // Base


七、class中的Generator方法

    方法前面加&quot; * &quot; 号表示该方法是Generator函数

    class MyClass = {
        constructor(){
            ...
        }

        * getName(){
            ...
        }
    }
</code></pre><h4 id="Promise-异步编程"><a href="#Promise-异步编程" class="headerlink" title="Promise 异步编程"></a>Promise 异步编程</h4><pre><code>resolve: 成功        reject: 失败

Example:

    var pro = new Promise(function(resolve, reject){        // resolve成功, reject失败
        setTimeout(function(){
            resolve();            // 4毫秒后执行成功
        }, 400)
    })

    pro.then(
        function(){                        // 这里执行的就是reslove
            console.log(&apos;成功执行&apos;);
        },
        function(){                        // 这里执行的就是reject
            console.log(&apos;失败执行&apos;);
        }
    )
    .catch(function(e){                // 捕获异常，如果then中的两个方法成功失败有报错就会走catch
        console.log(e)
    })


方法: 

一、Promise.all([实例1，实例2，实例3]): 用于多个promise实例，当三个实例都为真的时候all这个结果为真

    var p1 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p1完成&quot;);
        }, 400);
    })

    var p2 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p2完成&quot;);
        }, 1000);
    })

    var p3 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p3完成&quot;);
        }, 4000);
    })

    var p4 = Promise.all([p1, p2, p3]);
    p4.then(function(){
        console.log(&apos;三个全部执行成功&apos;)
    }, function(){
        console.log(&apos;失败&apos;)
    })

二、Promise.race([实例1，实例2，实例3]): 只要有一个为成功，p4为成功，与all()方法正反
</code></pre><h4 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h4><pre><code>一、export: 模块输出

    1、使用对象简写方式

        var name1 = &apos;aaa&apos;;
        var name2 = &apos;bbb&apos;;
        var name3 = &apos;ccc&apos;;

        // 对象的简写 相当于{ name1: name1, name2: name2, name3: name3 }
        export {name1, name2, name3} 

        // 也可以写成    
        export var name1 = &apos;aaa&apos;;
        export var name2 = &apos;bbb&apos;;
        export var name3 = &apos;ccc&apos;;


    2、可以直接输出变量、函数或类

        export function person(){ ... }

        export {...}

        // 不能直接输出变量名
        var name = &apos;siguang&apos;;
        export name;            // 报错

        写成: export var name = &apos;siguang&apos;;        
        写成: var name = &apos;siguang&apos;;   export {name};    


    3、跨模块常量

        const常量只能在当前代码下使用，通过export可以进行跨模块常量，多个文件都可以使用

        export const name = &apos;siguang&apos;;
        export const age = 33;

        import * as info from &apos;userinfo&apos;;        // 或 import { name, age } from &apos;userinfo&apos;


二、as 关键字来修改名字

    meat.js

        export function beef(){
            return &apos;牛肉&apos;;
        }

        export function pork(){
            return &apos;猪肉&apos;;
        }

    main.js

        // * 代表meat.js下所有的对外接口，转换成meat对象下，这样就可以通过meat来调用meat下的
        import * as meat from &apos;./meat.js&apos;;        
        console.log(meat.beef());        // 牛肉
        console.log(meat.pork());        // 猪肉


三、* 将somModule内的所有导出接口

    import * as newSome from &apos;./someModule&apos;        // 将someModule类的所有接口更改到newSome下


四、export default 指定匿名

    import加载时将定义的名与导出的相同，否则无法加载，如果指定默认输出使用export default，在import导入的时候不用在关心命名的问题

    1、meat.js

            // 输出时是匿名
            export default function() {
                console.log(&apos;foo&apos;);
            }

            简写
            export default(){        // export default {}  写成默认对象

            }

        main.js

            // 导入时可以任意起名
            import beef from &apos;./meat.js&apos;


    2、default与不写default输出的区别

        // 使用default来输出，import不需要使用 {}
        export default function crc32() {
            // ...
        }
        import crc32 from &apos;crc32&apos;;

        // 不使用default来输出，import需要使用 {}
        export function crc32() { // 输出
            // ...
        };
        import {crc32} from &apos;crc32&apos;; // 输入


五、import: 模块加载

    // 取整个对象
    import $ from &apos;jquery&apos;;

    // 通过解构取对象
    import {name1, name2, nam3} from &apos;./user.js&apos;;

    // 通过逗号分两整体和解构分别来取
    import React, { Component, PropTypes } from &apos;react&apos;;

    // 重命名
    import * as React from &apos;react&apos;;        // * 对整体模块加载，并通过as转换一个名

    // 按需加载
    button.addEventListener(&apos;click&apos;, event =&gt; {
        imoprt(&apos;dialog.js&apos;)
            .then(dialog =&gt; {
                dialog.show();
            }).
            catch(err =&gt;{
                // error
            })
    }, false)


六、不同写法

    1、普通写法

        meat.js
            export function beef(){
                return &apos;牛肉&apos;;
            }
            export function pork(){
                return &apos;猪肉&apos;;
            }

        main.js

            import { beef, pork } from &apos;meat.js&apos;;
            console.log(beef());        // 牛肉
            console.log(pork());        // 猪肉


    2、key的简写

        var fn1 = funtion(){
            console.log(&apos;fn1&apos;);
        }

        var fn2 = function(){
            console.log(&apos;fn2&apos;);
        }

        export {fn1, fn2}         // 对象名与key相同可以写成一个
</code></pre><h4 id="数据结构-Set-、Map"><a href="#数据结构-Set-、Map" class="headerlink" title="数据结构 Set()、Map()"></a>数据结构 Set()、Map()</h4><pre><code>一、Set(): 类似数组的一种新结构，成员都是唯一的值没有重复值，相当于数组去重

    # 数组去重的新方法
    let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
    console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
    let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    特性: 
        1、不允许数组里有重复数据

    方法: 
        1、set.size(): 获取数据的长度

        2、set.add(value): 添加值

        3、set.delete(value): 删除set的实例值

        4、set.has(value): 传入的参数是否为set的成员

        5、set.clear(): 删除set的所有成员


二、Map(): 传统的对象key只能为字符串, Map可以是对象和其它类型

    var map = new Map([[&apos;name&apos;, &apos;age&apos;]]);
    console.log(map);        // {name: &apos;age&apos;}

    特性: 
        不允许有重复的key值

    方法: 
        1、map.size: 成员总数

        2、map.set(&apos;key&apos;, &apos;value&apos;): 添加成员

        3、map.get(): 获取

        4、map.clear(): 清除所有
</code></pre><h4 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h4><pre><code>一、repeat(): 复制字符串  &apos;哈哈哈！&apos;.repeat(5);    复制五个&apos;哈哈哈！&apos;

二、includes()、startsWith()、endsWith(): 查找三个方法

    var str = &apos;siguang 1983&apos;;
    str.includes(&apos;o&apos;);        // 查找字符串中是否包含值，包含返回true否则返回false
    str.startsWith(&apos;s&apos;);    // 第一个字符是不是s，如果是返回true
    str.endsWith(&apos;d&apos;);        // 最后一个字符是不是 d，返回布尔值
</code></pre><h4 id="数值-Math"><a href="#数值-Math" class="headerlink" title="数值 Math"></a>数值 Math</h4><pre><code>一、trunc(): 去除小数部分

    Math.trunc(123.123123);    // 123

二、sign(): 判断是正数还是负数，如果是正数返回1，负数返回-1，0返回0

    Math.sign(-234);    // -1

三、hypot(): 返回所有参数的平方和的平方根

    Math.hypot(3,4);    // 5 勾股定理
</code></pre><h4 id="数组扩展-Array"><a href="#数组扩展-Array" class="headerlink" title="数组扩展 Array"></a>数组扩展 Array</h4><pre><code>一、form(): 将对象转成数组

    var obj = {&apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;};
    var arr =  Array.form(obj); console.log(arr);        // [a, b, c]


二、of(): 将一组值转成数组

    var arrA = new Array(1, 2, 3);    // 生成一个[1,2,3]
    var arrB = new Array(3);        // arrB.length  等于3 如果传一个参数这样会生成一个3个空值

    var arrC = Array.of(3);            // [3] 解决了new Array的问题


三、find(): 找出第一个符合条件的数据元素

    // 找出数组中值大于3的第一个数
    var arr = [1,2,3,4,5,6];
    var n = arr.find(function(value, index){
        return value &gt; 3;
    })
    console.log(n);        // 4


四、findIndex(): 找出第一个符合条件的位置，也就是所引值

五、fill(填充内容, 填充开始的位置, 填充结束的位置): 填充数组

    var arr = [1,2,3,4,5,6];
    arr.fill(7);        // 数组里全部为7
    arr.fill(7, 1, 3);    // 数组下标从1-3的值为7
    console.log(arr);


六、for...of: 遍历数组、字符串的值，但不能遍历对象

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr){
        console.log(value);        // 1,2,3,4,5,6 只能将遍历出数组的值
    }


七、keys()和values(): 返回数组的Key或value

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr.key()){
        console.log(value);
    }


八、entries(): 将数组的key和value一块输出

    var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];
    for(var [key, value] of arr.entries()){
        console.log(key, value);
    }

    返回: 
        0 &quot;a&quot;
        1 &quot;b&quot;
        2 &quot;c&quot;
        3 &quot;d&quot;
        4 &quot;e&quot;
        5 &quot;f&quot;


九、includes(): 查看数组中是否包含指定的值

    var arr = [1, 2, 3, 4, 5];
    arr.includes(3);        // true
</code></pre><h4 id="二进制数组-ArrayBuffer对象"><a href="#二进制数组-ArrayBuffer对象" class="headerlink" title="二进制数组 ArrayBuffer对象"></a>二进制数组 ArrayBuffer对象</h4><pre><code>二进制数组由三类对象组成: 

    ArrayBuffer对象: 代表原始的二进制数据。

    TypedArray视图: 用来读写简单类型的二进制数据。

    DataView视图: 用来读写复杂类型的二进制数据。


一、ArrayBuffer 对象

    它不能直接读写，只能通过（TypedArray和DataView）来读写。

    ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。

    var buf = new ArrayBuffer(32);        // 生成一段32字节的内存区域，每个字节默认为0


    属性和方法: 

    1、byteLength: 返回分配内存的字节长度

        var buffer = new ArrayBuffer(32);

        buffer.byteLength;        // 32


    2、slice(): 拷贝字节

        var buffer = new ArrayBuffer(8);

        var newBuffer = buffer.slice(0, 3);     //拷贝`buffer`对象的前三个字节（从0到3前结束），生成一个新的ArrayBuffer对象: newBuffer


    3、isView(): 返回一个布尔值，表示参数是否为ArrayBuffer的视图实例

        var buffer = new ArrayBuffer(8);
        ArrayBuffer.isView(buffer) // false

        var v = new Int32Array(buffer);
        ArrayBuffer.isView(v) // true


二、TypedArray 视图

    TypedArray数组只提供9种固定的构造函数
</code></pre><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><pre><code>新的数据类型，独一无二的值，凡是属性名属于Symbol类型，就是独一无二的

# 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();

s1 === s2         // false

# 有参数的情况
var s1 = Symbol(&apos;foo&apos;);
var s2 = Symbol(&apos;foo&apos;);

s1 === s2         // false

一、不能与其它值进行运算

    var sym = Symbol(&apos;My symbol&apos;);
    console.log(&quot;your symbol is &quot; + sym);        // 报错


二、toString()转成字符串

    let sym = Symbol(&apos;my symbol&apos;);
    sym.toString()    // &quot;Symbol(my symbol)&quot;
</code></pre><h4 id="Proxy-拦截器"><a href="#Proxy-拦截器" class="headerlink" title="Proxy 拦截器"></a>Proxy 拦截器</h4><pre><code>可以监听对象身上发生变化，对操作对象属性读取时做一个拦截器

&lt;script&gt;
    let obj = {
        a: 1,
        b: 2
    }

    // 相当于操作对象属性时的一个拦截器
    let p1 = new Proxy(obj, {
        get(obj, key) { // 获取值操作
            return obj[key];
        },
        set(obj, attr, value) { // 赋值操作

            // 这里来做拦截，如果修改的key=a 并且 value值小于10不会就将值修改
            if (attr == &apos;a&apos; &amp;&amp; value &lt; 10) {
                obj[attr] = value;
            }
        }
    })

    // 设置属性
    p1.a = 9; // {a: 9, b: 2}
    p1.a = 20; // {a: 9, b: 2}
    p1.b = 10; // {a: 9, b: 20}

    // 获取属性值
    console.log(p1.a, p1.b);    
&lt;/script&gt;
</code></pre><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><pre><code>Generator是ES6提供的异步函数，Generator可以通过yield表达式来定义步骤，通过next()来获取结果 

Example: 

    function* ouputGenerator() {
        yield &apos;hello&apos;;            // 调用后不会马上执行，只有调用next()才会返回
        yield &apos;world&apos;;
        return &apos;ending&apos;;
    }

    let gen = ouputGenerator();

    console.log(gen.next());     // {value: &quot;hello&quot;, done: false}  value就是返回值
    console.log(gen.next());     // {value: &quot;world&quot;, done: false}
    console.log(gen.next());     // {value: &quot;ending&quot;, done: true}  done为true就是后面没有yeild的定义


一、Generator的特征:

    1、function 关键字与函数名之间有一个&quot;*&quot;号

    2、函数体内有 yield 语句

    3、可以执行暂停

    4、generator也可以不用yield, 但需要执行一次next()


二、属性和方法

    1、next() 可以带一个参数，参数可以是上一个yield的返回值

        done为true 表示结束  Object {value: &quot;ending&quot;, done: true}

    2、value: 就是next返回的值，done为false表示已经结束

    3、yield: 定义表达式


三、Generator与Promise的区别

    promise如果写多个嵌套会很麻烦:

        getArticleList()
            .then(articles =&gt; getArticle(articles[0].id))
            .then(article =&gt; getAuthor(article.authorId))
            .then(author =&gt; {
                alert(author.email);
            });

        function getAuthor(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/E105pDLh&quot;,{
                    author: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticle(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/EkI02vUn&quot;,{
                    id: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticleList(){
            return new Promise(function(resolve, reject){
            $.ajax(
                &quot;http://beta.json-generator.com/api/json/get/Ey8JqwIh&quot;)
                .done(function(result){
                    resolve(result);
                }); 
            });
        }


    Generator的写法:

        function* run(){
            var articles = yield getArticleList();
            var article = yield getArticle(articles[0].id);
            var author = yield getAuthor(article.authorId);
            console.log(author.email);  
        }

        var gen = run();
        gen.next().value
            .then(articles =&gt; {
                gen.next(articles).value.then(article =&gt; {
                    gen.next(article).value.then(author =&gt; {
                    gen.next(author)
                })
            })
        })


Example:

    function* ouputGenerator() {
        console.log(&apos;调用了&apos;)        // ** 如果没执行next不会执行 ** 
    }

    var gen = ouputGenerator();

    setTimeout(()=&gt;{
        gen.next()
    }, 3000)
</code></pre><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><pre><code>async 是ES7引入的函数，使的异步变得更加方便

Generator函数执行必须靠执行器，也就是需要调next()，async函数有自带的执行器，async返回的是Promise对象

await: 命令后面是一个Promise对象

Example:

    async function getStockPriceByName(name) {
        var symbol = await getStockSymbol(name);
        var stockPrice = await getStockPrice(symbol);
        return stockPrice;
    }

    getStockPriceByName(&apos;goog&apos;).then(function (result) {
        console.log(result);
    });
</code></pre><p>| 参考资料<br>| <a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/babel.html</a><br>| <a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/style</a><br>| <a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/babel/">Babel</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/babel/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>涉及知识点</p>
<p>babel安装<br>ES6转ES5 babel-preset-es2015<br>jsx文件的转换 npm i babel-preset-react<br>.babelrc 文件配置 presets来解析<br>加UMD模块，可以自带模块代码</p>
</blockquote>
<h4 id="一、babel"><a href="#一、babel" class="headerlink" title="一、babel"></a>一、babel</h4><pre><code>1、安装：

    npm install babel-cli

    包括了: babel、babel-node、babel-core、babel-register


        1) babel-register模块改写require命令，为它加上一个钩子。require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。

            npm install --save-dev babel-register

            // 先加载babel-register，这样就会不在对index.js进行转码了
            require(&quot;babel-register&quot;);
            require(&quot;./index.js&quot;);

        2) 浏览器环境

            下载babel-core: npm install babel-core@5

            &lt;!-- 引用browser.js --&gt;
            &lt;script src=&quot;node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt;
            &lt;!-- type值为text/babel --&gt;
            &lt;script type=&quot;text/babel&quot;&gt;
                // 这里写es6的代码
            &lt;/script&gt;


2、    babel用处

    1）将ES6转成ES5代码在安装 babel-preset-es2015

        npm i babel-preset-es2015 --save-dev

        需要创建一个 .babelrc 文件
        {
              &quot;presets&quot;: [&quot;es2015&quot;]
        }

    2）babel-polyfill: 可以在在浏览器直接解析    npm i babel-polyfill --save-dev

    3）React的JSX代码: npm i babel-preset-react --save-dev

        对.babelrc文件配置
        {
              &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
        }


2、执行编译

    # babel main.js     // 将文件直接编译

    # babel main.js --out-file  main-component.js     // 将main.js编译成一个main-component.js, 缩定--out-file 写成 -o

    # babel src --out-dir build   // 将 src目录下的所有文件编译到build目录下，--out-dir简写 -d

    # babel --watch main.js --out-file main-component.js  --source-maps  // --watch 侦听文件的变化，--source-maps 会在文件打出文件的目录, 简写 -w

    # babel src --out-dir lib  // 编译目录，src目录下的所有文件进行编辑并放到lib文件夹中


3、浏览器上直接编译 browser.js

    可以直接转换，不需要执行编译命令

    1、加载需要文件
        babel-core/browser.js 
        babel-core/browser-polyfill.js     // 修补浏览器工具的，浏览器不支持的时候需要它

    2、&lt;script&gt;调用
        type中必须写成 &apos;text/babel&apos;
        &lt;script src=&quot;main.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;


4、brower-sync 创建一个server环境

    命令：brower-sync start --server
</code></pre><h4 id="二、使用模块plugins"><a href="#二、使用模块plugins" class="headerlink" title="二、使用模块plugins"></a>二、使用模块plugins</h4><pre><code>1、对模块的处理

UMD模块，可以将代码转成模块化的模式

npm install --save-dev babel-plugin-transform-es2015-modules-umd

.babelrc文件
{
    &quot;plugins&quot;: [&quot;transform-es2015-modules-umd&quot;]
}

index.js:

    export default 42;

output:

    (function (global, factory) {
        if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
            define([&quot;exports&quot;], factory);
        } 
        else if (typeof exports !== &quot;undefined&quot;) {
            factory(exports);
        } 
        else {
            var mod = {
                exports: {}
            };
            factory(mod.exports);
            global.actual = mod.exports;
        }
    })(this, function (exports) {
        &quot;use strict&quot;;

        Object.defineProperty(exports, &quot;__esModule&quot;, {
            value: true
        });

        exports.default = 42;
    });
</code></pre><h4 id="二、Balel与Gulp结合"><a href="#二、Balel与Gulp结合" class="headerlink" title="二、Balel与Gulp结合"></a>二、Balel与Gulp结合</h4><pre><code>下载gulp和gulp-bable包

npm i gulp gulp-babel --save

gulpFile:

    var gulp = require(&apos;gulp&apos;);
    var babel = require(&apos;gulp-babel&apos;);

    gulp.task(&apos;babel&apos;, function(){
        return gulp.src(&apos;./src/*.js&apos;)
            .pipe(babel())
            .pipe(gulp.dest(&apos;build&apos;))
    })

    gulp.task(&apos;default&apos;,[&apos;babel&apos;]);
</code></pre><h4 id="三、Babel与Webpack结合"><a href="#三、Babel与Webpack结合" class="headerlink" title="三、Babel与Webpack结合"></a>三、Babel与Webpack结合</h4><pre><code>下载webpack和babel需要的包

npm install babel-loader babel-core babel-preset-es2015 webpack --save-dev

webpack.config.js:

    var webpack = require(&apos;webpack&apos;);
    var path = require(&apos;path&apos;);

    module.exports = {

        /* 页面入口 - 单入口文件 */
        entry: {
            index : &apos;./src/js/webpackPackMain.js&apos;          // 单入口文件
        },

        output: {
            path: &apos;./dist/js/&apos;,
            filename: &apos;[name].min.js?[hash]&apos;            // [hash] 将文件输出后加一个hash值
        },

        //加载器配置
        module: {
            loaders: [
                &lt;!-- { test: /\.css$/, loader: &apos;style-loader!css-loader&apos;},
                { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},
                { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;}, --&gt;

                // es6转es5
                {
                    test: /\.js$/,
                    exclude: /(node_modules|bower_components)/,
                    loader: &apos;babel-loader&apos;,
                    query: {
                        presets: [&apos;es2015&apos;]
                    }
                }
            ]
        }
    };
</code></pre><h4 id="四、相关插件"><a href="#四、相关插件" class="headerlink" title="四、相关插件"></a>四、相关插件</h4><pre><code>babel-preset-es2015     将ES6编译成ES5的代码

babel-preset-react        用于React中JSX语法的转码 不需要使用jsx-loader

{
    &quot;presets&quot;: [
        &quot;es2015&quot;,
        &quot;react&quot;
    ],
    &quot;plugins&quot;: []
}
</code></pre><h4 id="五、babel-preset-stage-x"><a href="#五、babel-preset-stage-x" class="headerlink" title="五、babel-preset-stage-x"></a>五、babel-preset-stage-x</h4><pre><code>http://www.cnblogs.com/chris-oil/p/5717544.html

用于ES7的提案

这个流程分为 5（0－4）个阶段。 随着提案得到越多的关注就越有可能被标准采纳，于是他们就继续通过各个阶段，最终在阶段 4 被标准正式采纳。

以下是4 个不同阶段的（打包的）预设：

babel-preset-stage-0
babel-preset-stage-1
babel-preset-stage-2
babel-preset-stage-3

注意 stage-4 预设是不存在的因为它就是上面的 es2015 预设。

以上每种预设都依赖于紧随的后期阶段预设。例如，babel-preset-stage-1 依赖 babel-preset-stage-2，后者又依赖 babel-preset-stage-3。.

Stage 0：

    Function Bind Syntax：函数的绑定运算符
    String.prototype.at：字符串的静态方法at

Stage 1：

    Class and Property Decorators：Class的修饰器
    Class Property Declarations：Class的属性声明
    Additional export-from Statements：export的写法改进
    String.prototype.{trimLeft,trimRight}：字符串删除头尾空格的方法

Stage 2：

    Rest/Spread Properties：对象的Rest参数和扩展运算符

Stage 3

    SIMD API：“单指令，多数据”命令集
    Async Functions：async函数
    Object.values/Object.entries：Object的静态方法values()和entries()
    String padding：字符串长度补全
    Trailing commas in function parameter lists and calls：函数参数的尾逗号
    Object.getOwnPropertyDescriptors：Object的静态方法getOwnPropertyDescriptors

Stage 4：

    Array.prototype.includes：数组实例的includes方法
    Exponentiation Operator：指数运算符

使用的时候只需要安装你想要的阶段就可以了： $ npm install --save-dev babel-preset-stage-2

添加 .babelrc 配置文件。
  {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;react&quot;,
      &quot;stage-2&quot;
    ],
    &quot;plugins&quot;: []
  }
</code></pre><blockquote>
<p>参考资料</p>
<p><a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a>            // 官网</p>
</blockquote>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
