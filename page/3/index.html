<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之八）HTTP/">nodeJS（之八）HTTP</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之八）HTTP/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h4><pre><code>let http = require(&apos;http&apos;);        // 导入http模块

HTTP协议构建就是在请求和响应上，由http.ServerRequest和http.ServerResponse构造出来的。
</code></pre><h4 id="http-server类"><a href="#http-server类" class="headerlink" title="http.server类"></a>http.server类</h4><pre><code>是一个创建服务的类 ServerRequest()

方法:

    1、close([callback]): 停止服务器连接

    2、listen(path, [callback]): 侦听, 与TCP使用方法相同

属性:

    1、listening: 返回是否在监听连接服务器的布尔值

    2、maxHeadersCount: 限制最大的请求头数据，默认2000

    3、keepAliveTimeout

    3、setTimeout(msecs, callback): 为socket设置超时值，如果一个超时发生

事件

    1、connect - 请求时触发


Example:

    const HOST = &apos;127.0.0.1&apos;;
    const PORT = 3000;

    // 创建服务器
    let server = http.createServer((req, res) =&gt; {
        console.log(&apos;请求方法:&apos;, request.method);       // 请求方法
        console.log(&apos;请求url:&apos;, request.url);          // 请求url
        console.log(&apos;请求头:&apos;, request.headers);       // 请求头

        res.writeHead(200);
        res.end(&apos;hello world&apos;);    
    })            

    // 侦听3000端口
    server.listen(PORT, HOST, ()=&gt; {
        console.log(`server running at http://${hostname}:${port}`);
    })
</code></pre><h4 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h4><pre><code>url - 返回url地址

method - 返回请求方法
</code></pre><h4 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h4><pre><code>// 这里res返回的就是ServerResponse类
const server = http.createServer((req, res) =&gt; { ..... });   

方法:

    1、addTrailers(headers)

    2、end([data],[encoding],[callback]) - 告诉服务器所有响应头和主体都已被发送，等同于response.write()

    3、finished: 

    4、getHeader(name): 

    5、headersSent: 返回消息头是否被发送，发送为true否则false

    6、removeHeader(name): 移出一个头消息 response.removeHeader(&apos;Content-Encoding&apos;);

    7、sendDate: 如果设置为true消息头存在日期消息头则自动生成并且响应在发送

    8、setHeader(name, value): 设置头信息

        response.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);
        response.setHeader(&apos;Set-Cookie&apos;, [&apos;type=ninja&apos;, &apos;language=javascript&apos;]);

    9、setTimeout(msecs, callback): 设置 socket 的超时时间

    10、statusCode: 设置向客户端响应的状态码  res.statusCode = 200;

    11、statusMessage

    12、write(chunk[, encoding][, callback])

    13、writeContinue()

    14、writeHead(statusCode[, statusMessage][, headers]): 发送一个响应头给请求

        writeHead(状态码, [状态消息], {响应头信息})

        Example: res.writeHead(200, { content-Type: &apos;text/html&apos;, Connection: &apos;keep-alive&apos;})

    15、setEncoding(编码): 设置编码格式 res.setEncoding(&apos;utf8&apos;);


res.connection

事件:

    1、close - 关闭连接，会自动调用response.end();

    2、finish - 当响应已被发送时触发
</code></pre><h4 id="http-IncomingMessage-类"><a href="#http-IncomingMessage-类" class="headerlink" title="http.IncomingMessage 类"></a>http.IncomingMessage 类</h4><pre><code>const server = http.createServer((req, res) =&gt; { ..... });  就是req返回的类

1、headers: 客户端的请求头

2、method: 获取请求方式

3、url: 请求url

4、statusCode: 状态码

5、statusMessage: 状态消息

6、socket: 与连接有关的 net.Socket 对象。

7、destroy([error])

8、httpVersion: http的版本

9、rawHeaders

10、rawTrailers

11、setTimeout(msecs, callback)

12、trailers
</code></pre><h4 id="http-createServer-创建server服务"><a href="#http-createServer-创建server服务" class="headerlink" title="http.createServer(): 创建server服务"></a>http.createServer(): 创建server服务</h4><h4 id="http-get-options-callback-用来模拟客户端向服务器发送请求"><a href="#http-get-options-callback-用来模拟客户端向服务器发送请求" class="headerlink" title="http.get(options, [callback]): 用来模拟客户端向服务器发送请求"></a>http.get(options, [callback]): 用来模拟客户端向服务器发送请求</h4><pre><code>Example： 请求nodejs.org的index.json文件，返回json的内容

const http = require(&apos;http&apos;);

http.get(&apos;http://nodejs.org/dist/index.json&apos;, (res) =&gt; {
    const statusCode = res.statusCode;
    const contentType = res.headers[&apos;content-type&apos;];

    let error;
    if (statusCode !== 200) {
        error = new Error(`请求失败。\n` +
            `状态码: ${statusCode}`);
    } else if (!/^application\/json/.test(contentType)) {
        error = new Error(`无效的 content-type.\n` +
            `期望 application/json 但获取的是 ${contentType}`);
    }
    if (error) {
        console.log(error.message);
        // 消耗响应数据以释放内存
        res.resume();
        return;
    }

    res.setEncoding(&apos;utf8&apos;);
    let rawData = &apos;&apos;;
    res.on(&apos;data&apos;, (chunk) =&gt; rawData += chunk);
    res.on(&apos;end&apos;, () =&gt; {
        try {
            let parsedData = JSON.parse(rawData);
            console.log(parsedData);
        } catch (e) {
            console.log(e.message);
        }
    });
}).on(&apos;error&apos;, (e) =&gt; {
    console.log(`错误: ${e.message}`);
});
</code></pre><h4 id="http-request-options-callback-模拟HTTP请求"><a href="#http-request-options-callback-模拟HTTP请求" class="headerlink" title="http.request(options, [callback]): 模拟HTTP请求"></a>http.request(options, [callback]): 模拟HTTP请求</h4><pre><code>options:

    protocol &lt;String&gt; 使用的协议。默认为 &apos;http:&apos;。

    host &lt;String&gt; 请求发送至的服务器的域名或 IP 地址。默认为 &apos;localhost&apos;。

    hostname &lt;String&gt; host 的别名。为了支持 url.parse()，hostname 优于 host。

    family &lt;Number&gt; 当解析 host 和 hostname 时使用的 IP 地址族。 有效值是 4 或 6。当未指定时，则同时使用 IP v4 和 v6。

    port &lt;Number&gt; 远程服务器的端口。默认为 80。

    localAddress &lt;String&gt; 要绑定到网络连接的本地接口。

    socketPath &lt;String&gt; Unix 域 Socket（使用 host:port 或 socketPath 的其中之一）。

    method &lt;String&gt; 一个指定 HTTP 请求方法的字符串。默认为 &apos;GET&apos;。

    path &lt;String&gt; 请求的路径。默认为 &apos;/&apos;。 应包括查询字符串（如有的话）。如 &apos;/index.html?page=12&apos;。 
    当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。

    headers &lt;Object&gt; 一个包含请求头的对象。

    auth &lt;String&gt; 基本身份验证，如 &apos;user:password&apos; 来计算 Authorization 头。

    agent &lt;http.Agent&gt; | &lt;Boolean&gt; 控制 Agent 的行为。 当使用 Agent 是，请求默认为 Connection: keep-alive。 可能的值有：
    undefined (默认): 对该主机和端口使用 http.globalAgent。

    Agent 对象：显式地使用传入的 Agent。

    false: 不对连接池使用 Agent，默认请求 Connection: close。

    createConnection &lt;Function&gt; 当不使用 agent 选项时，产生一个用于请求的 socket/stream 的函数。 这可以用于避免创建一个自定义的 Agent 类，只是为了覆盖默认的 createConnection 函数。详见 agent.createConnection()。

    timeout &lt;Integer&gt;: 一个数值，指定 socket 超时的毫秒数。 它会在 socket 被连接时设置超时。


Example:

    var postData = querystring.stringify({
            &apos;msg&apos; : &apos;Hello World!&apos;
        });

    var options = {
        hostname: &apos;www.google.com&apos;,
        port: 80,
        path: &apos;/upload&apos;,
        method: &apos;POST&apos;,
        headers: {
            &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,
            &apos;Content-Length&apos;: Buffer.byteLength(postData)
        }
    };

    var req = http.request(options, (res) =&gt; {
        console.log(`STATUS: ${res.statusCode}`);
        console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
        res.setEncoding(&apos;utf8&apos;);
        res.on(&apos;data&apos;, (chunk) =&gt; {
            console.log(`主体: ${chunk}`);
        });
        res.on(&apos;end&apos;, () =&gt; {
            console.log(&apos;响应中已无数据。&apos;);
        });
    });

    req.on(&apos;error&apos;, (e) =&gt; {
        console.log(`请求遇到问题: ${e.message}`);
    });

    // 写入数据到请求主体
    req.write(postData);
    req.end();
</code></pre><h4 id="http概念"><a href="#http概念" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、请求方法:

    Get: 请求从服务器获取数据，没有请求体，不会影响服务器数据

    Post: 从服务器获取数据，有请求体，会影响服务器端的数据

    DELETE: 从服务器删除资源

    HEAD: 向服务器获取响应头，不要响应体

    PUT: 要新的服务器一个资源

    OPTIONS: 获取服务器支持的方法


2、文件类型 Content-type

    html: text/html

    ASCII文本: text/plain

    jpeg图片: image/jpeg

    GIF图片: image/gif

    javascript: text/javascript

    css: text/css

    表单: application/x-www-form-urlencoded



# 获取 index.html 文件内容返回给客户端

    var http = require(&apos;http&apos;);
    var fs = require(&apos;fs&apos;);

    exports.createServer2 = function(){
        var server = http.createServer(function(request, response){

            var url = request.url;

            // 获取 index.html 文件内容返回给客户端
            fs.readFile(&apos;./index.html&apos;, &apos;utf-8&apos;, function(err, data){
                console.log(err, data);

                response.write(data);
                response.end();
            })
        });

        server.listen(8081, &apos;localhost&apos;);
    }


# 处理Get请求的参数

    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url, true);

        console.log(oUrl.query);        // { username: &apos;siguang&apos;, age: &apos;30&apos; }

        var urlQuery = oUrl.query;
        if(urlQuery){
            response.write(&apos;服务器接收GET请求参数成功\n&apos;)
            response.write(&apos;用户名:&apos;+ urlQuery.username +&apos;\n&apos;);
            response.write(&apos;年级:&apos;+ urlQuery.age +&apos;\n&apos;);
        }
        else{
            response.write(&apos;服务器接收参数失败&apos;);
        }
        response.end();
    });

    server.listen(8081, &apos;localhost&apos;);


# 处理POST请求

    if(urlObj.pathname == &apos;/register&apos;){           // 处理 &apos;/clock&apos; 的请求
        var str = &apos;&apos;;
        var userList = {};

        // 通过on来侦听 data事件, data事件就是接收客户端传输过来的事件, 用可接收post的数据
        request.on(&apos;data&apos;, function(data){
            console.log(data.toString());          // 返回的是 Buffer
            str += data.toString();
        })

        // 所有接收完成后处理接收数据
        request.on(&apos;end&apos;, function(data){
            userList = JSON.parse(str);

            response.writeHead(&apos;200&apos;, {&apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;});
            if(userList.username == &apos;aaa&apos; &amp;&amp; userList.password == &apos;ssssss&apos;){
                 response.end(JSON.stringify({&quot;res&quot;:true,&quot;message&quot;:&quot;注册成功&quot;}));        // 这里一定要用JSON.stringify来转成串
            }
            else{
                response.end(JSON.stringify({&apos;res&apos;:false,&apos;message&apos;:&apos;注册失败&apos;}));
            }
            response.end();
        })
    }

    注意：

        1、客户端发送ajax请求时

            如果data是字符串，接收过来就是 &apos;{&apos;username&apos;: &apos;aaa&apos;, &apos;password&apos;: &apos;ssssss&apos;}&apos; 字符串可以直接转成json,

            如果data传的是一个对象，jquery会转成&quot;{&apos;username&apos;=&apos;aaa&apos;&amp;&apos;password&apos;=&apos;ssssss&apos;}&quot;, 还需要node重组
</code></pre><h4 id="http概念-1"><a href="#http概念-1" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、up 工具 通过nodeAPI来监听文件或目录下所有文件，如果有文件改变不需要重启服务器

    $ sudo npm i up -g   

    运行命令: up -watch -port 8080 server.js 
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之九）Connect中间件/">nodeJS（之九）Connect中间件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之九）Connect中间件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><pre><code>Connect是HTTP服务的中间件

$ 安装 npm i connect --save


// 引用模块
var connect = require(&apos;connect&apos;);

// 创建服务器
var server = connect.createServer();

// 处理静态文件
server.use(connect.static(__dirname + &apos;/statice&apos;));     // connect.static 静态文件目录

// 监听
server.listen(3000);
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>1、静态目录设置 -  server.use(connect.static(__dirname + &apos;/statice&apos;));

2、客户端缓存时间 -  server.use(connect.static(__dirname + &apos;/statice&apos;), {maxAge: 100000});

3、静态文件以&quot;.&quot;开始都认为是隐藏文件 - server.use(connect.static(__dirname + &apos;/statice&apos;), {hidden: true});

4、query中间件，解析字符串  &apos;/posts?page=5&apos;

    server.use(connect.query);
    server.use(function(req, res){
        let page = req.query.page;
    })

5、logger，打印日志，四种日志格式，default/dev/short/tiny

    connect.createServer(
        connect.logger(&apos;dev&apos;),
        function(req, res){
            res.writeHead(200);
            res.end(&apos;hello);
        }
    )

7、body parser  文件上传
</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><pre><code>使用cookieParser()

// cookie: secret1=val1; secret2=val2

server.use(cookieParser());
server.use(function(req, res){
    let ser1 = req.cookies.secret1;
    let ser2 = req.cookies.secret2;
})
</code></pre><h4 id="session-会话"><a href="#session-会话" class="headerlink" title="session 会话"></a>session 会话</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之五）Path/">nodeJS基 (之五) Path模块</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之五）Path/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| baseName() - 返回文件名，带扩展<br>| dirname() - 返回一个指定的绝对路径<br>| join() - 两个路径进行拼接<br>| extname() - 返回文件的扩展名<br>| isAbsolute() - 是否是一个绝对路径<br>| resolve() - 把路径解析成一个绝对路径<br>| format() - 从配置中返回一个路径<br>| parse() - 拆分一个路径，与format相反</p>
<h4 id="baseName-返回文件名-带扩展名"><a href="#baseName-返回文件名-带扩展名" class="headerlink" title="baseName(): 返回文件名(带扩展名)"></a>baseName(): 返回文件名(带扩展名)</h4><pre><code>let name = path.basename(&apos;./resource/haha.txt&apos;, &apos;.txt&apos;);    // 返回 haha
let allName = path.basename(&apos;./resource/haha.txt&apos;);         // 返回 haha.txt
</code></pre><h4 id="dirname-返回一个path目录"><a href="#dirname-返回一个path目录" class="headerlink" title="dirname() 返回一个path目录"></a>dirname() 返回一个path目录</h4><pre><code>let pathName = path.dirname(&apos;./&apos;);
console.log(pathName, __dirname);
</code></pre><h4 id="extname-fileStr-返回文件的扩展名"><a href="#extname-fileStr-返回文件的扩展名" class="headerlink" title="extname(fileStr) 返回文件的扩展名"></a>extname(fileStr) 返回文件的扩展名</h4><pre><code>let extension = path.extname(&apos;权限申请.xlsx&apos;);
console.log(extension);        // .xlsx
</code></pre><h4 id="isAbsolute-path-判断path是否是一个绝对路径"><a href="#isAbsolute-path-判断path是否是一个绝对路径" class="headerlink" title="isAbsolute(path) 判断path是否是一个绝对路径"></a>isAbsolute(path) 判断path是否是一个绝对路径</h4><pre><code>var absolutePath =  path.isAbsolute(&apos;./ss&apos;);
var notAbsolutePath = path.isAbsolute(&apos;/Users/apple/&apos;)
console.log(absolutePath);      // false
console.log(notAbsolutePath);   // true
</code></pre><h4 id="join-paths-多个路径拼接成一个路径"><a href="#join-paths-多个路径拼接成一个路径" class="headerlink" title="join(paths) 多个路径拼接成一个路径"></a>join(paths) 多个路径拼接成一个路径</h4><pre><code>let pathStr = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;);
let parentDirectory = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;, &apos;..&apos;);    // ..减少一级目录
console.log(pathStr);           // /foo/bar/bar/asdf/quux
console.log(parentDirectory);   // /foo/bar/bar/asdf
</code></pre><h4 id="resolve-p1-p2-把路径解析为一个绝对路径"><a href="#resolve-p1-p2-把路径解析为一个绝对路径" class="headerlink" title="resolve(p1, p2) 把路径解析为一个绝对路径"></a>resolve(p1, p2) 把路径解析为一个绝对路径</h4><pre><code>var newPath = path.resolve(__dirname, &apos;sss.txt&apos;);
console.log(newPath);
</code></pre><h4 id="format-pathobject-从配置对象返回一个路径字符串"><a href="#format-pathobject-从配置对象返回一个路径字符串" class="headerlink" title="format(pathobject) 从配置对象返回一个路径字符串"></a>format(pathobject) 从配置对象返回一个路径字符串</h4><pre><code>let basePath = path.format({
    root: &apos;/book&apos;,
    dir: &apos;/home/user/dir&apos;,
    base: &apos;file.txt&apos;
})
console.log(basePath);      // output -&gt;  /home/user/dir/file.txt
</code></pre><h4 id="parse-path-将一个路径拆分与format相反"><a href="#parse-path-将一个路径拆分与format相反" class="headerlink" title="parse(path) 将一个路径拆分与format相反"></a>parse(path) 将一个路径拆分与format相反</h4><pre><code>let pathStr = path.parse(__dirname);
console.log(pathStr);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之一）Global全局/">nodeJS基 (之一) Global全局对象</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之一）Global全局/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| <strong>filename - 前当文件名<br>| </strong>dirname - 当前所在的目录<br>| setTimeout、clearTimeout - 定时器<br>| setInterval、clearInterval - 定时器<br>| console - 打印到控制台<br>| process - 进程<br>| exports、require() - 导入、导出<br>| </p>
<h4 id="dirname-当前的绝对路径"><a href="#dirname-当前的绝对路径" class="headerlink" title="__dirname  当前的绝对路径"></a>__dirname  当前的绝对路径</h4><h4 id="filename-当前文件名"><a href="#filename-当前文件名" class="headerlink" title="__filename  当前文件名"></a>__filename  当前文件名</h4><h4 id="exports-暴露接口"><a href="#exports-暴露接口" class="headerlink" title="exports  暴露接口"></a>exports  暴露接口</h4><h4 id="require-引入模板"><a href="#require-引入模板" class="headerlink" title="require()  引入模板"></a>require()  引入模板</h4><pre><code>1、模块分为

    模块加载：require(&apos;2.js&apos;);

    1）内置模块:  var fs = require(&apos;fs&apos;);        // 加载Node的内置模块 fs文件系统

    2）文件模块: 自己定义的业务模块

        定义一个food.common.js

        var food = reuqire(&apos;./js/food.common&apos;);        // 加载业务模块

    3）加载第三方模块

        require(&apos;./2&apos;);        // 先按照加载的模块文件进行查找，如果没有找到会在文件名加上.js


2、绝对和相对路径

    var fs = require(&apos;fs&apos;);        // 绝对路径，是在Node通过内部的node_modules查找到的模块

    var moduleA = reuqire(&apos;./lib/moduleA&apos;);        // 相对路径


2、npm 全局安装和局部安装

    1）全局安装会安装到Node目录中，各项目都可以使用 npm install -g gulp

    2）局部安装，将一个模块安装到node_modules中，只在当前和子目录中使用


require.cache
require.resolve()
</code></pre><h4 id="global-全局对象"><a href="#global-全局对象" class="headerlink" title="global  全局对象"></a>global  全局对象</h4><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><pre><code>module和exports两个全局变量

1）module：每个模块下都包括module对象

    Module {
        id: &apos;.&apos;,
        exports: {},
        parent: null,
        filename: &apos;/Users/apple/siguang.liu/nodeProject/server.js&apos;,
        loaded: false,
        children: [],
        paths: [
            &apos;/Users/apple/siguang.liu/nodeProject/node_modules&apos;,
            &apos;/Users/apple/siguang.liu/node_modules&apos;,
            &apos;/Users/apple/node_modules&apos;,
            &apos;/Users/node_modules&apos;,
            &apos;/node_modules&apos;
        ]
     }

 2）exports外部接口，通过require就可以调用这个接口

     其实exports就是module.exports的引用

    exports.name = &apos;siguang&apos;;
    exports.getPrivate = function(){
        return &apos;haha&apos;;
    }
</code></pre><h4 id="process-进程"><a href="#process-进程" class="headerlink" title="process  进程"></a>process  进程</h4><h4 id="console-打印到控制台"><a href="#console-打印到控制台" class="headerlink" title="console 打印到控制台"></a>console 打印到控制台</h4><pre><code>log()、info()、error()、warn()、time()、timeEnd()
</code></pre><h4 id="setImmediate-callback-…args-、clearImmediate-immediateObject"><a href="#setImmediate-callback-…args-、clearImmediate-immediateObject" class="headerlink" title="setImmediate(callback[, …args])、clearImmediate(immediateObject)"></a>setImmediate(callback[, …args])、clearImmediate(immediateObject)</h4><h4 id="setInterval-、clearInterval"><a href="#setInterval-、clearInterval" class="headerlink" title="setInterval()、clearInterval()"></a>setInterval()、clearInterval()</h4><h4 id="setTimeout-、clearTimeout"><a href="#setTimeout-、clearTimeout" class="headerlink" title="setTimeout()、clearTimeout()"></a>setTimeout()、clearTimeout()</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJs（之二）FileSystem/">nodeJS (之二) FileSystem</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJs（之二）FileSystem/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| open() - 打开文件<br>| close() - 关闭文件<br>| stat() - 文件信息<br>| read()、write() - 读文件数据并写入Buffer<br>| readFile()、readFileSync() - 读、写取文件，可以读图片并写出图片，但不能写流文件<br>| createReadStream()、createWriteStream() - 读/写文件流<br>| rename()、renameSync() - 修改文件或目录<br>| ftruncate() - 截断文件<br>| appendFile() - 将数据追加到文件中<br>| mkdir() - 创建/删除目录<br>| rmdir() - 删除空目录<br>| readDir()、readdirSync() - 读取目录下所有文件<br>|<br>| stat() - 文件信息<br>| utimes() - 修改文件时间<br>| watchFile() - 监视文件<br>| access() - 判断文件或目录权限<br>| link() - 硬链接<br>| unlink() - 删除文件链接<br>| symlink() - 符号链接<br>| readlink() - 读取链接源地址<br>| watchFile()、watch() - 侦听文件/文件夹内文件的变化 </p>
<h4 id="fs-模块引用"><a href="#fs-模块引用" class="headerlink" title="fs 模块引用"></a>fs 模块引用</h4><pre><code>var fs = reuqire(&apos;fs&apos;);        // 加载文件模块

文件系统方法有异步和同步两种

1、readFile()与createReadStream()区别

    readFile是整个文件都读取完后在载入内存中，createReadStream()分片来读取内容块，直接读取完成，缓存与文件流的区别
</code></pre><h3 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h3><h4 id="open-异步打开文件"><a href="#open-异步打开文件" class="headerlink" title="open() 异步打开文件"></a>open() 异步打开文件</h4><pre><code>open(文件路径， 打开方式（读/写），设置模式（读4/写2/执行1）, callback(err, fd文件句柄)): 异步打开文件

    打开方式: r 读、 w 写

opensync(): 同步打开文件

Example:

    const fileName = path.resolve(__dirname, &apos;test.txt&apos;);
    fs.open(fileName, &apos;r&apos;, (err, fd) =&gt; {
        console.log(err);
        fs.close();
    })
</code></pre><h4 id="close-关闭一个文件"><a href="#close-关闭一个文件" class="headerlink" title="close() 关闭一个文件"></a>close() 关闭一个文件</h4><pre><code>fs.close(fd, callback)
</code></pre><h4 id="read-指定的文件中读取数据，并写入缓存区buffer"><a href="#read-指定的文件中读取数据，并写入缓存区buffer" class="headerlink" title="read() 指定的文件中读取数据，并写入缓存区buffer"></a>read() 指定的文件中读取数据，并写入缓存区buffer</h4><pre><code>read(fd, buffer, offset, length, position, callback): 读文件

// read(路径, 指定存到的缓存区, buf的开始, buf的结束, 文件读取的起启位置, callback)

Example: 
    var buf = new Buffer(6);
    fs.open(path.resolve(basePath, &apos;append.txt&apos;), &apos;r&apos;, (err, fd) =&gt; {
        if(err){
            console.log(err);
            return false;
        }

        fs.read(fd, buf, 0, buf.length, 3, (err, bytesRead, buffer) =&gt; {
            var str = new Buffer(buffer);
            console.log(str.toString())
            console.log(&apos;bytesRead : &apos; + bytesRead);
        })
    })
</code></pre><h4 id="write-指定的文件中写数据"><a href="#write-指定的文件中写数据" class="headerlink" title="write() 指定的文件中写数据"></a>write() 指定的文件中写数据</h4><pre><code>fs.write(fd, buffer, offset, length, position, callback)
</code></pre><h4 id="readFile-读取文件"><a href="#readFile-读取文件" class="headerlink" title="readFile() 读取文件"></a>readFile() 读取文件</h4><pre><code>readFile(&apos;filename&apos;, [编码方式], callback): 读取文件(异步) , readFileSync同步读取文件

缺点: readFile()是先将数据全部读入内存，文件大时候，读取效率低下，而createReadStream会把文件分割成小块，然后通过事件和来最后得到数据

*注意*: 编码方式不设置返回的是Buffer, 如果设置了utf-8返回的是字符串

Example:
    fs.readFile(&apos;./nodeJS学习笔记.txt&apos;, &apos;utf-8&apos;, function(err, data){
        if(err){
            console.log(&apos;文件读取错误&apos;)
        }
        else{
            var buf = new Buffer(data);        // 将读取到的数据转成Buffer
            console.log(buf.toString());    // 二进制转成字符串
        }                
    })
</code></pre><h4 id="writeFile-向文件写内容"><a href="#writeFile-向文件写内容" class="headerlink" title="writeFile() 向文件写内容"></a>writeFile() 向文件写内容</h4><pre><code>可以使用readFile读图片并写出图片，但不能写流文件

writeFile(filename, data, [flag], callback(err)err不为真写入成功) 向文件写内容，文件不存在自动创建文件

writeFileSync同步

    filename: 路径加文件名, 如果文件不存在会创建一个文件**
    data: 写入的内容可以是字符串或二进制
    flag: 对文件怎么来操作,  &apos;w&apos; 清空后在写入  &apos;a&apos; 将新内容加到之后  {flag: &apos;w&apos;}
    writeFileSync(&apos;文件名&apos;, &apos;内容&apos;): 同步写文件

Example: 
    var writeBuf = new Buffer(writeStr);

    fs.writeFile(&apos;./buffer/file/user.txt&apos;, writeStr, {flag: &apos;a&apos;}, function(err){
        err ? console.log(&apos;文件写入失败&apos;) : console.log(&apos;文件写入成功&apos;);
    })
</code></pre><h4 id="createReadStream-path-options-读取文件流"><a href="#createReadStream-path-options-读取文件流" class="headerlink" title="createReadStream(path, [options]): 读取文件流"></a>createReadStream(path, [options]): 读取文件流</h4><pre><code>fs模块允许你通过Stream来对数据进行读取操作，与readFile、writeFile不同是它对内存分配不是一次完成的.

options:
    { 
        flags: &apos;r&apos;,            // r只读 w写
        encoding: null,        // 字符编码 utf-8
        fd: null,
        mode: 0666,
        autoClose: true,    // 读完数据是否关闭文件描述符
        start: 0,            // 读取流的开始
        end: 300            // 读取流的结束
    }

Example: 
    var fs = require(&apos;fs&apos;);
    var rs = fs.createReadStream(path.resolve(basePath, &apos;test.txt&apos;), {statr:100});
    var str = &apos;&apos;;        // 存储读取的数据

    // 读取数据
    rs.on(&apos;data&apos;, (data)=&gt;{
        str += data;
    })

    // 数据读取完成
    rs.on(&apos;end&apos;, ()=&gt;{
        console.log(&apos;读取完成&apos;)
        console.log(str);            // 打印出读取数据
    })

    // 读取出错
    rs.on(&apos;error&apos;, (err) =&gt; {
        console.log(err);
    })
</code></pre><h4 id="createWriteStream-文件路径-options-可写数据流"><a href="#createWriteStream-文件路径-options-可写数据流" class="headerlink" title="createWriteStream(文件路径, {options}): 可写数据流"></a>createWriteStream(文件路径, {options}): 可写数据流</h4><pre><code>write(): 写入内容, 把文件内容清空后在写入

end(): 关闭写入

    var fs = require(&apos;fs&apos;);
    var ws = fs.createWriteStream(&apos;./files/stream.txt&apos;);

    // 写入内容
    ws.write(&apos;内容加入到文件中&apos;, &apos;utf-8&apos;, function(){
        console.log(arguments);
    })
    ws.end(function(){

    })
</code></pre><h4 id="rename-修改文件或目录名"><a href="#rename-修改文件或目录名" class="headerlink" title="rename() 修改文件或目录名"></a>rename() 修改文件或目录名</h4><pre><code>rename(oldPath, newPath, callback) 修改文件或目录名, renameSync同步

Example: 
    let oldName = path.resolve(basePath, &apos;newTest.txt&apos;);
    let newName = path.resolve(basePath, &apos;test.txt&apos;);
    fs.rename(oldName, newName, (err) =&gt; {
        if(err){
            console.log(err);
        }
        console.log(&apos;文件名修改成功&apos;)
    })
</code></pre><h4 id="ftruncate-截断文件"><a href="#ftruncate-截断文件" class="headerlink" title="ftruncate() 截断文件"></a>ftruncate() 截断文件</h4><pre><code>ftruncate(文件路径, 第几个字符截断, callback) 截断文件， ftruncateSync同步

一个中文四个字节，英文两个字节

Example: 
    const basePath = __dirname;
    fs.open(path.resolve(basePath, &apos;test.txt&apos;), &apos;r+&apos;, (err, fd)=&gt;{
        if(err){
            console.log(err);
        }
        else{
            fs.truncate(fd, 400, (err)=&gt;{        // 截取四百个字节
                var readNewFile = fs.readFile(fd, &apos;utf8&apos;, (err, data)=&gt;{    // 读取文件
                    var buf = new Buffer(data);
                    console.log(buf.toString(&apos;utf-8&apos;));        //
                    fs.close();
                });
            })
        }
    })
</code></pre><h4 id="appendFile-将数据追加到文件中"><a href="#appendFile-将数据追加到文件中" class="headerlink" title="appendFile(): 将数据追加到文件中"></a>appendFile(): 将数据追加到文件中</h4><pre><code>appendFile(文件名, 加入内容): 异步地追加数据到一个文件，如果文件不存在则创建文件，与writeFile()中设置flag: &apos;a&apos; 一样

Example: 
    fs.appendFile(path.resolve(basePath, &apos;append.txt&apos;), &apos;这是要加入的字符串&apos;, (err) =&gt; {
        console.log(&apos;complate&apos;);
    })
</code></pre><h3 id="二、操作目录"><a href="#二、操作目录" class="headerlink" title="二、操作目录"></a>二、操作目录</h3><h4 id="mkdir-目录名-callback-err-、rmdir-创建-删除目录"><a href="#mkdir-目录名-callback-err-、rmdir-创建-删除目录" class="headerlink" title="mkdir(目录名, callback(err))、rmdir(): 创建/删除目录"></a>mkdir(目录名, callback(err))、rmdir(): 创建/删除目录</h4><pre><code>fs.mkdir(&apos;js/lib&apos;, function(err){        // 可以连续创建子目录， 先创建js，并在js目录下在创建lib目录
    console.log(err)
})
</code></pre><h4 id="rmdir-path-callback-删除空目录"><a href="#rmdir-path-callback-删除空目录" class="headerlink" title="rmdir(path, callback): 删除空目录"></a>rmdir(path, callback): 删除空目录</h4><h4 id="readdir-path-callback-err-files-获取目录下所有文件"><a href="#readdir-path-callback-err-files-获取目录下所有文件" class="headerlink" title="readdir(path, callback(err, files)): 获取目录下所有文件"></a>readdir(path, callback(err, files)): 获取目录下所有文件</h4><pre><code>eaddirSync()同步

files: 将目录下所有文件返回一个数组

fs.readdir(basePath, &apos;utf-8&apos;, (err, files) =&gt; {
    if(err){
        console.log(&apos;文件目录获取失败&apos;, err);
    }
    else{
        files.forEach(function(data){
            var buf = new Buffer(data);
            console.log(buf);       // 输出文件名的二进制
        })
    }
})
</code></pre><h3 id="三、文件权限"><a href="#三、文件权限" class="headerlink" title="三、文件权限"></a>三、文件权限</h3><h4 id="chown-文件所有者变更"><a href="#chown-文件所有者变更" class="headerlink" title="chown() 文件所有者变更"></a>chown() 文件所有者变更</h4><pre><code>fs.chown(文件名,uid,gid,回调函数);
fs.fchown(文件句柄fd,uid,gid,回调函数);
fs.lchown(链接路径,uid,gid,回调函数);    
</code></pre><h4 id="chmod-文件权限变更"><a href="#chmod-文件权限变更" class="headerlink" title="chmod()文件权限变更"></a>chmod()文件权限变更</h4><pre><code>fs.chmod(文件名,mode,回调函数);
fs.fchmod(文件句柄,mode,回调函数);
fs.lchmod(链接路径,mode,回调函数);
</code></pre><h4 id="stat-文件信息"><a href="#stat-文件信息" class="headerlink" title="stat() 文件信息"></a>stat() 文件信息</h4><pre><code>也可以判断文件是否存在

fs.stat(文件路径, 回调函数(err.fs.Stats对象)); 获取文件或目录下的文件详情
fs.fstat(文件句柄fd, 回调函数(err.fs.Stats对象)); 显示文件或文件系统状态
fs.lstat(链接路径, 回调函数(err.fs.Stats对象)); 显示文件或文件系统状态(符号链接)

stat(path, callback(err, stats)): 获取文件详情， statSync同步

    fs.stat(`${dir}/img/readText.txt`, function (err, stats) {
        console.log(stats);                    // stats类
        console.log(stats.isFile());        // true
    })

    stats.isFile() - 是否是文件
    stats.isDirectory() - 是否是目录
    stats.isBlockDevice() - 是否是块设备
    stats.isCharacterDevice() - 是否是是字符
    stats.isSymbolicLink() (仅对 fs.lstat() 有效) - 是否是软链接
    stats.isFIFO() - 是不是FIFO
    stats.isSocket() - 是不是Socket


Example: fileSystem目录下有两个文件， a.txt、main.js

    fs.readdir(&apos;./fileSystem&apos;, function(err, files){
        files.forEach(function(file){
            console.log(file)
            fs.stat(&apos;./fileSystem/&apos;+file, function(erro, stats){
                console.log(&apos;是否是目录:&apos; + stats.isDirectory());
                console.log(&apos;是否是文件:&apos; + stats.isFile());
                console.log(stats);      // 输出所有文件的详情
            })
        })
    })
</code></pre><h4 id="utimes-修改文件时间"><a href="#utimes-修改文件时间" class="headerlink" title="utimes() 修改文件时间"></a>utimes() 修改文件时间</h4><pre><code>fs.utimes(文件路径,访问时间,新建时间,回调函数);
fs.futimes(文件句柄,访问时间,新建时间,回调函数);      
</code></pre><h4 id="watchFile-监视文件"><a href="#watchFile-监视文件" class="headerlink" title="watchFile()监视文件"></a>watchFile()监视文件</h4><pre><code>fs.watchFile(文件名,[options],listener_callback(当前文件的stats,改变前的stats));      
fs.unwatchFile(文件名);
</code></pre><h4 id="access-path-mode-callback-也是判断文件或目录的权限"><a href="#access-path-mode-callback-也是判断文件或目录的权限" class="headerlink" title="access(path, [mode], callback): 也是判断文件或目录的权限"></a>access(path, [mode], callback): 也是判断文件或目录的权限</h4><pre><code>fs.constants.F_OK - path 文件对调用进程可见。 这在确定文件是否存在时很有用，但不涉及 rwx 权限。 如果没指定 mode，则默认为该值。
fs.constants.R_OK - path 文件可被调用进程读取。
fs.constants.W_OK - path 文件可被调用进程写入。
fs.constants.X_OK - path 文件可被调用进程执行。 对 Windows 系统没作用（相当于 fs.constants.F_OK）
</code></pre><h3 id="四、链接文件操作"><a href="#四、链接文件操作" class="headerlink" title="四、链接文件操作"></a>四、链接文件操作</h3><h4 id="创建一个硬链接"><a href="#创建一个硬链接" class="headerlink" title="创建一个硬链接"></a>创建一个硬链接</h4><pre><code>fs.link(srcpath, dstpath, [callback]): 硬链接 

fs.symlink(destination, path, [type], [callback]): 符号链接
</code></pre><h4 id="读取链接指向的路径"><a href="#读取链接指向的路径" class="headerlink" title="读取链接指向的路径"></a>读取链接指向的路径</h4><pre><code>fs.readlink(path, [callback(err,linkstr)]): 读取链接源地址 

fs.unlink(path,[callback]); 删除文件链接
</code></pre><h4 id="watchFile-、watch-侦听文件-文件夹内的文件的变化"><a href="#watchFile-、watch-侦听文件-文件夹内的文件的变化" class="headerlink" title="watchFile()、watch(): 侦听文件/文件夹内的文件的变化"></a>watchFile()、watch(): 侦听文件/文件夹内的文件的变化</h4><pre><code>unwatchFile(): 停止侦听

// 侦听文件
fs.watch(&apos;./buffer/file/password.txt&apos;, {encoding: &apos;buffer&apos;}, (eventType, filename) =&gt; {
    console.log(eventType, filename);
    if (filename){
        console.log(filename);
    }
});

// 向password.txt写内容
fs.writeFile(&apos;./buffer/file/password.txt&apos;, &apos;添加新内容&apos;, {flag: &apos;a&apos;}, function(err, data){
    if(!err){
        console.log(&apos;写入成功&apos;);
    }
})
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之十）TCP/">nodeJS（之十）TCP</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之十）TCP/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><pre><code>NodeJS中有三种socket: 1、TCP   2、UDP   3、Unix域套接字

TPC套接字分为: 服务端和客户端

    服务端TCP监听来自客户端的连接请求，并使用TCP连接向客户端发送数据；客户端TCP连接到服务端并与服务器交互数据。客户端与服务端之间依靠套接字进行双向通信。

1、引用TCP模块

    const net = require(&apos;net&apos;);
    const PROT = 6969;

2、HTTP模块也是继承TCP模块
</code></pre><h4 id="net-Server类"><a href="#net-Server类" class="headerlink" title="net.Server类"></a>net.Server类</h4><pre><code>1、createServer() 创建tcp服务器

2、close() - 关闭

3、listen() - 侦听

    const HOST = &apos;127.0.0.1&apos;;
    const PORT = 6969;

    // 写法1 
    let server = net.crateServer(function(conn){
        ...
    });
    server.listen({host: HOST, port: PORT}, function(){    // 或 server.listen(PORT, HOST, function(){
        console.log(&apos;这里是异步的&apos;);
    });

    // 写法2
    let server = net.crateServer(function(conn){
        ...
    }).listen(PORT, HOST);


4、address() - 返回绑定的IP端口等信息 {&quot;address&quot;:&quot;::&quot;,&quot;family&quot;:&quot;IPv6&quot;,&quot;port&quot;:6969}

属性

1、listening - server是否正在监听连接

2、maxConnections - 当前server连接数过多时拒绝连接


事件

1、close - 关闭

2、connection - 建立连接时触发

3、error - 错误时触发

4、listening - 服务被绑定后调用
</code></pre><h4 id="net-Socket类"><a href="#net-Socket类" class="headerlink" title="net.Socket类"></a>net.Socket类</h4><h4 id="net-connect"><a href="#net-connect" class="headerlink" title="net.connect"></a>net.connect</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/01/10/Sass/">Sass</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/01/10/Sass/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-01-10T10:10:21.000Z" itemprop="datePublished">2017-01-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Sass/">Sass</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 知识点<br>| 变量 - $声明  !default默认值  全局和局部变量<br>| 嵌套 - 选择器嵌套、属性嵌套、伪类嵌套<br>| 宏 - @mixin声明宏、@include调用宏、宏可以加参数<br>| 继承 - @extend来承继一个class<br>| 占位符 - %mt5定义，@extend来调用<br>| 插值 - #{}<br>| 函数<br>| Sass规则 - @imponrt，@media<br>| 自定义函数 - @function 函数名<br>| Sass语句 - @if、@else，@for，@while<br>| 运算 - +、-、*、/</p>
<h4 id="关于SASS"><a href="#关于SASS" class="headerlink" title="关于SASS"></a>关于SASS</h4><pre><code>Sass是CSS预处理器定义了一种新的语言

sass的扩展名为 .sass 老版本 控制缩进不需要使用 {} 或 ;     // 类似jade

sass的扩展名为 .scss 新版本 与正常css写法相同

其它预处理:

    Sass（SCSS）
    LESS
    Stylus
    Turbine
    Swithch CSS
    CSS Cacheer
    DT CSS
</code></pre><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><pre><code>一、$ 声明变量

    1、作为值使用
        $color: &apos;#ccc&apos;;
        .test{
            background-color: $color;        // 调用
        }

    2、作为属性名使用
        $side : left;
        .rounded {
            border-#{$side}-radius: 5px;    // 输出 border-left-radius: 5px
        }

二、!default 默认变量使用

    默认值在组件中很有作用

    $baseLineHeight: 2;
    $baseLineHeight: 1.5 !default;            // 在没有定义baseLineHeight值时，执行1.5的默认值
    body{
        line-height: $baseLineHeight;    // line-hgiht: 2;
    }

三、全局变量和局布变量

    // 全局变量定义
    $color: orange !default;        
    .block {
        color: $color;
    }

    // 局部变量定义
    em {
        $color: red;
        a {
            color: $color;
        }
    }
</code></pre><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><pre><code>一、选择器嵌套

    nav {
        a {
            color: red;

            header &amp; {
                color:green;
            }
        }  
    }
    输出:
        nav a { color: red; }
        header nav a { color: green; }

    nav {
        a {
            color: red;

            header &amp; {
                color:green;
            }
        }  
    }
    输出:
        .nav a { color: red }
        .header .nav a { color:green }


二、属性嵌套

    .box {
        border: {
            top: 1px solid red;
            bottom: 1px solid green;
        }
    }
    输出: .box {  border-top: 1px solid red; border-bottom: 1px solid green; }


三、伪类嵌套

    .clearfix{
        &amp;:before,
        &amp;:after {
            content:&quot;&quot;;
            display: table;
        }
        &amp;:after {
            clear:both;
            overflow: hidden;
        }
    }

    输出
    clearfix:before, .clearfix:after {
        content: &quot;&quot;;
        display: table;
    }
    .clearfix:after {
        clear: both;
        overflow: hidden;
    }
</code></pre><h4 id="混合宏和声明混合宏"><a href="#混合宏和声明混合宏" class="headerlink" title="混合宏和声明混合宏"></a>混合宏和声明混合宏</h4><pre><code>宏相当将一些属性封装到一个宏中，类似函数可重复利用

一、使用“@mixin”声明一个混合宏

    @mixin border-radius {
        -webkit-border-radius: 5px;
        border-radius: 5px;
    }

    .text { 
        @include border-radius            /* 调用宏 */
    }


二、定义带参数的宏

    @mixin border-radius($radius:5px){        // 定义一个默认值为5px
        -webkit-border-radius: $radius;
        border-radius: $radius;
    }

    .text { 
        @include border-radius(10px)         // 调用
    }


带逻辑运算符

    @mixin box-shadow($shadow...) {
        @if length($shadow) &gt;= 1 {
            @include prefixer(box-shadow, $shadow);
        } 
        @else{
            $shadow:0 0 4px rgba(0,0,0,.3);
            @include prefixer(box-shadow, $shadow);
        }
    }
</code></pre><h4 id="扩展和继承"><a href="#扩展和继承" class="headerlink" title="扩展和继承"></a>扩展和继承</h4><pre><code>继承是可以直接继承一个class类下所有的属性,

@extend .className;

.btn {
    border: 1px solid #ccc;
    padding: 6px 10px;
    font-size: 14px;
}

.btn-primary {
    background-color: #f36;
    color: #fff;
    @extend .btn;
}

.btn-primary-2 {
    background-color: #f36;
    color: #fff;
    font-size: 16px;
    @extend .btn;
}


结果:
.btn, .btn-primary, .btn-primary-2 {
    border: 1px solid #ccc;
    padding: 6px 10px;
    font-size: 14px; 
}

.btn-primary {
    background-color: #f36;
    color: #fff; 
}

.btn-primary-2 {
    background-color: #f36;
    color: #fff;
    font-size: 16px; 
}
</code></pre><h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><pre><code>定义占位符 %名称 , 调用使用@extend

%mt5 {
    margin-top: 5px;
}
%pt5{
    padding-top: 5px;
}

.btn {
    @extend %mt5;
    @extend %pt5;
}
.block {
    @extend %mt5;

    span {
        @extend %pt5;
    }
}

结果
.btn, .block {
    margin-top: 5px; 
}
.btn, .block span {
    padding-top: 5px; 
}
</code></pre><h4 id="插值"><a href="#插值" class="headerlink" title="插值#{}"></a>插值#{}</h4><pre><code>可以将变量与属性结合

$properties: (margin, padding);
@mixin set-value($side, $value) {
    @each $prop in $properties {
        #{$prop}-#{$side}: $value;
    }
}
.login-box {
    @include set-value(top, 14px);
}

结果：
.login-box {
    margin-top: 14px;
    padding-top: 14px;
}
</code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><pre><code>// 不会被显示到代码中

/* */  显示到代码中
</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>1、数字: 如，1、 2、 13、 10px

2、字符串：有引号字符串或无引号字符串，如，&quot;foo&quot;、 &apos;bar&apos;、 baz

3、颜色：如，blue、 #04a3f9、 rgba(255,0,0,0.5)

4、布尔型：如，true、 false

5、空值：如，null

6、值列表：用空格或者逗号分开，如，1.5em 1em 0 2em 、 Helvetica, Arial, sans-serif
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>一、字符串函数

    1、unquote(str): 删除字符串中的引号

    2、quote(str): 给字符添加引号

        .test1 {
            content:  unquote(&apos;Hello Sass!&apos;) ;        // 输出 content: Hello Sass
        }

        .test3 {
            content: quote(ImWebDesigner);        // 输出 content: &apos;ImWebDesigner&apos;;
        }

    3、to-upper-case(): 转大写

    4、to-lower-case(): 转小写


二、数字函数

    1、percentage($value)：将一个不带单位的数转换成百分比值；

        .footer{  width : percentage(5px / 10px)  }      // width: 50%

    2、round($value)：将数值四舍五入，转换成一个最接近的整数；

    3、ceil($value)：将大于自己的小数转换成下一位整数；

    4、floor($value)：将一个数去除他的小数部分；

    5、abs($value)：返回一个数的绝对值；

    6、min($numbers…)：找出几个数值之间的最小值；

    7、max($numbers…)：找出几个数值之间的最大值；

    8、random(): 获取随机数

三、列表函数

    1、nth函数（nth function） 可以直接访问值列表中的某一项；

    2、join函数（join function） 可以将多个值列表连结在一起；

    3、append函数（append function） 可以在值列表中添加值； 

    4、@each规则（@each rule） 则能够给值列表中的每个项目添加样式。

四、判断函数类型

    1、type-of($value)：返回一个值的类型

    2、unit($number)：返回一个值的单位

    3、unitless($number)：判断一个值是否带有单位

    4、comparable($number-1, $number-2)：判断两个值是否可以做加、减和合并

五、unitless(): 用来判断一个值是否带有单位，如果不带单位返回的值为 true，带单位返回的值为 false

    @mixin adjust-location($x, $y) {
        @if unitless($x) {    
            $x: 1px * $x;
        }
        @if unitless($y) {    
            $y: 1px * $y;
        }
        position: relative; 
        left: $x; 
        top: $y;
    }

    .botton{
        @include adjust-location(20px, 30);
    }

六、comparable(): 用来判断两个数是否可以进行“加，减”以及“合并”, 返回true/false

     comparable(2px,1rem)


七、三元函数: if(true,8em,20em);        // 第一个参数为


八、map 在Sass中，maps代表一种数据类型，可以包含若干键值对的对象类型

    创建一个map数据:

        $color: (
            default: #fff,
            primary: #222,
            negative: #333
        );        // 注意必须加 “;” 号 

        .box {
            color: map-get($color, default);
        }


    获取map数据的函数:

    1、map-get($map,$key)：根据给定的 key 值，返回 map 中相关的值。

    2、map-merge($map1,$map2)：将两个 map 合并成一个新的 map。

    3、map-remove($map,$key)：从 map 中删除一个 key，返回一个新 map。

    4、map-keys($map)：返回 map 中所有的 key。

    5、map-values($map)：返回 map 中所有的 value。

    6、map-has-key($map,$key)：根据给定的 key 值判断 map 是否有对应的 value 值，如果有返回 true，否则返回 false。

        @function colors($color){
            @if not map-has-key($social-colors,$color){
                @warn &quot;No color found for `#{$color}` in $social-colors map. Property omitted.&quot;;
            }
            @return map-get($social-colors,$color);
        }

    7、keywords($args)：返回一个函数的参数，这个参数可以动态的设置 key 和 value。


九、REG

    rgb($red,$green,$blue)：根据红、绿、蓝三个值创建一个颜色；

    rgba($red,$green,$blue,$alpha)：根据红、绿、蓝和透明度值创建一个颜色；

    red($color)：从一个颜色中获取其中红色值；

    green($color)：从一个颜色中获取其中绿色值；

    blue($color)：从一个颜色中获取其中蓝色值；

    mix($color-1,$color-2,[$weight])：把两种颜色混合在一起。
</code></pre><h4 id="Sass规则"><a href="#Sass规则" class="headerlink" title="Sass规则"></a>Sass规则</h4><pre><code>一、@import: 用于引用scss或sass文件

二、@media: 媒体查询功能

    .sidebar {
        width: 300px;
        @media screen and (orientation: landscape) {
            width: 500px;
        }
    }

    输出:
    .sidebar {
        width: 300px; 
    }
    @media screen and (orientation: landscape) {
        .sidebar {
            width: 500px; 
        }
    }
</code></pre><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><pre><code>SASS允许用户编写自己的函数。

// 定义函数
</code></pre><p>　　@function double($n) {<br>　　　　@return $n * 2;<br>　　}</p>
<pre><code>// 调用函数
</code></pre><p>　　#sidebar {<br>　　　　width: double(5px);<br>　　}</p>
<h4 id="高级语句"><a href="#高级语句" class="headerlink" title="高级语句"></a>高级语句</h4><pre><code>一、条件语句

    @if lightness($color) &gt; 30% {
　　　　background-color: #000;
　　} 
    @else {
　　　　background-color: #fff;
　　}


二、循环语句

    @for $i from 1 to 10 {
　　　　.border-#{$i} {
　　　　　　border: #{$i}px solid blue;
　　　　}
　　}


　　$i: 6;
　　@while $i &gt; 0 {
　　　　.item-#{$i} { width: 2em * $i; }
　　　　$i: $i - 2;
　　}


    $list: adam john wynn mason kuroir;        //$list 就是一个列表
    @mixin author-images {
        @each $author in $list {
            .photo-#{$author} {
                background: url(&quot;/images/avatars/#{$author}.png&quot;) no-repeat;
            }
        }
    }
</code></pre><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><pre><code>+、-、*、/

$container: 960px;
$sidebar-width: 220px;
$gap-width: 20px;
.content{
    width: $container - $sidebar-width;
    float: left;
}

结果:
.content {
    width: 740px;
    float: left; 
}

颜色计算
p {
    color: #010203 + #040506;
}
</code></pre><h4 id="Sass的目录结构"><a href="#Sass的目录结构" class="headerlink" title="Sass的目录结构"></a>Sass的目录结构</h4><p>  sass/<br>    |<br>    |– base/<br>    |   |– reset.scss       # Reset/normalize<br>    |   |– typography.scss  # Typography rules<br>    |   …                  # Etc…<br>    |<br>    |– components/<br>    |   |– buttons.scss     # Buttons<br>    |   |– carousel.scss    # Carousel<br>    |   |– cover.scss       # Cover<br>    |   |– dropdown.scss    # Dropdown<br>    |   |– navigation.scss  # Navigation<br>    |   …                  # Etc…<br>    |<br>    |– helpers/<br>    |   |– functions.scss   # Sass Functions<br>    |   |– mixins.scss      # Sass Mixins<br>    |   |– helpers.scss     # Class &amp; placeholders helpers<br>    |   …                  # Etc…<br>    |<br>    |– layout/<br>    |   |– grid.scss        # Grid system<br>    |   |– header.scss      # Header<br>    |   |– footer.scss      # Footer<br>    |   |– sidebar.scss     # Sidebar<br>    |   |– forms.scss       # Forms<br>    |   …                  # Etc…<br>    |<br>    |– pages/<br>    |   |– home.scss        # Home specific styles<br>    |   |– contact.scss     # Contact specific styles<br>    |   …                  # Etc…<br>    |<br>    |– themes/<br>    |   |– theme.scss       # Default theme<br>    |   |– admin.scss       # Admin theme<br>    |   …                  # Etc…<br>    |<br>    |– vendors/<br>    |   |– bootstrap.scss   # Bootstrap<br>    |   |– jquery-ui.scss   # jQuery UI<br>    |   …                  # Etc…<br>    |<br>    |- variables.scss   # 存储Sass变量文件<br>    |<br>    `– main.scss             # primary Sass file </p>
<p>| <a href="http://www.w3cplus.com/preprocessor/organize-that-sass.html" target="_blank" rel="noopener">http://www.w3cplus.com/preprocessor/organize-that-sass.html</a>                  # 组织Sass文件<br>| <a href="http://www.w3cplus.com/preprocessor/architecture-sass-project.html" target="_blank" rel="noopener">http://www.w3cplus.com/preprocessor/architecture-sass-project.html</a>        # SASS的目录结构<br>| <a href="http://www.w3cplus.com/blog/tags/302.html" target="_blank" rel="noopener">http://www.w3cplus.com/blog/tags/302.html</a>             </p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/01/10/Less/">Less</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/01/10/Less/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-01-10T10:10:21.000Z" itemprop="datePublished">2017-01-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Less/">Less</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h4><pre><code>@nice: #5b83ad
@light-blue: @nice + #111;

#header {
    background-color: @nice;
}
</code></pre><h4 id="二、混合"><a href="#二、混合" class="headerlink" title="二、混合"></a>二、混合</h4><pre><code>定义一个类的样式

示例1：
    .bordered {
        border-top: 1px black solid;
        border-bottom: 1px black solid;
    }

    加载到#menu a内
    #menu a {
      color: #111;
      .bordered;
    }

    .post a {
      color: red;
      .bordered;
    }


示例2：混合带参数
    .border-radius(@values) {
          -webkit-border-radius: @values;
        -moz-border-radius: @values;
        border-radius: @values;
    }

    .box-radius{ width: @filler; heigth: 30px; border: 1px #ccc solid; .border-radius(4px) }


示例3：
    .a, #b {
        color: red;
    }
    .mixin-class {
        .a();
    }

    输出：
    .a, #b {
        color: red;
    }
    .mixin-class {
        color: red;
    }


示例4：
    .my-mixin {
        color: black;
    }
    .my-other-mixin() {
        background: white;
    }
    .class {
        .my-mixin;
        .my-other-mixin;
    }

    输出：
    .my-mixin {
        color: black;
    }
    .class {
        color: black;
        background: white;
    }
</code></pre><h4 id="三、嵌套"><a href="#三、嵌套" class="headerlink" title="三、嵌套"></a>三、嵌套</h4><pre><code>示例1：

    #header{
        color: black;

        .navigation {
            font-size: 12px;
        }
    }

    output：

        #header {
            color: black;
        }
        #header .navigation {
            font-size: 12px;
    }

示例2：a 的 hover

    .box {
        a {
            color: red;
            $:hover {
                color: green;
            }
        }
    }

    output:
    .box a { color: red; }
    .box a:hover { color: green; }


示例3：arguments 可以将所有参数显示到值中

    .border-arg(@width, @color, @style){
        border: @arguments;            // 这里使用@arguments就相当于 @width @color @style
    }
</code></pre><h4 id="四、运算"><a href="#四、运算" class="headerlink" title="四、运算"></a>四、运算</h4><pre><code>@base: 5%;
@filler: @base * 2;
.boxA { width: @filler; height: 20px; background-color: #c3c3c3; }
</code></pre><h4 id="五、匹配模式"><a href="#五、匹配模式" class="headerlink" title="五、匹配模式"></a>五、匹配模式</h4><pre><code>// 设置匹配
.trangle(top, @width, @color){
    border-width: @width; 
    border-color: transparent transparent @color transparent;
    border-style: dashed dashed solid dashed
}

.trangle(left, @width, @color){
    border-width: @width; 
    border-color: transparent @color transparent transparent;
    border-style: dashed dashed solid dashed
}

.trangle(right, @width, @color){
    border-width: @width; 
    border-color: transparent transparent transparent @color;
    border-style: dashed dashed solid dashed
}

.trangle(bottom, @width, @color){
    border-width: @width; 
    border-color: @color transparent transparent transparent;
    border-style: dashed dashed solid dashed
}

/* 匹配模式 */
.trangleL {
    width: 0; height: 0; overflow: hidden;
    .trangle(right, 18px, red)        /* 这里调用的right 就是右三角 */
}
&lt;div class=&quot;trangleL&quot;&gt;&lt;/div&gt;
</code></pre><h4 id="六、作用域-Scope"><a href="#六、作用域-Scope" class="headerlink" title="六、作用域 Scope"></a>六、作用域 Scope</h4><pre><code>@var: red;
#page {
    @var: white;
    #header {
        color: @var; // white
    }
}

编译后：
#page .header {
    color: white;
}
</code></pre><h4 id="七、注释"><a href="#七、注释" class="headerlink" title="七、注释"></a>七、注释</h4><pre><code>/* */    会被编译，输出会显示注释
//         不会被编译，输出不会显示注释
</code></pre><h4 id="八、importe"><a href="#八、importe" class="headerlink" title="八、importe"></a>八、importe</h4><pre><code>导入less文件： @import &apos;libary&apos;;        不用加.less
导入css文件：     @import &apos;typo.css&apos;;    
</code></pre><h4 id="九、url"><a href="#九、url" class="headerlink" title="九、url"></a>九、url</h4><pre><code>@images: &quot;../img&quot;;

// 用法
body {
    color: #444;
    background: url(&quot;@{images}/white-sand.png&quot;);
}
</code></pre><h4 id="十、循环"><a href="#十、循环" class="headerlink" title="十、循环"></a>十、循环</h4><pre><code>.loop(@counter) when (@counter &gt; 0) {        // 循环使用 定义函数名(参数) when (条件）
    .loop((@counter - 1));        // 每一次减1
    width: (10px * @counter);     // code for each iteration
}
div {
    .loop(3); // launch the loop
}

output:
div {
    width: 10px;
    width: 20px;
    width: 30px;
}
</code></pre><h4 id="十一、合并"><a href="#十一、合并" class="headerlink" title="十一、合并"></a>十一、合并</h4><pre><code>.mixin() {
    box-shadow+: inset 0 0 10px #555;
}
.myclass {
    .mixin();
    box-shadow+: 0 0 20px black;
}


.myclass {
    box-shadow: inset 0 0 10px #555, 0 0 20px black;
}
</code></pre><h4 id="十二、避免编译使用-“-”"><a href="#十二、避免编译使用-“-”" class="headerlink" title="十二、避免编译使用 “~”"></a>十二、避免编译使用 “~”</h4><pre><code>.text {
    width: ~(30px + 30px);        // 这里就不会被计算，而直接输出width: 30px + 30px;
}
</code></pre><h4 id="十三、与构建工具结合"><a href="#十三、与构建工具结合" class="headerlink" title="十三、与构建工具结合"></a>十三、与构建工具结合</h4><pre><code>可以使用gulp 或 webpack 来进行编译
</code></pre><blockquote>
<p>参考资料</p>
<p><a href="http://less.bootcss.com" target="_blank" rel="noopener">http://less.bootcss.com</a><br><a href="http://www.wtoutiao.com/p/15bzfg3.html" target="_blank" rel="noopener">http://www.wtoutiao.com/p/15bzfg3.html</a><br><a href="http://www.w3cplus.com/css/sass-vs-less-vs-stylus-a-preprocessor-shootout.html" target="_blank" rel="noopener">http://www.w3cplus.com/css/sass-vs-less-vs-stylus-a-preprocessor-shootout.html</a><br><a href="http://www.w3cplus.com/preprocessor/architecture-sass-project.html" target="_blank" rel="noopener">http://www.w3cplus.com/preprocessor/architecture-sass-project.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/01/10/nodeJS基础用法/">nodeJS基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/01/10/nodeJS基础用法/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-01-10T10:10:21.000Z" itemprop="datePublished">2017-01-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| nodeJS<br>|<br>| buffer: 处理二进制, 对字符串与二进制进行转换 (done)<br>| fs: 文件系统操作 (done)<br>| http: 处理http请求, 创建服务器, 和处理客户端与服务器之间的数据传递request、response (done)<br>| stream: 文件流<br>| path: 文件路径的处理 (done)<br>| URL: 网络地址解析 (done)<br>| querystring: URL查询字符串 (done)<br>| Cookie、Session、Token (done)<br>| event: 事件机制<br>|<br>| DNS: 域名解析<br>| net: TCP网络<br>| dgram: UDP网络<br>| crypto: 数据加密<br>| process: 进程<br>| childe_process: 子进程<br>| cluster: 集群<br>| global: 全局<br>|<br>| Express<br>| Template 模板 jade、<br>| Mysql (done)<br>| MongoDB<br>| redis<br>| RESTful 架构<br>| </p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>优点:
    前端的局限性，可以对文件、进程、数据库等进操作，是一门纯后端
    处理高并发  程序异步执行不会阻塞

缺点: nodejs是单线程

1、nodeJS安装，mac或windows系统需要到官网下载安装包，自带npm包管理器

2、安装express框架：npm install -g express

        $ express       // 执行命令

3、更新node版本

    node需要下载一个n模块，是用来专门管理nodejs的版本

    $ sudo npm install -g n     # 安装n模块

    $ sudo n stable        # 升级到稳定版，也可以指定版本号 n v0.10.26

        sudo n 8.9.4        # 升级到指定版本


4、其它命令

    npm -v                  # 显示版本，检查npm 是否正确安装。

    npm install express      # 安装express模块

    npm install -g express  # 全局安装express模块

    npm list                 # 列出已安装模块

    npm show express         # 显示模块详情

    npm update                # 升级当前目录下的项目的所有模块

    npm update express        # 升级当前目录下的项目的指定模块

    npm update -g express      # 升级全局安装的express模块

    npm uninstall express      # 删除指定的模块
</code></pre><h4 id="NPM与包"><a href="#NPM与包" class="headerlink" title="NPM与包"></a>NPM与包</h4><pre><code>NodeJS以CommonJS的包规范来制订，由包结构和包描述文件两部分组件

1、包结构

    npm 下载完包存储到 node_modules 目录中，包含:

    1）package.json: 包描述

    2）bin: 存放可执行的二进制文件

    3）lib: 存储javascript代码目录

    4）doc: 用于存放文档的目录

    5）test: 存放单元测试用例代码
</code></pre><h4 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h4><pre><code>Node采用了Google的V8引擎，作为javascript语言的解释器，Node是基于事件驱动和异步I/O的服务器环境

1、JS与node的区别

    1）JS中顶层对象是 window，nodeJS中的顶层对象是 global

    2）JS中 var a = 10; window.a; 可以访问到，但在node中global.a是访问不到的，因为node有模块的概念

        node中一个文件就是珍上模块，每个模块有自己的作用域

2、REPL环境

    在命令行输入node, 可以直接运行node命令
</code></pre><h4 id="模块系统-require、exports"><a href="#模块系统-require、exports" class="headerlink" title="模块系统 require、exports"></a>模块系统 require、exports</h4><pre><code>1、模块分为

    模块加载：require(&apos;2.js&apos;);

    1）内置模块:  var fs = require(&apos;fs&apos;);        // 加载Node的内置模块 fs文件系统

    2）文件模块: 自己定义的业务模块

        定义一个food.common.js

        var food = reuqire(&apos;./js/food.common&apos;);        // 加载业务模块

    3）加载第三方模块

        require(&apos;./2&apos;);        // 先按照加载的模块文件进行查找，如果没有找到会在文件名加上.js


2、绝对和相对路径

    var fs = require(&apos;fs&apos;);        // 绝对路径，是在Node通过内部的node_modules查找到的模块

    var moduleA = reuqire(&apos;./lib/moduleA&apos;);        // 相对路径


2、npm 全局安装和局部安装

    1）全局安装会安装到Node目录中，各项目都可以使用 npm install -g gulp

    2）局部安装，将一个模块安装到node_modules中，只在当前和子目录中使用


3、模块化

    module和exports两个全局变量

    1）module：每个模块下都包括module对象

        Module {
            id: &apos;.&apos;,
            exports: {},
            parent: null,
            filename: &apos;/Users/apple/siguang.liu/nodeProject/server.js&apos;,
            loaded: false,
            children: [],
            paths: [
                &apos;/Users/apple/siguang.liu/nodeProject/node_modules&apos;,
                &apos;/Users/apple/siguang.liu/node_modules&apos;,
                &apos;/Users/apple/node_modules&apos;,
                &apos;/Users/node_modules&apos;,
                &apos;/node_modules&apos;
            ]
         }

     2）exports外部接口，通过require就可以调用这个接口

         其实exports就是module.exports的引用

        exports.name = &apos;siguang&apos;;
        exports.getPrivate = function(){
            return &apos;haha&apos;;
        }
</code></pre><h4 id="事件-EventEmitter"><a href="#事件-EventEmitter" class="headerlink" title="事件 EventEmitter"></a>事件 EventEmitter</h4><pre><code>var EventEmitter = require(&apos;events&apos;).EventEmitter,
    a = new EventEmitter;

a.on(&apos;event&apos;, function(){
    console.log(&apos;event called&apos;);
})
a.emit(&apos;event&apos;);
</code></pre><p>—————————- Node API 文档 —————————-</p>
<h4 id="process-进程对象"><a href="#process-进程对象" class="headerlink" title="process 进程对象"></a>process 进程对象</h4><pre><code>1、pid：进程id，也就是进程名

2、kill(pid)：杀掉进程

3、nextTick(callback): 会在第一次事件环中最末尾执行，setTimeout和setImmediate属于第二事件环

    console.log(&apos;开始&apos;);

    setImmediate(function(){
        console.log(&apos;setImmediate&apos;)
    });

    setTimeout(function(){
        console.log(&apos;setTimeout&apos;);
    }, 0);

    process.nextTick(function(){
        console.log(&apos;nextTick&apos;);
    })

    console.log(&apos;结束&apos;);


    output:

        ---------------  第一次 ----------------
        开始
        结束
        nextTick

        ---------------  第二次 ----------------
        setTimeout
        setImmediate
</code></pre><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><pre><code>传输控制协议TCP是一个面向连接的协议，保证两台计算机之间数据传输的可靠性和顺序

它可以将数据从一台计算机完整有序的传到另一台计算机，http模块就是继承了net（TCP）模块

var net = require(&apos;net&apos;);        // 引用TCP模块

telnet系统嵌套的客户端，端口23, 用来连接服务器

退出TCP连接 alt+[, 退出telnet quit命令
</code></pre><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><pre><code>基于HTTP服务器的工具, 提供新的组织代码的方式来与请求响应对象进行交互，称为中间件

引用模块 var connect = require(&apos;connect&apos;);

connect作用: 

    1、托管静态文件

    2、处理错误及不存在的url

    3、处理不同类型的请求
</code></pre><h4 id="utils-工具"><a href="#utils-工具" class="headerlink" title="utils 工具"></a>utils 工具</h4><pre><code>var utils = reuqire(&apos;utils&apos;);
</code></pre><h4 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h4><pre><code>EventEmitter 类

var EventEmitter = require(&apos;events&apos;);
var emitter = new EventEmitter();

1、addListener(event, listener): 创建事件，客户端通过事件来调用，而服务端通过代码来调用事件侦听

       on(event, listener):

       //  addListener 事件
    var EventEmitter = require(&apos;events&apos;).EventEmitter;
    var emitter = new EventEmitter();

    emitter.addListener(&apos;some_events&apos;, function(foo, bar){
        console.log(foo, bar);
    })

    emitter.emit(&apos;some_events&apos;, &apos;helloA&apos;, &apos;world&apos;);         // helloA world
    emitter.emit(&apos;some_events&apos;, &apos;helloB&apos;, &apos;world&apos;);         // helloB world


    // on 可以
    emitter.on(&apos;message&apos;, function(mes, name, age){
        console.log(mes +&quot; name:&quot;+ name +&quot; age:&quot;+ age);
    })

    emitter.emit(&apos;message&apos;, &apos;消息1&apos;, &apos;siguang&apos;, &apos;32&apos;);       // 消息1 name:siguang age:32
    emitter.emit(&apos;message&apos;, &apos;消息2&apos;, &apos;lulu&apos;, &apos;30&apos;);          // 消息2 name:lulu age:30


2、once()：只执行一次

    emitter.once(&apos;onceEvent&apos;, function(age){
        console.log(age);
    })

    emitter.emit(&apos;onceEvent&apos;, &apos;1&apos;);        // 只执行此次事件
    emitter.emit(&apos;onceEvent&apos;, &apos;2&apos;);
    emitter.emit(&apos;onceEvent&apos;, &apos;3&apos;);


3、removeListener(): 删除listener

4、removeAllListeners(): 删除所有

5、setMaxListeners(num): 正常事件的个数为10个, 如果超出通过此方法来改变限制的个数

6、setMaxListeners(): 每个emitter实例的最大监听数

7、listeners(event): 返回指琮事件的数组

8、emit(事件名, 参数): 执行事件

9、listenerCount(emitter, event): 返回事件个数
</code></pre><h4 id="cookie-和-Session"><a href="#cookie-和-Session" class="headerlink" title="cookie 和 Session"></a>cookie 和 Session</h4><pre><code>https://cnodejs.org/topic/55f8d70a20d84f3d377582a3

1、cookie和session的区别

    cookie存放在客户端 session存放到服务器上

    cookie不安全，客户端可以修改, session不会被修改

    session会保存在一定时间内保存在服务器端, 当访问增多, 会影响性能


2、cookie

    存储到客户端的信息

3、session

    # npm install express-session --save       // 安装

    session原理

        1）服务器端有一个对象专门存session的对象或库 如sessions={};

        2）通过req.session.sign来检查是否为已登录状态

        3）如果没有登录，第一次访问会生成一个sid，Date.now()+Math.random(); 将sid存储到sessions中

        4）把这个sid发送到浏览器端, 通过请求头中会有一个set-cookie, 将session中存到cookie中

            set-cookie:connect.sid=s%3AjDb0ns6Ekas3I7ll3tm9Bxg_wd4WjBJY.wL8VyIWdHQNFWt%2ByE%2BjAV30r4M7ZQdVIXgeKBOzx5iY; Path=/; Expires=Fri, 25 Nov 2016 03:27:38 GMT; HttpOnly

            HttpOnly 不能读不能写


    session(options): 选项内容

        1）name: session名称，设置cookie中，默认为connect.sid

        2）stroe: session存储方式，默认存在内存中，也可以存储到redis、mongodb

        3）secret: 通过设置secret字符串，来计算hash值并放在cookie产生的signedCookie防篡改

        4) cookie: 存放session id 的cookie

        5) genid: 产生一个新的session_id时，所使用的函数，默认使用uid2这个npm包

        6）rolling: 每个请求都重新设置一个cookie

        7）resave: 即使session没有被修改也保存session值

        8）saveUnintialized: 保存新创建但未修改的session


    示例:

        router.get(&apos;/&apos;, function (req, res) {

            if (req.session.sign) { // 检查用户是否已经登录
                console.log(req.session);//打印session的值
                res.send(&apos;welecome &lt;strong&gt;&apos; + req.session.name + &apos;&lt;/strong&gt;, 欢迎你再次登录&apos;);
            }
            else {      // 否则展示index页面
                req.session.sign = true;
                req.session.name = &apos;haha&apos;;
                res.end(&apos;欢迎登陆！&apos;);
            }

        });
</code></pre><h4 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h4><pre><code>轮循: 隔多长时间ajax发一次请求, 不间隔的去发

长轮循: 隔多长时间ajax发一次请求，接到结果后在发出下一次请求


webScoket: 长连接，浏览器和服务器只需要一次握手，浏览器就和服务器形成一个快速通道，两者之间相互传送数据

    1、节省资源: Header只有2 Bytes，1字节8位   1kb = 1024 bytes

    2、推送消息: 不需要客户端发请求


1、安装

    # npm install ws

2、socket.io库

    Socket.IO是websocket库，包括客户端的js和服务器端的nodejs，目标是构建可以在不同浏览器和移动设备上使用实时应用.

    # npm install socket.io


    https://www.zhihu.com/question/20831000         // scoketIO最大连接数和并发数
</code></pre><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>1、同步方法 try catch

2、异步 判断回调函数error对象

3、流里判断错误，监听error事件

    rs.on(&apos;error&apos;, function(error){
        console.log(error);
    })
</code></pre><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><pre><code>content-type 的一些参数值: http://blog.csdn.net/blueheart20/article/details/45174399

request请求头: 客户端请求服务器的请求头

    1、host: 主机地址

    2、connection: 客户端与服务器的连接选项

    3、accept: 服务器处理内容的优先级, q是权重 0-1之间范围

    4、user-agent: 用户代理，发送浏览器的硬件、系统等信息, 可以通过些选择来收集用户的pc端还是moblie端访问的多少

    5、accept-encoding: 告诉服务器所支持的编码

    6、accept-language: 告诉服务器所使用的语言, 用于判断中文站还是英文站


response响应: 服务器向客户端响应

    1、statusCode: 状态码

    2、resonPhrase: 状态码描述

    3、headers: 响应头信息

        1) content-Type: 内容类型

        2) location: 重定向url

        3) content-disposition: 下载文件名

        4) content-length: 响应内容的字节数

        5) set-cookie: 写入客户端cookie

        6) content-encoding: 响应内容编码

        7) cache-Control: 缓存

        8) Expires: 指定缓存过期时间

        9) Etag: 服务器响应内容没有变化重新下载数据

        10) connection: 默认keep-alive 保持连接，断开使用close
</code></pre><blockquote>
<p>参考资料</p>
<p><a href="https://thinkjs.org/" target="_blank" rel="noopener">https://thinkjs.org/</a><br><a href="https://chyingp.gitbooks.io/nodejs/content/%E8%BF%9B%E9%98%B6/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%88%90datauri.html" target="_blank" rel="noopener">https://chyingp.gitbooks.io/nodejs/content/%E8%BF%9B%E9%98%B6/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%88%90datauri.html</a>    ***<br><a href="http://nodeapi.ucdok.com/api/" target="_blank" rel="noopener">http://nodeapi.ucdok.com/api/</a>                    // API中文文档<br><a href="https://github.com/wangxueliang/node-api/blob/master/doc/fs.md" target="_blank" rel="noopener">https://github.com/wangxueliang/node-api/blob/master/doc/fs.md</a>   API中文部分<br><a href="https://nodejs.xiangfa.org/documentation/" target="_blank" rel="noopener">https://nodejs.xiangfa.org/documentation/</a>        // API中文文档<br><a href="https://cnodejs.org/getstart" target="_blank" rel="noopener">https://cnodejs.org/getstart</a>                     // node入门<br><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="noopener">http://nqdeng.github.io/7-days-nodejs/</a><br><a href="http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb" target="_blank" rel="noopener">http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb</a><br><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="noopener">http://nqdeng.github.io/7-days-nodejs/</a>        // 7天会Node<br><a href="https://www.gitbook.com/@chyingp" target="_blank" rel="noopener">https://www.gitbook.com/@chyingp</a><br><a href="http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb" target="_blank" rel="noopener">http://cnodejs.org/topic/581b0c4ebb9452c9052e7acb</a><br><a href="https://cnodejs.org/topic/56ef3edd532839c33a99d00e" target="_blank" rel="noopener">https://cnodejs.org/topic/56ef3edd532839c33a99d00e</a><br><a href="https://github.com/leizongmin/node123" target="_blank" rel="noopener">https://github.com/leizongmin/node123</a>        // 资料导航</p>
<p>Express框架</p>
<p><a href="http://www.expressjs.com.cn/starter/hello-world.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/starter/hello-world.html</a><br><a href="https://github.com/expressjs?page=2" target="_blank" rel="noopener">https://github.com/expressjs?page=2</a>        express下的插件<br><a href="https://github.com/nodejs" target="_blank" rel="noopener">https://github.com/nodejs</a>     nodeJS插件</p>
</blockquote>
<p>插件:</p>
<p><a href="http://node.zhufengpeixun.cn/" target="_blank" rel="noopener">http://node.zhufengpeixun.cn/</a><br><a href="https://github.com/node-modules?page=1" target="_blank" rel="noopener">https://github.com/node-modules?page=1</a></p>
<p><a href="https://github.com/keepfool/node-lessons" target="_blank" rel="noopener">https://github.com/keepfool/node-lessons</a></p>
<p>1、cookie: <a href="https://github.com/expressjs/cookie-parser" target="_blank" rel="noopener">https://github.com/expressjs/cookie-parser</a>    // cookie-parser  </p>
<pre><code>http://www.cnblogs.com/coolicer/p/4191548.html
</code></pre><p>2、express-session: session的处理</p>
<p>3、cookie、sesssion加密的包 cookie-signature:    <a href="https://github.com/visionmedia/node-cookie-signature" target="_blank" rel="noopener">https://github.com/visionmedia/node-cookie-signature</a></p>
<pre><code>https://segmentfault.com/q/1010000000392851
</code></pre><p>4、token: express-jwt         <a href="https://www.npmjs.com/package/express-jwt" target="_blank" rel="noopener">https://www.npmjs.com/package/express-jwt</a></p>
<pre><code>http://ninghao.net/blog/2834
</code></pre><p>5、socket.io:  npm install socket.io             <a href="https://github.com/socketio/socket.io" target="_blank" rel="noopener">https://github.com/socketio/socket.io</a></p>
<p>2、mysql: <a href="https://www.npmjs.com/package/mysql" target="_blank" rel="noopener">https://www.npmjs.com/package/mysql</a>         // 连接和处理mysql</p>
<p>3、ws安装socket/IO服务包: npm install ws</p>
<p>4、mime:  <a href="https://github.com/broofa/node-mime" target="_blank" rel="noopener">https://github.com/broofa/node-mime</a>        // 响应css、js文件的请求</p>
<pre><code>http://blog.csdn.net/zgljl2012/article/details/44700953
</code></pre><p>5、body-parser: <a href="https://github.com/expressjs/body-parser" target="_blank" rel="noopener">https://github.com/expressjs/body-parser</a>  // json  </p>
<pre><code>https://segmentfault.com/a/1190000003061925
</code></pre><p>6、superagent: <a href="http://visionmedia.github.io/superagent/" target="_blank" rel="noopener">http://visionmedia.github.io/superagent/</a></p>
<pre><code>http://www.codesec.net/view/183926.html
</code></pre><p>7、node-images:  <a href="https://github.com/zhangyuanwei/node-images" target="_blank" rel="noopener">https://github.com/zhangyuanwei/node-images</a>     // 图片转换</p>
<p>8、node-xlsx: <a href="https://github.com/mgcrea/node-xlsx" target="_blank" rel="noopener">https://github.com/mgcrea/node-xlsx</a>      // 处理xlsx文件</p>
<p>9、multer: <a href="https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md" target="_blank" rel="noopener">https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md</a>    // 处理文件上传</p>
<pre><code>req.body存储表单内容

req.file存储上传控制的内容

multer({dest: &apos;./public/upfile&apos;});    设置图片文件存储的路径

upload.single(&apos;sendUpfile&apos;);        // 上传单个文件 file的name=&quot;sendUpfile&quot;
</code></pre><p>11、multiparty 文件上传: <a href="https://github.com/expressjs/node-multiparty" target="_blank" rel="noopener">https://github.com/expressjs/node-multiparty</a></p>
<p>10、formidable: <a href="https://cnodejs.org/topic/4f5c62932373009b5c0b027b" target="_blank" rel="noopener">https://cnodejs.org/topic/4f5c62932373009b5c0b027b</a> // 文件上传</p>
<p>11、up工具用于重启服务器, 每次代码修改不需要重启服务器，通过up来完成</p>
<pre><code>安装 sudo npm install up -g

运行 到项目目录 up -watch -port 8080 server.js
</code></pre><p>模板:</p>
<p>1、handlebars  <a href="http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html</a></p>
<pre><code>http://www.ghostchina.com/introducing-the-handlebars-js-templating-engine/
hbs:  http://www.cnblogs.com/chyingp/p/hbs-getting-started.html
</code></pre><p>1、Jade</p>
<p>2、ejs</p>
<p>3、Haml</p>
<p>4、CoffeeKup</p>
<p>MD5 JS <a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5</a></p>
<p>HTML5  new FormData()   <a href="http://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html" target="_blank" rel="noopener">http://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/26/handlebars模板/">Hanlebars.js 模板引擎</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/26/handlebars模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-26T07:45:55.000Z" itemprop="datePublished">2016-12-26</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 涉及知识点<br>|<br>|</p>
<h4 id="headlebars介绍"><a href="#headlebars介绍" class="headerlink" title="headlebars介绍"></a>headlebars介绍</h4><pre><code>Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。它采用&quot;Logic-less template&quot;（无逻辑模版）的思路，在加载时被预编译，而不是到了客户端执行到代码时再去编译， 这样可以保证模板加载和运行的速度。Handlebars兼容Mustache，你可以在Handlebars中导入Mustache模板。
</code></pre><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><pre><code>1、下载handlebars.js文件在页面中直接引用

2、通过npm下载，require(&apos;handlebars&apos;)直接引用
</code></pre><h4 id="使用Handlebars"><a href="#使用Handlebars" class="headerlink" title="使用Handlebars"></a>使用Handlebars</h4><pre><code>&lt;!-- 编译模板后输出的位置 --&gt;    
  &lt;div id=&quot;tableList&quot;&gt;&lt;/div&gt;

&lt;!-- 定义的模板 --&gt;
&lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    {{date.year}} 年 {{date.month}} 月 {{date.day}} 日 &lt;br&gt;
    &lt;table&gt;
      {{#each person}}
           &lt;tr&gt;
          &lt;td&gt;姓名:{{name}}, 年龄:{{age}}&lt;/td&gt;
        &lt;/tr&gt; 
      {{/each}}
      &lt;/table&gt;
&lt;/script&gt;

&lt;!--插件引用--&gt;
&lt;script src=&quot;js/lib/zepto.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/lib/handlebars.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  $(document).ready(function() {

    // 模拟的json对象
    var data = {
        date: {
            year: &apos;2016&apos;,
            month: &apos;12&apos;,
            day: &apos;26&apos;
        },
        person: [
            {name: &apos;siguang&apos;, age: 20},
            {name: &apos;lulu&apos;, age: 20},
            {name: &apos;haha&apos;, age: 20},
            {name: &apos;heihei&apos;, age: 20}
        ]
    }

     // 预编译模板
    var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());

    //将json对象用刚刚注册的Handlebars模版封装，得到最终的html，插入到基础table中。
    $(&apos;#tableList&apos;).html(myTemplate(data));

  });
&lt;/script&gt;
</code></pre><h4 id="handlebars语句"><a href="#handlebars语句" class="headerlink" title="handlebars语句"></a>handlebars语句</h4><pre><code>1、{{#each 对象 }}  循环数据

&lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
  {{#each student}}
    &lt;tr&gt;
      &lt;td&gt;{{name}}&lt;/td&gt;
      &lt;td&gt;{{sex}}&lt;/td&gt;
      &lt;td&gt;{{age}}&lt;/td&gt;
    &lt;/tr&gt; 
  {{/each}}
&lt;/script&gt;


2、{{#each }} 嵌套

    {{#each this}} each中的this

    &lt;!-- 定义的模板 --&gt;
    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        {{#each this}}
            {{#each info}}
                &lt;!-- 这里取name 使用../到上一层来取， info数组内容使用this来输出 --&gt;
                {{../name}}的{{this}}&lt;br&gt;
            {{/each}}
        {{/each}}
    &lt;/script&gt;


    &lt;script src=&quot;js/lib/zepto.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/lib/handlebars.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() {
        //模拟的json对象
        var data = [
             {
                &quot;name&quot;:&quot;张三&quot;,
                &quot;info&quot;:[
                    &quot;眼睛&quot;,
                    &quot;耳朵&quot;,
                    &quot;鼻子&quot;
                ]
            },
            {
                &quot;name&quot;:&quot;李四&quot;,
                &quot;info&quot;:[
                    &quot;爸爸&quot;,
                    &quot;妈妈&quot;,
                    &quot;妻子&quot;
                ]
            }
        ];

        var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());
        $(&apos;#dataList&apos;).html(myTemplate(data));
      });
    &lt;/script&gt;


3、@index 访问父级索引

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        &lt;table&gt;
        {{#each this}}
            &lt;tr&gt;
                &lt;td&gt;{{addOne @index}}.&lt;/td&gt;
                &lt;td&gt;{{name}}&lt;/td&gt;
                &lt;td&gt;{{sex}}&lt;/td&gt;
                &lt;td&gt;{{age}}&lt;/td&gt;
            &lt;/tr&gt;
        {{/each}}
        &lt;/table&gt;
    &lt;/script&gt;

    &lt;!--进行数据处理、html构造--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var data = [
            {
                name: &quot;张三&quot;,
                sex: &quot;男&quot;,
                age: 35
            },{
                name: &quot;李四&quot;,
                sex: &quot;男&quot;,
                age: 23
            },{
                name: &quot;甜妞&quot;,
                sex: &quot;女&quot;,
                age: 18
            }
        ];

        // 注册索引+1的helper
        var handleHelper = Handlebars.registerHelper(&quot;addOne&quot;,function(index){
            //返回+1之后的结果
            return index+1;
        });

        //解析模版
        var handle = Handlebars.compile($(&quot;#table-template&quot;).html());
        //生成html
        var html = handle(data);
        //插入到页面
        $(&quot;#dataList&quot;).append(html);
    &lt;/script&gt;


4、#with 循环时进行到某一个上下文

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    &lt;table&gt;
        {{#each this}}
        &lt;tr&gt;
            &lt;td&gt;{{name}}&lt;/td&gt;
            &lt;td&gt;{{sex}}&lt;/td&gt;
            &lt;td&gt;{{age}}&lt;/td&gt;
            &lt;td&gt;
                &lt;!-- 这里通过 #with 直接找到favorite数组 --&gt;
                {{#with favorite}}
                {{#each this}}
                &lt;p&gt;{{name}}&lt;/p&gt;
                {{/each}}
                {{/with}}
            &lt;/td&gt;
        &lt;/tr&gt; 
        {{/each}}
    &lt;/table&gt;

    &lt;/script&gt;

    &lt;!--进行数据处理、html构造--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() {
        //模拟的json对象
        var data = [
                {
                    &quot;name&quot;: &quot;张三&quot;,
                    &quot;sex&quot;: &quot;0&quot;,
                    &quot;age&quot;: 18,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;唱歌&quot;
                      },{
                        &quot;name&quot;:&quot;篮球&quot;
                      }
                    ]
                },
                {
                    &quot;name&quot;: &quot;李四&quot;,
                    &quot;sex&quot;: &quot;0&quot;,
                    &quot;age&quot;: 22,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;上网&quot;
                      },{
                        &quot;name&quot;:&quot;足球&quot;
                      }
                    ]
                },
                {
                    &quot;name&quot;: &quot;妞妞&quot;,
                    &quot;sex&quot;: &quot;1&quot;,
                    &quot;age&quot;: 18,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;电影&quot;
                      },{
                        &quot;name&quot;:&quot;旅游&quot;
                      }
                    ]
                }
            ];

        // 注册一个Handlebars模版，通过id找到某一个模版，获取模版的html框架
        var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());

        // 将json对象用刚刚注册的Handlebars模版封装，得到最终的html，插入到基础table中。
        $(&apos;#dataList&apos;).html(myTemplate(data));
    });
    &lt;/script&gt;

5、{{#if }} 判断

     &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        {{#each student}}
            {{#if name}}
                &lt;tr&gt;
                    &lt;td&gt;{{name}}&lt;/td&gt;
                    &lt;td&gt;{{sex}}&lt;/td&gt;
                    &lt;td&gt;{{age}}&lt;/td&gt;
                &lt;/tr&gt;
            {{/if}}
        {{/each}}
    &lt;/script&gt;


6、registerHelper() 注册handlebars

    需要用到js处理并返回数据需要用到注册，类似过滤器

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    {{#each student}}
        {{#if name}}

            &lt;!-- compare 注册名， age 20 为参数 --&gt;
            {{#compare age 20}}
                &lt;tr&gt;
                    &lt;td&gt;{{name}}&lt;/td&gt;
                    &lt;td&gt;{{sex}}&lt;/td&gt;
                    &lt;td&gt;{{age}}&lt;/td&gt;
                &lt;/tr&gt;
            {{else}}
                &lt;tr&gt;
                    &lt;td&gt;?&lt;/td&gt;
                    &lt;td&gt;?&lt;/td&gt;
                    &lt;td&gt;?&lt;/td&gt;
                &lt;/tr&gt;
            {{/compare}}
        {{/if}}
    {{/each}}
    &lt;/script&gt;

    //注册一个比较大小的Helper,判断v1是否大于v2
    Handlebars.registerHelper(&quot;compare&quot;,function(v1,v2,options){
        if(v1&gt;v2){
            //满足添加继续执行
            return options.fn(this);
        }
        else{
            //不满足条件执行{{else}}部分
            return options.inverse(this);
        }
    });
</code></pre><p>| 参考资料<br>| <a href="http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html</a></p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
