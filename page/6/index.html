<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/金融类/">金融类</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/金融类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/金融/">金融</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="居民的金融四大决策"><a href="#居民的金融四大决策" class="headerlink" title="居民的金融四大决策"></a>居民的金融四大决策</h4><pre><code>一、消费决策和储蓄决策 - 多少财富用于消费，多少为储蓄

二、投资决策 - 怎么样投资所节省的资金

三、融资决策 - 自己的消费和投资计划

四、风险管理决策 - 降低金融不确定性
</code></pre><h4 id="金融体系"><a href="#金融体系" class="headerlink" title="金融体系"></a>金融体系</h4><pre><code>金融体系包括金融市场、金融中介、金融服务企业以其它用来执行居民户、企业和政府的金融决策的机构

1、金融中介 - 主要业务向客户提供金融产品和服务的企业，主要包括(银行、存款储蓄机构、保险公司、养老金与退休基金、投资银行、风险投资企业、资产管理企业)
</code></pre><h2 id="M0、M1、M2"><a href="#M0、M1、M2" class="headerlink" title="M0、M1、M2"></a>M0、M1、M2</h2><h2 id="什么是金融、金融体系"><a href="#什么是金融、金融体系" class="headerlink" title="什么是金融、金融体系"></a>什么是金融、金融体系</h2><h2 id="赤字"><a href="#赤字" class="headerlink" title="赤字"></a>赤字</h2><h2 id="金融危机和次贷危机"><a href="#金融危机和次贷危机" class="headerlink" title="金融危机和次贷危机"></a>金融危机和次贷危机</h2><pre><code>低利率照成所有人去银行进行贷款，然后使用杠杆

杠杆是用借贷来扩大交易收益的手段

杠杆的操作 - 例 A用1万美元买一个箱子，在以1.1万美元卖给B，在中间赚了1千美元，这属于正常操作，

        如果用杠杆就是 A有1万美元，又去借了99万美元，这样手里有100万美元，去买了100个箱子，赚取110万，还了99万借款和1万的利息，赚了9万美元

次贷危机 - 通过这种杠杆会使大面积的贷款短贷导金融系统破崩溃
</code></pre><h2 id="刚性兑付"><a href="#刚性兑付" class="headerlink" title="刚性兑付"></a>刚性兑付</h2><pre><code>就是投资、理财的项目，无论赔了赚了都有平台或银行兜底，打破刚性兑付就是将打掉这种模式，平台和银行不在兜底，赔与赚要看借款方的企业
</code></pre><h2 id="投资类型"><a href="#投资类型" class="headerlink" title="投资类型"></a>投资类型</h2><pre><code>股票

基金

p2p借贷

股权投资
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>只要政府低利率加上超发货币，资产一定会上涨
</code></pre><p><a href="https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=340s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=340s</a><br><a href="https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=342s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mu9W9SrsXu8&amp;t=342s</a></p>
<p><a href="https://www.youtube.com/watch?v=eY_Y_w_95JY&amp;list=PLuoaTfw_1lYwyxS-RQ7_Hwsd_gcAdVJtV" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eY_Y_w_95JY&amp;list=PLuoaTfw_1lYwyxS-RQ7_Hwsd_gcAdVJtV</a>  金融学</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之基础篇/">React Native之基础篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之基础篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React Native 介绍"></a>React Native 介绍</h4><pre><code>一、Native的类别

    React Native 编译后是原生应用，v0.22.0热更新hot reloading

    Hybrid  混合应用

    phoneGap 包皮应用，一次编写，到处运行，依然是网页，只是将页面内容内嵌到webView中，用中间件来对网页进行通信，对一些动画会有性能上的问题


二、实时加载（Live Reload）和热加载（Hot Reload）的区别

    http://www.jianshu.com/p/1fa6e9c0799f

    Enable Live Reload  实时加载，应用于更新时需要刷新当前页面，可以看到全局刷新效果

    Enable Hot Reloading   热加载，当布局修改时会自动更新模拟器，看不出来刷新效果类似买局部刷新

三、React Native 应用部署/热更新 codePush

    http://blog.csdn.net/fengyuzhengfan/article/details/52003798
</code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>1、安装 XCode

    $ xcode-select --install  检查xcode是否安装, 如果未安装会出现提示

    android 下载 android studio  https://developer.android.google.cn/index.html


2、安装 homebrew

    用于包管理，与npm类似

    $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;

    $ sudo chown -R `whoami` /usr/local   解决/usr/local目录不可写的权限问题  

    Homebrew将工具安装到 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。


3、安装 watchman 和 flow

    watchman是facebook的开源项目用于监视文件并且记录文件的改动情况

    flow 是js的静态类型检查器，用于找出js代码中的类型错误

    $ brew install watchman

    $ brew install flow


4、安装 NodeJS

5、安装 react-native 

    $ npm install -g react-native-cli      // Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载

6、vscode中react-native插件
</code></pre><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><pre><code>1、创建项目

    $ react-native init 项目名  // 创建项目

    $ react-native run-ios     // 运行 react-native run-ios --simulator &quot;iPhone 4s&quot;  定义模拟器类型

        或者在ios目录 AwesomeProject.xcodeproj  双击打开


2、查看命令

    $ react-native -h   所有命令

    $ react-native -v   版本


3、安装第三方插件

    $ npm i react-native-elements lodash query-string sha1 react-native-audio react-native-video react-native-image-picker react-native-progress react-native-sk-countdown react-native-swiper react-native-barcodescanner --save


4、link 命令

    link的原因：以下组件都是原生开发，wrapper了一层js，因此需要link .a到project中

    $ react-native link

    或 rnpm link     需要先安装rnpm     npm install rnpm -g --save-dev


5、模拟器调试技巧

    http://blog.csdn.net/quanqinyang/article/details/52215652  

    # 模拟器打开后可以通过cmd+1/2/3/4来调整窗口大小

    # 模拟器在所有窗口置顶 window -&gt; stay in front

    # ISO cmd + D 打开调试菜单，Android cmd + M

    # comond + T  show Animate 呼出菜单cmd+D会变成慢动画


    # Reload 重新bundle代码 cmd + R

    # Debug JS Remotely   调试模式 chrome Developer Tools调试

    # Enable Live Reload  实时加载，应用于更新时需要刷新当前页面，可以看到全局刷新效果

    # Enable Hot Reloading   热加载，当布局修改时会自动更新模拟器，看不出来刷新效果类似买局部刷新


    # 警告

        红错误 - console.error(&apos;&apos;)

        关闭警告 - console.disableYellowBox = true;    显示警告 - console.warn(&apos;YellowBox is disabled.&apos;);

    # 日志 - react-native log-ios      react-native log-android

    # chrome开发工具 - debug js Remotely  可以跟进代码
</code></pre><h4 id="react-native-目录"><a href="#react-native-目录" class="headerlink" title="react-native 目录"></a>react-native 目录</h4><pre><code>.
├── .DS_Store
├── .babelrc            // ES6转换的配置
├── .buckconfig
├── .flowconfig         // 做js代码类型检查 
├── .watchmanconfig     // 监听文件改变watchman的配置
├── .gitattributes
├── .gitignore          // 对哪些文件被git忽略不显示
├── node_modules        // 存储资源包    
├── __tests__
├── android             // android原生文件目录
├── ios                 // ios的原生文件目录 运行reactNative会将文件打包到这个目录，然后xcode调用的就是这里的项目文件
├── app.json
├── index.android.js    // android文件入口
├── index.ios.js        // ios文件入口
├── package.json        // 依赖文件
└── yarn.lock
</code></pre><h4 id="AppRegistry-注册模块，用来告诉RN哪个组件被注册为根窗口"><a href="#AppRegistry-注册模块，用来告诉RN哪个组件被注册为根窗口" class="headerlink" title="AppRegistry 注册模块，用来告诉RN哪个组件被注册为根窗口"></a>AppRegistry 注册模块，用来告诉RN哪个组件被注册为根窗口</h4><pre><code>AppRegistry是js运行RN应用的入口，通过registerComponent()来注册方法

AppRegistry.registerComponent(&apos;项目名&apos;, () =&gt; 入口组件名)  注册入口

AppRegistry.runApplication 来真正运行应用
</code></pre><h4 id="React-Native-生命周期"><a href="#React-Native-生命周期" class="headerlink" title="React Native 生命周期"></a>React Native 生命周期</h4><pre><code>第一阶段，初始化

    getDefaultProps -&gt; getInitialState -&gt; componentWillMount -&gt; render -&gt; componentDidMount

       获取配置参数        获取初始状态值         通知要开始渲染        渲染       告诉组件已经完成


第二阶段，运行阶段 组件运行中

    1、state变化 -&gt; shouldComponentUpdate -&gt; componentWhllUpdate -&gt;  render -&gt; componentDidUpdate

       状态变化    判断组件是否要更新true/false     需要更新就触发           渲染         更新组件

    2、props变化 -&gt; componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWhllUpdate -&gt;  render -&gt; componentDidUpdate

       props变化         属性改变调用             判断组件是否要更新true/false       需要更新就触发        渲染           更新组件


第三阶段 卸载

    unmount -&gt; componentWillUnmout -&gt; 结束 
</code></pre><p><img src="images/lifecycle.png" alt="组件生命周期"></p>
<h4 id="props、state"><a href="#props、state" class="headerlink" title="props、state"></a>props、state</h4><pre><code>一、props属性: 父组件传值给子组件

    &lt;Greeting name=&apos;Rexxar&apos; /&gt;      父组件调用子组件

    &lt;Text&gt;Hello {this.props.name}!&lt;/Text&gt;   子组件接收

    1、defaultProps定义默认的props

        class Smiple extends Component{
            static defaultProps = {     // 定义默认props静态属性
                name: &apos;siguang&apos;
            }

            static propsTypes = {       // 检测props的类型
                name: &apos;String&apos;
            }

            render(){
                return (
                    &lt;View&gt;
                        &lt;Text&gt; {this.props.name} &lt;/Text&gt;
                    &lt;View&gt;
                )
            }
        }


二、state状态、setState()改变状态，组件中可以改变的值

    export default class rrdProject extends Component {
        constructor(props){
            super(props);

            // 定义state对象
            this.state = { 
                showText: &apos;&apos;
            }
        }

        // state = {  };     // RN也支持ES7 类的静态属性写法

        render() {
            return(
                &lt;View style={styles.container}&gt;
                    &lt;Text&gt;这里有内容: {this.state.showText}&lt;/Text&gt;
                &lt;/View&gt;
            );
        }
    }
</code></pre><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><pre><code>通过ref来获取真实的DOM

import childComponent from &apos;./childComponent&apos;;

class Simple extends Component {
    clickChild(){
        var size = this.refs.childRef.getSize();       // 获取childComponent组件的getSize()方法
    }

    render() {
        return (
            &lt;View&gt;
                &lt;Text&gt;Simple 基本页面&lt;/Text&gt;
                &lt;button onPress={this.clickChild} title=&quot;点击&quot; /&gt;

                &lt;childComponent ref=&quot;childRef&quot; /&gt;
            &lt;/View&gt;
        )
    }
}
</code></pre><h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><pre><code>http://blog.csdn.net/sbsujjbcy/article/details/50017029
http://www.cnblogs.com/wonyun/p/5481134.html

1、直接写样式

    &lt;View style={{width: 193, height: 110}}&gt;&lt;/View&gt;     {{}} 两个括号可以直接写样式
    &lt;View style={styles.red}&gt;&lt;/View&gt;                    {} 一个括号需要来调用样式类
    const styles = StyleSheet.create({
        red: {
            color: red
        }
    })

2、写多个样式

    &lt;Text style={[styles.btn, styles.color]}&gt;立即体验&lt;/Text&gt;

    // 支持表达式
    &lt;Text style={[styles.btn, styles.color &amp;&amp; this.props.dotColor]}&gt;立即体验&lt;/Text&gt;


2、styleSheet.create({}) 定义样式

    const styles = StyleSheet.create({
        rootView:{
            height: &apos;100%&apos;,
            width: &apos;100%&apos;,
            backgroundColor: &apos;#eff0f3&apos;
        },
        big: {
            color: &apos;blue&apos;,
            fontSize: 30
        }
    })
    &lt;View style={styles.rootView}&gt;      // 多个样式 style={[styles.rootView, styles.big]}
        &lt;Text&gt;REACT NATIVE ELEMENTS&lt;/Text&gt;
    &lt;/View&gt;


3、颜色支持

    &apos;#ccc&apos;、 &apos;rgba(0,0,0,.4)&apos;、 &apos;transparent&apos;、 &apos;red&apos;


4、RN样式与css样式的异同

    View类型div，会默认占用窗口的100%宽度

    绝对定位和相对定位不需要父元素设置positioin，也没有zIndex配置

    不能将RN的inline元素设置maginTop、marginBottom

    样式继承只存在Text元素内的Text元素

        &lt;Text style={{color:'red'}}&gt;
             &lt;Text&gt;父：我是white还是red{&apos;\n&apos;}
                 &lt;Text&gt;子：那我是神马颜色&lt;/Text&gt;
             &lt;/Text&gt;
       &lt;/Text&gt;
</code></pre><h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h4><pre><code>直接给组件指定宽、高   &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;
http://www.devio.org/2016/08/01/Reac-Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/#和而不同

一、父视图属性:

    1、flexDirection(&apos;row&apos;, &apos;column&apos;,&apos;row-reverse&apos;,&apos;column-reverse&apos;)- 布局子元素的排列方向，默认是column不是row

        &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;
            &lt;View style={{flex:1, height: 50, backgroundColor: 'powderblue'}} /&gt;
            &lt;View style={{flex:2, height: 50, backgroundColor: 'skyblue'}} /&gt;
            &lt;View style={{flex:3, height: 50, backgroundColor: 'steelblue'}} /&gt;
        &lt;/View&gt;

        重要:  
            &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;  
            父组件没设置flexDirection=row，默认布局为列，子组件设置flex:1是没用的，子组件只能设置width
            父组件设置为flexDirection=row，子组件可以设置flex:1

    2、flexWrap (&apos;wrap&apos;, &apos;nowrap&apos;) - 定义子元素是否允许多行排列

    3、justifyContent (&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;space-between&apos;, &apos;space-around&apos;) - 定义子元素如何对齐

    4、alignItems (&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) - 定义子元素在侧轴对齐的


    justifyContent - 子元素沿主轴的排列方式

        justifyContent: flex-start、center、flex-end、space-around以及space-between
        &lt;View style={{ flex: 1,  flexDirection: 'row' justifyContent: center}}&gt;

    alignItems - 


二、子视图属性：

    1、alignSelf (&apos;auto&apos;, &apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) - 

    2、flex - 
</code></pre><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><pre><code>RN里网络请求分为: Fetch、WebSocket、XMLHttpRequest
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>onPress: 点击

onLongPress: 长按

maximumZoomScale和minimumZoomScale: 双指缩放

http://reactnative.cn/docs/0.42/panresponder.html
</code></pre><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><pre><code>1、LayoutAnimation 用于全局的布局动画

2、Animated 用于创建更精细的交互控制的动画

    Animated 封装了四个可以动画的组件: View、Text、Image和ScrollView

    start/stop 方法来控制动画按顺序执行
</code></pre><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><pre><code>setTimeout, clearTimeout
setInterval, clearInterval
setImmediate, clearImmediate
requestAnimationFrame, cancelAnimationFrame
</code></pre><h4 id="RN与原生通信"><a href="#RN与原生通信" class="headerlink" title="RN与原生通信"></a>RN与原生通信</h4><pre><code>http://blog.csdn.net/zww1984774346/article/details/71167775

rn与IOS原生通信的三部分

    1、属性        2、原生模块      3、原生UI组件封装

    原生要写到AppDelegate.m文件中

    # 属性是最简单的跨组件通信，从原生组件传递属性到React Native 或 React Native到原生组件

        原生中添加imageList:

            NSArray *imageList = @[@&quot;https://facebook.github.io/react/img/logo_og.png&quot;,
                        @&quot;https://facebook.github.io/react/img/logo_og.png&quot;];

            NSDictionary *props = @{@&quot;images&quot; : imageList};

            RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                        moduleName:@&quot;AwesomeProject&quot;
                                        initialProperties:props             // 这里initialProperties:props]传递给RN
                                        launchOptions:launchOptions];

        RN中接收与props传值一样:

            &lt;View&gt;
                {
                    this.props.images.map(function(items){
                        return &lt;Image 
                            source={{uri:items}} 
                            style={{width:100,height:100}}&gt;&lt;/Image&gt; 
                    })
                }
            &lt;/View&gt;


1、RN访问OC

    // 创建原生模块实例
    var NativeModule = require(&apos;react-native&apos;).NativeModules.NativeTest;

    // 调用原生的doSomething()方法
    NativeModule.doSomething(&apos;ReactNative&apos;);


2、OC访问RN

http://www.jianshu.com/p/9d7dbf17daa5
</code></pre><h4 id="生成测试包"><a href="#生成测试包" class="headerlink" title="生成测试包"></a>生成测试包</h4><pre><code>iOS—最全的真机测试教程   http://www.cocoachina.com/ios/20160711/17004.html

团队开发的Xcode配置和生成包

    xCode -&gt; Preferencse -&gt; Accounts -&gt; + 填加 选择 add apple ID 将账号和密码输入

    点击工程目录 -&gt; General 
        -&gt; Identity面板下的 Bundle Identifler 填写权限 “com.ucredit.paydayloan” 
        -&gt; 在 Signing面板中的 Team 中选择&quot;ZhongChengXingyu of......&quot;

    将手机与mac连接，将Device选择当前手机设备，点击 运行，写读取设备成功后，在运行一次这次是执行build
</code></pre><h4 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h4><pre><code>两种方法加载原生组件

1、react-native link 命令

    不仅会将第三方模块的原生组件代码链接入 Android/IOS 中，还会将字体等文件移动相应的目录中

2、通过Xcode来导入组件

    http://www.cnblogs.com/shaoting/p/6148085.html

3、Flow

    Flow是 Facebook出品的表态类型语言，可以将RN内部也支持ES 7的类属性的写法

        // 就可以不用在象ES 6将静态属性写到constructor中
        class MyComponent extends Component {
            constructor(props){
                super(props);

                // 私有属性
                this.isField = 1;   
                // state
                this.state = {
                    username: &apos;siguang&apos;
                }
            }

            render(){
                return (
                    &lt;View&gt;
                        {this.username}
                    &lt;/View&gt;
                )
            }
        }

        class MyComponent extends Component {
            isField = 1;
            state = {
                username: &apos;siguang&apos;
            }

            render(){
                return (
                    &lt;View&gt;
                        {this.usernmae}
                    &lt;/View&gt;
                )
            }
        }
</code></pre><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><pre><code>1、Command+R  重新刷新

2、Command+D  打开菜单 

3、Debug JS Remotely 用chrome浏览器调试,Alt+Command+j出现浏览器debug窗口

4、Disable Live Reload 时实刷新，代码修改保存后会就刷新

5、show Perf Monitor 打开FPS监控器

6、show Inspector 用于查看页面结构及属性
</code></pre><p>XCode装证书<br><a href="http://www.cocoachina.com/ios/20160711/17004.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160711/17004.html</a></p>
<p>| 相关文章<br>| <a href="https://github.com/jondot/awesome-react-native#videos" target="_blank" rel="noopener">https://github.com/jondot/awesome-react-native#videos</a><br>| <a href="http://reactnative.cn/docs/0.44/getting-started.html" target="_blank" rel="noopener">http://reactnative.cn/docs/0.44/getting-started.html</a><br>| <a href="http://www.devio.org/" target="_blank" rel="noopener">http://www.devio.org/</a><br>| <a href="https://github.com/crazycodeboy/RNStudyNotes/" target="_blank" rel="noopener">https://github.com/crazycodeboy/RNStudyNotes/</a><br>| <a href="http://blog.csdn.net/quanqinyang/article/details/52215652" target="_blank" rel="noopener">http://blog.csdn.net/quanqinyang/article/details/52215652</a>   调试方法<br>| <a href="http://lib.csdn.net/base/reactnative/structure" target="_blank" rel="noopener">http://lib.csdn.net/base/reactnative/structure</a><br>| <a href="http://www.jianshu.com/p/5b185df2d11a" target="_blank" rel="noopener">http://www.jianshu.com/p/5b185df2d11a</a><br>| <a href="http://www.lcode.org/react-native/" target="_blank" rel="noopener">http://www.lcode.org/react-native/</a><br>| <a href="http://blog.csdn.net/column/details/reactnative2016.html?&amp;page=3" target="_blank" rel="noopener">http://blog.csdn.net/column/details/reactnative2016.html?&amp;page=3</a><br>| <a href="http://lib.csdn.net/article/reactnative/63268" target="_blank" rel="noopener">http://lib.csdn.net/article/reactnative/63268</a>   打包到真机<br>|<br>| 示例<br>| <a href="https://github.com/react-native-community" target="_blank" rel="noopener">https://github.com/react-native-community</a><br>| <a href="https://github.com/ljunb/react-native-iShiWuPai" target="_blank" rel="noopener">https://github.com/ljunb/react-native-iShiWuPai</a>       示例<br>| <a href="https://github.com/sunnylqm" target="_blank" rel="noopener">https://github.com/sunnylqm</a><br>| <a href="https://github.com/DoctorQ/react-native-helloworld" target="_blank" rel="noopener">https://github.com/DoctorQ/react-native-helloworld</a><br>|<br>| <a href="http://blog.csdn.net/liu__520/article/category/6460088" target="_blank" rel="noopener">http://blog.csdn.net/liu__520/article/category/6460088</a><br>| <a href="http://www.devio.org/tags/#React" target="_blank" rel="noopener">http://www.devio.org/tags/#React</a> Native<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/NPM/">NPM 常用命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/NPM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/npm/">npm</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么"></a>npm是什么</h4><pre><code>资源包的管理器，安装NodeJS时会直接安装NPM
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>$ 下载并安装node.js也就将npm直接安装

$ npm install npm@latest -g        // 更新npm

$ npm i [package_name]         // 安装包，将在当前目录创建一个node_modules目录，将下载的包保存到这个目录

$ npm update     // 获取最新的包并更新

$ npm uninstall [package_name]    // 卸载包，命令是将node_modules目录将包的文件删除

$ npm uninstall --save [package_name]    // 卸载包，将从package.json文件中删除依赖, 如果--save-dev安装就需要换成--save-dev

# npm i -g [package_name]    // 全局安装包，两种安装本地和全局安装，如果遇到acces错误权限问题，需要在前面加sudo，安装在/usr/local/lib/node_modules/中

$ npm update -g [package_name]    // 更新全局包

$ npm uninstall -g [package_name]    // 卸载全局包
</code></pre><h4 id="package-json参数介绍"><a href="#package-json参数介绍" class="headerlink" title="package.json参数介绍"></a>package.json参数介绍</h4><pre><code>name - 包名

version - 包的版本号

description - 包的描述

homepage - 包的官网 url 

author - 包的作者姓名

contributors - 包的其他贡献者姓名

dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下

repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上

main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(&quot;express&quot;)

keywords - 关键字
</code></pre><h4 id="npm-install-安装模块"><a href="#npm-install-安装模块" class="headerlink" title="npm install 安装模块"></a>npm install 安装模块</h4><pre><code>npm i [package_name] --save-dev

1、-S, --save 安装包添加到dependencies（项目依赖)中

    npm i 包名 --save

    当发布时可以不会将node_module目录发布出去，可以将package.json发布出去，其它项目的人，可以通过npm install 下载dependenciess中的所有包内容.

    例：
        npm install gulp --save 或 npm install gulp -S

        &quot;dependencies&quot;: {
            &quot;gulp&quot;: &quot;^1.0.0&quot;
        }

2、-D, --save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它

    npm install gulp --save-dev 或 npm install gulp -D

    &quot;devDependencies&quot;: {
        &quot;gulp&quot;: &quot;^1.0.0&quot;
    }


3、-O, --save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）

    npm install gulp --save-optional 或 npm install gulp -O

    &quot;optionalDependencies&quot;: {
        &quot;gulp&quot;: &quot;^1.0.0&quot;
    }


4、-E, --save-exact 精确安装指定模块版本

    npm install gulp --save-exact 或 npm install gulp -E

    输入命令npm install gulp -ES，留意package.json 文件的 dependencies 字段，以看出版本号中的^消失了

    &quot;dependencies&quot;: {
        &quot;gulp&quot;: &quot;3.9.1&quot;
    }
</code></pre><h4 id="npm-i-选项–global，–save，–save-dev"><a href="#npm-i-选项–global，–save，–save-dev" class="headerlink" title="npm i 选项–global，–save，–save-dev"></a>npm i 选项–global，–save，–save-dev</h4><pre><code>-global: 简写 -g

    npm i express -g 为全局安装，这种就可以直接使用express命令, 否则会提示express不是内部或外部命令

-save: 简写 -S, 作用是在package.json的dependencies字段增加或修改安装包和版本号

-save-dev: 简写 -D, 是修改devDependencies, 这样就不用安装了某个包之后手动修改package.json
</code></pre><h4 id="与-版本"><a href="#与-版本" class="headerlink" title="~ 与 ^ 版本"></a>~ 与 ^ 版本</h4><pre><code>版本分为: 主版本号、次版本号、补丁版本号

&quot;devDependencies&quot;: {
    &quot;vue&quot;: &quot;~2.2.2&quot;,            // 匹配最近小版本，如，会匹配所有的2.2.x版本，但最高不会匹配2.3.0
    &quot;vue-router&quot;: &quot;^2.2.0&quot;        // 最近的一个大版本，所有 2.x.x但不不包括3.0.0，相当于 2.0.0 &lt;= version &lt; 3.0.0
}
</code></pre><h4 id="npm-ls-查看安装的模块"><a href="#npm-ls-查看安装的模块" class="headerlink" title="npm ls 查看安装的模块"></a>npm ls 查看安装的模块</h4><pre><code>查看安装模块及依赖：npm ls -g
</code></pre><h4 id="发布模块"><a href="#发布模块" class="headerlink" title="发布模块"></a>发布模块</h4><pre><code>使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：

$ npm adduser
Username: mcmohd
Password:
Email: (this IS public) xxxxxx@qq.com

来发布模块命令: $ npm publish
</code></pre><h4 id="script属性"><a href="#script属性" class="headerlink" title="script属性"></a>script属性</h4><pre><code>script属性定义的对应了一段shell脚本

1、npm start 启动模块

    该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序

    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;gulp -ws&quot;
    }

2、npm stop 停止模块

3、npm restart 重新启动模块
</code></pre><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><pre><code>一、npm使用过程中遇到的 Cannot find module &apos;internal/fs&apos;，错误场景 gulp中执行任务报错，的确amd-optimize插件中的graceful-fs与gulp中graceful-fs的版本问题，

    解决:
        删除插件 npm uninstall graceful-fs
        安装  npm i graceful-fs --save

二、$ npm view react versions    查看包在npm所有版本

三、$ npm i vue@2.0.0 --save    安装指定版本
</code></pre><p>| 参考资料<br>| <a href="https://www.npmjs.com.cn/" target="_blank" rel="noopener">https://www.npmjs.com.cn/</a><br>| <a href="https://www.cnblogs.com/blackgan/p/7828047.html" target="_blank" rel="noopener">https://www.cnblogs.com/blackgan/p/7828047.html</a>            常用命令<br>| <a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/master-npm/</a><br>| <a href="https://github.com/ericdum/mujiang.info/issues/6/" target="_blank" rel="noopener">https://github.com/ericdum/mujiang.info/issues/6/</a><br>| <a href="http://www.luckyonecn.com/blog/difference_between_dependencies_and_devdependencies_in_npm/" target="_blank" rel="noopener">http://www.luckyonecn.com/blog/difference_between_dependencies_and_devdependencies_in_npm/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之组件篇/">React Native之组件篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之组件篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h5 id="组件列表"><a href="#组件列表" class="headerlink" title="组件列表"></a>组件列表</h5><pre><code>ListView - 用于展示数据列表

ScrollView - 带滚动条的容器

Fetch - 请求网络接口数据

TarBarIOS - 切换菜单

TouchableHighlight - 封装视图，可以将一些内容放到这个容器中方便处理点击


View - 窗口，相当于div

Image - 加载图片

Text - 展示文本

TextInput - 文本输入框

Button - 按钮
</code></pre><h4 id="根据ios、android不同系统"><a href="#根据ios、android不同系统" class="headerlink" title="根据ios、android不同系统"></a>根据ios、android不同系统</h4><pre><code>定义一个兼容组件:
    var Component = Platform.select({
        ios: () =&gt; require(&apos;ComponentIOS&apos;),
        android: () =&gt; require(&apos;ComponentAndroid&apos;),
    })();

调用组件
    &lt;Component /&gt;


样式兼容:
    import { Platform, StyleSheet } from &apos;react-native&apos;;
    var styles = StyleSheet.create({
        height: (Platform.OS === &apos;ios&apos;) ? 200 : 100,
    });

    import { Platform, StyleSheet } from &apos;react-native&apos;;
    var styles = StyleSheet.create({
        container: {
            flex: 1,
            ...Platform.select({
            ios: {
                backgroundColor: &apos;red&apos;,
            },
            android: {
                backgroundColor: &apos;blue&apos;,
            },
            }),
        },
    });
</code></pre><h4 id="react-native-内置组件"><a href="#react-native-内置组件" class="headerlink" title="react-native 内置组件"></a>react-native 内置组件</h4><pre><code>需要在react-native对象进行解构 

import {View, TextInput, Text} from &apos;react-native&apos;
</code></pre><h4 id="View-用来布局的组件"><a href="#View-用来布局的组件" class="headerlink" title="View 用来布局的组件"></a>View 用来布局的组件</h4><pre><code>&lt;View style={{ flex: 1; justifyContent: 'center', alignItems: 'center}}&gt;
    &lt;Text&gt;xxxxx&lt;/Text&gt;
&lt;/View&gt;
</code></pre><h4 id="Text-显示文本内容"><a href="#Text-显示文本内容" class="headerlink" title="Text 显示文本内容"></a>Text 显示文本内容</h4><pre><code>&lt;Text&gt;Component A&lt;/Text&gt;
</code></pre><h4 id="TextInput-文本输入框"><a href="#TextInput-文本输入框" class="headerlink" title="TextInput 文本输入框"></a>TextInput 文本输入框</h4><pre><code>属性: 

    autoCapitalize - 枚举类型，可选值有none,sentences,words,characters.当用户输入时，用于提示。

    placeholder - 占位符，在输入前显示的文本内容。

    value - 文本输入框的默认值。

    placeholdertTextColor - 占位符文本颜色。

    password - 如果为ture ， 则是密码输入框，文本显示为＊＊＊。

    multiline - 如果为true ， 则是多行输入。

    editable - 如果为false ， 文本框不可输入。其默认值事true。

    autoFocus - 如果为true， 将自动聚焦。

    clearButtonMode - 枚举类型，可选值有never，while－enditing , unless-editing,always.用于显示清除按钮。

    maxLength - 能够输入的最长字符数。

    enablesReturnKeyAutomatically : 如果值为true，表示没有文本时键盘是不能有返回键的。其默认值为false。

    returnKeyType - 枚举类型，可选值有default,go,google,join,next,route,search,send,yahoo,done,emergency-call。表示软键盘返回键显示的字符串。

事件:

    onChangeText - 当文本输入框的内容发生变化时，调用该函数。onChangeText接收一个文本的参数对象。

    onChange - 当文本变化时，调用该函数。

    onEndEditing - 当结束编辑时，调用该函数。

    onBlur - 失去焦点出发事件。

    onFocus - 获得焦点出发事件。

    onSubmitEditing : 当结束编辑后，点击键盘的提交按钮出发该事件。


&lt;TextInput
    style={styles.inp}
    placeholder=&quot;none&quot;
    autoCapitalize=&quot;none&quot; /&gt;
</code></pre><h4 id="Keyboard-控制-键盘的"><a href="#Keyboard-控制-键盘的" class="headerlink" title="Keyboard 控制 键盘的"></a>Keyboard 控制 键盘的</h4><h4 id="KeyboardAvoidingView-键盘"><a href="#KeyboardAvoidingView-键盘" class="headerlink" title="KeyboardAvoidingView  键盘"></a>KeyboardAvoidingView  键盘</h4><pre><code>用于解决手机上弹出键盘挡住视图，本组件可以自动根据键盘的位置，调整自身的position
</code></pre><h4 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h4><pre><code>color: 颜色       disabel: 是否可用       onPress: 点击事件       title: 按钮文本

&lt;Button
    onPress={onPressLearnMore}
    title=&quot;Learn More&quot;
    color=&quot;#841584&quot;
    accessibilityLabel=&quot;Learn more about this purple button&quot; /&gt;
</code></pre><h4 id="Image-图片-加载的两种方式"><a href="#Image-图片-加载的两种方式" class="headerlink" title="Image 图片 加载的两种方式"></a>Image 图片 加载的两种方式</h4><pre><code>onLayout: 元素挂载或布局中改变调用      onLoad: 加载成功完成调用        onLoadEnd: 加载结束后，无论成功失败都调用

resizeMode:  cover:等比拉伸      strech:保持原有大小       contain:图片拉伸  充满空间

source: 图片的资源地址


1、require引用  使用静态图片资源

    &lt;Image source={require(&apos;./components/images/i1.png&apos;)} style={{width: 100, height: 100}} resizeMode={&apos;cover&apos;} /&gt;

    注: 使用require静态资源，不允许拼接url &lt;Image source={require(&apos;./img/my_icon&apos;+&apos;.png&apos;)} /&gt;


2、uri  使用网络图片资源

    &lt;Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} style={{width: 400, height: 400}} /&gt;


3、使用原生图片资源(ios中的图片)

    打开xCode 在工程 打开images xcassets目录，将图片vue-banner.jpg拖入到appicon下进行导入

    加载 &lt;Image source={{uri: 'vue-banner'}} style={styles.imgStyle2} resizeMode=&quot;cover&quot; /&gt;  重启项目


4、使用本地文件系统中的资源(相册里的图片)
</code></pre><h4 id="TarBarIOS-选项卡插件-只能在根元素不能被任何元素包裹"><a href="#TarBarIOS-选项卡插件-只能在根元素不能被任何元素包裹" class="headerlink" title="TarBarIOS  选项卡插件 只能在根元素不能被任何元素包裹"></a>TarBarIOS  选项卡插件 只能在根元素不能被任何元素包裹</h4><pre><code>TabBarIOS 属性

    barTintColor 标签栏背景色 

    tintColor 当前选中的标签颜色 

    translucent Boolean  是否标签栏半透明

    &lt;TabBarIOS barTintColor=&quot;#ccc&quot; tintColor=&quot;#fff&quot;&gt;
        &lt;TabBarIOS.Item&gt; ... &lt;/TabBarIOS.Item&gt;
    &lt;/TabBarIOS&gt;


TabBarIOS.Item 属性

    title: 图标下面的标题文字

    badge: 右上角显示一个红色气泡 提示气泡

    icon: 显示的图标  

        icon={require(&apos;../images/i4.png&apos;)} 加载本地

        icon={{uri: base64Icon, scale: 3}} 加载其它 并且带缩放

    selectedIcon: 选中的图标

    selected: 是否为选中状态 selected: {this.state.selectName = &apos;blue&apos;}

    onPress(): 按下
</code></pre><h4 id="Fetch-网络请求"><a href="#Fetch-网络请求" class="headerlink" title="Fetch 网络请求"></a>Fetch 网络请求</h4><pre><code>获取接口数据, 处理get或post的请求

Example:

    1、Get

    onPressLearnMore(){
        let that = this;
        const REQUEST_URL = &apos;http://goucai.diyicai.com/lottery/hisnumber.action?lotteryId=001&amp;issueLen=20&amp;d=1496242956216&apos;;

        fetch(REQUEST_URL)
            .then((response) =&gt; {
                return response.json();  //把response转为json
            })
            .then((responseData) =&gt; {   // 接收上面的转好的json
                debugger;
                let data = responseData[0].ernieDate;
                that.setState({lotter: data})
                console.log(data);
            })
            .catch((error) =&gt; {
                this.setState({
                    error: true,
                    errorInfo: error
                })
            })
            .done();
    }

    2、post:

    fetch(&apos;https://mywebsite.com/endpoint/&apos;, {
        method: &apos;POST&apos;,
        headers: {
            &apos;Accept&apos;: &apos;application/json&apos;,
            &apos;Content-Type&apos;: &apos;application/json&apos;,
        },
        body: JSON.stringify({
            firstParam: &apos;yourValue&apos;,
            secondParam: &apos;yourOtherValue&apos;,
        })
    })
</code></pre><h4 id="FlatList-加载网络数据"><a href="#FlatList-加载网络数据" class="headerlink" title="FlatList 加载网络数据"></a>FlatList 加载网络数据</h4><h4 id="SectionList-分组的列表组件"><a href="#SectionList-分组的列表组件" class="headerlink" title="SectionList 分组的列表组件"></a>SectionList 分组的列表组件</h4><pre><code>不需要分组可以使用FlatList, 如果需要分组使用SectionList
</code></pre><h4 id="TouchableHighlight-封装视图-把一部分内容放到一个容器中可以方便处理"><a href="#TouchableHighlight-封装视图-把一部分内容放到一个容器中可以方便处理" class="headerlink" title="TouchableHighlight  封装视图 把一部分内容放到一个容器中可以方便处理"></a>TouchableHighlight  封装视图 把一部分内容放到一个容器中可以方便处理</h4><pre><code>render: function () {
    return (
        &lt;TouchableHighlight onPress={this._onPressButton} style={styles.mt40}&gt;
            &lt;View&gt;
                &lt;Text&gt;{this.state.userName}&lt;/Text&gt;
                &lt;Image
                    style={styles.mt40}
                    source={require(&apos;./src/images/1.jpg&apos;)}
                /&gt;
            &lt;/View&gt;                    
        &lt;/TouchableHighlight&gt;
    );
}
</code></pre><h4 id="Dimensions-获取设备屏幕的宽高"><a href="#Dimensions-获取设备屏幕的宽高" class="headerlink" title="Dimensions  获取设备屏幕的宽高"></a>Dimensions  获取设备屏幕的宽高</h4><pre><code>let winWidth = Dimensions.get(&apos;window&apos;).width;
let winHeight = Dimensions.get(&apos;window&apos;).height;
</code></pre><h4 id="DatePickerIOS-日期选择器"><a href="#DatePickerIOS-日期选择器" class="headerlink" title="DatePickerIOS  日期选择器"></a>DatePickerIOS  日期选择器</h4><pre><code>date: 当前被选中的日期      mode: 选择器模式       onDateChange: 选中事件

maximumdDate: 可选的最大日期       minimumDate: 可选的最小日期        

minuteInterval: 可选的最小分钟     timeZoneOffsetInMinutes: 时区差，单位分钟
</code></pre><h4 id="TimePickerAndroid-Android时间选择器的对话框"><a href="#TimePickerAndroid-Android时间选择器的对话框" class="headerlink" title="TimePickerAndroid Android时间选择器的对话框"></a>TimePickerAndroid Android时间选择器的对话框</h4><h4 id="ActivityIndicator-loading加载图标"><a href="#ActivityIndicator-loading加载图标" class="headerlink" title="ActivityIndicator  loading加载图标"></a>ActivityIndicator  loading加载图标</h4><pre><code>animating: 是否显示 true false

color: 图片颜色

size: 大小  small large
</code></pre><h4 id="Modal-弹层"><a href="#Modal-弹层" class="headerlink" title="Modal  弹层"></a>Modal  弹层</h4><pre><code>不是弹窗，而是整弹个层

animationType: 展示层的动画效果  slide 滑动   fade 淡入淡出    none 无

onRequestClose: 
</code></pre><h4 id="alert、AlertIOS-对话框"><a href="#alert、AlertIOS-对话框" class="headerlink" title="alert、AlertIOS  对话框"></a>alert、AlertIOS  对话框</h4><pre><code>Alert.alert(标题，内容，[{确定按钮和}]

&lt;Text onPress={() =&gt; Alert.alert(
    &apos;这里是弹层的标题&apos;,
    &apos;这里是内容&apos;,
    [
        {text: &apos;取消&apos;, onPress: () =&gt; console.log(&apos;Cancel Pressed!&apos;)},    // 显示的按钮和回调函数
        {text: &apos;确定&apos;, onPress: () =&gt; console.log(&apos;OK Pressed!&apos;)},
    ]
)}&gt;点击显示弹窗&lt;/Text&gt;
</code></pre><h4 id="Navigator-NavigatorIOS-导航"><a href="#Navigator-NavigatorIOS-导航" class="headerlink" title="Navigator NavigatorIOS  导航"></a>Navigator NavigatorIOS  导航</h4><h4 id="StatusBar-状态栏组件"><a href="#StatusBar-状态栏组件" class="headerlink" title="StatusBar 状态栏组件"></a>StatusBar 状态栏组件</h4><pre><code>控制顶部运营商、电量位置的

属性: 

    animated bool   进行设置当状态栏的状态发生变化的时候是否需要加入动画。当前该动画支持backgroundColor,barStyle和hidden属性

    hidden  bool  进行设置状态栏是否隐藏（最顶部的那条栏）

    backgroundColor   color类型，仅支持Android设备，设置状态栏的背景颜色

    translucent bool类型，仅支持Android设备, 进行设置状态栏是否为透明。当状态栏的值为true的时候，应用将会在状态栏下面进行绘制显示。这样在Android平台上面就是沉浸式的效果，可以达到Android和iOS应用一致性效果。该值常常配置半透明效果的状态栏颜色一起使用

    barStyle  enum(&apos;default&apos;,&apos;light-content&apos;)  枚举类型，仅支持iOS设备。进行设置状态栏文字的颜色

    networkActivityIndicatorVisible   bool类型，仅支持iOS设备。设置状态栏上面的网络进度加载器是否进行显示

    showHideTransition   enum(&apos;fade&apos;,&apos;slide&apos;) 枚举类型，仅支持iOS设备。进行设置当隐藏或者显示状态栏的时候的动画效果。默认值为&apos;fade&apos;
</code></pre><h4 id="Picker-PickerIOS-象select的选择菜单"><a href="#Picker-PickerIOS-象select的选择菜单" class="headerlink" title="Picker PickerIOS  象select的选择菜单"></a>Picker PickerIOS  象select的选择菜单</h4><pre><code>1、selectedValue: 选中后的值

2、onValueChange: 触发事件

3、PickerIOS.Item: 定义菜单的先项

&lt;PickerIOS
    style={{width:200}}
    selectedValue={this.state.language}
    onValueChange={(lang) =&gt; this.setState({language: lang})}&gt;
    &lt;PickerIOS.Item label=&quot;Java&quot; value=&quot;java&quot; /&gt;
    &lt;PickerIOS.Item label=&quot;JavaScript&quot; value=&quot;js&quot; /&gt;
&lt;/PickerIOS&gt;
&lt;Text&gt;当前选择的是:{this.state.language}&lt;/Text&gt;
</code></pre><h4 id="Slider-选择一个范围的组件-滑块"><a href="#Slider-选择一个范围的组件-滑块" class="headerlink" title="Slider  选择一个范围的组件, 滑块"></a>Slider  选择一个范围的组件, 滑块</h4><pre><code>属性:

    disabled    bool    如果为true，用户无法移动这个滑动条。默认值为false

    maximumValue    number    滑动条最大值。默认为1

    minimumValue    number    滑动条最小值，默认为0

    onSlidingComplete    function    当用户完成值的改变被回调的方法

    onValueChange    function    当用户正在滑动滑动条持续回调的方法

    step    number    滑动条的最小单位。这个值应该在0到最大值-最小值之间。默认为0

    testID    string    

    value    number    滑动条选择的值。这个值应该在最小值和最大值之间，它们的默认值分别为0和1。默认值为0
</code></pre><h4 id="Switch-开关滑块组件"><a href="#Switch-开关滑块组件" class="headerlink" title="Switch  开关滑块组件"></a>Switch  开关滑块组件</h4><pre><code>disabled 是否禁用

onValueChange 当值改变时回调

value 开关是否打开，默认false

onTintColor: 开启状态背景颜色

tintColor: 关闭状态时边框颜色或背景色

thumbTintColor: 开关上按钮的颜色     

testID
</code></pre><h4 id="ScrollView-可滚动的容器，可以放多个组件和视图"><a href="#ScrollView-可滚动的容器，可以放多个组件和视图" class="headerlink" title="ScrollView  可滚动的容器，可以放多个组件和视图"></a>ScrollView  可滚动的容器，可以放多个组件和视图</h4><h4 id="ListView-用于垂直滚动列表，用于元素之间结构近似而仅数据不同-listView不立即渲染所有元素-优先渲染屏幕可见元素"><a href="#ListView-用于垂直滚动列表，用于元素之间结构近似而仅数据不同-listView不立即渲染所有元素-优先渲染屏幕可见元素" class="headerlink" title="ListView  用于垂直滚动列表，用于元素之间结构近似而仅数据不同, listView不立即渲染所有元素, 优先渲染屏幕可见元素"></a>ListView  用于垂直滚动列表，用于元素之间结构近似而仅数据不同, listView不立即渲染所有元素, 优先渲染屏幕可见元素</h4><pre><code>ListView继承了ScrollView所以有ScrollView下所有的属性

ListView属性:

    dataSource - 列表数据源

    renderRow - 解析每一条的数据的展示结构样式

    rowHasChanged - 函数也是ListView的必需属性。这里我们只是简单的比较两行数据是否是同一个数据（===符号只比较基本类型数据的值，和引用类型的地址）来判断某行数据是否变化了。

    scrollView - automaticallyAdjustContentInsets={false} 如果不设置这个属性顶部会一个块留白

ListView方法:

    ListView.DataSource - 用于比对两条数据是否相同，如果不相同进行渲染


Example:

    class DemoComponent extends Component {
        constructor(props){
            super(props);
            const ds = new ListView.DataSource({
                rowHasChanged: (r1, r2) =&gt; r1 !== r2
            });

            this.state = {
                dataSource: ds.cloneWithRows([
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    },
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    },
                    {
                        img: require(&apos;../../images/car-img.png&apos;),
                        title: &apos;福特福克斯2011款 两厢 1.8L 自动时尚型&apos;
                    }               
                ])
            }
        }

        // 返回每一条数据的结构
        carRenderRow(rowData){
            return (
                &lt;View style={styles.carList}&gt;
                    &lt;Image source={rowData.img} style={styles.carPicture} /&gt;
                    &lt;Text style={styles.carFont1}&gt;{rowData.title}&lt;/Text&gt;                  
                &lt;/View&gt;
            )
        }

        render(){
            return (
                &lt;View style={{flex: 1, marginBottom: 60}}&gt;
                    &lt;ListView
                        dataSource={this.state.dataSource}
                        renderRow={this.carRenderRow} /&gt;             
                &lt;/View&gt;
            )
        }
    }
</code></pre><h4 id="RefreshControl-下拉刷新"><a href="#RefreshControl-下拉刷新" class="headerlink" title="RefreshControl  下拉刷新"></a>RefreshControl  下拉刷新</h4><pre><code>PullToRefreshAndroidView 也是实现下拉刷新的组件

属性方法

    onRefresh  function方法 当视图开始刷新的时候调用

    refreshing  bool  决定加载进去指示器是否为活跃状态，也表名当前是否在刷新中

    colors [ColorPropType]   android平台适用  进行设置加载进去指示器的颜色，至少设置一种，最好可以设置4种

    enabled  bool   android平台适用   用来设置下拉刷新功能是否可用

    progressBackgroundColor ColorPropType  设置加载进度指示器的背景颜色

    size RefreshLayoutConsts.SIZE.DEFAULT  android平台适用  加载进度指示器的尺寸大小 ，具体可以查看RefreshControl.SIZE(详细点击进入)

    tintColor ColorPropType   iOS平台适用  设置加载进度指示器的颜色

    title string iOS平台适用  设置加载进度指示器下面的标题文本信息
</code></pre><h4 id="AppState、AppStateIOS-获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你"><a href="#AppState、AppStateIOS-获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你" class="headerlink" title="AppState、AppStateIOS  获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你"></a>AppState、AppStateIOS  获取应用当前是在前台还是在后台，并且能在状态变化的时候通知你</h4><pre><code>AppState.currentState 返回的值:

    active - 表示当前App在前台运行

    background - 应用正在后台运行。用户既可能在别的应用中，也可能在桌面。

    inactive - 该状态我们可以暂时不考虑，因为该状态不会出现在现在React Native App中。
</code></pre><h4 id="AppRegistry-运行RN的入口"><a href="#AppRegistry-运行RN的入口" class="headerlink" title="AppRegistry 运行RN的入口"></a>AppRegistry 运行RN的入口</h4><pre><code>AppRegistry.registerComponent(&apos;exampleApp&apos;, () =&gt; exampleApp);
</code></pre><h4 id="AsyncStorage-简单的、未加密的、异步的、持久化的Key-Value存储系统"><a href="#AsyncStorage-简单的、未加密的、异步的、持久化的Key-Value存储系统" class="headerlink" title="AsyncStorage  简单的、未加密的、异步的、持久化的Key-Value存储系统"></a>AsyncStorage  简单的、未加密的、异步的、持久化的Key-Value存储系统</h4><pre><code>一、方法: anyncStroage每个方法返回的都是一个Promise

    getItem(key, callback) - 获取数据

    setItem(key, value, callback) - 存储数据

    removeItem(key, callback) - 删除数据

    mergeItem(key, value, callback) - 合并两值

    clear() - 删除全部

    getAllKeys(callback) - 获取所有可访问到的数据

    flushGetRequest() - 清除所有进行中的查询操作

    multiGet(keys &lt;Array&gt;, callback) - 获取keys所包含所有的字段值

        AsyncStroage.multiGet([&apos;user&apos;, &apos;enter&apos;])
            .then((data) =&gt; {
                // 这里可以取到本地存储中的user和enter的值
                /*
                * data返回的是一个二维数组
                * [
                *   [&quot;key1&quot;, &quot;aaa&quot;],
                *   [&quot;key2&quot;, &quot;bbb&quot;]
                * ]
                */

                let user = JSON.parse(data);
            })
</code></pre><h4 id="ProgressBarAndroid-ProgressViewIOS-加载进度"><a href="#ProgressBarAndroid-ProgressViewIOS-加载进度" class="headerlink" title="ProgressBarAndroid ProgressViewIOS 加载进度"></a>ProgressBarAndroid ProgressViewIOS 加载进度</h4><pre><code>属性:

    View 相关属性样式全部继承(例如:宽和高,背景颜色,边距等相关属性样式)

    progress number  设置进度值 (范围在0-1之间)

    progressTintColor  string  设置进度条本身的颜色

    progressViewStyle   enum(&apos;default&apos;,&apos;bar&apos;)  加载进度的风格   枚举类型 默认风格和Bar条类型

    trackImage   Image.propTypes.source    设置一个可以拉伸的图片，设置进度条剩下部分进度的图片

    trackTintColor  string   进度条的颜色(已经有进度的情况)
</code></pre><h4 id="DrawerLayoutAndroid-抽屉-安卓"><a href="#DrawerLayoutAndroid-抽屉-安卓" class="headerlink" title="DrawerLayoutAndroid   抽屉 安卓"></a>DrawerLayoutAndroid   抽屉 安卓</h4><p>SegmentedControlIOS<br>ToolbarAndroid<br>TouchableNativeFeedback<br>TouchableOpacity<br>TouchableWithoutFeedback<br>ViewPagerAndroid<br>VirtualizedList<br>WebView</p>
<p>API<br>ActionSheetIOS<br>AdSupportIOS<br>Animated<br>BackAndroid<br>BackHandler     后退<br>CameraRoll      访问本地相册<br>Clipboard       读写剪贴板的内容<br>DatePickerAndroid  Android日期选择器的对话框<br>Easing<br>Geolocation     地理位置<br>ImageEditor     根据URI剪裁对应的图片<br>ImagePickerIOS<br>ImageStore<br>InteractionManager<br>LayoutAnimation 当布局变化时，自动将视图运动到它们新的位置上<br>Linking         传入和传出的App链接进行交互<br>NativeMethodsMixin<br>NetInfo         获取设备联网或离线的状态信息<br>PanResponder    多点触摸操作协调成一个手势<br>PermissionsAndroid<br>PixelRatio      获取设备的像素密度的方法<br>PushNotificationIOS 处理应用的推送通知<br>Share           打开一个对话框来共享文本内容<br>StyleSheet      定义css样式<br>Systrace<br>ToastAndroid<br>Vibration       控制设备震动<br>布局样式属性<br>阴影样式属性</p>
<hr>
<h4 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h4><pre><code>rnpm介绍 下载完第三方组件不能直接用，需要通过rnpm 直接组件的内容挂载到工程中去，需要执行$ rnpm link 模块名 ，与react-native link 相同

    安装rnpm  $ npm i rnpm -g

    link的原因：以下组件都是原生开发，wrapper了一层js，因此需要link .a到project中

$ react-native-elements   基础组件    https://github.com/react-native-community/react-native-elements#buttons


$ lodash 

$ query-string 

$ sha1      加密模块

$ react-native-button

$ react-native-audio      音频

$ react-native-video      视频  https://github.com/react-native-community/react-native-video

$ react-native-image-picker  摄像头和本地相册  https://github.com/marcshilling/react-native-image-picker

$ react-native-progress   进度条

$ react-native-storage    存储  https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md

$ react-native-sk-countdown  倒计时

$ react-native-swiper     轮播 https://github.com/leecade/react-native-swiper

$ react-native-barcodescanner 扫二维码 Android   https://github.com/ideacreation/react-native-barcodescanner
                                      http://blog.csdn.net/liu__520/article/details/52889950

$ react-native-animatable  动画   https://github.com/oblador/react-native-animatable

$ react-native-device-info 设备信息  https://github.com/rebeccahughes/react-native-device-info
                                    http://www.ncloud.hk/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/react-native-acquisition-device-information-component-react-native-device-info/


Geolocation  内置的地理位置 


http://www.jianshu.com/p/53ff78168acc       整理的插件
https://yq.aliyun.com/articles/78154?utm_campaign=wenzhang&amp;utm_medium=article&amp;utm_source=QQ-qun&amp;201759&amp;utm_content=m_20152
http://www.jianshu.com/p/e30feb098ef2
</code></pre><h4 id="react-native-vector-icons-图标类"><a href="#react-native-vector-icons-图标类" class="headerlink" title="react-native-vector-icons 图标类"></a>react-native-vector-icons 图标类</h4><pre><code>1、安装 npm i react-native-vector-icons --save &amp;&amp; react-native link react-native-vector-icons

2、引用

    import FontAwesome from &apos;react-native-vector-icons/FontAwesome&apos;;        // 引用的FontAwesome文件
    /* 图标文件名
        Entypo
        EvilIcons 
        FontAwesome 
        Foundation 
        Ionicons 
        MaterialIcons
        MaterialCommunityIcons 
        Octicons 
        Zocial 
        SimpleLineIcons 
    */

    class myfirst extends Component {
        render() {
            return (
                &lt;View style={styles.container}&gt;
                    &lt;FontAwesome name=&quot;address-book&quot; size={20} color=&quot;#4F8EF7&quot; /&gt;
                &lt;/View&gt;
            )
        }
    }

3、注意: 这里icon对一些组件封装

    import Icon from &apos;react-native-vector-icons/Ionicons&apos;;
    return (
        &lt;TabBarIOS&gt;
            &lt;Icon.TabBarItem        // 这里对TabBarItem进行了封装  或者ToolbarAndroid
                title=&quot;Home&quot;
                iconName=&quot;ios-home-outline&quot;     // 这里属性名为 iconName 而不是 icon
                selectedIconName=&quot;ios-home&quot;&gt;    // 选中的
                &lt;View style={styles.tabContent}&gt;&lt;Text&gt;Home Tab&lt;/Text&gt;&lt;/View&gt;
            &lt;/Icon.TabBarItem&gt;
        &lt;/TabBarIOS&gt;
    );

https://github.com/oblador/react-native-vector-icons
http://ionicons.com/  图标官网
http://blog.csdn.net/uuq/article/details/53150841  使用方法  
https://github.com/oblador/react-native-vector-icons#installation   图标对应的name值 
</code></pre><h4 id="mockjs"><a href="#mockjs" class="headerlink" title="mockjs"></a>mockjs</h4><pre><code>npm i mockjs --save

import Mock from &apos;mockjs&apos;
</code></pre><p>| 参考资料<br>| react.parts/native   // 第三方组件列表 <strong><em><br>|<br>| <a href="http://www.lcode.org/react-native/" target="_blank" rel="noopener">http://www.lcode.org/react-native/</a><br>| <a href="http://blog.csdn.net/hsbirenjie/article/category/6307126/3" target="_blank" rel="noopener">http://blog.csdn.net/hsbirenjie/article/category/6307126/3</a><br>| <a href="http://blog.csdn.net/jiangqq781931404/article/category/6055594/2" target="_blank" rel="noopener">http://blog.csdn.net/jiangqq781931404/article/category/6055594/2</a><br>| <a href="http://www.hangge.com/blog/cache/category_76_1.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/category_76_1.html</a>       </em></strong><br>| <a href="http://blog.csdn.net/mengks1987/article/category/6850683" target="_blank" rel="noopener">http://blog.csdn.net/mengks1987/article/category/6850683</a><br>| <a href="http://blog.csdn.net/yuanguozhengjust/article/category/6058018" target="_blank" rel="noopener">http://blog.csdn.net/yuanguozhengjust/article/category/6058018</a><br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/宏观经济学/">宏观经济学</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/宏观经济学/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/经济学/">经济学</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="宏观经济、微观经济"><a href="#宏观经济、微观经济" class="headerlink" title="宏观经济、微观经济"></a>宏观经济、微观经济</h2><pre><code>宏观经济 - 研究整体经济现象，包括通货膨胀、失业和经济增长

微观经济 - 研究家庭和企业如何做出决策，以及市场上的相互影响
</code></pre><h2 id="GDP"><a href="#GDP" class="headerlink" title="GDP"></a>GDP</h2><pre><code>国内生产总值即GDP，可以衡量经济中所有人总收

GDP = 消费 + 投资 + 政府购买 + 净出口

一、消费

    消费是家庭除购买住房之外用于物品与服务的支出

二、投资

    用于未来生产更多物品和服务的物品，如房产，这里投资与金融投资不同

三、政府购买 

    包括政府员工薪水与公务支出

四、净出口

    等于外国对国内生产的物品进行购买
</code></pre><h2 id="CPI"><a href="#CPI" class="headerlink" title="CPI"></a>CPI</h2><pre><code>消费物价指数 - 是普通消费者所购买的物品与服务总费用的衡量指标
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/JS作用域和整理经验/">JS作用域和整理经验</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/JS作用域和整理经验/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><pre><code>一、示例

    console.log(str);        // 输出undefined  因为读取的是解析器预先存储的str，还没有被赋值
    var str = 1;         


二、示例2

    alert(a);        // 弹出的是function a(){ alert(&quot;2&quot;)}
    var a = 1;
    function a(){
        alert(&quot;2&quot;)
    }

    预解析会保存a = undefinded，和 a = function a(){alert(&quot;2&quot;)}，
    因为函数与变量重名，函数后最执行所以保留函数，结果输出的就是函数


三、示例3

    var a = 1;
    function a(){
        alert(&quot;2&quot;);
    }

    // 报错，因为a被定义成变量，typeof a 返回的是number，如果 var a;不能定义值那么a()是成功的
    a();


四、示例4

    var a = 1;
    function fn1(){
        alert(a);
        // 注意这里因为是使用var声明所以执行数预解析器才会把它单独存储起来，
        // 如果将var去掉，a=2改成了赋值这样会改变外部的a的值，下面输出的就是1，2
        var a = 2;
    }

    fn1();                        // undefined
    console.log(a);        // 1


五、示例5

    function foo(){
        return fn1;

        function fn1(){};
        var fn1 = 10;
    }

    var f = foo();

    // 输出 function fn1(){};    因为调用foo函数时，return  fn1因为变量还未定义所以 直接调用的函数
    alert(f);                


六、示例6

    var  myname = &quot;global&quot;; // 全局变量
    function func() {

        // &quot;undefined&quot;，如果函数内不在定义myname就会找全局的变量，但函数本身已经定义了，预编译会先将变量定义成undefined
        alert(myname);                 
        var myname = &quot;local&quot;;
        alert(myname);                 // &quot;local&quot;
    }
    func();


七、示例7

    &lt;script&gt;
        window.name = &apos;globalName&apos;;

        var getName = function(){
            return this.name;
        }

        getName();         // &apos;globalName&apos;
    &lt;/script&gt;


八、示例8

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var callback = function(){
                return this.id;        // divA
            }
            callback();            // window
        }
    &lt;/script&gt;


 九、示例9

    1、Example
        var getName;
        console.log(getName)    // undefined

        getName()                // Uncaught TypeError: getName is not a function

        var getName = function() {
            console.log(&apos;wscat&apos;)
        }

    2、Example
        var getName;
        console.log(getName)    // function getName() {console.log(&apos;oaoafly&apos;)}

        getName()                // oaoafly

        function getName() {
            console.log(&apos;oaoafly&apos;)
        }


十、bind()

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var obj = {
                id: &apos;objId&apos;,
                callback: function(){
                    return this.id;         // &apos;divA&apos;
                }.bind(window)                // 通过bind来将callback内的this指向window
            }

            console.log(obj.callback());    // &apos;window&apos;
        }
    &lt;/script&gt;


十一、严格模式下的this

    &lt;script&gt;
        &apos;use strict&apos;

        function fun(){
            alert(this);        // 返回 &apos;undefined&apos;, strict模式下this不会指向全局
        }

        fun();
    &lt;/script&gt;


十二、箭头函数下的this指向

    let Template = {
        test(){
            console.log(this);        // this指向Template

            document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                // 如果非箭头函数this应该指向 #showThis
                // 这里箭头函数不是指向调用者，所以指向了 Template
                console.log(this);    
            }
        }
    }
    Template.test();
</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code>1、函数本身是对象也是构造函数

2、直接挂载到函数下，是对象的属性和方法

    function Foo(){};
    Foo.username = &apos;111&apos;;     // 注意这里Foo的属性不能为name因为被name被函数的名所占用
    Foo.getName = function(){ console.log(this.username) };

    // 调用
    Foo.getName();        // 111

3、在构造函数的内部属性和方法

    function Foo() {
        this.username = &apos;111&apos;
    }
    Foo.username = &apos;222&apos;;

    // 调用
    console.log(new Foo().username);    // 111

&lt;script&gt;
    function Foo() {
        getName = function() {
            console.log(this);
            console.log(1);
        }

        console.log(this);
        return this;
    }
    Foo.getName = function() { // 这里只是Foo对象的方法，而不是构造函数的方法，
        console.log(2);
    }

    // Foo.prototype.getName = function() {
    //     console.log(3);
    // }

    var getName = function() {
        console.log(4)
    }

    function getName() {
        console.log(5)
    }

    Foo.getName(); // 2    Foo.getName=function(){}  是存到Foo下的方法，Foo.getName()可以取到
    getName(); // 4     如果一个作用域下有var的变量名与函数名相当，var的作用域提升高于function
    Foo().getName();     // 1  因为Foo()被调用，定义中加了return this，Foo指向的是window全局，getName没有var升明，所以为全局，所以相当于window.getName()，Foo中如果不加return this那么就会报错，因为Foo没有链式调用，所以this断了
    getName(); // 1   因为上面已经将Foo内的getName()提升成全局，所以会赋盖掉var getName、function getName定义的全局方法

    // var ofo = new Foo;
    // ofo.getName();   // 3

    // Foo既是一个对象也是一个构造函数
    new Foo.getName();             // 2  先执行Foo.getName()，因为&quot;.&quot;运算符优先于new运算符，所以这时候Foo只是一个对象并不是构造函数的实例，所以会调用对象下的方法
    new Foo().getName();         // 1  先执行new Foo()构造函数，然后在构造函数下去找getName方法，Foo构造函数方法没有getName()所以到prototype下去找
    new new Foo().getName();     // 1  与上面相同
&lt;/script&gt;
</code></pre><h4 id="将对象拷贝并不引用指针"><a href="#将对象拷贝并不引用指针" class="headerlink" title="将对象拷贝并不引用指针"></a>将对象拷贝并不引用指针</h4><pre><code>有两种方法，一是使用for...in将一个对象拷贝到另一个对象

另一种方法是使用Object.assign()

let objA = {
    name: &apos;siguang&apos;,
    age: 30
}
let objB = Object.assign({}, objA);
objB.name = &apos;lulu&apos;;         // lulu
console.log(objA.name);     // siguang
</code></pre><h4 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h4><pre><code>浅拷贝就是对象之间还存引用关系，深拷贝就是两个对象之间没有引用关系

一、浅拷贝

    const a = {t: 1, p: &apos;gg&apos;};
    const b = a;
    b.t = 3;
    console.log(a);     // {t: 3, p: &apos;gg&apos;}
    console.log(b);     // {t: 3, p: &apos;gg&apos;}

二 、深拷贝

    1、Object.assign() 方法是将两个对象合并，并返回一个新对象

        **** 注意assig()只能拷贝一层，多层结构还是浅拷贝 ****

        const c = {t: 1, p: &apos;gg&apos;};
        const d = Object.assign({}, c);
        d.t = 3;
        console.log(c);     // {t: 1, p: &apos;gg&apos;}
        console.log(d);     // {t: 3, p: &apos;gg&apos;}

    2、Object.create() 将拷贝的内容入到prototype下，对象和数组都适用

        对象:

            var oA = {
                name: &apos;sg&apos;,
                age: 33
            }
            var oB = {};
            oB = Object.create(oA);

            oB.eat = &apos;bread&apos;;

        数组:

            var oA = [1,2]
            var oB = [];
            oB = Object.create(oA);

            oB.push(3);            // oB.length;   3        

    3、jQuery.extend()

        let oa = {a: 1, b: 2}; let ob = {};  
        $.extend(ob, oa); 
        ob.b = 3; 
        console.log(oa, ob);        // oa: {a: 1, b: 2}、 ob: {a: 1, b: 3}
</code></pre><h4 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h4><pre><code>一、concat()方法

    var arrA = [1,2,3];
    var arrB = arrA.concat();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

二、slice()方法

    var arrA = [1,2,3];
    var arrB = arrA.slice();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

两种方法都是回返一个不带指向的新数组
</code></pre><h4 id="对象处理"><a href="#对象处理" class="headerlink" title="对象处理"></a>对象处理</h4><pre><code>一、查看是否是一个空对象

    // 使用keys来查看对象中所有的kyes并返回一个数组，如果数组为度为0则对象为空
    var obj = {}; 
    var Len = Object.keys(obj);         
    console.log(Len.length);

二、查看对象中属性是否存在

    var obj = {
        a: 1,
        b: 2
    }
    console.log(obj.c);        // undefined
</code></pre><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><pre><code>function isDataType(data){

}
</code></pre><h4 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h4><pre><code>一、数据去重

    1、普通方法

        function clearRepeat(arr){
            var newArr = [], obj = {};
            for(var i=0; i&lt;arr.length; i++){
                if(!obj[arr[i]]){
                    obj[arr[i]] = &apos;&apos;;        // 对象属性相同会直接覆盖
                    newArr.push(key);        
                }
            }
            return newArr;
        }

        let retArray = clearRepeat([3,2,3,4,5,5,2,2,13,3]);


    2、使用ES6的set()方法，set方法就是不允许数组内有重复的值

        let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
        console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
        let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    http://www.jb51.net/article/46154.htm


二、数组排序

    1、使用sort方法

        var arr = [6,7,5,8,4,2342342,23,234,2,34];
        arr.sort(function(v1, v2){
            return v1 - v2        // 正序
        })
        console.log(arr);


三、返回数组中最大最小值

    let arr = [2,1,423,343,5,67,8];
    let min = Math.min.apply(null, arr);
    let max = Math.max.apply(null, arr);
</code></pre><h4 id="编写组件并兼容AMD、ES6写法"><a href="#编写组件并兼容AMD、ES6写法" class="headerlink" title="编写组件并兼容AMD、ES6写法"></a>编写组件并兼容AMD、ES6写法</h4><pre><code>;(function(root, factory){

    // 判断使用的支持定义模块的方式
    if(typeof define === &apos;function&apos; &amp;&amp; define.amd){
        define(factory)
    }
    else if(typeof exports === &apos;object&apos;){
        module.exports = factory();
    }
    else{
        root.NProgress = factory();
    }

})(this, function(){
    console.log(`输出内容`);
})
</code></pre><p>| <a href="https://juejin.im/entry/58db95eaac502e0058f8472e" target="_blank" rel="noopener">https://juejin.im/entry/58db95eaac502e0058f8472e</a><br>| <a href="http://www.iamaddy.net/2015/04/front-end-engineering/" target="_blank" rel="noopener">http://www.iamaddy.net/2015/04/front-end-engineering/</a>       // 前端的发展</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/微观经济学/">微观经济学</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/微观经济学/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/经济学/">经济学</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是经济"><a href="#什么是经济" class="headerlink" title="什么是经济"></a>什么是经济</h2><pre><code>经济 - 管理一个家庭的人

稀缺性 - 社会资源的有限性

经济学 - 研究社会如休管理自己的稀缺资源
</code></pre><h2 id="经济学的十大原理"><a href="#经济学的十大原理" class="headerlink" title="经济学的十大原理"></a>经济学的十大原理</h2><pre><code>一、人们面临权衡取舍 - 要知道做一件事情得到了什么，又舍去了什么，什么都想要最后确什么都没有
</code></pre><h2 id="绝对优势、比较优势"><a href="#绝对优势、比较优势" class="headerlink" title="绝对优势、比较优势"></a>绝对优势、比较优势</h2><pre><code>比较优势说明每种物品应该由生产这种物品成本较低的国家生产
</code></pre><h2 id="进口、出口"><a href="#进口、出口" class="headerlink" title="进口、出口"></a>进口、出口</h2><pre><code>进口: 在国外生产在国内销售的物品叫进口

出口: 在国内生产而在国外销售的物品称出口
</code></pre><h2 id="成本机会"><a href="#成本机会" class="headerlink" title="成本机会"></a>成本机会</h2><h2 id="供给与需求"><a href="#供给与需求" class="headerlink" title="供给与需求"></a>供给与需求</h2><pre><code>供给量是卖者愿意并且能够出售该物品的数量

供给定理是一种物品价格上升，该物品供给量增加，物品价格下降，物品供给量减少
</code></pre><h2 id="过剩、短缺"><a href="#过剩、短缺" class="headerlink" title="过剩、短缺"></a>过剩、短缺</h2><pre><code>过剩 - 当价格下降，供给者不能卖出他们想卖的所有物品

短缺 - 当前价格下，需求者不能买到他们想买的物品
</code></pre><h2 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h2><pre><code>市场是由某种物品或服务的买者或卖者组成的一个群体，买者作为一个群体决定了一种产品的需求，而卖者作为一个群体决定了一个产品的代给
</code></pre><h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><pre><code>竞争市场有许多买者与卖者并且每
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-框架/">EggJS基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-框架/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| this.ctx - 当前请求的上下文 Content对象的实例ctx，Request、Response<br>| this.app - 当前应用对象Application 对象的实例<br>| this.service - 定义的Service，等价于 this.ctx.service<br>| this.config - 应用配置<br>| this.logger - 日志对象 方法debug, info, warn, error<br>| app.cache - 缓存</p>
<h4 id="Egg介绍、安装"><a href="#Egg介绍、安装" class="headerlink" title="Egg介绍、安装"></a>Egg介绍、安装</h4><pre><code>Egg.js属于MVC类型的NodeJS框架

一、下载脚手架:

    $ npm i egg-init -g
    $ egg-init egg-example --type=simple
    $ cd egg-example
    $ npm i

二、启动项目:

    $ npm run dev
    $ open localhost:7001
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code>config
    |- config.default.js        // 默认配置文件, 所有环境都会加载这个配置文件, 一般用于开发环境的默认配置文件
    |- config.test.js           // 开发环境配置
    |- config.prod.js           // 生产环境配置
    |- config.unittest.js
    |- plugin.js                // 控制插件
    `- config.local.js

一、引入插件

    module.exports = {
        mysql: {
            enable: true,           // 开启或关闭插件
            package: &apos;egg-mysql&apos;    // package为一个npm模块，package.json中的dependencies中，框架会在node_modules目录中找到这个插件入口
        },
    };

    也可以指定path 来替代 package
    const path = require(&apos;path&apos;);
    module.exports = {
        mysql: {
            enable: true,
            path: path.join(__dirname, &apos;../app/plugin/egg-mysql&apos;),
        },
    };
</code></pre><h4 id="Router-路由"><a href="#Router-路由" class="headerlink" title="Router 路由"></a>Router 路由</h4><pre><code>用来接收请求URL，在交给controller处理

app.get(路由名，路由URL路由，middleware(可以配置多个)，controller)

一、controller的两个写法

    # router
    module.exports = app =&gt; {
        // 1、controller目录的home.js进行处理
        app.get(&apos;/&apos;, &apos;home&apos;);             

        // 2、payTool目录、billquery.js文件、getLoanUser方法
        app.post(&apos;/getLoanUser&apos;, &apos;payTool.billquery.getLoanUser&apos;);
    };

    # controller/home.js
    module.exports = function* () {
        this.body = &apos;Hello World&apos;;  // 响应给客户端
    };

    # controller/payTool/billquery.js
    module.exports = app =&gt; {
        class BillqueryController extends app.Controller {
            async getLoanUser(){
                const { ctx, app, service } = this;
                const response = await service.payTool.billquery.getRepayPlan(ctx.request.body);
                ctx.body = response;
            }
        }
    }


二、路由中间件 - 在访问路由之前通过中间件来对路由进行一些处理

    app.get(&apos;router-name&apos;, &apos;middleware1&apos;, &apos;middleware2&apos;, &apos;controlll&apos;);

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

    2、路由中调用

        注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

        // 引用中间件
        const checkAuth = app.middleware.checkAuth();

        // 不需要验证
        app.get(&apos;/&apos;, &apos;home.index&apos;);
        app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

        // 需要验证是否登录的
        app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表


三、参数获取

    1、获取url参数 ctx.query

        http://127.0.0.1:7001/search?name=egg  取出name的值

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, app.controller.search);
        };

        // app/controller/search.js
        module.exports = function* (ctx) {
            tx.body = `search: ${this.query.name}`;
        };


    2、路由参数 ctx.params

        http://127.0.0.1:7001/user/123/xiaoming   取出 123、xiaoming

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/user/:id/:name&apos;, app.controller.user.info);
        };

        // app/controller/user.js
        exports.info = function* (ctx) {
            ctx.body = `user: ${ctx.params.id}, ${ctx.params.name}`;
        };


四、重定向 - 当路由不存在时会走一个默认的路由

    1、内部重定向

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;index&apos;, &apos;/home/index&apos;, &apos;home.index&apos;);
            app.redirect(&apos;/&apos;, &apos;/home/index&apos;, 302);
        };

    2、外部重定义 controller中来执行路由的跳转 redirect

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, &apos;search&apos;);
        };

        // app/controller/search.js
        module.exports = function* () {
            const type = this.query.type;
            const q = this.query.q || &apos;nodejs&apos;;

            // 这里跳转
            ctx.redirect(&apos;/admin/home&apos;);
        };

五、多路由映射 - 将路由分类并用一个路由主文件加载其它的路由文件

    // router.js 通过一个主文件将两个路由加载进来
    module.exports = app =&gt; {
        require(&apos;./router/news&apos;)(app);
        require(&apos;./router/admin&apos;)(app);
    };

    // router/news.js
    module.exports = app =&gt; {
        app.get(&apos;/news/list&apos;, app.controller.news.list);
        app.get(&apos;/news/detail&apos;, app.controller.news.detail);
    };

    // router/admin.js
    module.exports = app =&gt; {
        app.get(&apos;/admin/user&apos;, app.controller.admin.user);
        app.get(&apos;/admin/log&apos;, app.controller.admin.log);
    };

六、路由规则

    // app/router.js
    module.exports = app =&gt; {
        app.get(/^\/package\/([\w-.]+\/[\w-.]+)$/, app.controller.package.detail);
    };
</code></pre><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><pre><code>controller继承于app.controller, 负责解析用户输入，处理后返回相应的结果, 框架推荐Controller层主要对用户请求参数进行处理（校验、转换），然后用service处理业务结果并返回

用户HTTP请求（路由处理） &lt;=&gt; 校验组装（controller处理）&lt;=&gt; 业务处理（service）

一、Controller的两种写法

    1、函数写法

        // app/controller/posts.js
        exports.index = function* () {};
        exports.new = function* () {};
        exports.create = function* () {};

        // router 调用
        app.get(&apos;/index&apos;, &apos;posts/index&apos;);
        app.get(&apos;/new&apos;, &apos;posts/new&apos;);
        app.get(&apos;/create&apos;, &apos;posts/create&apos;);


    2、类写法

        // app/controller/post.js
        module.exports = app =&gt; {
            class PostController extends app.Controller {       // 定义一个PostController的类，继承了app.Controller
                * create() {
                    const { ctx, service } = this;
                    const createRule = {
                        title: { type: &apos;string&apos; },
                        content: { type: &apos;string&apos; },
                    };
                    // 校验参数
                    ctx.validate(createRule);
                    // 组装参数
                    const author = ctx.session.userId;
                    const req = Object.assign(ctx.request.body, { author });
                    // 调用 Service 进行业务处理
                    const res = yield service.post.create(req);
                    // 设置响应内容和响应状态码
                    ctx.body = { id: res.id };
                    ctx.status = 201;
                }
            }
            return PostController;
        }

        // router 调用   app/router.js
        module.exports = app =&gt; {
            app.post(&apos;createPost&apos;, &apos;/api/posts&apos;, &apos;post.create&apos;);
        }


二、app.Controller下this上挂载的几个属性

    1、this.ctx: 当前请求的上下文Context对象的实例

    2、this.app: Application对象的实例，可以取到框架的全局对象和方法

    3、this.service: 取到service下的方法

    4、this.config: 获取或添加修改config的配置

    5、this.logger: 日志打印


三、获取请求

    ctx.method: 请求方法

    ctx.path: 请求路径

    ctx.host: 请求IP

    1、query 获取GET请求中传递参数

        url: /posts?category=egg&amp;language=node  通过context.query拿到url的参数  

        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;

                const queryName = ctx.query;    // {category: &apos;egg&apos;, language: &apos;node&apos;}
                ctx.body = queryName;
            }
        }

    2、queries 能取到重复的参数key

        // posts?category=egg&amp;id=1&amp;id=2&amp;id=3 参数解析成对象,id有多个

        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;

                const queryName = ctx.queries;    // {category: &apos;egg&apos;, id: [1,2,3]}
                ctx.body = queryName;
            }
        }

    3、params 参数   

        路由: app.get(&apos;/projects/:projectId/app/:appId&apos;, &apos;app.listApp&apos;);

        // 请求: GET /projects/1/app/2
        class QueryController extends app.Controller{
            async getParams(app){
                const { ctx, app, service } = this;

                const params = {
                    id: ctx.params.projectId,
                    appid: ctx.params.appId
                };
                ctx.body = queryName;
            }
        }

    4、body 获取post传的数据

        框架内置bodyParser中间件，挂载到 context.request.body上，来取post的内容

        ctx.request.body  来获取post传过来的参数 {&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;1111&quot;}

        exports.listPosts = function* (ctx) {
            assert.equal(ctx.request.body.title, &apos;controller&apos;);
            assert.equal(ctx.request.body.content, &apos;what is controller&apos;);
        };

        &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;&quot; /&gt;
        &lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot; /&gt;

        config.default.js设置， 默认body最大长度为100kb
        bodyParser: {
            jsonLimit: &apos;1mb&apos;,
            formLimit: &apos;1mb&apos;,
        }

    5、获取上传文件

        浏览器上都是通过 Multipart/form-data 格式发送文件的，框架通过内置 Multipart 插件来支持获取用户上传的文件

        &lt;form method=&quot;POST&quot; action=&quot;/upload?_csrf={{ ctx.csrf | safe }}&quot; enctype=&quot;multipart/form-data&quot;&gt;
            title: &lt;input name=&quot;title&quot; /&gt;
            file: &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;
            &lt;button type=&quot;submit&quot;&gt;上传&lt;/button&gt;
        &lt;/form&gt;

        const path = require(&apos;path&apos;);
        const sendToWormhole = require(&apos;stream-wormhole&apos;);

        module.exports = function* (ctx) {
            const stream = yield ctx.getFileStream();
            const name = &apos;egg-multipart-test/&apos; + path.basename(stream.filename);
            // 文件处理，上传到云存储等等
            let result;
            try {
                result = yield ctx.oss.put(name, stream);
            } catch (err) {
                // 必须将上传的文件流消费掉，要不然浏览器响应会卡死
                yield sendToWormhole(stream);
                throw err;
            }
            ctx.body = {
                url: result.url,
                // 所有表单字段都能通过 `stream.fields` 获取到
                fields: stream.fields,
            };
        };


        在config/config.default.js 中配置来新增支持的文件扩展名，或者重写整个白名单

        新增支持的文件扩展名
        module.exports = {
            multipart: {
                fileExtensions: [ &apos;.apk&apos; ], // 增加对 .apk 扩展名的支持
            },
        };

        覆盖整个白名单
        module.exports = {
            multipart: {
                whitelist: [ &apos;.png&apos; ], // 覆盖整个白名单，只允许上传 &apos;.png&apos; 格式
            },
        };

    6、发送HTTP响应

        1）设置status

            exports.create = function* (ctx) {
                // 设置状态码为 201
                ctx.status = 201;
            };

        2）设置body 响应给请求方

            exports.show = function* (ctx) {
                ctx.body = {
                    name: &apos;egg&apos;,
                    category: &apos;framework&apos;,
                    language: &apos;Node.js&apos;,
                };
            };
            exports.page = function* (ctx) {
                ctx.body = &apos;&lt;html&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/html&gt;&apos;;
            };
</code></pre><h4 id="ctx-header-头"><a href="#ctx-header-头" class="headerlink" title="ctx.header 头"></a>ctx.header 头</h4><pre><code>获取整个 header 对象的方法: context.headers、context.header、context.request.headers、context.request.header

get()方法获取请求 header 中的一个字段的值、字段不存在返回null:  context.get(name)、context.request.get(name)

一、获取header

    1、ctx.header 取出头信息

        async from(ctx){
            console.log(ctx.header);
        }

        返回结果
        { 
            host: &apos;127.0.0.1:7001&apos;,
            connection: &apos;keep-alive&apos;,
            &apos;content-length&apos;: &apos;21&apos;,
            &apos;postman-token&apos;: &apos;a7e094b5-21ce-eb94-e403-3d517c832f30&apos;,
            &apos;cache-control&apos;: &apos;no-cache&apos;,
            origin: &apos;chrome-extension://aicmkgpgakddgnaphhhpliifpcfhicfo&apos;,
            &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;,
            &apos;content-type&apos;: &apos;application/json&apos;,
            accept: &apos;*/*&apos;,
            &apos;accept-encoding&apos;: &apos;gzip, deflate, br&apos;,
            &apos;accept-language&apos;: &apos;zh-CN,zh;q=0.8,en;q=0.6&apos;,
            cookie: &apos;csrfToken=RNHUjeOf0Zsl9jNl2f5BhreT&apos; 
        }

    2、ctx.protocol 协议

    3、ctx.ips 返回ip 一个数组

    4、ctx.ip 返回请求方的ip

    5)、ctx.host


二、设置header

    context.set(key, value) 方法可以设置一个响应头，context.set(headers) 设置多个 Header。

    exports.show = function* (ctx) {
        const start = Date.now();
        ctx.body = yield ctx.service.post.get();
        const used = Date.now() - start;
        // 设置一个响应头
        ctx.set(&apos;show-response-time&apos;, userd.toString());
    };
</code></pre><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><pre><code>可以通过context.cookies来获取和设置cookie值

一、cookie操作

    获取 ctx.cookies.get(&apos;count&apos;);

    设置 ctx.cookies.set(&apos;count&apos;, ++count);

    删除 ctx.cookies.set(&apos;count&apos;, null);


二、设置options

    context.cookies.set(key, value, options)

    1、maxAge: nunber - 在浏览器保存最长时间

    2、expires: date - 设置这个键值的失效时间

    3、path: string - 设置生效的URL路径

    4、domain: string - 设置生效的域名

    5、httpOnly: boolean - 设置是否可以被js访问

    6、secure: boolean - 设置键值只在HTTPS连接上传输

    7、overwrite: boolean - 设置key相当键值如何处理，true为后设置的覆盖前面设置的，false发送两个

    8、sign: boolean - 对cookie是否进行签名，true防止前端对这个值进行篡改

    9、encrypt: boolean - 对cookie进行加密

    ctx.cookies.set(key, value, {
        httpOnly: false,
        sign: false,
    });


三、Cookie 密钥

    config/config.default.js

    module.exports = {
        keys: &apos;key1,key2&apos;,
    };
</code></pre><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><pre><code>context.session 来访问或者修改当前用户 Session 

1、读取和设置 Session

    exports.fetchPosts = function* (ctx) {

        // 获取 Session 上的内容
        const user = ctx.session.user;
        const posts = yield ctx.service.post.fetch(userId);

        // 修改 Session 的值
        ctx.session.user = ctx.session.user ? ctx.session.user++ : 1;

        ctx.body = {
            success: true,
            posts,
        };
    };


2、删除session

    exports.deleteSession = function* (ctx) {
        ctx.session = null;
    };


3、设置 session配置

    // config.default.js

    exports.session = {
        key: &apos;EGG_SESS&apos;,
        maxAge: 24 * 3600 * 1000, // 1 天
        httpOnly: true,
        encrypt: true,
    };
</code></pre><h4 id="service-处理业务逻辑"><a href="#service-处理业务逻辑" class="headerlink" title="service 处理业务逻辑"></a>service 处理业务逻辑</h4><pre><code>service 需要继承于 app.Service，service在复杂业务场景下做业务逻辑封装的抽象层

一、service的ctx

    1、this.ctx.curl - 发起网络调用

    2、this.ctx.service.otherService - 调用service

    3、this.ctx.db - 发起数据库调用


二、Example

    // 调用服务 app/controller/user.js
    module.exports = app =&gt; {
        class User extends app.controller {
            async addUser(){
                let userData = {
                    name: &apos;siguang&apos;,
                    password: &apos;xxxxxx&apos;
                }
                let isAddUser = yield ctx.service.user.createUser(userData)
                if(setUser){
                    ctx.body = &apos;添加成功&apos;
                }
                ctx.body = isAddUser ? &apos;添加成功&apos; : &apos;添加失败&apos;;
            }
        }
    }

    // 定义一个Service app/service/user.js
    module.exports = app =&gt; {                   // 中间件支持两个参数 options中间件配置，app当前应用Application的实例
        class User extends app.Service {

            async createUser(params){
                const url = &apos;/account/blance/createUser&apos;;
                let result = await this.ctx.curl(url, {
                    method: &apos;POST&apos;,
                    dataType: &apos;json&apos;,   // 自动解析 JSON response
                    data: params,
                    timeout: 15000,     // 15 秒超时
                }

                this.ctx.logger.info(&apos;响应结果：&apos;, result.data);
                return result.data;
            }
        }
        return User;
    };
</code></pre><h4 id="中间件-Middleware"><a href="#中间件-Middleware" class="headerlink" title="中间件 Middleware"></a>中间件 Middleware</h4><pre><code>一、config.default.js 配置全局

    module.exports = {
        // 配置需要的中间件，数组顺序即为中间件的加载顺序
        middleware: [ &apos;gzip&apos; ],
        // 配置 gzip 中间件的配置
        gzip: {
            threshold: 1024, // 小于 1k 的响应体不压缩
        },
    };

    // 框架中默认的中间件
    module.exports = {
        bodyParser: {
            jsonLimit: &apos;10mb&apos;,
        },
    };


二、通用配置

    enable：控制中间件是否开启。

    match：设置只有符合某些规则的请求才会经过这个中间件。

    ignore：设置符合某些规则的请求不经过这个中间件。

    bodyParser: {
        enable: false,
        jsonLimit: &apos;10mb&apos;,
    },


三、Example: 

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

    2、路由中调用

        注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

        // 引用中间件
        const checkAuth = app.middleware.checkAuth();

        // 不需要验证
        app.get(&apos;/&apos;, &apos;home.index&apos;);
        app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

        // 需要验证是否登录的
        app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表
</code></pre><h4 id="Validate-参数校验插件"><a href="#Validate-参数校验插件" class="headerlink" title="Validate 参数校验插件"></a>Validate 参数校验插件</h4><pre><code>validate只用于post请求的参数校验，get请求取出的都是字符串

一、在config/plugin.js配置中添加

    exports.validate = {
        enable: true,
        package: &apos;egg-validate&apos;,
    };


二、Exmaple

    async refundApply() {
        const { ctx, app, service } = this;
        const paramRule = {
            partnerUserId: { type: &apos;string&apos; },
            applyUserName: { type: &apos;string&apos; },
            amount: { type: &apos;string&apos; }, 
            sourceAccount: { type: &apos;string&apos; }, 
        };

        const paramErrors = app.validator.validate(paramRule, ctx.request.body);
        if (paramErrors) {
            ctx.body = app.renderBody({
                statusType: app.statusType.paramsError,
                error: paramErrors,
            });
            return;
        }

        const response = await service.payTool.billquery.refundApply(ctx.request.body);
        ctx.body = response;
    }


三、验证规则  

    1、required - 是否当前字段必须有，required: false 可以为空

    2、allowEmpty - 允许为空

    2、int - 只能为整数

    3、number - 可以是整数和浮点数

    4、date - 日期 &apos;YYYY-MM-DD&apos;     birthoday: &apos;date&apos;

    5、dateTime - 日期 YYYY-MM-DD HH:mm:ss

    6、boolean - 是否是布尔值        working: &apos;boolean&apos;

    7、string - 是否是字符串, 字符串的四个规则:            

        allowEmpty - 允许为空字符串

        format - 使用正则来验证字符串的格式

        max - 字符串最大长度

        min - 字符串最小长度

        const rule = {
            username: { allowEmpty: true, min: 10, max: 100, format: /^\d+$/ }
        }

    8、email - 是否是email格式

    9、password - 密码验证规则 max最大、min最小、compare比较  pass: {type: password, max: 32, min: 6}

    10、url - 是否是url

    11、enum - 如果是枚举需要加一个规则

        // operateType的值必须是values数组中的一项，values必须为数组
        const paramRule = {
            operateType: { type: &apos;enum&apos;, values: [&apos;REPAYMENT&apos;, &apos;CHARGE&apos;] },        
        }
        const paramErrors = app.validator.validate(paramRule, ctx.request.body);

    12、object - 如果是对象，需要加一个规则 

    13、array - 如果是数组，需要加一个规则

        itemType 数组中每一个元素的规则 
        rule - An object that validate the items of the array. Only work with itemType.
        max - 数组最大长度
        min - 数组最小长度

    https://github.com/node-modules/parameter#rule
    https://github.com/node-modules/parameter/blob/master/benchmark.js
    https://github.com/node-modules/parameter/blob/master/example.js
</code></pre><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><pre><code>jsonp只能get请求

// config/config.default.js  jsonp的配置
exports.jsonp = {
    callback: &apos;callback&apos;, // 识别 query 中的 `callback` 参数
    limit: 100, // 函数名最长为 100 个字符
};


// app/router.js  路由加jsonp中间件
module.exports = app =&gt; {
    const jsonp = app.jsonp();
    app.get(&apos;/api/posts/:id&apos;, jsonp, &apos;posts.show&apos;);         // 通过jsonp中间件来让路由支付一个中间件
    app.get(&apos;/api/posts&apos;, jsonp, &apos;posts.list&apos;);
};

// app/controller/posts.js
exports.show = function* (ctx) {
    ctx.body = {
        name: &apos;egg&apos;,
        category: &apos;framework&apos;,
        language: &apos;Node.js&apos;,
    };
};

用户请求 /api/posts/1?callback=fn，响应为 JSONP 格式，如果用户请求 /api/posts/1
</code></pre><h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><pre><code>Node模拟客户端请求，curl请求默认 content-type: application/x-www-form-urlencoded,

app.curl(url, options) 和 app.httpclient.request(url, options) 两种方法相同

一、Example:

    module.exports = app =&gt; {
        class HttpClientController extends app.Controller{
            async getHttpClient(){
                const {ctx, app, service} = this;

                let result = await this.ctx.curl(&apos;http://goucai.diyicai.com/lottery/getissue.action?lotteryId=001&amp;issueLen=100&amp;d=1502966960306&apos;, {
                    methods: &apos;get&apos;
                });

                let phones = [];
                let resultObj = JSON.parse(result.data.toString());
                resultObj.forEach((data, idx, arr)=&gt;{
                    console.log(&apos;data------&apos;, data);
                    phones.push(data.endTime);
                })

                ctx.body = phones.join(&apos;,&apos;)
            }
        }
        return HttpClientController;
    }


二、config配置 // config/config.default.js

    exports.httpclient = {
        // 默认开启 http/https KeepAlive 功能
        keepAlive: true,

        // 空闲的 KeepAlive socket 最长可以存活 4 秒
        freeSocketKeepAliveTimeout: 4000,

        // 当 socket 超过 30 秒都没有任何活动，就会被当作超时处理掉
        timeout: 30000,

        // 允许创建的最大 socket 数
        maxSockets: Infinity,

        // 最大空闲 socket 数
        maxFreeSockets: 256,

        // 是否开启本地 DNS 缓存，默认关闭
        // 一旦设置开启，则每个域名的 DNS 查询结果将在进程内缓存 10 秒
        enableDNSCache: false,
    };


三、options对象

    let options = {};
    const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, options);

    1、mothod: 请求方法

    2、data: 需要发送的数据 { foo: &apos;bar&apos; }

    3、dataAsQueryString: Boolean 如果为 true 即使在post情况下，也会强制将options.data以 querystringstringify处理后拼接到url的query参数上

    4、content（String|Buffer）: 发送请求的正文，如果设置了此参数会忽略data参数

        ctx.curl(url, {
            method: &apos;POST&apos;,
            // 直接发送原始 xml 数据，不需要 HttpClient 做特殊处理
            content: &apos;&lt;xml&gt;&lt;hello&gt;world&lt;/hello&gt;&lt;/xml&gt;&apos;,
            headers: {
                &apos;content-type&apos;: &apos;text/html&apos;,
            },
        });

    5、stream（ReadStream）: 发送请求正文的可读数据流

        ctx.curl(url, {
            method: &apos;POST&apos;,
            stream: fs.createReadStream(&apos;/path/to/read&apos;),
        });

    6、writeStream: 接受响应数据的可写数据流

        ctx.curl(url, {
            writeStream: fs.createWriteStream(&apos;/path/to/store&apos;),
        });

    7、consumeWriteStream: Boolean 是否等待 writeStream 完全写完才算响应全部接收完毕，默认是 true

    8、contentType: 请求数据的格式，默认undefined

    9、dataType: 响应数据格式

    10、headers: 自定义请求头

    11、timeout: 请求超时时间 默认是 [ 5000, 5000 ]，即创建连接超时是 5 秒，接收响应超时是 5 秒。

    12、agent: 

    13、httpsAgent

    14、auth、digestAuth

    15、followRedirect：Boolean 是否自动跟进3xx的跳转响应

    16、maxRedirects: number 最大自动跳转次数

    17、formatRedirectUrl: 自定义实现302、301

    18、beforeRequest: 请求发送前会调用beforeRequest钩子

        ctx.curl(url, {
            beforeRequest: options =&gt; {
                // 例如我们可以设置全局请求 id，方便日志跟踪
                options.headers[&apos;x-request-id&apos;] = uuid.v1();
            }
        });

    19、streaming：是否直接返回响应流

    20、gzip: Boolean是否开始gzip

    21、timing: Boolean 是否开启请求各阶段的时间没是


四、Get请求

    1、options.method = &apos;post&apos;  设置请求参数，默认是get请求可以不用加

         const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, {method: post});

    2、status: 响应状态码

    3、headers: 响应头信息 有{&apos;conent-type&apos;: &apos;text/html&apos;}

    4、data: 响应body, 返回的是Buffer类型, 如果设置了options.dataType会根据参数来处理


五、Post请求

    module.exports = function* post(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {

            // 必须指定 method
            method: &apos;POST&apos;,

            // 通过 contentType 告诉 HttpClient 以 JSON 格式发送
            contentType: &apos;json&apos;,

            // 要传的数据 
            data: {
                hello: &apos;world&apos;,
                now: Date.now(),
            },

            // 明确告诉 HttpClient 以 JSON 格式处理返回的响应 body
            dataType: &apos;json&apos;,
        });
        ctx.body = result.data;
    };


六、From表单提交

    以 ontent-type: application/x-www-form-urlencoded 的格式提交请求数据

    // app/controller/form.js
    module.exports = function* form(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT 和 DELETE
            method: &apos;POST&apos;,
            // 不需要设置 contentType，HttpClient 会默认以 application/x-www-form-urlencoded 格式发送请求
            data: {
                now: Date.now(),
                foo: &apos;bar&apos;,
            },
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.form;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;foo&quot;: &quot;bar&quot;,
        //   &quot;now&quot;: &quot;1483864184348&quot;
        // }
    };


七、Multipart 方式上传

    From 表单提交时包含文件的时候，需要用到 multipart/form-data 进行提交了

    引用fromstream 第三方模块

    // app/controller/multipart.js
    const FormStream = require(&apos;formstream&apos;);
    module.exports = function* multipart(ctx) {
        const form = new FormStream();

        // 设置普通的 key value
        form.field(&apos;foo&apos;, &apos;bar&apos;);

        // 上传当前文件本身用于测试
        form.file(&apos;file&apos;, __filename);
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 生成符合 multipart/form-data 要求的请求 headers
            headers: form.headers(),
            // 以 stream 模式提交
            stream: form,
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.files;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;file&quot;: &quot;&apos;use strict&apos;;\n\nconst For....&quot;
        // }
    };

    // 添加更多文件
    form.file(&apos;file1&apos;, file1);
    form.file(&apos;file2&apos;, file2);


八、以Stream 方式上传文件

    Stream 实际会以 Transfer-Encoding: chunked 传输编码格式发送

    // app/controller/stream.js
    const fs = require(&apos;fs&apos;);
    module.exports = function* stream(ctx) {
        // 上传当前文件本身用于测试
        const fileStream = fs.createReadStream(__filename);

        // httpbin.org 不支持 stream 模式，使用本地 stream 接口代替
        const url = `${ctx.protocol}://${ctx.host}/stream`;
        const result = yield ctx.curl(url, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 以 stream 模式提交
            stream: fileStream,
        });

        ctx.status = result.status;
        ctx.set(result.headers);
        ctx.body = result.data;
        // 响应最终会是类似以下的结果：
        // {&quot;streamSize&quot;:574}
    };
</code></pre><h4 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h4><pre><code>读取数据渲染模板，呈现给用户

一、使用

    1、$ npm i egg-view-ejs --save         // 安装

    2、配置

        // config/plugin.js
        exports.nunjucks = {
            enable: true,
            package: &apos;egg-view-nunjucks&apos;        // 开启插件使用numjucks模板
        };

        // config/config.default.js
        exports.view = {
            defaultViewEngine: &apos;nunjucks&apos;,
            mapping: {
                &apos;.tpl&apos;: &apos;nunjucks&apos;,
            },
        };


    3、render、renderString两个方法

        render(fileName, locals, viewOptions): filenName: 文件路径、locals: 渲染的数据、viewOptions: 用户传入的配置

    render(name, locals) 渲染模板文件, 并赋值给 ctx.body

    renderView(name, locals) 渲染模板文件, 仅返回不赋值

    renderString(tpl, locals) 渲染模板字符串, 仅返回不赋值


- numjucks模板语法: http://mozilla.github.io/nunjucks/cn/templating.html  见模板md -
</code></pre><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><pre><code>Egg内置static插件，static默认映射到 public目录

app/public
├── css
│   └── news.css
└── js
    ├── lib.js
    └── news.js
</code></pre><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><pre><code>一、Application - 全局的方法和对象挂载到Application中

    // extend/application.js 创建全局对象
    module.exports = {
        // 全局返回状态类型
        statusType: &apos;STATUS_TYPE&apos;,

        // 生成返回报文
        renderBody(params) {
            if (typeof params.statusType === &apos;undefined&apos;) {
                throw new Error(&apos;statusType error&apos;);
            }
            const response = {
                data: params.data || {},
                message: params.message || this.statusMessage[params.statusType],
                status: params.statusType,
            };

            if (params.error) response.error = params.error;
            return response;
        }
    }

    // 调用 controller、service都可以
    module.exports = app =&gt; {
        return class UserController extends app.Controller {
            async fetch() {
                this.ctx.body = app.cache.get(this.ctx.query.id);
            }
        };
    };
</code></pre><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><pre><code>有些任务需要定时来完成，如定时上报，定时远程更新本地缓存，定时任务都统一存放在 app/schedule 目录下

创建一个定时任务 app/schedule/update_cache.js

module.exports = {
    // 通过 schedule 属性来设置定时任务的执行间隔等配置
    schedule: {
        interval: &apos;1m&apos;,     // 1 分钟间隔
        type: &apos;all&apos;,        // 指定所有的 worker 都需要执行
    },

    // task 是真正定时任务执行时被运行的函数，第一个参数是一个匿名的 Context 实例
    * task(ctx) {
        const res = yield ctx.curl(&apos;http://www.api.com/cache&apos;, {
            dataType: &apos;json&apos;,
        });
        ctx.app.cache = res.data;
    }
};
</code></pre><h4 id="框架扩展"><a href="#框架扩展" class="headerlink" title="框架扩展"></a>框架扩展</h4><pre><code>框架扩展自身功能: Application、Context、Request、Response、Helper，在这几个对象上扩展就在extend目录里创建相应的js文件，application.js

    Helper用来提供一些实用的utility函数

一、Application 全局应用对象扩展

    访问 ctx.app,  Controller，Middleware，Helper，Service 中都可以通过 this.app 访问到 Application 对象

    // app.js
    module.exports = app =&gt; {
        app.config
    };

    // 扩展 app.foo() 方法 app/extend/application.js
    module.exports = {
        foo(param) {
            // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性
        },
    };


二 、Context 扩展

    extend/content.js

    module.export = {
        async foo(param){
            ...
        }
    }

    引用 await this.ctx.foo({name: &apos;siguang&apos;});


三、Helper 用来编写一些实用函数

    // app/extend/helper.js
    const moment = require(&apos;moment&apos;);
    exports.relativeTime = time =&gt; moment(new Date(time * 1000)).fromNow();

    // 也可以在模板里面使用：
    &lt;!-- app/views/news/list.tpl --&gt;
    {{ helper.relativeTime(item.time) }}
</code></pre><h4 id="启动自定义"><a href="#启动自定义" class="headerlink" title="启动自定义"></a>启动自定义</h4><pre><code>用来进行应用启动时进行初始化工作

// 通过入口文件app.js
module.exports = app =&gt; {
    app.beforeStart(function* () {

        // 应用会等待这个函数执行完成才启动
        app.cities = yield app.curl(&apos;http://example.com/city.json&apos;, {
            method: &apos;GET&apos;,
            dataType: &apos;json&apos;,
        });
    });
};
</code></pre><h4 id="logger-日志"><a href="#logger-日志" class="headerlink" title="logger 日志"></a>logger 日志</h4><pre><code>this.ctx.logger.info(&apos;xxxxxx&apos;);

logger.debug()、logger.info()、logger.warn()、logger.error()

config.deubgger 文件配置

    logger: {
        level: &apos;DEBUG&apos;,
        dir: &apos;../app/logger&apos;,
    }
</code></pre><h4 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h4><pre><code>egg-bin模块（用于本地开发和单元测试）

package.json:

   {
       &quot;scripts&quot;: {
           &quot;dev&quot;: &quot;egg-bin dev --port 7001&quot;
       }
   }
</code></pre><h4 id="插件的开发"><a href="#插件的开发" class="headerlink" title="插件的开发"></a>插件的开发</h4><pre><code>自定义插件存储目录:  lib/plugin/...

egg-ua插件

1、创建package.json

    {
        &quot;eggPlugin&quot;: {
            &quot;name&quot;: &quot;ua&quot;
        }
    }

2、egg-ua/us.js插件文件

    module.exports = {
        get isIOS() {
            const iosReg = /iphone|ipad|ipod/i;
            return iosReg.test(this.get(&apos;user-agent&apos;));
        },
    };

3、config/plugin.js   通过path来挂载插件

    const path = require(&apos;path&apos;);
    exports.ua = {
        enable: true,
        path: path.join(__dirname, &apos;../lib/plugin/egg-ua&apos;),
    };
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>├── package.json
├── app.js (可选)            // 启动初始化
├── agent.js (可选)
├── app
|   ├── router.js           // 路由规则
│   ├── controller          // 处理用户的输入
│   |   └── home.js
│   ├── service (可选)       // 服务，编写业务逻辑
│   |   └── user.js
│   ├── middleware (可选)    // 中间件
│   |   └── response_time.js
│   ├── schedule (可选)      // 定时任务
│   |   └── my_task.js
│   ├── public (可选)        // 静态目录
│   |   └── reset.css
│   ├── view (可选)          // 模板
│   |   └── home.tpl
│   └── extend (可选)        // 框架扩展
│       ├── helper.js (可选)
│       ├── request.js (可选)
│       ├── response.js (可选)
│       ├── context.js (可选)     // ctx扩展
│       ├── application.js (可选)     // 全局方法
│       └── agent.js (可选)
├── config                  // 配置
|   ├── plugin.js
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test                    // 测试
    ├── middleware
    |   └── response_time.test.js
    └── controller
        └── home.test.js
</code></pre><blockquote>
<p>参考资料<br><a href="http://koa.bootcss.com/" target="_blank" rel="noopener">http://koa.bootcss.com/</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-问题积累/">EggJS框架-问题积累</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-问题积累/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="数据库需要指定表"><a href="#数据库需要指定表" class="headerlink" title="数据库需要指定表"></a>数据库需要指定表</h4><pre><code>module.exports = app =&gt; {
    const mongoose = app.mongoose;
    const UserSchema = new mongoose.Schema({
        username: { type: String },
        passworrd: { type: String }
    }, {collection: &apos;user&apos;});

    return mongoose.model(&apos;User&apos;, UserSchema);
}
</code></pre><h4 id="不支持ES6的import"><a href="#不支持ES6的import" class="headerlink" title="不支持ES6的import"></a>不支持ES6的import</h4><pre><code>module.exports = app =&gt; {}      // egg使用ES5的导出所以不支持 import
</code></pre><p>1、this.get(‘user-agent’)  controller中通过this.get()获取请求头的信息</p>
<p>bodyParser  中间件，egg内置，用来处里post</p>
<p>加入全局方法:<br>module.exports = {<br>  generateUuid() {<br>    const uuid = uuidV1();<br>    return uuid.replace(/-/g, ‘’).toUpperCase();<br>  },<br>};</p>
<blockquote>
<p>参考资料<br><a href="http://koa.bootcss.com/" target="_blank" rel="noopener">http://koa.bootcss.com/</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js./">EggJS基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js./">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Egg安装"><a href="#Egg安装" class="headerlink" title="Egg安装"></a>Egg安装</h4><pre><code>Egg.js属于MVC类型的NodeJS框架

$ mkdir egg-example &amp;&amp; cd egg-example

$ npm init egg --type=simple

$ npm i

$ npm run dev

$ open localhost:7001
</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code>1、config
        |- config.default.js        // 默认配置文件, 所有环境都会加载这个配置文件, 一般用于开发环境的默认配置文件
        |- config.test.js           // 开发环境配置
        |- config.prod.js           // 生产环境配置
        |- config.unittest.js
        |- plugin.js                // 控制插件
        `- config.local.js

    module.exports = {
        mysql: {
            enable: true,           // 开启或关闭插件
            package: &apos;egg-mysql&apos;    // package为一个npm模块，package.json中的dependencies中，框架会在node_modules目录中找到这个插件入口
        },
    };

    也可以指定path 来替代 package
    const path = require(&apos;path&apos;);
    module.exports = {
        mysql: {
            enable: true,
            path: path.join(__dirname, &apos;../app/plugin/egg-mysql&apos;),
        },
    };

2、app.js文件

    app.js是入口文件，需要手动创建在根目录下，包括了生命周期函数
    module.exports = app =&gt; {
        console.log(&apos;start&apos;)
    }
</code></pre><h4 id="Router-路由"><a href="#Router-路由" class="headerlink" title="Router 路由"></a>Router 路由</h4><pre><code>用来接收请求URL，在交给controller处理

app.get(路由名，路由URL路由，middleware(可以配置多个)，controller)

一、controller的两个写法

    # router
    module.exports = app =&gt; {
        // 1、controller目录的home.js进行处理
        app.get(&apos;/&apos;, &apos;home&apos;);             

        // 2、payTool目录、billquery.js文件、getLoanUser方法
        app.post(&apos;/getLoanUser&apos;, &apos;payTool.billquery.getLoanUser&apos;);
    };

    # controller/home.js
    module.exports = function* () {
        this.body = &apos;Hello World&apos;;  // 响应给客户端
    };

    # controller/payTool/billquery.js
    module.exports = app =&gt; {
        class BillqueryController extends app.Controller {
            async getLoanUser(){
                const { ctx, app, service } = this;
                const response = await service.payTool.billquery.getRepayPlan(ctx.request.body);
                ctx.body = response;
            }
        }
    }


二、路由中间件 - 在访问路由之前通过中间件来对路由进行一些处理

    app.get(&apos;router-name&apos;, &apos;middleware1&apos;, &apos;middleware2&apos;, &apos;controlll&apos;);

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

    2、路由中调用

        注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

        // 引用中间件
        const checkAuth = app.middleware.checkAuth();

        // 不需要验证
        app.get(&apos;/&apos;, &apos;home.index&apos;);
        app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

        // 需要验证是否登录的
        app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表


三、参数获取

    1、获取url参数 ctx.query

        http://127.0.0.1:7001/search?name=egg  取出name的值

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, app.controller.search);
        };

        // app/controller/search.js
        module.exports = function* (ctx) {
            tx.body = `search: ${this.query.name}`;
        };


    2、路由参数 ctx.params

        http://127.0.0.1:7001/user/123/xiaoming   取出 123、xiaoming

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/user/:id/:name&apos;, app.controller.user.info);
        };

        // app/controller/user.js
        exports.info = function* (ctx) {
            ctx.body = `user: ${ctx.params.id}, ${ctx.params.name}`;
        };


四、重定向 - 当路由不存在时会走一个默认的路由

    1、内部重定向

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;index&apos;, &apos;/home/index&apos;, &apos;home.index&apos;);
            app.redirect(&apos;/&apos;, &apos;/home/index&apos;, 302);
        };

    2、外部重定义 controller中来执行路由的跳转 redirect

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, &apos;search&apos;);
        };

        // app/controller/search.js
        module.exports = function* () {
            const type = this.query.type;
            const q = this.query.q || &apos;nodejs&apos;;

            // 这里跳转
            ctx.redirect(&apos;/admin/home&apos;);
        };

五、多路由映射 - 将路由分类并用一个路由主文件加载其它的路由文件

    // router.js 通过一个主文件将两个路由加载进来
    module.exports = app =&gt; {
        require(&apos;./router/news&apos;)(app);
        require(&apos;./router/admin&apos;)(app);
    };

    // router/news.js
    module.exports = app =&gt; {
        app.get(&apos;/news/list&apos;, app.controller.news.list);
        app.get(&apos;/news/detail&apos;, app.controller.news.detail);
    };

    // router/admin.js
    module.exports = app =&gt; {
        app.get(&apos;/admin/user&apos;, app.controller.admin.user);
        app.get(&apos;/admin/log&apos;, app.controller.admin.log);
    };

六、路由规则

    // app/router.js
    module.exports = app =&gt; {
        app.get(/^\/package\/([\w-.]+\/[\w-.]+)$/, app.controller.package.detail);
    };
</code></pre><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><pre><code>controller继承于app.controller, 负责解析用户输入，处理后返回相应的结果, 框架推荐Controller层主要对用户请求参数进行处理（校验、转换），然后用service处理业务结果并返回

用户HTTP请求（路由处理） &lt;=&gt; 校验组装（controller处理）&lt;=&gt; 业务处理（service）

一、Controller的两种写法

    1、函数写法

        // app/controller/posts.js
        exports.index = function* () {};
        exports.new = function* () {};
        exports.create = function* () {};

        // router 调用
        app.get(&apos;/index&apos;, &apos;posts/index&apos;);
        app.get(&apos;/new&apos;, &apos;posts/new&apos;);
        app.get(&apos;/create&apos;, &apos;posts/create&apos;);


    2、类写法

        // app/controller/post.js
        module.exports = app =&gt; {
            class PostController extends app.Controller {       // 定义一个PostController的类，继承了app.Controller
                * create() {
                    const { ctx, service } = this;
                    const createRule = {
                        title: { type: &apos;string&apos; },
                        content: { type: &apos;string&apos; },
                    };
                    // 校验参数
                    ctx.validate(createRule);
                    // 组装参数
                    const author = ctx.session.userId;
                    const req = Object.assign(ctx.request.body, { author });
                    // 调用 Service 进行业务处理
                    const res = yield service.post.create(req);
                    // 设置响应内容和响应状态码
                    ctx.body = { id: res.id };
                    ctx.status = 201;
                }
            }
            return PostController;
        }

        // router 调用   app/router.js
        module.exports = app =&gt; {
            app.post(&apos;createPost&apos;, &apos;/api/posts&apos;, &apos;post.create&apos;);
        }


二、app.Controller下this上挂载的几个属性

    1、this.ctx: 当前请求的上下文Context对象的实例

    2、this.app: Application对象的实例，可以取到框架的全局对象和方法

    3、this.service: 取到service下的方法

    4、this.config: 获取或添加修改config的配置

    5、this.logger: 日志打印


三、获取请求

    ctx.method: 请求方法

    ctx.path: 请求路径

    ctx.host: 请求IP

    1、query 获取GET请求中传递参数

        url: /posts?category=egg&amp;language=node  通过context.query拿到url的参数  

        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;
                const queryName = ctx.query;    // {category: &apos;egg&apos;, language: &apos;node&apos;}
                ctx.body = queryName;
            }
        }

    2、queries 能取到重复的参数key

        // posts?category=egg&amp;id=1&amp;id=2&amp;id=3 参数解析成对象,id有多个
        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;
                const queryName = ctx.queries;    // {category: &apos;egg&apos;, id: [1,2,3]}
                ctx.body = queryName;
            }
        }

    3、params 参数   

        路由: app.get(&apos;/projects/:projectId/app/:appId&apos;, &apos;app.listApp&apos;);

        // 请求: GET /projects/1/app/2
        class QueryController extends app.Controller{
            async getParams(app){
                const { ctx, app, service } = this;
                const params = {
                    id: ctx.params.projectId,
                    appid: ctx.params.appId
                };
                ctx.body = queryName;
            }
        }

    4、body 获取post传的数据

        框架内置bodyParser中间件，挂载到 context.request.body上，来取post的内容

        ctx.request.body  来获取post传过来的参数 {&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;1111&quot;}

        exports.listPosts = function* (ctx) {
            assert.equal(ctx.request.body.title, &apos;controller&apos;);
            assert.equal(ctx.request.body.content, &apos;what is controller&apos;);
        };

        &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;&quot; /&gt;
        &lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot; /&gt;

        config.default.js设置， 默认body最大长度为100kb
        bodyParser: {
            jsonLimit: &apos;1mb&apos;,
            formLimit: &apos;1mb&apos;,
        }

    5、获取上传文件

        浏览器上都是通过 Multipart/form-data 格式发送文件的，框架通过内置 Multipart 插件来支持获取用户上传的文件

        &lt;form method=&quot;POST&quot; action=&quot;/upload?_csrf={{ ctx.csrf | safe }}&quot; enctype=&quot;multipart/form-data&quot;&gt;
            title: &lt;input name=&quot;title&quot; /&gt;
            file: &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;
            &lt;button type=&quot;submit&quot;&gt;上传&lt;/button&gt;
        &lt;/form&gt;

        const path = require(&apos;path&apos;);
        const sendToWormhole = require(&apos;stream-wormhole&apos;);

        module.exports = function* (ctx) {
            const stream = yield ctx.getFileStream();
            const name = &apos;egg-multipart-test/&apos; + path.basename(stream.filename);
            // 文件处理，上传到云存储等等
            let result;
            try {
                result = yield ctx.oss.put(name, stream);
            } catch (err) {
                // 必须将上传的文件流消费掉，要不然浏览器响应会卡死
                yield sendToWormhole(stream);
                throw err;
            }
            ctx.body = {
                url: result.url,
                // 所有表单字段都能通过 `stream.fields` 获取到
                fields: stream.fields,
            };
        };


        在config/config.default.js 中配置来新增支持的文件扩展名，或者重写整个白名单

        新增支持的文件扩展名
        module.exports = {
            multipart: {
                fileExtensions: [ &apos;.apk&apos; ], // 增加对 .apk 扩展名的支持
            },
        };

        覆盖整个白名单
        module.exports = {
            multipart: {
                whitelist: [ &apos;.png&apos; ], // 覆盖整个白名单，只允许上传 &apos;.png&apos; 格式
            },
        };

    6、发送HTTP响应

        1）设置status

            exports.create = function* (ctx) {
                // 设置状态码为 201
                ctx.status = 201;
            };

        2）设置body 响应给请求方

            exports.show = function* (ctx) {
                ctx.body = {
                    name: &apos;egg&apos;,
                    category: &apos;framework&apos;,
                    language: &apos;Node.js&apos;,
                };
            };
            exports.page = function* (ctx) {
                ctx.body = &apos;&lt;html&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/html&gt;&apos;;
            };
</code></pre><h4 id="ctx-header-头"><a href="#ctx-header-头" class="headerlink" title="ctx.header 头"></a>ctx.header 头</h4><pre><code>获取整个 header 对象的方法: context.headers、context.header、context.request.headers、context.request.header

get()方法获取请求 header 中的一个字段的值、字段不存在返回null:  context.get(name)、context.request.get(name)

一、获取header

    1、ctx.header 取出头信息

            async from(ctx){
                console.log(ctx.header);
            }
            返回结果
            { 
                host: &apos;127.0.0.1:7001&apos;,
                connection: &apos;keep-alive&apos;,
                &apos;content-length&apos;: &apos;21&apos;,
                &apos;postman-token&apos;: &apos;a7e094b5-21ce-eb94-e403-3d517c832f30&apos;,
                &apos;cache-control&apos;: &apos;no-cache&apos;,
                origin: &apos;chrome-extension://aicmkgpgakddgnaphhhpliifpcfhicfo&apos;,
                &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;,
                &apos;content-type&apos;: &apos;application/json&apos;,
                accept: &apos;*/*&apos;,
                &apos;accept-encoding&apos;: &apos;gzip, deflate, br&apos;,
                &apos;accept-language&apos;: &apos;zh-CN,zh;q=0.8,en;q=0.6&apos;,
                cookie: &apos;csrfToken=RNHUjeOf0Zsl9jNl2f5BhreT&apos; 
            }

    2、ctx.protocol 协议

    3、ctx.ips 返回ip 一个数组

    4、ctx.ip 返回请求方的ip

    5)、ctx.host


二、设置header

    context.set(key, value) 方法可以设置一个响应头，context.set(headers) 设置多个 Header。
    exports.show = function* (ctx) {
        const start = Date.now();
        ctx.body = yield ctx.service.post.get();
        const used = Date.now() - start;
        // 设置一个响应头
        ctx.set(&apos;show-response-time&apos;, userd.toString());
    };
</code></pre><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><pre><code>可以通过context.cookies来获取和设置cookie值

一、cookie操作

    获取 ctx.cookies.get(&apos;count&apos;);

    设置 ctx.cookies.set(&apos;count&apos;, ++count);

    删除 ctx.cookies.set(&apos;count&apos;, null);


二、设置options

    context.cookies.set(key, value, options)

    1、maxAge: nunber - 在浏览器保存最长时间

    2、expires: date - 设置这个键值的失效时间

    3、path: string - 设置生效的URL路径

    4、domain: string - 设置生效的域名

    5、httpOnly: boolean - 设置是否可以被js访问

    6、secure: boolean - 设置键值只在HTTPS连接上传输

    7、overwrite: boolean - 设置key相当键值如何处理，true为后设置的覆盖前面设置的，false发送两个

    8、sign: boolean - 对cookie是否进行签名，true防止前端对这个值进行篡改

    9、encrypt: boolean - 对cookie进行加密

    ctx.cookies.set(key, value, {
        httpOnly: false,
        sign: false,
    });


三、Cookie 密钥

    config/config.default.js

    module.exports = {
        keys: &apos;key1,key2&apos;,
    };
</code></pre><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><pre><code>context.session 来访问或者修改当前用户 Session 

1、读取和设置 Session

    exports.fetchPosts = function* (ctx) {
        // 获取 Session 上的内容
        const user = ctx.session.user;
        const posts = yield ctx.service.post.fetch(userId);

        // 修改 Session 的值
        ctx.session.user = ctx.session.user ? ctx.session.user++ : 1;

        ctx.body = {
            success: true,
            posts,
        };
    };


2、删除session

    exports.deleteSession = function* (ctx) {
        ctx.session = null;
    };


3、设置 session配置

    // config.default.js

    exports.session = {
        key: &apos;EGG_SESS&apos;,
        maxAge: 24 * 3600 * 1000, // 1 天
        httpOnly: true,
        encrypt: true,
    };
</code></pre><h4 id="service-处理业务逻辑"><a href="#service-处理业务逻辑" class="headerlink" title="service 处理业务逻辑"></a>service 处理业务逻辑</h4><pre><code>service 需要继承于 app.Service，service在复杂业务场景下做业务逻辑封装的抽象层

一、service的ctx

    1、this.ctx.curl - 发起网络调用

    2、this.ctx.service.otherService - 调用service

    3、this.ctx.db - 发起数据库调用


二、Example

    // 调用服务 app/controller/user.js
    module.exports = app =&gt; {
        class User extends app.controller {
            async addUser(){
                let userData = {
                    name: &apos;siguang&apos;,
                    password: &apos;xxxxxx&apos;
                }
                let isAddUser = yield ctx.service.user.createUser(userData)
                if(setUser){
                    ctx.body = &apos;添加成功&apos;
                }
                ctx.body = isAddUser ? &apos;添加成功&apos; : &apos;添加失败&apos;;
            }
        }
    }

    // 定义一个Service app/service/user.js
    module.exports = app =&gt; {                   // 中间件支持两个参数 options中间件配置，app当前应用Application的实例
        class User extends app.Service {
            async createUser(params){
                const url = &apos;/account/blance/createUser&apos;;
                let result = await this.ctx.curl(url, {
                    method: &apos;POST&apos;,
                    dataType: &apos;json&apos;,   // 自动解析 JSON response
                    data: params,
                    timeout: 15000,     // 15 秒超时
                }
                this.ctx.logger.info(&apos;响应结果：&apos;, result.data);
                return result.data;
            }
        }
        return User;
    };
</code></pre><h4 id="Middleware-中间件"><a href="#Middleware-中间件" class="headerlink" title="Middleware 中间件"></a>Middleware 中间件</h4><pre><code>一、config.default.js 配置全局

    module.exports = {
        // 配置需要的中间件，数组顺序即为中间件的加载顺序
        middleware: [ &apos;gzip&apos; ],
        // 配置 gzip 中间件的配置
        gzip: {
            threshold: 1024, // 小于 1k 的响应体不压缩
        },
    };

    // 框架中默认的中间件
    module.exports = {
        bodyParser: {
            jsonLimit: &apos;10mb&apos;,
        },
    };


二、通用配置

    enable：控制中间件是否开启。

    match：设置只有符合某些规则的请求才会经过这个中间件。

    ignore：设置符合某些规则的请求不经过这个中间件。

    bodyParser: {
        enable: false,
        jsonLimit: &apos;10mb&apos;,
    },


三、Example: 

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

2、路由中调用

    注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

    // 引用中间件
    const checkAuth = app.middleware.checkAuth();

    // 不需要验证
    app.get(&apos;/&apos;, &apos;home.index&apos;);
    app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

    // 需要验证是否登录的
    app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表
</code></pre><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><pre><code>jsonp只能get请求

// config/config.default.js  jsonp的配置
exports.jsonp = {
    callback: &apos;callback&apos;, // 识别 query 中的 `callback` 参数
    limit: 100, // 函数名最长为 100 个字符
};


// app/router.js  路由加jsonp中间件
module.exports = app =&gt; {
    const jsonp = app.jsonp();
    app.get(&apos;/api/posts/:id&apos;, jsonp, &apos;posts.show&apos;);         // 通过jsonp中间件来让路由支付一个中间件
    app.get(&apos;/api/posts&apos;, jsonp, &apos;posts.list&apos;);
};

// app/controller/posts.js
exports.show = function* (ctx) {
    ctx.body = {
        name: &apos;egg&apos;,
        category: &apos;framework&apos;,
        language: &apos;Node.js&apos;,
    };
};

用户请求 /api/posts/1?callback=fn，响应为 JSONP 格式，如果用户请求 /api/posts/1
</code></pre><h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><pre><code>Node模拟客户端请求，curl请求默认 content-type: application/x-www-form-urlencoded,

app.curl(url, options) 和 app.httpclient.request(url, options) 两种方法相同

一、Example:

    module.exports = app =&gt; {
        class HttpClientController extends app.Controller{
            async getHttpClient(){
                const {ctx, app, service} = this;
                let result = await this.ctx.curl(&apos;http://goucai.diyicai.com/lottery/getissue.action?lotteryId=001&amp;issueLen=100&amp;d=1502966960306&apos;, {
                    methods: &apos;get&apos;
                });

                let phones = [];
                let resultObj = JSON.parse(result.data.toString());
                resultObj.forEach((data, idx, arr)=&gt;{
                    console.log(&apos;data------&apos;, data);
                    phones.push(data.endTime);
                })
                ctx.body = phones.join(&apos;,&apos;)
            }
        }
        return HttpClientController;
    }

二、config配置 // config/config.default.js

    exports.httpclient = {
        // 默认开启 http/https KeepAlive 功能
        keepAlive: true,

        // 空闲的 KeepAlive socket 最长可以存活 4 秒
        freeSocketKeepAliveTimeout: 4000,

        // 当 socket 超过 30 秒都没有任何活动，就会被当作超时处理掉
        timeout: 30000,

        // 允许创建的最大 socket 数
        maxSockets: Infinity,

        // 最大空闲 socket 数
        maxFreeSockets: 256,

        // 是否开启本地 DNS 缓存，默认关闭
        // 一旦设置开启，则每个域名的 DNS 查询结果将在进程内缓存 10 秒
        enableDNSCache: false,
    };

三、options对象

    let options = {};
    const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, options);

    1、mothod: 请求方法

    2、data: 需要发送的数据 { foo: &apos;bar&apos; }

    3、dataAsQueryString: Boolean 如果为 true 即使在post情况下，也会强制将options.data以 querystringstringify处理后拼接到url的query参数上

    4、content（String|Buffer）: 发送请求的正文，如果设置了此参数会忽略data参数

            ctx.curl(url, {
                method: &apos;POST&apos;,
                // 直接发送原始 xml 数据，不需要 HttpClient 做特殊处理
                content: &apos;&lt;xml&gt;&lt;hello&gt;world&lt;/hello&gt;&lt;/xml&gt;&apos;,
                headers: {
                    &apos;content-type&apos;: &apos;text/html&apos;,
                },
            });

    5、stream（ReadStream）: 发送请求正文的可读数据流

            ctx.curl(url, {
                method: &apos;POST&apos;,
                stream: fs.createReadStream(&apos;/path/to/read&apos;),
            });

    6、writeStream: 接受响应数据的可写数据流

            ctx.curl(url, {
                writeStream: fs.createWriteStream(&apos;/path/to/store&apos;),
            });

    7、consumeWriteStream: Boolean 是否等待 writeStream 完全写完才算响应全部接收完毕，默认是 true

    8、contentType: 请求数据的格式，默认undefined

    9、dataType: 响应数据格式

    10、headers: 自定义请求头

    11、timeout: 请求超时时间 默认是 [ 5000, 5000 ]，即创建连接超时是 5 秒，接收响应超时是 5 秒。

    12、agent: 

    13、httpsAgent

    14、auth、digestAuth

    15、followRedirect：Boolean 是否自动跟进3xx的跳转响应

    16、maxRedirects: number 最大自动跳转次数

    17、formatRedirectUrl: 自定义实现302、301

    18、beforeRequest: 请求发送前会调用beforeRequest钩子

        ctx.curl(url, {
            beforeRequest: options =&gt; {
                // 例如我们可以设置全局请求 id，方便日志跟踪
                options.headers[&apos;x-request-id&apos;] = uuid.v1();
            }
        });

    19、streaming：是否直接返回响应流

    20、gzip: Boolean是否开始gzip

    21、timing: Boolean 是否开启请求各阶段的时间没是


四、Get请求

    1、options.method = &apos;post&apos;  设置请求参数，默认是get请求可以不用加

        const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, {method: post});

    2、status: 响应状态码

    3、headers: 响应头信息 有{&apos;conent-type&apos;: &apos;text/html&apos;}

    4、data: 响应body, 返回的是Buffer类型, 如果设置了options.dataType会根据参数来处理


五、Post请求

    module.exports = function* post(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method
            method: &apos;POST&apos;,

            // 通过 contentType 告诉 HttpClient 以 JSON 格式发送
            contentType: &apos;json&apos;,

            // 要传的数据 
            data: {
                hello: &apos;world&apos;,
                now: Date.now(),
            },

            // 明确告诉 HttpClient 以 JSON 格式处理返回的响应 body
            dataType: &apos;json&apos;,
        });
        ctx.body = result.data;
    };


六、From表单提交

    以 ontent-type: application/x-www-form-urlencoded 的格式提交请求数据

    // app/controller/form.js
    module.exports = function* form(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT 和 DELETE
            method: &apos;POST&apos;,
            // 不需要设置 contentType，HttpClient 会默认以 application/x-www-form-urlencoded 格式发送请求
            data: {
                    now: Date.now(),
                    foo: &apos;bar&apos;,
            },
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.form;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;foo&quot;: &quot;bar&quot;,
        //   &quot;now&quot;: &quot;1483864184348&quot;
        // }
    };


七、Multipart 方式上传

    From 表单提交时包含文件的时候，需要用到 multipart/form-data 进行提交了

    引用fromstream 第三方模块

    // app/controller/multipart.js
    const FormStream = require(&apos;formstream&apos;);
    module.exports = function* multipart(ctx) {
        const form = new FormStream();

        // 设置普通的 key value
        form.field(&apos;foo&apos;, &apos;bar&apos;);

        // 上传当前文件本身用于测试
        form.file(&apos;file&apos;, __filename);
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 生成符合 multipart/form-data 要求的请求 headers
            headers: form.headers(),
            // 以 stream 模式提交
            stream: form,
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.files;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;file&quot;: &quot;&apos;use strict&apos;;\n\nconst For....&quot;
        // }
    };

    // 添加更多文件
    form.file(&apos;file1&apos;, file1);
    form.file(&apos;file2&apos;, file2);


八、以Stream 方式上传文件

    Stream 实际会以 Transfer-Encoding: chunked 传输编码格式发送

    // app/controller/stream.js
    const fs = require(&apos;fs&apos;);
    module.exports = function* stream(ctx) {
        // 上传当前文件本身用于测试
        const fileStream = fs.createReadStream(__filename);

        // httpbin.org 不支持 stream 模式，使用本地 stream 接口代替
        const url = `${ctx.protocol}://${ctx.host}/stream`;
        const result = yield ctx.curl(url, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 以 stream 模式提交
            stream: fileStream,
        });

        ctx.status = result.status;
        ctx.set(result.headers);
        ctx.body = result.data;
        // 响应最终会是类似以下的结果：
        // {&quot;streamSize&quot;:574}
    };
</code></pre><h4 id="服务端模板渲染"><a href="#服务端模板渲染" class="headerlink" title="服务端模板渲染"></a>服务端模板渲染</h4><pre><code>读取数据渲染模板，呈现给用户

$ npm i egg-view-ejs --save         // 安装

$ 配置

    // config/plugin.js
    exports.nunjucks = {
        enable: true,
        package: &apos;egg-view-nunjucks&apos;        // 开启插件使用numjucks模板
    };

    // config/config.default.js
    exports.view = {
        defaultViewEngine: &apos;nunjucks&apos;,
        mapping: {
            &apos;.tpl&apos;: &apos;nunjucks&apos;,
        },
    };

render、renderString两个方法

    render(fileName, locals, viewOptions): filenName: 文件路径、locals: 渲染的数据、viewOptions: 用户传入的配置

    render(name, locals) 渲染模板文件, 并赋值给 ctx.body

    renderView(name, locals) 渲染模板文件, 仅返回不赋值

    renderString(tpl, locals) 渲染模板字符串, 仅返回不赋值

- numjucks模板语法: http://mozilla.github.io/nunjucks/cn/templating.html  见模板md -
</code></pre><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><pre><code>Egg内置static插件，static默认映射到 public目录

app/public
├── css
│   └── news.css
└── js
        ├── lib.js
        └── news.js
</code></pre><h4 id="框架扩展"><a href="#框架扩展" class="headerlink" title="框架扩展"></a>框架扩展</h4><pre><code>一、application 全局应用对象扩展

    访问 ctx.app,  Controller，Middleware，Helper，Service 中都可以通过 this.app 访问到 Application 对象

    // app.js
    module.exports = app =&gt; { 
        app.config
    };

    // 扩展 app.foo() 方法 app/extend/application.js
    module.exports = {
        foo(param) {
            // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性
        }
    };

二、context 扩展，可以在ctx中调用扩展方法

    extend/content.js
    module.export = {
        async isIOS() {
            const iosReg = /iphone|ipad|ipod/i;
            return iosReg.test(this.get(&apos;user-agent&apos;));
        },
    }
    引用 await this.ctx.isIOS();

三、helper 用来编写一些实用函数

    // app/extend/helper.js
    const moment = require(&apos;moment&apos;);
    exports.relativeTime = time =&gt; moment(new Date(time * 1000)).fromNow();

    // 在controller里使用
    async newsList(){
  const { ctx } = this;
  const time = ctx.helper.relativeTime();
  this.ctx.logger.info(&apos;data: %j&apos;, time)
}

    // 也可以在模板里面使用：
    &lt;!-- app/views/news/list.tpl --&gt;
    {{ helper.relativeTime(item.time) }}


四、request

五、response
</code></pre><h4 id="Schedule-定时任务"><a href="#Schedule-定时任务" class="headerlink" title="Schedule 定时任务"></a>Schedule 定时任务</h4><pre><code>有些任务需要定时来完成，如定时上报，定时远程更新本地缓存，定时任务都统一存放在 app/schedule 目录下

创建一个定时任务 app/schedule/update_cache.js

module.exports = {
    // 通过 schedule 属性来设置定时任务的执行间隔等配置
    schedule: {
        interval: &apos;1m&apos;,     // 1 分钟间隔
        type: &apos;all&apos;,        // 指定所有的 worker 都需要执行
        immediate: false,
  disable: !app.config.enableWarningSchedule,
    },

    // task 是真正定时任务执行时被运行的函数，第一个参数是一个匿名的 Context 实例
    * task(ctx) {
        const res = yield ctx.curl(&apos;http://www.api.com/cache&apos;, {
            dataType: &apos;json&apos;,
        });
        ctx.app.cache = res.data;
    }
};

1、type: 两种类型 worker 或 all，worker是每台机器只有一个worker执行定时任务， all是每台机器上的每个worker都会执行这个定时任务

2、interval：定时执行的时间

3、cron：指定一个执行的时间 ss mm hh dd mm dd

    // 每三小时准点执行一次
cron: &apos;0 0 */3 * * *&apos;,

4、immediate：如果为true，定时任务会在启动并ready后立即执行一次任务

5、disable：为true，这个定时任务不会被执行
</code></pre><h4 id="启动自定义"><a href="#启动自定义" class="headerlink" title="启动自定义"></a>启动自定义</h4><pre><code>用来进行应用启动时进行初始化工作

// 通过入口文件app.js
module.exports = app =&gt; {
    app.beforeStart(function* () {
        // 应用会等待这个函数执行完成才启动
        app.cities = yield app.curl(&apos;http://example.com/city.json&apos;, {
            method: &apos;GET&apos;,
            dataType: &apos;json&apos;,
        });
    });
};
</code></pre><h4 id="logger-日志"><a href="#logger-日志" class="headerlink" title="logger 日志"></a>logger 日志</h4><pre><code>this.ctx.logger.info(&apos;xxxxxx&apos;);

logger.debug()、logger.info()、logger.warn()、logger.error()

config.deubgger 文件配置

logger: {
    level: &apos;DEBUG&apos;,
    dir: &apos;../app/logger&apos;,
}
</code></pre><h4 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h4><pre><code>egg-bin模块（用于本地开发和单元测试）

package.json:

{
    &quot;scripts&quot;: {
        &quot;dev&quot;: &quot;egg-bin dev --port 7001&quot;
    }
}
</code></pre><h4 id="插件的开发"><a href="#插件的开发" class="headerlink" title="插件的开发"></a>插件的开发</h4><pre><code>自定义插件存储目录:  lib/plugin/...

egg-ua插件

1、创建package.json

    {
        &quot;eggPlugin&quot;: {
            &quot;name&quot;: &quot;ua&quot;
        }
    }

2、egg-ua/us.js插件文件

    module.exports = {
        get isIOS() {
            const iosReg = /iphone|ipad|ipod/i;
            return iosReg.test(this.get(&apos;user-agent&apos;));
        },
    };

3、config/plugin.js   通过path来挂载插件

    const path = require(&apos;path&apos;);
    exports.ua = {
        enable: true,
        path: path.join(__dirname, &apos;../lib/plugin/egg-ua&apos;),
    };
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>├── package.json
├── app.js (可选)            // 启动初始化
├── agent.js (可选)
├── app
|   ├── router.js           // 路由规则
│   ├── controller          // 处理用户的输入，返回相应的结果
│   |   └── home.js
│   ├── service (可选)       // 服务，编写业务逻辑
│   |   └── user.js
│   ├── middleware (可选)    // 中间件
│   |   └── response_time.js
│   ├── schedule (可选)      // 定时任务
│   |   └── my_task.js
│   ├── public (可选)        // 静态目录
│   |   └── reset.css
│   ├── view (可选)          // 模板
│   |   └── home.tpl
│   └── extend (可选)        // 框架扩展
│       ├── helper.js (可选)
│       ├── request.js (可选)
│       ├── response.js (可选)
│       ├── context.js (可选)     // ctx扩展
│       ├── application.js (可选)     // 全局方法
│       └── agent.js (可选)
├── config                  // 配置
|   ├── plugin.js
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test                    // 测试
        ├── middleware
        |   └── response_time.test.js
        └── controller
                └── home.test.js
</code></pre><h4 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h4><pre><code>一、egg启动时指定端口

    在package.json中
    script: {
        &quot;dev-fundmgmt&quot;: &quot;PLATFORM=fundmgmt egg-bin dev --port 20101&quot;,            // --port 20101
    }

二、vue-cli中webpack是否使用热更新

    script: {
        &quot;dev-fundmgmt&quot;: &quot;HOT_ENV=true node build/dev-server.js FUNDMGMT&quot;,
    }
    HOT_ENV=true   为false


二、vue中取启动里的变量

    script: {
        &quot;dev-fundmgmt&quot;: &quot;HOT_ENV=true node build/dev-server.js FUNDMGMT&quot;,
    }

    vue-cli中的dev.env.js

    var PLAT = process.argv;            // 取出命令中返回数组 [&apos;HOT_ENV=true&apos;, &apos;node&apos;, &apos;build/dev-server.js&apos;, &apos;FUNDMGMT&apos;];
    if (PLAT.toUpperCase().trim() === &apos;FUND&apos;) {
        PLAT = &apos;fund&apos;
    } 
    else if(PLAT.toUpperCase().trim() === &apos;FUNDMGMT&apos;){
        PLAT = &apos;fundmgmt&apos;;
    }
    else {
        PLAT = &apos;portal&apos;
    }
</code></pre><p>| <a href="http://koa.bootcss.com/" target="_blank" rel="noopener">http://koa.bootcss.com/</a></p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
