<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/Git/">Git</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/Git/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Git/">Git</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><pre><code>1、安装brew   https://brew.sh/ 后在安装

2、brew install git

3、git --version   查看git版本

4、which git       显示当前git所在的目录
</code></pre><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><pre><code>版本控制分为 集成式版本控制 和 分布式开发

    1、集成式开发（svn）：需要一台中央服务器，客户端需要连接到中央服务器进行更新、提交代码文件等

    2、分布式开发（Git）：每台机器都有自己版本库不需要中央服务器

分布式的好处：

    1、不需要连接中央服务器来提交和更新文件

    2、通过不同的版本来做不同阶段开发，不同的版本文件可以随时切换回之前的版本

    3、分支管理上要比svn方便很多


[master +0 ~0 -0 !1]: + 增加  ~修改  -删除  !有冲突

Git的配置文件：vi ~/.gitconfig
</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code>1、将远端的库克隆到本地:  git clone 远程代码库

2、切换到一个分支: git checkout 分支名

3、如果分支存在只切换分支，如果不存在则创建并切换到分支:  git checkout -b   新建本地分支名  origin/远端分支名

4、查看当前所在的分支:  git branch

   创建新分支: git branch 新分支名

5、将文件添加到暂存区:  git add 文件名         git add .  添加所有工作区文件到暂存区

6、提交文件:  git commit -m &apos;提交版本内容说明&apos;

7、将本地代码提交到远端库:  git push origin/develop_web  本地分支名

8、查看当前文件状态:  git status 

9、从远端拉取拉取代码:  git pull 远端分支名

10、临时保存:  git stash   git stash pop

11、从主分支上merge代码:  git merge origin/dev_crm2.6_base

12、将本地分支提交到主分支:  pull resquest

13、删除本地分支:  git branch -d dev_crm2.8_base

14、删除远端分支:  git push origin :PublicAdmin_V1.0.0_liusiguang        或  git branch -r -d origin/PublicAdmin_V1.0.0_liusiguang

15、从远端单独拉取一个文件:  git checkout origin/master -- path/to/file

16、撤消最后一次commit提交：git reset --hard HEAD^

17、chenkout一个分支后，pull的时候想在app_master下切换，使用下面命令进行转换

    git branch --set-upstream 当前分支名 远端分支名

18、git branch --track branch 名称 远端branch 建立一个 tracking 远端 branch 的 branch，这样以后 push/pull都会直接对应到该远端的branch。
    git branch --set-upstream branch 远端branch 将一个已存在的 branch 设定成 tracking 远端的branch。
</code></pre><h4 id="版本库介绍"><a href="#版本库介绍" class="headerlink" title="版本库介绍"></a>版本库介绍</h4><pre><code>工作区（文件）      暂存区（过度）     版本库      |       远端（服务器版本）    

1、工作区:  开发的区域

2、暂存区: 将工作区的文件执行 git add &apos;文件名&apos; 命令会使文件添加到暂存区，工作区的文件如果删除了就没有了

    git add &apos;文件名&apos;


3、版本库: 通过commit来提交到版本库， 暂存区需要先提交到版本库才能最后提交远端

    git commit -m &apos;提交说明内容&apos;

    add 和 commit 连着的写法
    git commit -a -m &apos;提交注释&apos;        // 这样可以省略add的步骤


4、提交到远端: 通过push来提交到远端

    git push origin develop_web_2.5.1_siguang            // 提交到远端
</code></pre><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><pre><code>1、设置贡献者

    设置用户名:     git config  --global user.name “username”

    设置Email-id:  git config  --global user.email “email”


2、设置避免PULLING提交合并:   git config --global branch.autosetuprebase always

3、颜色高亮

    git config --global color.ui true

    git config --global color.status auto

    git config --global color.branch auto


4、设置默认编辑器:  git config --global core.editor vim        Git的使用系统默认取自VISUAL或EDITOR环境变量的编辑器

5、设置默认的合并工具:  git config --global merge.tool vimdiff

6、查看设置命令:  git config --list
</code></pre><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><pre><code>1、git init 库名： 创建一个git仓库 

2、git remote add origin git@xbc.me:wordpress.git:    添加远程版本库origin

3、git remote:   显示所有远端主机

    git remote  -v:        查看远程仓库地址

    git remote show &lt;主机名&gt;:     查看远端主机的详细信息

    git remote add &lt;主机名&gt; &lt;网址&gt;:    添加远程主机

    git remote rm &lt;主机名&gt;:    删除远端主机

    git remote rename &lt;原主机名&gt; &lt;新主机名&gt;:    对无端主机进行改名

     在clone完成之后，Git 会自动为你将此远程仓库命名为origin，origin只相当于一个别名，运行git remote –v可以看到下载的版本路径。


克隆项目地址:    git clone 远程版本库地址
</code></pre><h4 id="文件操作（查看、添加、提交、删除、恢复，撤消）"><a href="#文件操作（查看、添加、提交、删除、恢复，撤消）" class="headerlink" title="文件操作（查看、添加、提交、删除、恢复，撤消）"></a>文件操作（查看、添加、提交、删除、恢复，撤消）</h4><pre><code>查看:

    1、git help:  显示help的命令功能

    2、git show 提交ID:  显示某次提交的内容，先通过git log来查看提交的ID

        commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e         // 提交的ID

    3、git log:  显示所有的版本记录


添加: 添加到缓存区

    1、git add 文件名:  将工作文件修改提交到本地暂存区            add只是刷新了git的跟踪信息，并未发到版本库中

    2、git add --all:  将所有修改过的文件提交到暂存区


提交: 提交到版本库

    1、git commit -m &apos;注释提交理由&apos;:  代码提交

        git commit --amend:  使用最后一次提交的注释在提交

    2、git push origin master:  将刚commit的版本推送到远程服务器


删除：

    1、git rm &apos;main.js&apos;:     删除暂存区的main.js文件

    2、git rm -f &apos;main.js&apos;:  删除工作区和暂存区的main.js文件

    3、git rm --cached &apos;main.js&apos;:  如果工作区和暂存区都有main.js，只删除暂存区文件


恢复：

    如果把工作区的文件删除了，想从版本库中恢复回来的方法:

    1、恢复文件

        先 git log 来查看commit 提交的历史版本，获取到commitId

        commit d5d9357319a4ef536b30f2d906bb71700beaa899
        Author: liusiugang &lt;liusiguang@renrendai.com&gt;
        Date:   Thu Nov 3 15:19:00 2016 +0800

            修改邻趣配送时间接口加merchantId参数+

        git checkout  [commitId] [要恢复的文件名]

        // 这样就将版本库中的common.coffee.js恢复到了工作区
        git checkout d5d9357319a4ef536b30f2d906bb71700beaa899  common.coffee.js   


    2、恢复版本

        1）git reset --hard  [commitId]    恢复到指定提交的版本的内容，通过commitId来指定版本

        2）git reset --hard HEAD^    恢复向后一个版本

        3）git reflog    显示所有的操作记录


撤消：

    1、git reset &lt;file&gt;：    从暂存区恢复到工作文件

    2、git reset --：        从暂存区恢复到工作文件

    3、git reset --hard：    恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改

    4、git reset HEAD b：    现在你只想提交a文件，不想提交b文件，应该这样

    5、git revert &lt;$id&gt;：    恢复某次提交的状态，恢复动作本身也创建了一次提交对象

    6、git revert HEAD：    恢复最后一次提交的状态

        git checkout -- filname  撤回远端版本或指定文件

        git commit --amend    重新合并一个提交方案


文件重命名：

    1、git mv reademe.txt 新文件名


查看当前库状态: git status

    显示
    On branch master        // master分支
    Your branch is up-to-date with &apos;origin/master&apos;.        // 你的分支是最新的 master
    nothing to commit, working directory clean            // 无提交，工作目录干净
</code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code>1、查看分支

    查看本地分支:  git branch

    查看远端分支:  git branch -r

    查看本地和远端分支:  git branch -a

    查看各分支最后提交的信息:  git branch -v

2、创建分支 

    git branch 分支名称

3、把分支提交到远端分支

    # 如果在本地创建一个分支，与团队其它人一起开发，需要将这个分支push到远端仓库，不然这个分支只是存在你本地，其它人看不到，每次commit完代码就需要提交到远端

    git push origin 本地分支名

    Example:

        appledeMacBook-Pro:what apple$ git push origin dev_1.1_lulu           // 将dev_1.1_lulu分支提交到远端
        Username for &apos;https://github.com&apos;: siguang1983            // 输入远程的用户名
        Password for &apos;https://siguang1983@github.com&apos;:             // 输入远端的密码
        Counting objects: 4, done.                                // 成功

4、删除分支: 

    git branch -d &lt;branch&gt;        删除某个分支

    git branch -D &lt;branch&gt;        强制删除某个分支 (未被合并的分支被删除的时候需要强制)

5、切换分支:

    git checkout [要切换的分支]        本地切换分支

    git checkout -b [新创建分支名]  [远端地址分支]            创建并且直接切换到这个新分支

6、合并分支: git morge  分支名

    git merge master develop        # 将develop分支合并到master上

7、分支的更新与合并

    # 将本地仓库更新到最新版本，直接更新自动合并冲突，如果执行fetch提示哪些冲突需要手动更新
    git pull origin 分支名

    # 执行一下合并，并且手动去去解决冲突
    git merge [branch]

    # 将这个冲突文件重新提交 
    git add &lt;filename&gt;

    # 查看一下冲突的文件
    git diff 确定分支  目标分支

    # 冲突处理完后就可以commit
    git commit -m &apos;fix conflict&apos;

8、删除远程版本:  git push origin :br-1.0.0

9、查看分支提交的记录:  git whatchanged

    commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e            // 提交的状态码
    Author: apple &lt;apple@appledeMacBook-Pro.local&gt;            // 提交人
    Date:   Mon May 2 17:24:16 2016 +0800                    // 日期

        siguang add index.js                // 提交文件

    :100644 100644 e69de29... 50b777e... M  js/index.js
</code></pre><h4 id="拉取远端代码-和-提交远端代码"><a href="#拉取远端代码-和-提交远端代码" class="headerlink" title="拉取远端代码 和 提交远端代码"></a>拉取远端代码 和 提交远端代码</h4><pre><code>1、pull、fetch 两种都是拉取代码功能，有一些小的差别

    git pull : 拉取远端代码，直接合并        // Already up-to-date. 已更新

    git fetch: 拉取远端代码，并不合并，查看哪些冲突，来进行手动merge合并


2、版本库提交到远端

    git push origin/dev_crm2.9_base


3、pull request：将代码提交到远端版本中的一个请求，在merge就可以直接合到远端仓库中
</code></pre><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><pre><code>拉取完代码git pull 或 git fetch 拉取远程某个分支的代码，再与本地的指定分支合并（包括fetch和merge）

git pull origin/dev_crm2.5_base 

git merge origin/dev_crm2.5_base

    有时候pull的时候会提示：git branch --set-upstream master origin/next  

    Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）

    如果有冲突 常见提示：
        Auto-merging addCacke.html            // 自动合并了这个文件
        CONFLICT (content): Merge conflict in addCacke.html            // 有冲突在 addCacke.html文件中合并冲突
        Automatic merge failed; fix conflicts and then commit the result.        // 自动合并失败解决冲突
</code></pre><h4 id="查看文件之间区别-diff"><a href="#查看文件之间区别-diff" class="headerlink" title="查看文件之间区别 diff"></a>查看文件之间区别 diff</h4><pre><code>1、git diff &lt;file&gt;:        是工作区与暂存区的

2、git diff &lt;$id1&gt; &lt;$id2&gt;:    比较两次提交之间的差异

3、git diff &lt;branch1&gt;..&lt;branch2&gt;:    在两个分支之间比较

4、git diff --staged:    比较暂存区和版本库差异

5、git diff --cached:    暂存区和版本区差异

6、git diff --stat:         仅仅比较统计信息
</code></pre><h4 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h4><pre><code>1、git log:  显示提交的所有记录

    commit 1bf1682120ac9fa622b04a77781f5999e0aabd9e         // 提交的ID
    Author: apple &lt;apple@appledeMacBook-Pro.local&gt;         // 提交用户
    Date:   Mon May 2 17:24:16 2016 +0800                 // 提交日期

        siguang add index.js            // 提交文件

2、git log &lt;file&gt;:        查看该文件每次提交记录

3、git log -p &lt;file&gt; :    查看每次详细修改内容的diff

4、git log -p -2:        查看最近两次详细修改内容的diff

5、git log --status:     查看提交统计信息
</code></pre><h4 id="sourceTree-使用"><a href="#sourceTree-使用" class="headerlink" title="sourceTree 使用"></a>sourceTree 使用</h4><pre><code>一、设置拉取、推送默认密码

    仓库 -&gt; 远程仓库 -&gt; 将路径配置成 http://用户名:密码@172.16.x.xx:7990/scm/ibg/ibg.git
</code></pre><blockquote>
<p>参考资料：</p>
<p>可视化工具：SourceTree<br>远端：stash</p>
<p><a href="http://iissnan.com/progit/" target="_blank" rel="noopener">http://iissnan.com/progit/</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</a><br><a href="http://www.yiibai.com/git/git_update_operation.html" target="_blank" rel="noopener">http://www.yiibai.com/git/git_update_operation.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/weex/">Weex</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/weex/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Weex/">Weex</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="Native调研"><a href="#Native调研" class="headerlink" title="Native调研"></a>Native调研</h1><h3 id="目前主流的应用大体分成三类：Native-App-Web-App-Hybrid-App"><a href="#目前主流的应用大体分成三类：Native-App-Web-App-Hybrid-App" class="headerlink" title="目前主流的应用大体分成三类：Native App, Web App, Hybrid App."></a>目前主流的应用大体分成三类：Native App, Web App, Hybrid App.</h3><h3 id="三类主流的优点"><a href="#三类主流的优点" class="headerlink" title="三类主流的优点"></a>三类主流的优点</h3><pre><code>1、native App

    性能好
    用户体验也比较好
    开发成本高，无法跨平台
    升级困难(审核),维护成本高

2、Web App特点:

    开发成本低,更新快,版本升级容易,自动升级
    跨平台，Write Once , Run Anywhere
    无法调用系统级的API
    临时入口，用户留存度低
    性能差,体验差,设计受限制
    相比Native App，Web App体验中受限于以上5个因素：网络环境，渲染性能，平台特性，受限于浏览器，系统限制。

3、Hybrid App(混合app)特点:

    Native App 和 Web App 折中的方案，保留了 Native App 和 Web App 的优点。
    但是还是性能差。页面渲染效率低，在Webview中绘制界面，实现动画，资源消耗都比较大,受限于技术,网速等因素
</code></pre><h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h3><pre><code>weex是阿里巴巴公司与2016年6月开源的一种用于构建移动跨平台的UI框架

特点:

    1、一次性编写代码多端运行，

    2、使用的vue的语法，RN使用的react语法

    3、轻量级,语法简单,易于使用

    4、可扩展,丰富内置组件,可扩展的API

    5、High Performance: 高性能


缺点: 只调研IOS

    1、weex开源比较晚资料也比较少，资料也不太容易看懂;

    2、没有对硬件调用的直接接口，需要swift进行modul的扩展（）;

    3、支持的组件也不完善;

    3、开发完成后对xcode不了解，所以在生成项目这块和导出包这块一直也没有解决(github上有人将创建了一个完整的项目);


weex流程:

    需要xcode、cocoapods、

    创建weex-cli  =&gt;  




基于JS开发框架:

    weex基于vue.js


性能对比:
</code></pre><div style="width:200px;"><br>    <img src="./img/1.png"><br></div>


<h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本:"></a>学习成本:</h4><pre><code>1.环境配置：

    ReactNative需要按照文档安装配置很多依赖的工具，相对比较麻烦。 weex安装cli之后就可以使用


2.vue vs react:

    react模板JSX学习使用有一定的成本 vue更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css
</code></pre><h4 id="weex-使用"><a href="#weex-使用" class="headerlink" title="weex 使用"></a>weex 使用</h4><pre><code>1、手机下载

    Weex Playground  可以通过二维码来看服务 


集成IOS

需要安装 iOS 开发环境 和 CocoaPods  


2、Cocoapods安装  http://blog.csdn.net/showhilllee/article/details/38398119/

    需要Ruby环境，Mac本身就自带Ruby

    $ sudo gem install cocoapods
</code></pre><p>思考:</p>
<pre><code>1、与web app 相比 navtive是不是可以不用考虑页面兼容问题（不同设备和系统）

2、cocoapads，xcode的一些处理，打包是否不用处理，还是只考虑写vue这块的内容就可以

3、weex怎么调用硬件设备

4、如果是原生与weex结合怎么来进行通信

5、weex不适用于做什么，和优、缺点是什么
</code></pre><p>|<br>| <a href="https://weex.apache.org/cn/" target="_blank" rel="noopener">https://weex.apache.org/cn/</a>      weex官网<br>| <a href="https://market.dotwe.org/ext/list.htm#6" target="_blank" rel="noopener">https://market.dotwe.org/ext/list.htm#6</a><br>| <a href="https://github.com/joggerplus/awesome-weex" target="_blank" rel="noopener">https://github.com/joggerplus/awesome-weex</a><br>| <a href="https://github.com/weexteam/weex-hackernews/blob/master/README.zh.md" target="_blank" rel="noopener">https://github.com/weexteam/weex-hackernews/blob/master/README.zh.md</a><br>| <a href="https://github.com/weexteam" target="_blank" rel="noopener">https://github.com/weexteam</a><br>| <a href="http://i.youku.com/i/UNDEzMDY2NjI0MA==/videos" target="_blank" rel="noopener">http://i.youku.com/i/UNDEzMDY2NjI0MA==/videos</a><br>| <a href="http://www.jianshu.com/p/cb6de4b85ea3" target="_blank" rel="noopener">http://www.jianshu.com/p/cb6de4b85ea3</a><br>| <a href="http://www.apicloud.com/" target="_blank" rel="noopener">http://www.apicloud.com/</a><br>| <a href="https://yq.aliyun.com/articles/57996" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57996</a>   react native与weex<br>| <a href="http://div.io/topic/1478" target="_blank" rel="noopener">http://div.io/topic/1478</a><br>| <a href="https://github.com/Elemefe/weex-vue-starter-kit" target="_blank" rel="noopener">https://github.com/Elemefe/weex-vue-starter-kit</a><br>|<br>|<br>| <a href="http://reactnative.cn/" target="_blank" rel="noopener">http://reactnative.cn/</a>         react native<br>| <a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="noopener">https://github.com/jondot/awesome-react-native</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之基础篇/">React Native之基础篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之基础篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React Native 介绍"></a>React Native 介绍</h4><pre><code>一、Native的类别

    React Native 编译后是原生应用，v0.22.0热更新hot reloading

    Hybrid  混合应用

    phoneGap 包皮应用，一次编写，到处运行，依然是网页，只是将页面内容内嵌到webView中，用中间件来对网页进行通信，对一些动画会有性能上的问题


二、实时加载（Live Reload）和热加载（Hot Reload）的区别

    http://www.jianshu.com/p/1fa6e9c0799f

    Enable Live Reload  实时加载，应用于更新时需要刷新当前页面，可以看到全局刷新效果

    Enable Hot Reloading   热加载，当布局修改时会自动更新模拟器，看不出来刷新效果类似买局部刷新

三、React Native 应用部署/热更新 codePush

    http://blog.csdn.net/fengyuzhengfan/article/details/52003798
</code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>1、安装 XCode

    $ xcode-select --install  检查xcode是否安装, 如果未安装会出现提示

    android 下载 android studio  https://developer.android.google.cn/index.html


2、安装 homebrew

    用于包管理，与npm类似

    $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;

    $ sudo chown -R `whoami` /usr/local   解决/usr/local目录不可写的权限问题  

    Homebrew将工具安装到 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。


3、安装 watchman 和 flow

    watchman是facebook的开源项目用于监视文件并且记录文件的改动情况

    flow 是js的静态类型检查器，用于找出js代码中的类型错误

    $ brew install watchman

    $ brew install flow


4、安装 NodeJS

5、安装 react-native 

    $ npm install -g react-native-cli      // Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载

6、vscode中react-native插件
</code></pre><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><pre><code>1、创建项目

    $ react-native init 项目名  // 创建项目

    $ react-native run-ios     // 运行 react-native run-ios --simulator &quot;iPhone 4s&quot;  定义模拟器类型

        或者在ios目录 AwesomeProject.xcodeproj  双击打开


2、查看命令

    $ react-native -h   所有命令

    $ react-native -v   版本


3、安装第三方插件

    $ npm i react-native-elements lodash query-string sha1 react-native-audio react-native-video react-native-image-picker react-native-progress react-native-sk-countdown react-native-swiper react-native-barcodescanner --save


4、link 命令

    link的原因：以下组件都是原生开发，wrapper了一层js，因此需要link .a到project中

    $ react-native link

    或 rnpm link     需要先安装rnpm     npm install rnpm -g --save-dev


5、模拟器调试技巧

    http://blog.csdn.net/quanqinyang/article/details/52215652  

    # 模拟器打开后可以通过cmd+1/2/3/4来调整窗口大小

    # 模拟器在所有窗口置顶 window -&gt; stay in front

    # ISO cmd + D 打开调试菜单，Android cmd + M

    # comond + T  show Animate 呼出菜单cmd+D会变成慢动画


    # Reload 重新bundle代码 cmd + R

    # Debug JS Remotely   调试模式 chrome Developer Tools调试

    # Enable Live Reload  实时加载，应用于更新时需要刷新当前页面，可以看到全局刷新效果

    # Enable Hot Reloading   热加载，当布局修改时会自动更新模拟器，看不出来刷新效果类似买局部刷新


    # 警告

        红错误 - console.error(&apos;&apos;)

        关闭警告 - console.disableYellowBox = true;    显示警告 - console.warn(&apos;YellowBox is disabled.&apos;);

    # 日志 - react-native log-ios      react-native log-android

    # chrome开发工具 - debug js Remotely  可以跟进代码
</code></pre><h4 id="react-native-目录"><a href="#react-native-目录" class="headerlink" title="react-native 目录"></a>react-native 目录</h4><pre><code>.
├── .DS_Store
├── .babelrc            // ES6转换的配置
├── .buckconfig
├── .flowconfig         // 做js代码类型检查 
├── .watchmanconfig     // 监听文件改变watchman的配置
├── .gitattributes
├── .gitignore          // 对哪些文件被git忽略不显示
├── node_modules        // 存储资源包    
├── __tests__
├── android             // android原生文件目录
├── ios                 // ios的原生文件目录 运行reactNative会将文件打包到这个目录，然后xcode调用的就是这里的项目文件
├── app.json
├── index.android.js    // android文件入口
├── index.ios.js        // ios文件入口
├── package.json        // 依赖文件
└── yarn.lock
</code></pre><h4 id="AppRegistry-注册模块，用来告诉RN哪个组件被注册为根窗口"><a href="#AppRegistry-注册模块，用来告诉RN哪个组件被注册为根窗口" class="headerlink" title="AppRegistry 注册模块，用来告诉RN哪个组件被注册为根窗口"></a>AppRegistry 注册模块，用来告诉RN哪个组件被注册为根窗口</h4><pre><code>AppRegistry是js运行RN应用的入口，通过registerComponent()来注册方法

AppRegistry.registerComponent(&apos;项目名&apos;, () =&gt; 入口组件名)  注册入口

AppRegistry.runApplication 来真正运行应用
</code></pre><h4 id="React-Native-生命周期"><a href="#React-Native-生命周期" class="headerlink" title="React Native 生命周期"></a>React Native 生命周期</h4><pre><code>第一阶段，初始化

    getDefaultProps -&gt; getInitialState -&gt; componentWillMount -&gt; render -&gt; componentDidMount

       获取配置参数        获取初始状态值         通知要开始渲染        渲染       告诉组件已经完成


第二阶段，运行阶段 组件运行中

    1、state变化 -&gt; shouldComponentUpdate -&gt; componentWhllUpdate -&gt;  render -&gt; componentDidUpdate

       状态变化    判断组件是否要更新true/false     需要更新就触发           渲染         更新组件

    2、props变化 -&gt; componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWhllUpdate -&gt;  render -&gt; componentDidUpdate

       props变化         属性改变调用             判断组件是否要更新true/false       需要更新就触发        渲染           更新组件


第三阶段 卸载

    unmount -&gt; componentWillUnmout -&gt; 结束 
</code></pre><p><img src="images/lifecycle.png" alt="组件生命周期"></p>
<h4 id="props、state"><a href="#props、state" class="headerlink" title="props、state"></a>props、state</h4><pre><code>一、props属性: 父组件传值给子组件

    &lt;Greeting name=&apos;Rexxar&apos; /&gt;      父组件调用子组件

    &lt;Text&gt;Hello {this.props.name}!&lt;/Text&gt;   子组件接收

    1、defaultProps定义默认的props

        class Smiple extends Component{
            static defaultProps = {     // 定义默认props静态属性
                name: &apos;siguang&apos;
            }

            static propsTypes = {       // 检测props的类型
                name: &apos;String&apos;
            }

            render(){
                return (
                    &lt;View&gt;
                        &lt;Text&gt; {this.props.name} &lt;/Text&gt;
                    &lt;View&gt;
                )
            }
        }


二、state状态、setState()改变状态，组件中可以改变的值

    export default class rrdProject extends Component {
        constructor(props){
            super(props);

            // 定义state对象
            this.state = { 
                showText: &apos;&apos;
            }
        }

        // state = {  };     // RN也支持ES7 类的静态属性写法

        render() {
            return(
                &lt;View style={styles.container}&gt;
                    &lt;Text&gt;这里有内容: {this.state.showText}&lt;/Text&gt;
                &lt;/View&gt;
            );
        }
    }
</code></pre><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><pre><code>通过ref来获取真实的DOM

import childComponent from &apos;./childComponent&apos;;

class Simple extends Component {
    clickChild(){
        var size = this.refs.childRef.getSize();       // 获取childComponent组件的getSize()方法
    }

    render() {
        return (
            &lt;View&gt;
                &lt;Text&gt;Simple 基本页面&lt;/Text&gt;
                &lt;button onPress={this.clickChild} title=&quot;点击&quot; /&gt;

                &lt;childComponent ref=&quot;childRef&quot; /&gt;
            &lt;/View&gt;
        )
    }
}
</code></pre><h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><pre><code>http://blog.csdn.net/sbsujjbcy/article/details/50017029
http://www.cnblogs.com/wonyun/p/5481134.html

1、直接写样式

    &lt;View style={{width: 193, height: 110}}&gt;&lt;/View&gt;     {{}} 两个括号可以直接写样式
    &lt;View style={styles.red}&gt;&lt;/View&gt;                    {} 一个括号需要来调用样式类
    const styles = StyleSheet.create({
        red: {
            color: red
        }
    })

2、写多个样式

    &lt;Text style={[styles.btn, styles.color]}&gt;立即体验&lt;/Text&gt;

    // 支持表达式
    &lt;Text style={[styles.btn, styles.color &amp;&amp; this.props.dotColor]}&gt;立即体验&lt;/Text&gt;


2、styleSheet.create({}) 定义样式

    const styles = StyleSheet.create({
        rootView:{
            height: &apos;100%&apos;,
            width: &apos;100%&apos;,
            backgroundColor: &apos;#eff0f3&apos;
        },
        big: {
            color: &apos;blue&apos;,
            fontSize: 30
        }
    })
    &lt;View style={styles.rootView}&gt;      // 多个样式 style={[styles.rootView, styles.big]}
        &lt;Text&gt;REACT NATIVE ELEMENTS&lt;/Text&gt;
    &lt;/View&gt;


3、颜色支持

    &apos;#ccc&apos;、 &apos;rgba(0,0,0,.4)&apos;、 &apos;transparent&apos;、 &apos;red&apos;


4、RN样式与css样式的异同

    View类型div，会默认占用窗口的100%宽度

    绝对定位和相对定位不需要父元素设置positioin，也没有zIndex配置

    不能将RN的inline元素设置maginTop、marginBottom

    样式继承只存在Text元素内的Text元素

        &lt;Text style={{color:'red'}}&gt;
             &lt;Text&gt;父：我是white还是red{&apos;\n&apos;}
                 &lt;Text&gt;子：那我是神马颜色&lt;/Text&gt;
             &lt;/Text&gt;
       &lt;/Text&gt;
</code></pre><h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h4><pre><code>直接给组件指定宽、高   &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;
http://www.devio.org/2016/08/01/Reac-Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/#和而不同

一、父视图属性:

    1、flexDirection(&apos;row&apos;, &apos;column&apos;,&apos;row-reverse&apos;,&apos;column-reverse&apos;)- 布局子元素的排列方向，默认是column不是row

        &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;
            &lt;View style={{flex:1, height: 50, backgroundColor: 'powderblue'}} /&gt;
            &lt;View style={{flex:2, height: 50, backgroundColor: 'skyblue'}} /&gt;
            &lt;View style={{flex:3, height: 50, backgroundColor: 'steelblue'}} /&gt;
        &lt;/View&gt;

        重要:  
            &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;  
            父组件没设置flexDirection=row，默认布局为列，子组件设置flex:1是没用的，子组件只能设置width
            父组件设置为flexDirection=row，子组件可以设置flex:1

    2、flexWrap (&apos;wrap&apos;, &apos;nowrap&apos;) - 定义子元素是否允许多行排列

    3、justifyContent (&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;space-between&apos;, &apos;space-around&apos;) - 定义子元素如何对齐

    4、alignItems (&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) - 定义子元素在侧轴对齐的


    justifyContent - 子元素沿主轴的排列方式

        justifyContent: flex-start、center、flex-end、space-around以及space-between
        &lt;View style={{ flex: 1,  flexDirection: 'row' justifyContent: center}}&gt;

    alignItems - 


二、子视图属性：

    1、alignSelf (&apos;auto&apos;, &apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) - 

    2、flex - 
</code></pre><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><pre><code>RN里网络请求分为: Fetch、WebSocket、XMLHttpRequest
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>onPress: 点击

onLongPress: 长按

maximumZoomScale和minimumZoomScale: 双指缩放

http://reactnative.cn/docs/0.42/panresponder.html
</code></pre><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><pre><code>1、LayoutAnimation 用于全局的布局动画

2、Animated 用于创建更精细的交互控制的动画

    Animated 封装了四个可以动画的组件: View、Text、Image和ScrollView

    start/stop 方法来控制动画按顺序执行
</code></pre><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><pre><code>setTimeout, clearTimeout
setInterval, clearInterval
setImmediate, clearImmediate
requestAnimationFrame, cancelAnimationFrame
</code></pre><h4 id="RN与原生通信"><a href="#RN与原生通信" class="headerlink" title="RN与原生通信"></a>RN与原生通信</h4><pre><code>http://blog.csdn.net/zww1984774346/article/details/71167775

rn与IOS原生通信的三部分

    1、属性        2、原生模块      3、原生UI组件封装

    原生要写到AppDelegate.m文件中

    # 属性是最简单的跨组件通信，从原生组件传递属性到React Native 或 React Native到原生组件

        原生中添加imageList:

            NSArray *imageList = @[@&quot;https://facebook.github.io/react/img/logo_og.png&quot;,
                        @&quot;https://facebook.github.io/react/img/logo_og.png&quot;];

            NSDictionary *props = @{@&quot;images&quot; : imageList};

            RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                        moduleName:@&quot;AwesomeProject&quot;
                                        initialProperties:props             // 这里initialProperties:props]传递给RN
                                        launchOptions:launchOptions];

        RN中接收与props传值一样:

            &lt;View&gt;
                {
                    this.props.images.map(function(items){
                        return &lt;Image 
                            source={{uri:items}} 
                            style={{width:100,height:100}}&gt;&lt;/Image&gt; 
                    })
                }
            &lt;/View&gt;


1、RN访问OC

    // 创建原生模块实例
    var NativeModule = require(&apos;react-native&apos;).NativeModules.NativeTest;

    // 调用原生的doSomething()方法
    NativeModule.doSomething(&apos;ReactNative&apos;);


2、OC访问RN

http://www.jianshu.com/p/9d7dbf17daa5
</code></pre><h4 id="生成测试包"><a href="#生成测试包" class="headerlink" title="生成测试包"></a>生成测试包</h4><pre><code>iOS—最全的真机测试教程   http://www.cocoachina.com/ios/20160711/17004.html

团队开发的Xcode配置和生成包

    xCode -&gt; Preferencse -&gt; Accounts -&gt; + 填加 选择 add apple ID 将账号和密码输入

    点击工程目录 -&gt; General 
        -&gt; Identity面板下的 Bundle Identifler 填写权限 “com.ucredit.paydayloan” 
        -&gt; 在 Signing面板中的 Team 中选择&quot;ZhongChengXingyu of......&quot;

    将手机与mac连接，将Device选择当前手机设备，点击 运行，写读取设备成功后，在运行一次这次是执行build
</code></pre><h4 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h4><pre><code>两种方法加载原生组件

1、react-native link 命令

    不仅会将第三方模块的原生组件代码链接入 Android/IOS 中，还会将字体等文件移动相应的目录中

2、通过Xcode来导入组件

    http://www.cnblogs.com/shaoting/p/6148085.html

3、Flow

    Flow是 Facebook出品的表态类型语言，可以将RN内部也支持ES 7的类属性的写法

        // 就可以不用在象ES 6将静态属性写到constructor中
        class MyComponent extends Component {
            constructor(props){
                super(props);

                // 私有属性
                this.isField = 1;   
                // state
                this.state = {
                    username: &apos;siguang&apos;
                }
            }

            render(){
                return (
                    &lt;View&gt;
                        {this.username}
                    &lt;/View&gt;
                )
            }
        }

        class MyComponent extends Component {
            isField = 1;
            state = {
                username: &apos;siguang&apos;
            }

            render(){
                return (
                    &lt;View&gt;
                        {this.usernmae}
                    &lt;/View&gt;
                )
            }
        }
</code></pre><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><pre><code>1、Command+R  重新刷新

2、Command+D  打开菜单 

3、Debug JS Remotely 用chrome浏览器调试,Alt+Command+j出现浏览器debug窗口

4、Disable Live Reload 时实刷新，代码修改保存后会就刷新

5、show Perf Monitor 打开FPS监控器

6、show Inspector 用于查看页面结构及属性
</code></pre><p>XCode装证书<br><a href="http://www.cocoachina.com/ios/20160711/17004.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160711/17004.html</a></p>
<p>| 相关文章<br>| <a href="https://github.com/jondot/awesome-react-native#videos" target="_blank" rel="noopener">https://github.com/jondot/awesome-react-native#videos</a><br>| <a href="http://reactnative.cn/docs/0.44/getting-started.html" target="_blank" rel="noopener">http://reactnative.cn/docs/0.44/getting-started.html</a><br>| <a href="http://www.devio.org/" target="_blank" rel="noopener">http://www.devio.org/</a><br>| <a href="https://github.com/crazycodeboy/RNStudyNotes/" target="_blank" rel="noopener">https://github.com/crazycodeboy/RNStudyNotes/</a><br>| <a href="http://blog.csdn.net/quanqinyang/article/details/52215652" target="_blank" rel="noopener">http://blog.csdn.net/quanqinyang/article/details/52215652</a>   调试方法<br>| <a href="http://lib.csdn.net/base/reactnative/structure" target="_blank" rel="noopener">http://lib.csdn.net/base/reactnative/structure</a><br>| <a href="http://www.jianshu.com/p/5b185df2d11a" target="_blank" rel="noopener">http://www.jianshu.com/p/5b185df2d11a</a><br>| <a href="http://www.lcode.org/react-native/" target="_blank" rel="noopener">http://www.lcode.org/react-native/</a><br>| <a href="http://blog.csdn.net/column/details/reactnative2016.html?&amp;page=3" target="_blank" rel="noopener">http://blog.csdn.net/column/details/reactnative2016.html?&amp;page=3</a><br>| <a href="http://lib.csdn.net/article/reactnative/63268" target="_blank" rel="noopener">http://lib.csdn.net/article/reactnative/63268</a>   打包到真机<br>|<br>| 示例<br>| <a href="https://github.com/react-native-community" target="_blank" rel="noopener">https://github.com/react-native-community</a><br>| <a href="https://github.com/ljunb/react-native-iShiWuPai" target="_blank" rel="noopener">https://github.com/ljunb/react-native-iShiWuPai</a>       示例<br>| <a href="https://github.com/sunnylqm" target="_blank" rel="noopener">https://github.com/sunnylqm</a><br>| <a href="https://github.com/DoctorQ/react-native-helloworld" target="_blank" rel="noopener">https://github.com/DoctorQ/react-native-helloworld</a><br>|<br>| <a href="http://blog.csdn.net/liu__520/article/category/6460088" target="_blank" rel="noopener">http://blog.csdn.net/liu__520/article/category/6460088</a><br>| <a href="http://www.devio.org/tags/#React" target="_blank" rel="noopener">http://www.devio.org/tags/#React</a> Native<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-数据库/">EggJS-数据库</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-数据库/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><pre><code>一、安装配置

    $ npm i --save egg-mysql

    // config/plugin.js  开启插件
    exports.mysql = {
        enable: true,
        package: &apos;egg-mysql&apos;,
    };
</code></pre><h4 id="egg-monogoose"><a href="#egg-monogoose" class="headerlink" title="egg-monogoose"></a>egg-monogoose</h4><pre><code>一、安装配置

    $ npm i egg-mongoose --save

    // {app_root}/config/plugin.js
    exports.mongoose = {
        enable: true,
        package: &apos;egg-mongoose&apos;,
    };

    // {app_root}/config/config.default.js
    module.exports = {
        mongoose: {
            url: &apos;mongodb://127.0.0.1:27017/ibg_node_core&apos;,
            options: {
                db: { native_parser: true },
                server: { poolSize: 5 },
                user: &apos;core&apos;,
                pass: &apos;we123&apos;,
            },
        },
    }


    // 多个mongos配置
    // {app_root}/config/config.default.js
    exports.mongoose = {
        url: &apos;mongodb://mongosA:27501,mongosB:27501&apos;,
        options: {}
    };


    // log
    module.exports = {
        logger: {
            dir: &apos;/home/admin/logs/demoapp&apos;,        // logger文件的目录
            level: &apos;DEBUG&apos;,                         // 开deubg模式
        },
    };


二、定义Schema

    // app/modle/reportWarningConfig.js

    module.exports = app =&gt; {
        const mongoose = app.mongoose;
        const ReportWarningConfigSchema = new mongoose.Schema({
                actionCode: { type: String, unique: true, trim: true }, // 动作编码
                interval: { type: Number, default: 1800 },  // 扫描间隔时间，单位：秒 默认 30分钟
                emailConfig: { // 发送邮件条件
                    appKey: { type: String, default: &apos;&apos;, trim: true },
                    appSecret: { type: String, default: &apos;&apos;, trim: true },
                    recipient: { type: [String] },  // 收件人
                },
                lastExecutedTime: { type: Date, default: Date.now },   // 最近执行时间
            }, 
            {
                timestamps: true,               // 设置timestamps，多加两个字段createdTime、updatedTime，来记录插入时间和更新时间
                collection: &apos;report_warning_config&apos;,
            }
        );

        return mongoose.model(&apos;ReportWarningConfig&apos;, ReportWarningConfigSchema);
    };


三、常用语句

    1、await app.model.login.find(条件): 返回的是一组数据， []

    2、await app.model.login.findOne(条件): 只返回一条数据, 如果没有匹配的返回null，

    3、await app.model.login.update(条件, 要更新的文档, 回调方法): 更新数据

    4、let loginTask = new app.model.login({ username: &apos;siguang&apos;, password: &apos;ssssss&apos;});     
       let doc = await loginTask.save();        // 插入数据 

    5、exec(callback): 在查询、更新后会执行一个回调函数来查看是否成功执行

    6、save(function(err, kitten){  }): 存储


四、Example

    1、查询

        async queryMonitorTask(){
            let monitorTaskList = await app.model.ReportWarningConfig.find();          // app.model.ReportWarningConfig 来指定用哪个文档
            return app.renderBody({
                statusType: app.statusType.success,
                data: {
                    list: monitorTaskList
                }
            });
        }


    2、更新

        更新需要先将文档查回来后，在修改某一个字段，如果一直更新会覆盖

        async updateMonitorTask(params){
            let response;
            let condition = {_id: params.id};
            let doc = await app.model.ReportWarningConfig.findOne(condition);       // 通过id来取到当前数据

            if(doc){
                doc.interval = params.interval;
                doc.emailConfig.recipient = params.emailRecipient;
                doc.smsConfig.recipient = params.smsRecipient;

                await doc.save();
                response = app.renderBody({
                    statusType: error,
                    error: error,
                });
            }
            else{
                response = app.renderBody({
                    statusType: app.statusType.error,
                    error: doc,
                });
            }

            return response;
        }


    3、插入数据

        插入数据将使用save()

         async insertMonitorTask(){
            const {ctx, app, service} = this;
            const {actionCode, interval, emailRecipient, smsRecipient} = ctx.request.body;

            // 将要插入的数据加到model中
            let monitorTask = new app.model.ReportWarningConfig({   // 注意这里使用new 
                actionCode,
                interval,
                emailConfig: {
                    recipient: emailRecipient
                },
                smsConfig: {
                    recipient: smsRecipient
                }
            })

            // 使用save()来插入
            let doc = await monitorTask.save();

            let response = app.renderBody({
                statusType: app.statusType.success,
                data: doc._id
            });
            ctx.body = response;
        }
</code></pre><h4 id="mongoose-积累"><a href="#mongoose-积累" class="headerlink" title="mongoose 积累"></a>mongoose 积累</h4><pre><code>一、查询出来的数据不能修改

    async getNewsContent(params){
        let doc = await app.model.News.findOne({_id: params.id});

        // 不能直接修改doc的对象，需要通过toObject()方法来转成对象的形势
        let newDoc = doc.toObject();
        newDoc.createdAt = app.dateFormat(new Date(newDoc.createdAt).getTime(), &apos;yyyy-MM-dd hh:mm:ss&apos;)
        newDoc.updatedAt = app.dateFormat(new Date(newDoc.updatedAt).getTime(), &apos;yyyy-MM-dd hh:mm:ss&apos;)
        console.log(`ResponseAAA ----- ${JSON.stringify(newDoc)}`)

        return {
            data: newDoc,
            message: &apos;获取成功&apos;,
            status: 0
        }
    }
</code></pre><p>unique</p>
<blockquote>
<p>参考资料<br><a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-问题积累/">EggJS框架-问题积累</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-问题积累/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="数据库需要指定表"><a href="#数据库需要指定表" class="headerlink" title="数据库需要指定表"></a>数据库需要指定表</h4><pre><code>module.exports = app =&gt; {
    const mongoose = app.mongoose;
    const UserSchema = new mongoose.Schema({
        username: { type: String },
        passworrd: { type: String }
    }, {collection: &apos;user&apos;});

    return mongoose.model(&apos;User&apos;, UserSchema);
}
</code></pre><h4 id="不支持ES6的import"><a href="#不支持ES6的import" class="headerlink" title="不支持ES6的import"></a>不支持ES6的import</h4><pre><code>module.exports = app =&gt; {}      // egg使用ES5的导出所以不支持 import
</code></pre><p>1、this.get(‘user-agent’)  controller中通过this.get()获取请求头的信息</p>
<p>bodyParser  中间件，egg内置，用来处里post</p>
<p>加入全局方法:<br>module.exports = {<br>  generateUuid() {<br>    const uuid = uuidV1();<br>    return uuid.replace(/-/g, ‘’).toUpperCase();<br>  },<br>};</p>
<blockquote>
<p>参考资料<br><a href="http://koa.bootcss.com/" target="_blank" rel="noopener">http://koa.bootcss.com/</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/MySQL/">MySQL</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/MySQL/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/数据库/">数据库</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>知识索引</p>
<p>数据类型: 字符型、整型、浮点型、日期时间型<br>操作符: 算术运算符、比较运算符、逻辑运算符、位运算符<br>属性: 自动编号<br>约束: 主键、外键、表关连、索引<br>库操作: 创建库、修改库、删除库、<br>表操作: 创建表、删除表、查看表结构、查看库中所有表<br>列操作: 添加列、删除列、修改列<br>记录操作: 插入记录、更新记录（单表、多表更新）、删除记录、查询记录（多列查询、分组、指定查询范围、使用别名）<br>子查询语句、例约束、<br>运算符与函数: 字符函数、数值运算符、比较运算符、日期时间函数、信息函数、聚合函数、加密函数、自定义函数<br>存储过程: 创建（参数:IN、OUT、INOUT）、调用<br>其它概念: 存储引擎、并发控制(锁、锁颗粒)、事务、</p>
</blockquote>
<h3 id="一、MySQL基础"><a href="#一、MySQL基础" class="headerlink" title="一、MySQL基础"></a>一、MySQL基础</h3><pre><code>1、MySQL介绍

    1）MySQL是关系型数据库

    2）安装后的有4个默认库

        1）information_schem: 

        2) performance_schema: 

        3) test: 

        4) mysql:     

    3）Mysql 端口号 3306

    4）mac下Mysql的配置文件 /usr/local/mysql-5.6.24-osx10.9-x86_64/my.cnf


2、MySQL 目录结构 

    mysql安装后的路径 /usr/local/mysql

    1）bin: 存储可执行文件

    2）data: 存储数据文件

    3）docs: 文档

    4）include: 存储包含头文件

    5）lib: 存储库文件

    6）share: 错误消息和字符集文件


3、停止和启动mysql服务

    关闭mysql服务    查看进程：ps -ef|grep mysql         杀进程和子进程：sudo kill -9 239 746

    启动mysql服务    sudo /usr/local/mysql-5.6.24-osx10.9-x86_64/bin/mysqld_safe

    系统偏好设置 -&gt; mysql   启动


4、登录、退出mysql

    1）登录

        mysql -uroot -pssssss -h127.0.0.1          

        -u 用户名    -p 密码       -P 端口号       -h 数据库地址 

        隐藏密码输入 mysql -uroot -h127.0.0.1 -p    回车后在输入密码


    2）退出: exit;


5、语法规范

    1）关键字和函数名全部大写

    2）数据库名称、表名称、字段字都小写

    3）SQL语句必须以&quot;;&quot;分号结束

        修改结束符  DELIMITER  //        以 // 为结束


6、数据库概念

    1）库: 一些关联表的集合

    2）表: 行和列组成, 行一条数据

    3）主键: 可以唯一标识不会有重复, 可以通过主键来查询数据

    4）外键: 外键可以引用主键数据，用于关联


7、安装mysql

    1）安装 homebrew      http://brew.sh/

    2）brew install mysql
</code></pre><h3 id="二、库服务命令"><a href="#二、库服务命令" class="headerlink" title="二、库服务命令"></a>二、库服务命令</h3><pre><code>1、启动和停止MySQL服务

    service stop mysql

    service start mysql

2、登录: mysql -uroot -p123456 -h127.0.0.1

3、退出: \q 、 exit、 quit
</code></pre><p>—————————– 语句 —————————–</p>
<pre><code>关键字与函数名全部大写

数据库名称表名字段名全部小写

SQL语句必须以分号结尾
</code></pre><h3 id="三、库操作语句"><a href="#三、库操作语句" class="headerlink" title="三、库操作语句"></a>三、库操作语句</h3><pre><code>1、创建数据库       CREATE DATABASE 库名;

        创建一个指定字符集的数据库         CREATE DATABASE 库名 CHARACTER SET utf8;

2、修改数据库       ALTER  DATABASE 库名 CHARACTER SET = uft-8;   // 将库编码改成utf8

3、删除数据库     DROP database 库名;

4、查看所有数据库     SHOW databases;

5、打开数据库        USE 库名;

6、查看当前所在的数据库   SELECT database();

7、查看库的编码: SHOW CREATE DATABASE 库名;
</code></pre><h3 id="四、操作表语句"><a href="#四、操作表语句" class="headerlink" title="四、操作表语句"></a>四、操作表语句</h3><pre><code>1、创建表        CREATE TABLE  表名(字段名 数据类型, 字段名 数据类型);

            CREATE TABLE  表名(字段 数据类型  primary key,  username VARCHAR(20));        // 加主键 primary key 

2、查看库中所有表  SHOW TABLES [db_name] [where expr];

3、查看表结构    SHOW COLUMNS FROM 表名;         // 与 desc 表名;   相同

4、删除表        DROP TABLE 表名;

5、ALTER 列操作: 

    1）添加列: ALTER TABLE 表名 ADD 列名 varchar(20);

    2）删除列: ALTER TABLE 表名 DROP 列名;

    3）修改列的类型信息

        ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称（这里可以用和原来列同名即可）】 BIGINT NOT NULL  COMMENT &apos;注释说明&apos;

    4）重命名列

        ALTER TABLE 【表名】 CHANGE 【列名称】【新列名称】 BIGINT NOT NULL  COMMENT &apos;注释说明&apos;

    5）重命名表

        ALTER TABLE 【表名字】 RENAME 【表新名字】

    6）删除表中主键

        Alter TABLE 【表名字】 drop primary key

    7）添加主键

        ALTER TABLE sj_resource_charges ADD CONSTRAINT PK_SJ_RESOURCE_CHARGES PRIMARY KEY (resid,resfromid)

    8）添加索引

        ALTER TABLE sj_resource_charges add index INDEX_NAME (name);

    9）添加唯一限制条件索引

        ALTER TABLE sj_resource_charges add unique emp_name2(cardnumber);

    10）删除索引

        ALTER TABLE [表名] index emp_name;
</code></pre><h3 id="五、记录操作语句"><a href="#五、记录操作语句" class="headerlink" title="五、记录操作语句"></a>五、记录操作语句</h3><pre><code>1、插入记录     

    1) INFO 插入指定字段值:     INSERT INTO 表名(name, age) VALUES (name值, age值);

    2) SET  插入指定字段值:     INSERT 表名 SET name=&quot;sssss&quot;, age=&quot;lll&quot;;

    3）插入所有字段值:        INSERT 表名 VALUES (NULL, name值, age值)；        // 1、没有INFO  2、如果id为主键、自增涨，需要给一个默认传入NULL 或 DEFAULT

    4）INSERT ... SELECT 将查询结果写入数据表

        INSERT [INTO] 表名 FROM 列名   SELECT 

        // 将查询出restaurant表中的type进行分组内容，插入到rest_type表中的type字段中

        INSERT rest_type(type) SELECT type FROM restaurant GROUP BY type;    


2、更新数据     

    单表更新:  UPDATE 表名 SET 要更新字段名=新值, 要更新字段名=新值  WHERE  条件        // 如果省略where条件，将修改表中的所有记录

    多表更新:  

        UPDATE 表1  [JOIN | CROSS JOIN | INNER JOIN] 表2

        表连接类型，JOIN、CROSS JOIN、INNER JOIN

                   LEFT [OUTER] JOIN 左外连接

                   RIGHT [OUTER] JOIN 右外连接


3、删除记录     

    单表删除:  DELETE FROM  表名 WHERE id=2

    多表删除:  



4、查询记录    

    查询所有列: SELECT * FROM 表名;        // 查询所有列

    查询多列:   SELECT username, age, sex FROM 表名;

    条件查询:   SELECT * FROM 表名  WHERE  条件表达式(id&lt;100);        // 查询表中的id小于100的所有记录

    查询结果分组 GROUP BY: 返回一个列中所有不相同的类别

        SELECT * FROM 表名  GROUP BY  列名 [ASC | DESC];             // 分组以哪列进行返回 ASC | DESC 正、倒序

                例: SELECT * FROM users GROUP BY sex;            # 返回sex列的分组内容，结果为两类: &apos;男&apos; 和 &apos;女&apos;


    HAVING 分组条件: SELECT * FROM 表名  GROUP BY  列名  HAVING  version &lt; 100;   // 分组后进行过滤

    LIMIT 指定查询范围: SELECT * FROM 表名 LIMIT  5, 10;        // 从第5条数据开始，查找出10条数据，也就是查询出第5-15条数据

    AS 给予别名: 当名子太长可以定义一个名，输出的时候就是定义的名字

            SELECT person AS ps, username AS un FORM users;


    --------------- select 其它  ---------------

    SELECT COUNT(*) FROM 表名 WHERE (条件)         // 返回记录的总数，如果不加条件返回整个表的总记录

    SELECT AVG(price) FROM 表名;                    // AVG()来求一个字段的平均值

    SELECT ROUND(AVG(price), 2) FROM 表名;        // ROUND() 对数值进行四舍五入


小技巧:

    1、SELECT * FROM users\G;        // 加\G 以网格形势展示查询，格式化了数据方便来看


设置空值

    例 UPDATE tag SET label=&apos;折&apos; WHERE label=NULL;        // 将label列中所有空值更新成&apos;折&apos;，失效不会被

    MySQL: null值需要通过几种方式

    1、is null、is not null: UPDATE tag SET label=&apos;折&apos; WHERE label is null;

    2、ISNULL(): 与上面一样 UPDATE tag SET label=&apos;折&apos; WHERE ISNULL(label);
</code></pre><h3 id="六、子查询语句"><a href="#六、子查询语句" class="headerlink" title="六、子查询语句"></a>六、子查询语句</h3><pre><code>子查询指嵌套在查询内部，且必须始终出现在圆括号内

子查询包含关键字或条件: DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等

子查询外层查询可以是: SELECT、INSERT、UPDATE、SET、DO

1、按返回结果集分类

    http://www.cnblogs.com/herry52/p/5643986.html

    分为4种：表子查询，行子查询，列子查询和标量子查询

    1) 表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。

        示例: 获取编号小于10的男性球员的号码

        SELECT playerno FROM (SELECT playerno, sex FROM players WHERE playerno &lt; 10) AS players10 WHERE sex=&apos;M&apos;;

        分析: 

        // 查询players中playerno小于10的两个字段的记录，并起别名为player10
        SELECT playerno, sex FROM players WHERE playerno &lt; 10 AS players10;    

        // 显示playerno字段内容，条件是子表中的sex=&apos;M&apos;
        SELECT playerno FROM 查询出的内容 WHERE sex=&apos;M&apos;


    2) 行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。

        示例: players表中获取与100号球员性别相同并且居住在同一城市的球员号码。

        SELECT playerno, sex, town FROM players WHERE (sex, town) = (select sex, town FROM players where playerno = 100);


    3) 列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）

        列子查询可以使用 IN、ANY、SOME、ALL

        1、修饰的比较运算符: ANY、SOME、ALL

            如果子查询返回：Subquery returns more than 1 row   多于一行记录，使用上面运算符

            ANY和SOME是等价的意思只符合一个就可以

            ALL 需要符合全部


        2、IN、NOT IN 子查询



    4) 标量子查询：可以指定一个标量表达式的任何地方，几乎都可以使用一个标量子查询

        示例: 获取和27号球员出生在同一年的球员的号码

        SELECT playerno, name, birth_date FROM players WHERE YEAR(birth_date) = (SELECT YEAR(birth_date) FROM players WHERE playerno=100) AND playerno != 100;
</code></pre><p>—————————– 运算符与函数 —————————–</p>
<h3 id="七、字符函数"><a href="#七、字符函数" class="headerlink" title="七、字符函数"></a>七、字符函数</h3><pre><code>1、CONCAT(): 字符连接    SELECT CONCAT(&apos;user&apos;, &apos;-&apos;, &apos;name&apos;);

    // 将tag表中value和label字段的值连接，并通过AS来返回一个别列名为tagName
    SELECT CONCAT(value, &apos;_&apos;, label) AS tagName FROM tag;


2、CONCAT_WS(): 使用指定的分隔符进行字符连接

    SELECT CONCAT_WS(&apos;|&apos;, name, user, id);        以&quot;|&quot;进行分隔


3、FORMAT(): 数据格式化

    SELECT FORMAT(132.34234, 2);        // 132.34


4、LOWER(): 将字符转成小写

5、UPPER(): 将字符转成大写

6、LEFT()、RIGHT(): 获取从左、右侧字符的几位

    SELECT LEFT(&apos;what are you doing.&apos;, 7);         // what ar

7、LENGTH(): 获取字符串长度

8、LTRIM()、RTRIM()、TRIM(): 删除前空格、删除后空格、删除前后空格

9、SUBSTRING(): 字符串的截取 substring();

        SELECT SUBSTRING(&apos;what are you doing.&apos;, 3, 7);        // at are

10、RESPLACE(): 字符替换 

        SELECT REPLACE(&apos;what are you doing.&apos;, &apos; &apos;, &apos;&apos;);      // whatareyoudoing.

11、LIKE(): 模式匹配

        %: 为任意字符            _: 任意一个字符

        ESCAPE: 使用哪个字符后的百分号

        SELECT * FROM sys_user WHERE username LIKE &apos;%@renrendai.com%&apos;\G;    // sys_user表中username字段匹配出 带有@renrendai.com的字符

        SELECT * FROM sys_user WHERE username LIKE &apos;%renren%%&apos; ESCAPE &apos;renren&apos;\G;    // 匹配出 renren%
</code></pre><h3 id="八、数值运算符"><a href="#八、数值运算符" class="headerlink" title="八、数值运算符"></a>八、数值运算符</h3><pre><code>1、CEIL(): 向上取整    SELECT CEIL(4.9);        // 5     SELECT CEIL(log) FROM office;

2、FLOOR(): 向下取整    SELECT FLOOR(4.2);        // 4

3、DIV(): 整数除法     SELECT 20 DIV 3;        // 6

4、MOD(): 取模

5、POWER(): 幂运算

6、ROUND(): 四舍五入        SELECT ROUND(2.3464, 2);    // 2.35

7、TEUNCATE(): 数字截取
</code></pre><h3 id="九、比较运算符"><a href="#九、比较运算符" class="headerlink" title="九、比较运算符"></a>九、比较运算符</h3><pre><code>1、[NOT] BETWEEN ... AND ... :  在不在一个范围内

        // 查找出fruit表中fruit_price字段（价格）10元至30无之间的数据
        SELECT fruit_id, fruit_desc, fruit_price FROM  fruit WHERE fruit_price BETWEEN 10 AND 30;


2、[NOT] IN(): 在不在几个值的内

        SELECT 10 IN (5, 20, 40);        // 返回0

        SELECT 10 IN (2, 10, 30, 49);    // 返回1


3、IS [NOT] NULL: 返回为空， IS NOT NULL 返回不为空

    // 返回 fruit_dim_three 内容为空的值
    SELECT fruit_product_name, fruit_price,fruit_dim_three FROM fruit WHERE fruit_dim_three IS NULL;  
</code></pre><h3 id="十、函数"><a href="#十、函数" class="headerlink" title="十、函数"></a>十、函数</h3><pre><code>1、日期时间函数

    1）NOW(): 返回一个当前日期和时间

    2）CURDATE(): 当前日期

    3）CURTIME(): 当前时间

    4）DATE_ADD(): 在一个时间内添加多少时间

            SELECT DATE_ADD(&apos;2016-12-12&apos;, INTERVAL 365 DAY);        // 返回 2017-12-12 , -365就是减365天

    5）DATEDIFF(date1, date2): 两个日期的差值

            SELECT DATEDIFF(&apos;2018-12-12&apos;, NOW());        // 2018-12-12与今天相差多少天

    6）DATE_FORMAT(): 日期格式化

            SELECT DATE_FORMAT(&apos;2016-12-10&apos;, &apos;%Y/%m/%d&apos;);        // 转换成 2016/12/10 

            SELECT DATE_FORMAT(NOW(), &apos;%Y年-%m月-%d日 %H时:%i分:%s秒&apos;);


2、信息函数

    1）CONNECTION_ID(): 连接的ID（线程的ID）

    2）DATABASE(): 查看当前数据库     SELECT DATABASE();

    3）LAST_INSERT_ID(): 最后插入记录

    4）USER(): 当前用户

    5）VERSION(): 版本信息


3、聚合函数

    1）AVG(): 平均值的计算

            SELECT AVG(fruit_price) FROM fruit;        // 将水果的价格字段平均值返回

    2）COUNT(): 返回条件的行数

            SELECT COUNT(列名) FROM 表名;        // 返回数目(NULL 不计)

            SELECT COUNT(*) FROM 表名;        // 返回所有的记录数

    3）MAX(): 最大值

    4）MIN(): 最小值

    5）SUM(): 返回和


4、加密函数

    1）MD5(): 信息摘要算法

            MD5(&apos;adf234sdf2=-a1%af123#$&apos;);        // 16f7709af2898dd3c9f116d56ea93c82

    2）PASSWORD(): 密码算法

            PASSWORD(&apos;adf234sdf2=-a1%af123#$&apos;);    // *6D3B0C079BFF7DAD315D9AF131F0868939A74A8D
</code></pre><h3 id="十一、自定义函数"><a href="#十一、自定义函数" class="headerlink" title="十一、自定义函数"></a>十一、自定义函数</h3><pre><code>1、创建自定函数:

    CREATE FUNCTION 函数名 RETURNS {STRING | INTERGER | REAL | DECIMAL} routine_body

    创建     函数      名    返回                    类型                     函数体          


    函数体: 由合法的SQL语句构成，可以是简单的SELECT 或 INSERT语句

    示例1 无参数:

        // 创建一个返回当前格式化的日期
        CREATE FUNCTION newDate() RETURNS VARCHAR(30) 

            RETURN  DATE_FORMAT(NOW(), &apos;%Y年-%m月-%d日 %H时:%i分:%s秒&apos;);

        // 调用
        SELECT newDate();        // 2016年-12月-12日 11时:31分:55秒


    示例2 有参数:

        CREATE FUNCTION fun2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) 

            RETURNS FLOAT(10,2) UNSIGNED  

            RETURN (num1+num2)/2;


        SELECT fun2(20, 30);        // 25.00


    示例3 返回语句

        # 需要修改结束符 “;”

        // 定义一个向users表中的username字段插入值

        DELIMITER //;

        CREATE FUNCTION addUser(username VARCHAR(20))

            RETURNS INT UNSIGNED

            BEGIN

            INSERT users(username) VALUES(username);

            RETURN LAST_INSERT_ID();

            END//


2、删除自定义函数: DROP FUNCTION 函数名;



ROW_COUNT(): 用于返回被 update, insert, delete 实际修改的行数

FOUND_ROWS(): 返回上一条执行语句，影响的行数
</code></pre><p>—————————– 数据类型 —————————–</p>
<h3 id="十二、数据类型："><a href="#十二、数据类型：" class="headerlink" title="十二、数据类型："></a>十二、数据类型：</h3><pre><code>1、int: 整型

2、浮点

    1）float: 单精度

    2）double: 双精度浮点

3、日期

    1）datetime: 日期

    2）timestamp: 日期

    3) year、month、date

4、字符型

    1）char: 定长字符类型

    2) varchar: 不定长字符

    3) tinytext:

    4) text: 

    5) medinmtext:

    6) longtext:

    7) enum: 

    8) set: 
</code></pre><h3 id="十三、操作符"><a href="#十三、操作符" class="headerlink" title="十三、操作符"></a>十三、操作符</h3><pre><code>1、算术运算符

    +     加   SET var1=2+2;       4
    -     减   SET var2=3-2;       1
    *     乘   SET var3=3*2;       6
    /     除   SET var4=10/3;      3.3333
    DIV   整除 SET var5=10 DIV 3;  3
    %     取模 SET var6=10%3 ;     1


2、比较运算符

    &gt;            大于 1&gt;2 False
    &lt;            小于 2&lt;1 False
    &lt;=           小于等于 2&lt;=2 True
    &gt;=           大于等于 3&gt;=2 True
    BETWEEN      在两值之间 5 BETWEEN 1 AND 10 True
    NOT BETWEEN  不在两值之间 5 NOT BETWEEN 1 AND 10 False
    IN           在集合中 5 IN (1,2,3,4) False
    NOT IN       不在集合中 5 NOT IN (1,2,3,4) True
    =            等于 2=3 False
    &lt;&gt;, !=       不等于 2&lt;&gt;3 False
    &lt;=&gt;          严格比较两个NULL值是否相等 NULL&lt;=&gt;NULL True
    LIKE         简单模式匹配 &quot;Guy Harrison&quot; LIKE &quot;Guy%&quot; True
    REGEXP       正则式匹配 &quot;Guy Harrison&quot; REGEXP &quot;[Gg]reg&quot; False
    IS NULL      为空 0 IS NULL False
    IS NOT NULL  不为空 0 IS NOT NULL True


3、逻辑运算符

    与(AND) &amp;&amp;       或（OR）||        非（NOT）！


4、位运算符

    |   位或
    &amp;   位与
    &lt;&lt;  左移位
    &gt;&gt;  右移位
    ~   位非(单目运算，按位取反)
</code></pre><h3 id="十四、属性"><a href="#十四、属性" class="headerlink" title="十四、属性"></a>十四、属性</h3><pre><code>1、AUTO_INCREMENT: 自动编号，必须与主键组合使用，起始值为1，每次增加1

2、primary key         主键约束 每张表只能存在一个主键，主键保证记录的唯一性, 主键自动为 NOT NULL

3、foreign            外键约束 保持数据的一致性, 实现一对一或一对多的关系约束
</code></pre><h3 id="十五、约束"><a href="#十五、约束" class="headerlink" title="十五、约束"></a>十五、约束</h3><pre><code>2、PRIMARY KEY（主键约束）: 每张表只能存在一个主键，保证记录的唯一性，主键自动为NOT NULL

3、UNIQUE KEY（唯一约束）: 可以保证记录的唯一性，字段可以为空值（NULL），每张数据表可以存在多个唯一约束

4、DEFAULT（默认约束）: 默认值，插入记录时没有赋值，自动赋予默认值

    创建表时的性别字段，有三个值1，2，3 =&gt; 男，女，不男不女  如果insert插入未写入值，默认加入3
    sex ENUM(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;) DEFAULT &apos;3&apos;        

5、FOREIGN KEY（外键约束）: 保证数据一致性和完整性，实现一对一 或 一对多关系

5、NOT NULL（非空约束） 不能为空，必须写值要不报错

6、NULL 可以为空


# 约束分为表级约束 和 列级约束

    约束只针对一个字段来约束，叫列级约束

    约束针对两个或以上字段来约束，叫表级约束


# 外键约束的要求

    1、父表和子表必须使用相同的存储引擎，禁止使用临时表

    2、数据表存储只能为InnoDB

    3、外键列和参照必须有相似的数据类型，



CURRENT_TIMESTAMP
</code></pre><p>—————————– 存储过程 —————————–</p>
<h3 id="十六、MySQL命令执行过程"><a href="#十六、MySQL命令执行过程" class="headerlink" title="十六、MySQL命令执行过程"></a>十六、MySQL命令执行过程</h3><pre><code>SQL命令 -&gt; MySQL引擎 -&gt; 语法正确 -&gt; 可识别命令 -&gt; 执行结果 -&gt; 返回客户端

需要这一套流程才能跑完，如果使用存储过程会节省中间的一些步骤，可以节省性能.
</code></pre><h3 id="十七、什么是存储过程"><a href="#十七、什么是存储过程" class="headerlink" title="十七、什么是存储过程"></a>十七、什么是存储过程</h3><pre><code>存储过程: 是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理

存储过程存储在数据库内，可以通过应用程序调用和输出

存储过程的优点:

    1、增强SQL语句的功能和灵活性

    2、实现较快的执行速度

        存储过程是不需要语法解析等操作，预编译，所以速度上要快

    3、减少网络流量

        后端应用程序与数据库通信，需要传SQL语句，如果有存储过程就直接告诉执行哪个存储过程就可以了
</code></pre><h3 id="十八、存储过程的使用"><a href="#十八、存储过程的使用" class="headerlink" title="十八、存储过程的使用"></a>十八、存储过程的使用</h3><pre><code>1、创建存储过程

    CREATE 

    [DEFINER = {user | CURRENT_USER}]         // 如果省略就是默认走的当前登录客户端的用户

    PROCEDURE 存储过程名(参数)


    参数：

        1) IN: 表示该参数值必须在调用存储过程时指定，这个值不能返回只能进不能出

        2）OUT: 表示该参数值可以审美观点存储过程改变，并且可以返回，

        3）INOUT: 表示该参数调用时指定，并且可以被改变和返回


    过程体

        1）由合法的SQL语句构成

        2）可以是做任意的SQL语句

        3）复合结构则使用BEGIN...END语句，与函数相同，如果执行两个或两个以上语句需要使用BEGIN...END

        4）复合结构可以包含声明、循环、控制结构



    示例1: 无参数

        // 定义一个返回客户端信息的存储过程
        CREATE PROCEDURE sp1() SELEECT VERSION();

        // 调用存储过程
        CALL sp1();                // 如果没有参数可以去掉小括号  CALL sp1;


    示例2: 带参数 IN

        DELIMITER //

        CREATE PROCEDURE removeUserId(IN uid INT UNSIGNED)

        BEGIN

        DELETE FROM users WHERE id=uid;                    // 通过传入的id来删除users表中的一条记录

        END //

        // 调用存储过程
        CALL removeUserId(5);    


    示例3: OUT

        DELIMITER ;;

        CREATE PROCEDURE removeIdAndReturnUserCount(IN pid INT UNSIGNED, OUT userCount INT UNSIGNED)         // OUT 定义输出的变量

        BEGIN 

        DELETE FROM users WHERE id = pid;                      // 删除指定的记录

        SELECT count(id) FROM users INTO userCount;         // 查询id字段所有的记录数，并返回userCount变量中，注意结果返回使用INTO

        END;;


        // 调用
        CALL removeIdAndReturnUserCount(3, @count);        // 执行删除并返回记录数，存储在count变量中

        SELECT @count;                // 显示变量的值



2、删除存储过程: DROP PROCEDURE 存储过程名;
</code></pre><p>—————————– 概念 —————————–</p>
<h3 id="十九、常用概念"><a href="#十九、常用概念" class="headerlink" title="十九、常用概念"></a>十九、常用概念</h3><pre><code>1、什么是存储引擎

    MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。

    每种存储引擎使用不同的存储机制、索引技术、锁定水平，最终提供广泛且不同的功能。


2、并发控制

    当多个连接对记录进行修改时保证数据的一致性和完整性

        例: 一个用户删除id=22的操作，另一个用户要读取id=22的操作，这样读取id=22就会报错

            解决这个问题就是使用并发，当迸发读或写时系统会使用锁系统，来控制读写


    1、锁

        共享锁（读锁）: 在同一时间段内，多个用户读取同一个资源，读取过程中数据不会发生任何变化.

        排他锁（写锁）: 在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其它的读锁或写锁操作.


    2、锁颗粒

        表锁: 开锁最小的锁策略

        行锁: 开锁最大的锁策略


3、事务

    事务的主要作用就是保证数据的完整性



4、外键

    保证数据一致性的策略



5、索引

    是对数据表中一列或多列进行排序的一种结构
</code></pre><h3 id="二十、Navicat工具"><a href="#二十、Navicat工具" class="headerlink" title="二十、Navicat工具"></a>二十、Navicat工具</h3><pre><code>1、导入、导出表数据

    1）导出，选择要导出的表右键 Dump SQL File 

    2）导入，选中Table右键 import Wizard...
</code></pre><blockquote>
<p>使用工具</p>
<p>Navicat</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-框架/">EggJS基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-框架/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| this.ctx - 当前请求的上下文 Content对象的实例ctx，Request、Response<br>| this.app - 当前应用对象Application 对象的实例<br>| this.service - 定义的Service，等价于 this.ctx.service<br>| this.config - 应用配置<br>| this.logger - 日志对象 方法debug, info, warn, error<br>| app.cache - 缓存</p>
<h4 id="Egg介绍、安装"><a href="#Egg介绍、安装" class="headerlink" title="Egg介绍、安装"></a>Egg介绍、安装</h4><pre><code>Egg.js属于MVC类型的NodeJS框架

一、下载脚手架:

    $ npm i egg-init -g
    $ egg-init egg-example --type=simple
    $ cd egg-example
    $ npm i

二、启动项目:

    $ npm run dev
    $ open localhost:7001
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code>config
    |- config.default.js        // 默认配置文件, 所有环境都会加载这个配置文件, 一般用于开发环境的默认配置文件
    |- config.test.js           // 开发环境配置
    |- config.prod.js           // 生产环境配置
    |- config.unittest.js
    |- plugin.js                // 控制插件
    `- config.local.js

一、引入插件

    module.exports = {
        mysql: {
            enable: true,           // 开启或关闭插件
            package: &apos;egg-mysql&apos;    // package为一个npm模块，package.json中的dependencies中，框架会在node_modules目录中找到这个插件入口
        },
    };

    也可以指定path 来替代 package
    const path = require(&apos;path&apos;);
    module.exports = {
        mysql: {
            enable: true,
            path: path.join(__dirname, &apos;../app/plugin/egg-mysql&apos;),
        },
    };
</code></pre><h4 id="Router-路由"><a href="#Router-路由" class="headerlink" title="Router 路由"></a>Router 路由</h4><pre><code>用来接收请求URL，在交给controller处理

app.get(路由名，路由URL路由，middleware(可以配置多个)，controller)

一、controller的两个写法

    # router
    module.exports = app =&gt; {
        // 1、controller目录的home.js进行处理
        app.get(&apos;/&apos;, &apos;home&apos;);             

        // 2、payTool目录、billquery.js文件、getLoanUser方法
        app.post(&apos;/getLoanUser&apos;, &apos;payTool.billquery.getLoanUser&apos;);
    };

    # controller/home.js
    module.exports = function* () {
        this.body = &apos;Hello World&apos;;  // 响应给客户端
    };

    # controller/payTool/billquery.js
    module.exports = app =&gt; {
        class BillqueryController extends app.Controller {
            async getLoanUser(){
                const { ctx, app, service } = this;
                const response = await service.payTool.billquery.getRepayPlan(ctx.request.body);
                ctx.body = response;
            }
        }
    }


二、路由中间件 - 在访问路由之前通过中间件来对路由进行一些处理

    app.get(&apos;router-name&apos;, &apos;middleware1&apos;, &apos;middleware2&apos;, &apos;controlll&apos;);

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

    2、路由中调用

        注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

        // 引用中间件
        const checkAuth = app.middleware.checkAuth();

        // 不需要验证
        app.get(&apos;/&apos;, &apos;home.index&apos;);
        app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

        // 需要验证是否登录的
        app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表


三、参数获取

    1、获取url参数 ctx.query

        http://127.0.0.1:7001/search?name=egg  取出name的值

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, app.controller.search);
        };

        // app/controller/search.js
        module.exports = function* (ctx) {
            tx.body = `search: ${this.query.name}`;
        };


    2、路由参数 ctx.params

        http://127.0.0.1:7001/user/123/xiaoming   取出 123、xiaoming

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/user/:id/:name&apos;, app.controller.user.info);
        };

        // app/controller/user.js
        exports.info = function* (ctx) {
            ctx.body = `user: ${ctx.params.id}, ${ctx.params.name}`;
        };


四、重定向 - 当路由不存在时会走一个默认的路由

    1、内部重定向

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;index&apos;, &apos;/home/index&apos;, &apos;home.index&apos;);
            app.redirect(&apos;/&apos;, &apos;/home/index&apos;, 302);
        };

    2、外部重定义 controller中来执行路由的跳转 redirect

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, &apos;search&apos;);
        };

        // app/controller/search.js
        module.exports = function* () {
            const type = this.query.type;
            const q = this.query.q || &apos;nodejs&apos;;

            // 这里跳转
            ctx.redirect(&apos;/admin/home&apos;);
        };

五、多路由映射 - 将路由分类并用一个路由主文件加载其它的路由文件

    // router.js 通过一个主文件将两个路由加载进来
    module.exports = app =&gt; {
        require(&apos;./router/news&apos;)(app);
        require(&apos;./router/admin&apos;)(app);
    };

    // router/news.js
    module.exports = app =&gt; {
        app.get(&apos;/news/list&apos;, app.controller.news.list);
        app.get(&apos;/news/detail&apos;, app.controller.news.detail);
    };

    // router/admin.js
    module.exports = app =&gt; {
        app.get(&apos;/admin/user&apos;, app.controller.admin.user);
        app.get(&apos;/admin/log&apos;, app.controller.admin.log);
    };

六、路由规则

    // app/router.js
    module.exports = app =&gt; {
        app.get(/^\/package\/([\w-.]+\/[\w-.]+)$/, app.controller.package.detail);
    };
</code></pre><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><pre><code>controller继承于app.controller, 负责解析用户输入，处理后返回相应的结果, 框架推荐Controller层主要对用户请求参数进行处理（校验、转换），然后用service处理业务结果并返回

用户HTTP请求（路由处理） &lt;=&gt; 校验组装（controller处理）&lt;=&gt; 业务处理（service）

一、Controller的两种写法

    1、函数写法

        // app/controller/posts.js
        exports.index = function* () {};
        exports.new = function* () {};
        exports.create = function* () {};

        // router 调用
        app.get(&apos;/index&apos;, &apos;posts/index&apos;);
        app.get(&apos;/new&apos;, &apos;posts/new&apos;);
        app.get(&apos;/create&apos;, &apos;posts/create&apos;);


    2、类写法

        // app/controller/post.js
        module.exports = app =&gt; {
            class PostController extends app.Controller {       // 定义一个PostController的类，继承了app.Controller
                * create() {
                    const { ctx, service } = this;
                    const createRule = {
                        title: { type: &apos;string&apos; },
                        content: { type: &apos;string&apos; },
                    };
                    // 校验参数
                    ctx.validate(createRule);
                    // 组装参数
                    const author = ctx.session.userId;
                    const req = Object.assign(ctx.request.body, { author });
                    // 调用 Service 进行业务处理
                    const res = yield service.post.create(req);
                    // 设置响应内容和响应状态码
                    ctx.body = { id: res.id };
                    ctx.status = 201;
                }
            }
            return PostController;
        }

        // router 调用   app/router.js
        module.exports = app =&gt; {
            app.post(&apos;createPost&apos;, &apos;/api/posts&apos;, &apos;post.create&apos;);
        }


二、app.Controller下this上挂载的几个属性

    1、this.ctx: 当前请求的上下文Context对象的实例

    2、this.app: Application对象的实例，可以取到框架的全局对象和方法

    3、this.service: 取到service下的方法

    4、this.config: 获取或添加修改config的配置

    5、this.logger: 日志打印


三、获取请求

    ctx.method: 请求方法

    ctx.path: 请求路径

    ctx.host: 请求IP

    1、query 获取GET请求中传递参数

        url: /posts?category=egg&amp;language=node  通过context.query拿到url的参数  

        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;

                const queryName = ctx.query;    // {category: &apos;egg&apos;, language: &apos;node&apos;}
                ctx.body = queryName;
            }
        }

    2、queries 能取到重复的参数key

        // posts?category=egg&amp;id=1&amp;id=2&amp;id=3 参数解析成对象,id有多个

        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;

                const queryName = ctx.queries;    // {category: &apos;egg&apos;, id: [1,2,3]}
                ctx.body = queryName;
            }
        }

    3、params 参数   

        路由: app.get(&apos;/projects/:projectId/app/:appId&apos;, &apos;app.listApp&apos;);

        // 请求: GET /projects/1/app/2
        class QueryController extends app.Controller{
            async getParams(app){
                const { ctx, app, service } = this;

                const params = {
                    id: ctx.params.projectId,
                    appid: ctx.params.appId
                };
                ctx.body = queryName;
            }
        }

    4、body 获取post传的数据

        框架内置bodyParser中间件，挂载到 context.request.body上，来取post的内容

        ctx.request.body  来获取post传过来的参数 {&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;1111&quot;}

        exports.listPosts = function* (ctx) {
            assert.equal(ctx.request.body.title, &apos;controller&apos;);
            assert.equal(ctx.request.body.content, &apos;what is controller&apos;);
        };

        &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;&quot; /&gt;
        &lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot; /&gt;

        config.default.js设置， 默认body最大长度为100kb
        bodyParser: {
            jsonLimit: &apos;1mb&apos;,
            formLimit: &apos;1mb&apos;,
        }

    5、获取上传文件

        浏览器上都是通过 Multipart/form-data 格式发送文件的，框架通过内置 Multipart 插件来支持获取用户上传的文件

        &lt;form method=&quot;POST&quot; action=&quot;/upload?_csrf={{ ctx.csrf | safe }}&quot; enctype=&quot;multipart/form-data&quot;&gt;
            title: &lt;input name=&quot;title&quot; /&gt;
            file: &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;
            &lt;button type=&quot;submit&quot;&gt;上传&lt;/button&gt;
        &lt;/form&gt;

        const path = require(&apos;path&apos;);
        const sendToWormhole = require(&apos;stream-wormhole&apos;);

        module.exports = function* (ctx) {
            const stream = yield ctx.getFileStream();
            const name = &apos;egg-multipart-test/&apos; + path.basename(stream.filename);
            // 文件处理，上传到云存储等等
            let result;
            try {
                result = yield ctx.oss.put(name, stream);
            } catch (err) {
                // 必须将上传的文件流消费掉，要不然浏览器响应会卡死
                yield sendToWormhole(stream);
                throw err;
            }
            ctx.body = {
                url: result.url,
                // 所有表单字段都能通过 `stream.fields` 获取到
                fields: stream.fields,
            };
        };


        在config/config.default.js 中配置来新增支持的文件扩展名，或者重写整个白名单

        新增支持的文件扩展名
        module.exports = {
            multipart: {
                fileExtensions: [ &apos;.apk&apos; ], // 增加对 .apk 扩展名的支持
            },
        };

        覆盖整个白名单
        module.exports = {
            multipart: {
                whitelist: [ &apos;.png&apos; ], // 覆盖整个白名单，只允许上传 &apos;.png&apos; 格式
            },
        };

    6、发送HTTP响应

        1）设置status

            exports.create = function* (ctx) {
                // 设置状态码为 201
                ctx.status = 201;
            };

        2）设置body 响应给请求方

            exports.show = function* (ctx) {
                ctx.body = {
                    name: &apos;egg&apos;,
                    category: &apos;framework&apos;,
                    language: &apos;Node.js&apos;,
                };
            };
            exports.page = function* (ctx) {
                ctx.body = &apos;&lt;html&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/html&gt;&apos;;
            };
</code></pre><h4 id="ctx-header-头"><a href="#ctx-header-头" class="headerlink" title="ctx.header 头"></a>ctx.header 头</h4><pre><code>获取整个 header 对象的方法: context.headers、context.header、context.request.headers、context.request.header

get()方法获取请求 header 中的一个字段的值、字段不存在返回null:  context.get(name)、context.request.get(name)

一、获取header

    1、ctx.header 取出头信息

        async from(ctx){
            console.log(ctx.header);
        }

        返回结果
        { 
            host: &apos;127.0.0.1:7001&apos;,
            connection: &apos;keep-alive&apos;,
            &apos;content-length&apos;: &apos;21&apos;,
            &apos;postman-token&apos;: &apos;a7e094b5-21ce-eb94-e403-3d517c832f30&apos;,
            &apos;cache-control&apos;: &apos;no-cache&apos;,
            origin: &apos;chrome-extension://aicmkgpgakddgnaphhhpliifpcfhicfo&apos;,
            &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;,
            &apos;content-type&apos;: &apos;application/json&apos;,
            accept: &apos;*/*&apos;,
            &apos;accept-encoding&apos;: &apos;gzip, deflate, br&apos;,
            &apos;accept-language&apos;: &apos;zh-CN,zh;q=0.8,en;q=0.6&apos;,
            cookie: &apos;csrfToken=RNHUjeOf0Zsl9jNl2f5BhreT&apos; 
        }

    2、ctx.protocol 协议

    3、ctx.ips 返回ip 一个数组

    4、ctx.ip 返回请求方的ip

    5)、ctx.host


二、设置header

    context.set(key, value) 方法可以设置一个响应头，context.set(headers) 设置多个 Header。

    exports.show = function* (ctx) {
        const start = Date.now();
        ctx.body = yield ctx.service.post.get();
        const used = Date.now() - start;
        // 设置一个响应头
        ctx.set(&apos;show-response-time&apos;, userd.toString());
    };
</code></pre><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><pre><code>可以通过context.cookies来获取和设置cookie值

一、cookie操作

    获取 ctx.cookies.get(&apos;count&apos;);

    设置 ctx.cookies.set(&apos;count&apos;, ++count);

    删除 ctx.cookies.set(&apos;count&apos;, null);


二、设置options

    context.cookies.set(key, value, options)

    1、maxAge: nunber - 在浏览器保存最长时间

    2、expires: date - 设置这个键值的失效时间

    3、path: string - 设置生效的URL路径

    4、domain: string - 设置生效的域名

    5、httpOnly: boolean - 设置是否可以被js访问

    6、secure: boolean - 设置键值只在HTTPS连接上传输

    7、overwrite: boolean - 设置key相当键值如何处理，true为后设置的覆盖前面设置的，false发送两个

    8、sign: boolean - 对cookie是否进行签名，true防止前端对这个值进行篡改

    9、encrypt: boolean - 对cookie进行加密

    ctx.cookies.set(key, value, {
        httpOnly: false,
        sign: false,
    });


三、Cookie 密钥

    config/config.default.js

    module.exports = {
        keys: &apos;key1,key2&apos;,
    };
</code></pre><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><pre><code>context.session 来访问或者修改当前用户 Session 

1、读取和设置 Session

    exports.fetchPosts = function* (ctx) {

        // 获取 Session 上的内容
        const user = ctx.session.user;
        const posts = yield ctx.service.post.fetch(userId);

        // 修改 Session 的值
        ctx.session.user = ctx.session.user ? ctx.session.user++ : 1;

        ctx.body = {
            success: true,
            posts,
        };
    };


2、删除session

    exports.deleteSession = function* (ctx) {
        ctx.session = null;
    };


3、设置 session配置

    // config.default.js

    exports.session = {
        key: &apos;EGG_SESS&apos;,
        maxAge: 24 * 3600 * 1000, // 1 天
        httpOnly: true,
        encrypt: true,
    };
</code></pre><h4 id="service-处理业务逻辑"><a href="#service-处理业务逻辑" class="headerlink" title="service 处理业务逻辑"></a>service 处理业务逻辑</h4><pre><code>service 需要继承于 app.Service，service在复杂业务场景下做业务逻辑封装的抽象层

一、service的ctx

    1、this.ctx.curl - 发起网络调用

    2、this.ctx.service.otherService - 调用service

    3、this.ctx.db - 发起数据库调用


二、Example

    // 调用服务 app/controller/user.js
    module.exports = app =&gt; {
        class User extends app.controller {
            async addUser(){
                let userData = {
                    name: &apos;siguang&apos;,
                    password: &apos;xxxxxx&apos;
                }
                let isAddUser = yield ctx.service.user.createUser(userData)
                if(setUser){
                    ctx.body = &apos;添加成功&apos;
                }
                ctx.body = isAddUser ? &apos;添加成功&apos; : &apos;添加失败&apos;;
            }
        }
    }

    // 定义一个Service app/service/user.js
    module.exports = app =&gt; {                   // 中间件支持两个参数 options中间件配置，app当前应用Application的实例
        class User extends app.Service {

            async createUser(params){
                const url = &apos;/account/blance/createUser&apos;;
                let result = await this.ctx.curl(url, {
                    method: &apos;POST&apos;,
                    dataType: &apos;json&apos;,   // 自动解析 JSON response
                    data: params,
                    timeout: 15000,     // 15 秒超时
                }

                this.ctx.logger.info(&apos;响应结果：&apos;, result.data);
                return result.data;
            }
        }
        return User;
    };
</code></pre><h4 id="中间件-Middleware"><a href="#中间件-Middleware" class="headerlink" title="中间件 Middleware"></a>中间件 Middleware</h4><pre><code>一、config.default.js 配置全局

    module.exports = {
        // 配置需要的中间件，数组顺序即为中间件的加载顺序
        middleware: [ &apos;gzip&apos; ],
        // 配置 gzip 中间件的配置
        gzip: {
            threshold: 1024, // 小于 1k 的响应体不压缩
        },
    };

    // 框架中默认的中间件
    module.exports = {
        bodyParser: {
            jsonLimit: &apos;10mb&apos;,
        },
    };


二、通用配置

    enable：控制中间件是否开启。

    match：设置只有符合某些规则的请求才会经过这个中间件。

    ignore：设置符合某些规则的请求不经过这个中间件。

    bodyParser: {
        enable: false,
        jsonLimit: &apos;10mb&apos;,
    },


三、Example: 

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

    2、路由中调用

        注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

        // 引用中间件
        const checkAuth = app.middleware.checkAuth();

        // 不需要验证
        app.get(&apos;/&apos;, &apos;home.index&apos;);
        app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

        // 需要验证是否登录的
        app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表
</code></pre><h4 id="Validate-参数校验插件"><a href="#Validate-参数校验插件" class="headerlink" title="Validate 参数校验插件"></a>Validate 参数校验插件</h4><pre><code>validate只用于post请求的参数校验，get请求取出的都是字符串

一、在config/plugin.js配置中添加

    exports.validate = {
        enable: true,
        package: &apos;egg-validate&apos;,
    };


二、Exmaple

    async refundApply() {
        const { ctx, app, service } = this;
        const paramRule = {
            partnerUserId: { type: &apos;string&apos; },
            applyUserName: { type: &apos;string&apos; },
            amount: { type: &apos;string&apos; }, 
            sourceAccount: { type: &apos;string&apos; }, 
        };

        const paramErrors = app.validator.validate(paramRule, ctx.request.body);
        if (paramErrors) {
            ctx.body = app.renderBody({
                statusType: app.statusType.paramsError,
                error: paramErrors,
            });
            return;
        }

        const response = await service.payTool.billquery.refundApply(ctx.request.body);
        ctx.body = response;
    }


三、验证规则  

    1、required - 是否当前字段必须有，required: false 可以为空

    2、allowEmpty - 允许为空

    2、int - 只能为整数

    3、number - 可以是整数和浮点数

    4、date - 日期 &apos;YYYY-MM-DD&apos;     birthoday: &apos;date&apos;

    5、dateTime - 日期 YYYY-MM-DD HH:mm:ss

    6、boolean - 是否是布尔值        working: &apos;boolean&apos;

    7、string - 是否是字符串, 字符串的四个规则:            

        allowEmpty - 允许为空字符串

        format - 使用正则来验证字符串的格式

        max - 字符串最大长度

        min - 字符串最小长度

        const rule = {
            username: { allowEmpty: true, min: 10, max: 100, format: /^\d+$/ }
        }

    8、email - 是否是email格式

    9、password - 密码验证规则 max最大、min最小、compare比较  pass: {type: password, max: 32, min: 6}

    10、url - 是否是url

    11、enum - 如果是枚举需要加一个规则

        // operateType的值必须是values数组中的一项，values必须为数组
        const paramRule = {
            operateType: { type: &apos;enum&apos;, values: [&apos;REPAYMENT&apos;, &apos;CHARGE&apos;] },        
        }
        const paramErrors = app.validator.validate(paramRule, ctx.request.body);

    12、object - 如果是对象，需要加一个规则 

    13、array - 如果是数组，需要加一个规则

        itemType 数组中每一个元素的规则 
        rule - An object that validate the items of the array. Only work with itemType.
        max - 数组最大长度
        min - 数组最小长度

    https://github.com/node-modules/parameter#rule
    https://github.com/node-modules/parameter/blob/master/benchmark.js
    https://github.com/node-modules/parameter/blob/master/example.js
</code></pre><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><pre><code>jsonp只能get请求

// config/config.default.js  jsonp的配置
exports.jsonp = {
    callback: &apos;callback&apos;, // 识别 query 中的 `callback` 参数
    limit: 100, // 函数名最长为 100 个字符
};


// app/router.js  路由加jsonp中间件
module.exports = app =&gt; {
    const jsonp = app.jsonp();
    app.get(&apos;/api/posts/:id&apos;, jsonp, &apos;posts.show&apos;);         // 通过jsonp中间件来让路由支付一个中间件
    app.get(&apos;/api/posts&apos;, jsonp, &apos;posts.list&apos;);
};

// app/controller/posts.js
exports.show = function* (ctx) {
    ctx.body = {
        name: &apos;egg&apos;,
        category: &apos;framework&apos;,
        language: &apos;Node.js&apos;,
    };
};

用户请求 /api/posts/1?callback=fn，响应为 JSONP 格式，如果用户请求 /api/posts/1
</code></pre><h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><pre><code>Node模拟客户端请求，curl请求默认 content-type: application/x-www-form-urlencoded,

app.curl(url, options) 和 app.httpclient.request(url, options) 两种方法相同

一、Example:

    module.exports = app =&gt; {
        class HttpClientController extends app.Controller{
            async getHttpClient(){
                const {ctx, app, service} = this;

                let result = await this.ctx.curl(&apos;http://goucai.diyicai.com/lottery/getissue.action?lotteryId=001&amp;issueLen=100&amp;d=1502966960306&apos;, {
                    methods: &apos;get&apos;
                });

                let phones = [];
                let resultObj = JSON.parse(result.data.toString());
                resultObj.forEach((data, idx, arr)=&gt;{
                    console.log(&apos;data------&apos;, data);
                    phones.push(data.endTime);
                })

                ctx.body = phones.join(&apos;,&apos;)
            }
        }
        return HttpClientController;
    }


二、config配置 // config/config.default.js

    exports.httpclient = {
        // 默认开启 http/https KeepAlive 功能
        keepAlive: true,

        // 空闲的 KeepAlive socket 最长可以存活 4 秒
        freeSocketKeepAliveTimeout: 4000,

        // 当 socket 超过 30 秒都没有任何活动，就会被当作超时处理掉
        timeout: 30000,

        // 允许创建的最大 socket 数
        maxSockets: Infinity,

        // 最大空闲 socket 数
        maxFreeSockets: 256,

        // 是否开启本地 DNS 缓存，默认关闭
        // 一旦设置开启，则每个域名的 DNS 查询结果将在进程内缓存 10 秒
        enableDNSCache: false,
    };


三、options对象

    let options = {};
    const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, options);

    1、mothod: 请求方法

    2、data: 需要发送的数据 { foo: &apos;bar&apos; }

    3、dataAsQueryString: Boolean 如果为 true 即使在post情况下，也会强制将options.data以 querystringstringify处理后拼接到url的query参数上

    4、content（String|Buffer）: 发送请求的正文，如果设置了此参数会忽略data参数

        ctx.curl(url, {
            method: &apos;POST&apos;,
            // 直接发送原始 xml 数据，不需要 HttpClient 做特殊处理
            content: &apos;&lt;xml&gt;&lt;hello&gt;world&lt;/hello&gt;&lt;/xml&gt;&apos;,
            headers: {
                &apos;content-type&apos;: &apos;text/html&apos;,
            },
        });

    5、stream（ReadStream）: 发送请求正文的可读数据流

        ctx.curl(url, {
            method: &apos;POST&apos;,
            stream: fs.createReadStream(&apos;/path/to/read&apos;),
        });

    6、writeStream: 接受响应数据的可写数据流

        ctx.curl(url, {
            writeStream: fs.createWriteStream(&apos;/path/to/store&apos;),
        });

    7、consumeWriteStream: Boolean 是否等待 writeStream 完全写完才算响应全部接收完毕，默认是 true

    8、contentType: 请求数据的格式，默认undefined

    9、dataType: 响应数据格式

    10、headers: 自定义请求头

    11、timeout: 请求超时时间 默认是 [ 5000, 5000 ]，即创建连接超时是 5 秒，接收响应超时是 5 秒。

    12、agent: 

    13、httpsAgent

    14、auth、digestAuth

    15、followRedirect：Boolean 是否自动跟进3xx的跳转响应

    16、maxRedirects: number 最大自动跳转次数

    17、formatRedirectUrl: 自定义实现302、301

    18、beforeRequest: 请求发送前会调用beforeRequest钩子

        ctx.curl(url, {
            beforeRequest: options =&gt; {
                // 例如我们可以设置全局请求 id，方便日志跟踪
                options.headers[&apos;x-request-id&apos;] = uuid.v1();
            }
        });

    19、streaming：是否直接返回响应流

    20、gzip: Boolean是否开始gzip

    21、timing: Boolean 是否开启请求各阶段的时间没是


四、Get请求

    1、options.method = &apos;post&apos;  设置请求参数，默认是get请求可以不用加

         const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, {method: post});

    2、status: 响应状态码

    3、headers: 响应头信息 有{&apos;conent-type&apos;: &apos;text/html&apos;}

    4、data: 响应body, 返回的是Buffer类型, 如果设置了options.dataType会根据参数来处理


五、Post请求

    module.exports = function* post(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {

            // 必须指定 method
            method: &apos;POST&apos;,

            // 通过 contentType 告诉 HttpClient 以 JSON 格式发送
            contentType: &apos;json&apos;,

            // 要传的数据 
            data: {
                hello: &apos;world&apos;,
                now: Date.now(),
            },

            // 明确告诉 HttpClient 以 JSON 格式处理返回的响应 body
            dataType: &apos;json&apos;,
        });
        ctx.body = result.data;
    };


六、From表单提交

    以 ontent-type: application/x-www-form-urlencoded 的格式提交请求数据

    // app/controller/form.js
    module.exports = function* form(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT 和 DELETE
            method: &apos;POST&apos;,
            // 不需要设置 contentType，HttpClient 会默认以 application/x-www-form-urlencoded 格式发送请求
            data: {
                now: Date.now(),
                foo: &apos;bar&apos;,
            },
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.form;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;foo&quot;: &quot;bar&quot;,
        //   &quot;now&quot;: &quot;1483864184348&quot;
        // }
    };


七、Multipart 方式上传

    From 表单提交时包含文件的时候，需要用到 multipart/form-data 进行提交了

    引用fromstream 第三方模块

    // app/controller/multipart.js
    const FormStream = require(&apos;formstream&apos;);
    module.exports = function* multipart(ctx) {
        const form = new FormStream();

        // 设置普通的 key value
        form.field(&apos;foo&apos;, &apos;bar&apos;);

        // 上传当前文件本身用于测试
        form.file(&apos;file&apos;, __filename);
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 生成符合 multipart/form-data 要求的请求 headers
            headers: form.headers(),
            // 以 stream 模式提交
            stream: form,
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.files;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;file&quot;: &quot;&apos;use strict&apos;;\n\nconst For....&quot;
        // }
    };

    // 添加更多文件
    form.file(&apos;file1&apos;, file1);
    form.file(&apos;file2&apos;, file2);


八、以Stream 方式上传文件

    Stream 实际会以 Transfer-Encoding: chunked 传输编码格式发送

    // app/controller/stream.js
    const fs = require(&apos;fs&apos;);
    module.exports = function* stream(ctx) {
        // 上传当前文件本身用于测试
        const fileStream = fs.createReadStream(__filename);

        // httpbin.org 不支持 stream 模式，使用本地 stream 接口代替
        const url = `${ctx.protocol}://${ctx.host}/stream`;
        const result = yield ctx.curl(url, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 以 stream 模式提交
            stream: fileStream,
        });

        ctx.status = result.status;
        ctx.set(result.headers);
        ctx.body = result.data;
        // 响应最终会是类似以下的结果：
        // {&quot;streamSize&quot;:574}
    };
</code></pre><h4 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h4><pre><code>读取数据渲染模板，呈现给用户

一、使用

    1、$ npm i egg-view-ejs --save         // 安装

    2、配置

        // config/plugin.js
        exports.nunjucks = {
            enable: true,
            package: &apos;egg-view-nunjucks&apos;        // 开启插件使用numjucks模板
        };

        // config/config.default.js
        exports.view = {
            defaultViewEngine: &apos;nunjucks&apos;,
            mapping: {
                &apos;.tpl&apos;: &apos;nunjucks&apos;,
            },
        };


    3、render、renderString两个方法

        render(fileName, locals, viewOptions): filenName: 文件路径、locals: 渲染的数据、viewOptions: 用户传入的配置

    render(name, locals) 渲染模板文件, 并赋值给 ctx.body

    renderView(name, locals) 渲染模板文件, 仅返回不赋值

    renderString(tpl, locals) 渲染模板字符串, 仅返回不赋值


- numjucks模板语法: http://mozilla.github.io/nunjucks/cn/templating.html  见模板md -
</code></pre><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><pre><code>Egg内置static插件，static默认映射到 public目录

app/public
├── css
│   └── news.css
└── js
    ├── lib.js
    └── news.js
</code></pre><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><pre><code>一、Application - 全局的方法和对象挂载到Application中

    // extend/application.js 创建全局对象
    module.exports = {
        // 全局返回状态类型
        statusType: &apos;STATUS_TYPE&apos;,

        // 生成返回报文
        renderBody(params) {
            if (typeof params.statusType === &apos;undefined&apos;) {
                throw new Error(&apos;statusType error&apos;);
            }
            const response = {
                data: params.data || {},
                message: params.message || this.statusMessage[params.statusType],
                status: params.statusType,
            };

            if (params.error) response.error = params.error;
            return response;
        }
    }

    // 调用 controller、service都可以
    module.exports = app =&gt; {
        return class UserController extends app.Controller {
            async fetch() {
                this.ctx.body = app.cache.get(this.ctx.query.id);
            }
        };
    };
</code></pre><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><pre><code>有些任务需要定时来完成，如定时上报，定时远程更新本地缓存，定时任务都统一存放在 app/schedule 目录下

创建一个定时任务 app/schedule/update_cache.js

module.exports = {
    // 通过 schedule 属性来设置定时任务的执行间隔等配置
    schedule: {
        interval: &apos;1m&apos;,     // 1 分钟间隔
        type: &apos;all&apos;,        // 指定所有的 worker 都需要执行
    },

    // task 是真正定时任务执行时被运行的函数，第一个参数是一个匿名的 Context 实例
    * task(ctx) {
        const res = yield ctx.curl(&apos;http://www.api.com/cache&apos;, {
            dataType: &apos;json&apos;,
        });
        ctx.app.cache = res.data;
    }
};
</code></pre><h4 id="框架扩展"><a href="#框架扩展" class="headerlink" title="框架扩展"></a>框架扩展</h4><pre><code>框架扩展自身功能: Application、Context、Request、Response、Helper，在这几个对象上扩展就在extend目录里创建相应的js文件，application.js

    Helper用来提供一些实用的utility函数

一、Application 全局应用对象扩展

    访问 ctx.app,  Controller，Middleware，Helper，Service 中都可以通过 this.app 访问到 Application 对象

    // app.js
    module.exports = app =&gt; {
        app.config
    };

    // 扩展 app.foo() 方法 app/extend/application.js
    module.exports = {
        foo(param) {
            // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性
        },
    };


二 、Context 扩展

    extend/content.js

    module.export = {
        async foo(param){
            ...
        }
    }

    引用 await this.ctx.foo({name: &apos;siguang&apos;});


三、Helper 用来编写一些实用函数

    // app/extend/helper.js
    const moment = require(&apos;moment&apos;);
    exports.relativeTime = time =&gt; moment(new Date(time * 1000)).fromNow();

    // 也可以在模板里面使用：
    &lt;!-- app/views/news/list.tpl --&gt;
    {{ helper.relativeTime(item.time) }}
</code></pre><h4 id="启动自定义"><a href="#启动自定义" class="headerlink" title="启动自定义"></a>启动自定义</h4><pre><code>用来进行应用启动时进行初始化工作

// 通过入口文件app.js
module.exports = app =&gt; {
    app.beforeStart(function* () {

        // 应用会等待这个函数执行完成才启动
        app.cities = yield app.curl(&apos;http://example.com/city.json&apos;, {
            method: &apos;GET&apos;,
            dataType: &apos;json&apos;,
        });
    });
};
</code></pre><h4 id="logger-日志"><a href="#logger-日志" class="headerlink" title="logger 日志"></a>logger 日志</h4><pre><code>this.ctx.logger.info(&apos;xxxxxx&apos;);

logger.debug()、logger.info()、logger.warn()、logger.error()

config.deubgger 文件配置

    logger: {
        level: &apos;DEBUG&apos;,
        dir: &apos;../app/logger&apos;,
    }
</code></pre><h4 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h4><pre><code>egg-bin模块（用于本地开发和单元测试）

package.json:

   {
       &quot;scripts&quot;: {
           &quot;dev&quot;: &quot;egg-bin dev --port 7001&quot;
       }
   }
</code></pre><h4 id="插件的开发"><a href="#插件的开发" class="headerlink" title="插件的开发"></a>插件的开发</h4><pre><code>自定义插件存储目录:  lib/plugin/...

egg-ua插件

1、创建package.json

    {
        &quot;eggPlugin&quot;: {
            &quot;name&quot;: &quot;ua&quot;
        }
    }

2、egg-ua/us.js插件文件

    module.exports = {
        get isIOS() {
            const iosReg = /iphone|ipad|ipod/i;
            return iosReg.test(this.get(&apos;user-agent&apos;));
        },
    };

3、config/plugin.js   通过path来挂载插件

    const path = require(&apos;path&apos;);
    exports.ua = {
        enable: true,
        path: path.join(__dirname, &apos;../lib/plugin/egg-ua&apos;),
    };
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>├── package.json
├── app.js (可选)            // 启动初始化
├── agent.js (可选)
├── app
|   ├── router.js           // 路由规则
│   ├── controller          // 处理用户的输入
│   |   └── home.js
│   ├── service (可选)       // 服务，编写业务逻辑
│   |   └── user.js
│   ├── middleware (可选)    // 中间件
│   |   └── response_time.js
│   ├── schedule (可选)      // 定时任务
│   |   └── my_task.js
│   ├── public (可选)        // 静态目录
│   |   └── reset.css
│   ├── view (可选)          // 模板
│   |   └── home.tpl
│   └── extend (可选)        // 框架扩展
│       ├── helper.js (可选)
│       ├── request.js (可选)
│       ├── response.js (可选)
│       ├── context.js (可选)     // ctx扩展
│       ├── application.js (可选)     // 全局方法
│       └── agent.js (可选)
├── config                  // 配置
|   ├── plugin.js
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test                    // 测试
    ├── middleware
    |   └── response_time.test.js
    └── controller
        └── home.test.js
</code></pre><blockquote>
<p>参考资料<br><a href="http://koa.bootcss.com/" target="_blank" rel="noopener">http://koa.bootcss.com/</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/04/Egg.js-第三方插件收集/">Egg.js</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-第三方插件收集/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| egg-validate POST参数规则校验  <a href="https://github.com/eggjs/egg-validate" target="_blank" rel="noopener">https://github.com/eggjs/egg-validate</a><br>| egg-mongoose Mongoose        <a href="https://github.com/eggjs/egg-mongoose" target="_blank" rel="noopener">https://github.com/eggjs/egg-mongoose</a></p>
<h4 id="egg-validate"><a href="#egg-validate" class="headerlink" title="egg-validate"></a>egg-validate</h4><pre><code>验证 Request Body的参数

$ npm i egg-validate --save  安装

// {app_root}/config/plugin.js
exports.validate = {
    package: &apos;egg-validate&apos;,
};

// 校验规则 post
async fromRule(){
    const {ctx, app} = this;

    // Request 参数规则
    const paramRule = {
        username: {type: &apos;string&apos;},
        password: {type: &apos;string&apos;},
        rememberMe: {type: &apos;boolean&apos;, required: false},
    };
    const paramErrors = app.validator.validate(paramRule, ctx.request.body);

    if(paramErrors){    // 如果为真说明校验不通过
        ctx.body = `校验失败`;
    }   
    else{
        ctx.body = `校验成功, ${ctx.request.body.username}`;
    }
}
</code></pre><h4 id="ejs-后端模板"><a href="#ejs-后端模板" class="headerlink" title="ejs 后端模板"></a>ejs 后端模板</h4><pre><code>$ npm install ejs

https://segmentfault.com/a/1190000004286562
http://www.360doc.com/content/16/0115/10/597197_528136785.shtml
https://github.com/tj/ejs
</code></pre><h4 id="nunjucks-后端模板"><a href="#nunjucks-后端模板" class="headerlink" title="nunjucks 后端模板"></a>nunjucks 后端模板</h4><pre><code>http://mozilla.github.io/nunjucks/cn/templating.html
https://github.com/eggjs/examples/tree/master/hackernews/app/view/news
</code></pre><h4 id="其它收集插件"><a href="#其它收集插件" class="headerlink" title="其它收集插件"></a>其它收集插件</h4><pre><code>1、ms返回时间 - https://github.com/zeit/ms       // ms用来返回一个时间  ms(&apos;2h&apos;) 返回 7200000  

2、MD5加密 - https://github.com/jkiss/crypto-js      npm i crypto-js --save  引用 const MD5 = require(&apos;crypto-js/md5&apos;);

3、文件上传 - https://github.com/node-modules/formstream

4、JSON串和对象互转 - https://github.com/ljharb/qs  // 可以根据key来进行排序 

5、验证码 - https://github.com/lemonce/svg-captcha/blob/master/README_CN.md
</code></pre><p>| 参考资料<br>| <a href="https://github.com/eggjs" target="_blank" rel="noopener">https://github.com/eggjs</a><br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/11/Gulp/">Gulp</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/11/Gulp/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-11T10:39:38.000Z" itemprop="datePublished">2016-11-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><pre><code>https://github.com/gulpjs

可以自动化执行任务的工具，主要用于生产环境和开发环境的文件处理

Gulp是一个新的基于流的管道式构建系统，需要很少的配置并且更快

主要作用:

    1、多个js或css文件合并、压缩

    2、Sass或Less的编译

    3、图像的压缩

    3、实时刷新页面的本地服务器

gulp对按需加载不好做到，如A和B页面都依赖base.js，但又各依赖a.js和b.js，这种情况gulp打包是将三个都包括了，所以css和html部分gulp来处理，js的webpack处理
</code></pre><h4 id="安装、使用"><a href="#安装、使用" class="headerlink" title="安装、使用"></a>安装、使用</h4><pre><code>$ npm install -g gulp     // 全局安装Gulp

$ npm init    // 创建package.json 项目描述文件

$ npm install --save-dev gulp    // 作为项目的开发依赖(只在开发时用，不会发布到线上)

$ touch gulpfile.js

    var gulp = require(&apos;gulp&apos;);
    gulp.task(&apos;default&apos;, function(){

    })

$ gulp     // 运行gulp
</code></pre><h4 id="gulp-方法"><a href="#gulp-方法" class="headerlink" title="gulp 方法"></a>gulp 方法</h4><pre><code>1、gulp.src(): 获取到想要处理的文件流，可以是一个字符串或者数组，返回一个stream

    1)、*.{png,jpg,gif,ico}      // 匹配文件

    2)、**/*.html        // 目录用**、文件名用*

    gulp.task(&apos;count&apos;, function(){
        gulp.src([&apos;aa.html&apos;, &apos;bb.html&apos;])    // 或 gulp.src(&apos;src/*.html&apos;);
            .pipe(gulp.uglify())
    })

2、gulp.pipe(): 将获取到的文件流通过pipe()导入到gulp的插件中进行处理

3、gulp.dest(): 用来写文件的，插件处理完，通过dest()处理完成后把流中的内容写到指定的文件中

    var gulp = require(&apos;gulp&apos;);
    gulp.src(&apos;js/main.js&apos;)                 // 获取文件的流的api
        .pipe(gulp.uglify())            // 文件进行压缩
        .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));     // 写文件的api


4、gulp.task(&apos;任务名&apos; [依赖任务], callback): 定义任务，依赖任务会在当前任务执行前完成

    gulp.task(&apos;test&apos;, [&apos;styles&apos;, &apos;task&apos;], function() {
        // 将你的默认的任务代码放在这
    });

    # gulp test     // 执行任务


5、gulp.watch(&apos;要监视文件的匹配模式&apos;, [要执行的task定义的任务], callback): 监视文件的变化，变化后来执行定义的任务
</code></pre><h4 id="gulp-执行命令"><a href="#gulp-执行命令" class="headerlink" title="gulp 执行命令"></a>gulp 执行命令</h4><pre><code>-v 或 --version 会显示全局和项目本地所安装的 gulp 版本号

--gulpfile 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录

--cwd dirpath 手动指定 CWD。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径

-T 或 --tasks 会显示所指定 gulpfile 的 task 依赖树

--tasks-simple 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表

--color 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持

--no-color 强制不显示颜色，即便检测到有颜色支持

--silent 禁止所有的 gulp 日志
</code></pre><h4 id="Gulp-扩散操作"><a href="#Gulp-扩散操作" class="headerlink" title="Gulp 扩散操作"></a>Gulp 扩散操作</h4><pre><code>1、复制单个文件task

    gulp.task(&apos;copy-html&apos;,function(){
        return gulp.src(&apos;app/index.html&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });


2、复制多个文件

    gulp.task(&apos;copy-images&apos;,function(){
        return gulp.src(&apos;app/imgs/**/*.{jpg,png}&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });

    gulp.task(&apos;copy-other&apos;,function(){
        return gulp.src([&apos;app/css/*.css&apos;,&apos;app/js/*.js&apos;],{base:&apos;app&apos;}).pipe(gulp.dest(&apos;dist&apos;));
    });
</code></pre><h4 id="gulp-插件"><a href="#gulp-插件" class="headerlink" title="gulp 插件"></a>gulp 插件</h4><pre><code>https://gulpjs.com/plugins/

$ gulp
$ gulp-babel babel-core babel-preset-env        // ES6转ES5
$ babel-plugin-transform-runtime        // ES6转ES5运行时转换
$ gulp-uglify            // 压缩js
$ gulp-concat            // 合并js
$ gulp-jshint            // js语法检测
$ gulp-less              // less编译
$ gulp-ruby-sass        // sass编译
$ gulp-minify-css        // css压缩
$ gulp-css-base64        // 生成64位图标
$ gulp-htmlmin           // html压缩
$ gulp-file-include        // includer嵌入到另一个html文件
$ gulp.spritesmith       // 雪碧图
$ gulp-imagemin          // 压缩图片
$ imagemin-pngquant      // 图片的深度压缩
$ gulp-cache             // 只压缩修改的图片
$ gulp-rev-append        // 加版本号，给页面文件引用的js和css资源
$ gulp-autoprefixer     // 自动补齐前缀，根据设置浏览器版本自动处理浏览器前缀 CSS3的前缀
$ gulp-react             // react区分jsx文件进行转换
$ gulp-webpack           // webpack
$ gulp-amd-optimizer     // requirejs 压缩
$ vinyl-buffer           // 流缓存
$ merge-stream           // 合并流
$ gulp-watch             // 侦听变化自动执行task
$ gulp-livereload        // 当监听文件发生变化时，浏览器自动刷新页面
$ gulp-header            // 注释自定义插件
$ gulp-rimraf            // 清除文件
$ gulp-clean             // 删除文件或目录
$ gulp-plumber           // 错误提示
$ gulp-notify            // 消息提示
$ gulp-rename            // 重命
$ gulp-connect           // gulp的服务器
$ gulp-browserify          // 
$ gulp-open                // 打开浏览器
$ gulp-md5-plus            // 生成md5码

一、gulpfile.js中引用插件   

    var uglify = require(&apos;gulp-uglify&apos;);


二、gulp-load-plugins 模块化管理插件

    1、一般情况下，gulpfile.js中的模块需要一个个加载。

        var gulp = require(&apos;gulp&apos;)
               jshint = require(&apos;gulp-jshint&apos;),
            uglify = require(&apos;gulp-uglify&apos;),
            concat = require(&apos;gulp-concat&apos;);

        gulp.task(&apos;js&apos;, function () {
               return gulp.src(&apos;js/*.js&apos;)
                  .pipe(uglify())
                  .pipe(concat(&apos;app.js&apos;))
                  .pipe(gulp.dest(&apos;build&apos;));
        });


    2、gulp-load-plugins 会加载 package.json中存在下面的插件依赖：

        &quot;devDependencies&quot;: {
            &quot;gulp&quot;: &quot;^3.9.0&quot;,
            &quot;gulp-uglify&quot;: &quot;^2.6.0&quot;,
            &quot;gulp-concat&quot;: &quot;^2.2.0&quot;
        }

        var gulp = require(&apos;gulp&apos;);
        var $ = require(&apos;gulp-load-plugins&apos;)();            // 加载gulp-load-plugins插件，并立刻运行

        使用：$.uglify  可以省去单个引入
        gulp.task(&apos;add&apos;, function(){
            gulp.src([&apos;js/main.js&apos;])
                .pipe($.concat)
                .pipe($.uglify)            // $.uglify就可以调用了
                .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));    // 如果不改变文件名就直接写成 dist/js/
        })
</code></pre><h4 id="gulp-webpack构建多页面"><a href="#gulp-webpack构建多页面" class="headerlink" title="gulp + webpack构建多页面"></a>gulp + webpack构建多页面</h4><pre><code>├── .DS_Store
├── src                // 生产目录
├── dist            // 发布目录
├── gulpfile.js
├── node_modules
└── package.json
</code></pre><p>| 参考资料<br>| <a href="http://www.gulpjs.com.cn/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/</a>   gulp中文网<br>| <a href="http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7</a><br>| <a href="http://www.gulpjs.com.cn/docs/recipes/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/recipes/</a>    gulp 技巧集<br>| <a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/api/</a>    gulp api<br>| <a href="http://www.techug.com/gulp" target="_blank" rel="noopener">http://www.techug.com/gulp</a>  gulp使用指南<br>| <a href="http://www.w3ctech.com/topic/134" target="_blank" rel="noopener">http://www.w3ctech.com/topic/134</a>    gulp开发教程<br>| <a href="http://www.qianduancun.com/nodejs/33.html" target="_blank" rel="noopener">http://www.qianduancun.com/nodejs/33.html</a>      gulp-load-plugins[模块化管理插件]<br>| <a href="http://segmentfault.com/a/1190000003098076#articleHeader0" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003098076#articleHeader0</a>        利用 gulp 处理前端工作流程<br>| <a href="http://www.cnblogs.com/2050/p/4198792.html" target="_blank" rel="noopener">http://www.cnblogs.com/2050/p/4198792.html</a>        前端构建工具gulpjs的使用介绍及技巧<br>| <a href="https://www.cnblogs.com/weixing/p/5474324.html" target="_blank" rel="noopener">https://www.cnblogs.com/weixing/p/5474324.html</a><br>|<br>| 多页面<br>| <a href="https://www.cnblogs.com/maskmtj/archive/2016/07/21/5597307.html" target="_blank" rel="noopener">https://www.cnblogs.com/maskmtj/archive/2016/07/21/5597307.html</a><br>| <a href="https://github.com/fwon/gulp-webpack-demo" target="_blank" rel="noopener">https://github.com/fwon/gulp-webpack-demo</a><br>|<br>| 文件流<br>| <a href="http://segmentfault.com/a/1190000000519006" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000519006</a>    nodejs中流(stream)的理解<br>| <a href="http://www.it165.net/pro/html/201406/15924.html" target="_blank" rel="noopener">http://www.it165.net/pro/html/201406/15924.html</a>    Node.js Stream（流）的学习笔记<br>| <a href="http://segmentfault.com/a/1190000000357044" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000357044</a>    Node 中的流（Stream）<br>|<br>| Promise<br>| <a href="http://segmentfault.com/a/1190000002591145" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002591145</a>    深入理解Promise实现细节<br>| <a href="http://www.tuicool.com/articles/fe6Jbyz" target="_blank" rel="noopener">http://www.tuicool.com/articles/fe6Jbyz</a>    Promise实现原理<br>| <a href="http://segmentfault.com/a/1190000003028634" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003028634</a>    异步编程 promise模式 的简单实现<br>| <a href="http://sentsin.com/web/861.html" target="_blank" rel="noopener">http://sentsin.com/web/861.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/02/webpack插件类/">webpack插件类</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/02/webpack插件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-02T03:06:16.000Z" itemprop="datePublished">2016-11-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><pre><code>1、自动刷新浏览器 - 修改代码编译后自动刷新浏览器

2、热替换 - 在不刷新整个网页的时候做到实时预览

    script: {
        &quot;server&quot;: &quot;webpack-dev-server --open --hot --inline&quot;
    }

    --hot 与在 new webpack.HotModuleReplacementPlugin() 相同

3、提取公用代码

    通过CommonsChunkPlugin插件来提取指定业务文件中的公用库

4、按需加载、首屏加载

    &lt;!-- 加载 import(/* webpackChunkName: &quot;show&quot; */&apos;./show&apos;, then((show) =&gt; {
        show(&apos;webpack&apos;)
    })) --&gt;
</code></pre><h4 id="将业务逻辑与其它组件库分离"><a href="#将业务逻辑与其它组件库分离" class="headerlink" title="将业务逻辑与其它组件库分离"></a>将业务逻辑与其它组件库分离</h4><pre><code>将业务逻辑和第三方代码分离，不能将他们都合并到一个文件内，使这个js文件比较大，并且跳转到另一个地址也还会重新加载这些公用的文件

Example: 

    对引用的jquery单独提取

    1、import $ from &apos;jquery&apos;;     // js中引用的jquery, 先npm i jquery下载包

    2、webpack.config.js

        // 入口文件
        entry: {
            app: path.resolve(__dirname, &apos;web/js/index.js&apos;),
            vendor: [&apos;jquery&apos;]
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;,
            chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        plugins: [
            // 将在html文件中添加&lt;script&gt;引用，并生创建到指定的目录中
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,
                filename: &apos;./web/index.html&apos;,
                template: &apos;./web/index.html&apos;,
                chunks: [&apos;app&apos;, &apos;vendor&apos;],            // 这里要把vendor依赖的文件加上，不然生成的html只有引用app.min.js，不会引用jquery.vendor.js
                inject: true,
                hash: true
            }),

            // 拆分插件
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendor&apos;,                            // 上面入口定义的节点组
                filename: &apos;jquery.vendor.js?[hash]&apos;     // 最后生成的文件名
            }),
        }
</code></pre><h4 id="require-ensure按需加载"><a href="#require-ensure按需加载" class="headerlink" title="require,ensure按需加载"></a>require,ensure按需加载</h4><pre><code>require()与require.ensure()加载的不同

1、require(): AMD加载规范，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数

2、require.ensure(): requi.ensure的依赖模块只会被先下载下来，但不会被执行，会将require.ensure()内加载的模块合成一个文件，在

    如果webpack打包会将所有资源加到一个文件中，这样会使这个文件变的很大，require.ensure()来对加载的资源单独打包

    require.ensure([], function(require) {
        var dialog = require(&apos;./components/dialog&apos;);
        // todo ...
    });

    CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好

    webpack.config.js中配置

        var chunks = Object.keys(entries);
        plugins: [
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendors&apos;,             // 将公共模块提取，生成名为`vendors`的chunk
                chunks: chunks,
                minChunks: chunks.length     // 提取所有entry共同依赖的模块
            })
        ]

http://blog.csdn.net/zhbhun/article/details/46826129
https://segmentfault.com/a/1190000007775743
</code></pre><h4 id="插件类详解"><a href="#插件类详解" class="headerlink" title="插件类详解"></a>插件类详解</h4><pre><code>* webpack-dev-server - webpack自带服务

webpack自带的插件
* CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin - 提取公用部分
* uglifyJsPlugin - js压缩

外部加载插件
* HotMooduleReplacementPlugin() - 热替换
* html-webpack-plugin - 解析html模板
* web-webpack-plugin - 与html-webpack-plugin类型国内人写的https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md
* extract-text-webpack-plugin - 单独打包css文件
* open-browser-webpack-plugin - 资源构建成功后自动打开浏览器 
* clean-webpack-plugin - 清除文件夹,添加hash后，会导致改变文件内容重新打包时文件名不同越来越多，使用clean-webpack-plugin

* babel-plugin-react-transform react-transform-hmr - react的热更新, 需要在配置bable.rc
* ExtractTextPlugin - 将js中引用的css文件抽取出一个单独的css文件
* webpack-merge - 合并数组、函数
* webpack-dev-middleware - devServer就是基于webpack-dev-middleware和ExpressJS来实现的
* imagemin-webpacl-plugin - 压缩图片
* webpack-spritesmith - 制作雪碧图
* HotModuleReplacementPlugin - devServer热更新

一、webpack-dev-server webpack自带服务

    webpack-dev-server有两种模式支持自动刷新——iframe模式和inline模式。

    1、iframe模式: 页面是嵌套在一个iframe下的，在代码发生改动的时候，这个iframe会重新加载;使用iframe模式无需额外的配置，只需在浏览器输入以下地址: http://localhost:8080/webpack-dev-server/index.html

    2、inline模式: 一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。

    以下三种配置都可以实现页面的刷新效果: 

        // 1.启动webpack-dev-server的时候带上inline参数
        webpack-dev-server --inline

        // 2.给HTML插入JS
        &lt;script src=&quot;http://localhost:3000/webpack-dev-server.js&quot;|&lt;/script|

        // 3.webpack配置
        entry: [
            &apos;webpack-dev-server/client?http://localhost:3000&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ]


二、HotMooduleReplacementPlugin() 热替换

    webpac-dev-server支持模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉。使用HMR功能也有两种方式: 命令行方式和Node.js API。

    1、cli命令行方式  webpack-dev-server --inline --hot

    2、Node.js API方式

        entry: [
            &apos;webpack/hot/dev-server&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ],
        devServer: {
            hot: true
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin(),
        ]


三、html-webpack-plugin 解析html模板

    插件将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

    $ npm i html-webpack-plugin

    $ const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);            // 引用插件

    1、单入口配置

        // 这里省略其他配置代码
        plugins: [
            // 使用这个plugin，这是最简单的一个配置，更多资料可到github查看
            new HtmlWebpackPlugin({
                title: &apos;zhufeng-react&apos;,
                template: &apos;./src/index.html&apos;,
            })
        ]

    2、多入口配置

        会将两个入口分别对html文件进行加载指定的入口js文件

        // 入口文件
        entry: {
            app: &apos;./web/js/index.js&apos;,
            list: &apos;./web/js/list.js&apos;
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;
        },

        plugins: [
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,                    // 生成html文档的标题
                filename: &apos;./web/index.html&apos;,    // 输出文件名称
                template: &apos;./web/index.html&apos;,    // 本地模板的位置，支持(handlebars、ejs、undersore、html)
                chunks: [&apos;app&apos;],                // 对应的入口entry, 也可以是数组[&apos;app&apos;, &apos;list&apos;]
                inject: true,                    // 向template中注入所有静态资源
                hash: true                        // 为静态资源添加webpack每次编译产生的唯一hash值， &lt;script type=&quot;text/javascript&quot; src=&quot;common.js?a3e1396b501cdd9041be&quot;&gt;&lt;/script&gt;
            }),
            new HtmlWebpackPlugin({
                title: &apos;list&apos;,
                filename: &apos;./web/list.html&apos;,
                template: &apos;./web/list.html&apos;,
                chunks: [&apos;list&apos;],
                inject: true,
                hash: true
            })
        ]

    https://segmentfault.com/q/1010000009810148
    https://www.cnblogs.com/wonyun/p/6030090.html


四、extract-text-webpack-plugin 单独打包css文件

    $ npm i extract-text-webpack-plugin


五、open-browser-webpack-plugin  资源构建成功后自动打开浏览器 --- 已可以在命令中配置

    1、package.json中加 --open，与使用此插件相同

        &quot;scripts&quot;: {
            &quot;start&quot;: &quot;webpack-dev-server --hot --inline --open&quot;,
        }


    2、$ npm install open-browser-webpack-plugin --save-dev

        var openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
            new openBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]


六、CSS Module

    webpack 的 css-loader 是解决这个问题的最好办法之一。简单配置一下: 
    module: {
      loaders: [{
        test: /\.css$/,
        loaders: [
          &apos;style-loader&apos;,
          &apos;css-loader?modules&amp;localIdentName=[name]__[local]___[hash:base64:5]&apos;,
          &apos;postcss-loader&apos;
        ]
      }]
    },
    postcss: [
      require(&apos;postcss-nested&apos;)(),
      require(&apos;cssnext&apos;)(),
      require(&apos;autoprefixer-core&apos;)({ browsers: [&apos;last 2 versions&apos;] })
    ]


七、UglifyJs Plugin 压缩资源

    var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;

    plugins: [
        new uglifyJsPlugin({
            compress: {
                warnings: false
            }
        }),
        new webpack.optimize.MinChunkSizePlugin({
            compress: {
                warnings: false
            }
        }),
        // 查找相等或近似的模块，避免在最终生成的文件中出现重复的模块
        new webpack.optimize.DedupePlugin(),
        // 按引用频度来排序 ID，以便达到减少文件大小的效果
        new webpack.optimize.OccurenceOrderPlugin(),
        new webpack.optimize.AggressiveMergingPlugin({
            minSizeReduce: 1.5,
            moveToParents: true
        })
    ]


八、clean-webpack-plugin 清除文件夹

    $ npm install clean-webpack-plugin --save-dev

    webpack.config.js:

        const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);

        plugins: [
            new CleanWebpackPlugin([&apos;dist&apos;]),
            new HtmlWebpackPlugin({
                title: &apos;Output Management&apos;
            })
        ]


九、react的热替换

    $ npm install --save-dev babel-plugin-react-transform react-transform-hmr

    .babelrc配置
        {
            &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
            &quot;env&quot;: {
                &quot;development&quot;: {
                &quot;plugins&quot;: [[&quot;react-transform&quot;, {
                    &quot;transforms&quot;: [{
                        &quot;transform&quot;: &quot;react-transform-hmr&quot;,

                        &quot;imports&quot;: [&quot;react&quot;],

                        &quot;locals&quot;: [&quot;module&quot;]
                    }]
                }]]
                }
            }
        }

十、ExtractTextPlugin 分享css和js文件

    $ npm install --save extract-text-webpack-plugin

    webpack.config.js

        const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

        module.exports = {
            entry: {},
            output: {},

            plugins:[
                new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
                new ExtractTextPlugin(&quot;style.css&quot;)
            ]

        }

十一、clean-webpack-plugin

    $ npm install clean-webpack-plugin --save

        const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);
        module.exports = {

            plugins: [
                &lt;!-- ...// 这里是之前配置的其它各种插件 --&gt;
                new CleanWebpackPlugin( &apos;build/*.*&apos;, {
                        root: __dirname,
                        verbose: true,
                        dry: false
                    }
                )
            ]
        }

十二、CommonsChunkPlugin

    const CommonsChunkPlugin = require(&apos;CommonsChunkPlugin&apos;);
    module.exports = {
        plugins: [
            new CommonsChunkPlugin({
                // 从哪些Chunk 中提取
                chunks: [&apos;a&apos;, &apos;b&apos;],
                // 提取的公共部分形成一个chunk
                name: &apos;common&apos;
            })
        ]
    }


十三、暴露全局对象

    如果想将report数据上报组件放到全局，有两种办法: 

    方法一: 
    在loader里使expose将report暴露到全局，然后就可以直接使用report进行上报
    {
        test: path.join(config.path.src, &apos;/js/common/report&apos;),
        loader: &apos;expose?report&apos;
    }

    方法二: 
    如果想用R直接代表report，除了要用expose loader之外，还需要用ProvidePlugin帮助，指向report，这样在代码中直接用R.tdw， R.monitor这样就可以
    new webpack.ProvidePlugin({
        &quot;R&quot;: &quot;report&quot;,
    })
</code></pre><h4 id="gulp与webpack构建单页面与多页面总结"><a href="#gulp与webpack构建单页面与多页面总结" class="headerlink" title="gulp与webpack构建单页面与多页面总结"></a>gulp与webpack构建单页面与多页面总结</h4><pre><code>1、gulp: 处理html、css都可以，对处理js依赖这块不占优势

2、webpack: 对js入口进行单页面构建和模块化开发，如果页面较多不占优势，多页面webpack也可以做到，不过将js合并并加载到html中配置比较麻烦，需要HtmlWebpackPlugin插件来完成，每一个页面都需要创建一次，也可以将公用进行提取chunks

3、gulp+webpck 构建多页面

    优点: gulp进行对html和css处理，webpack进行js的处理

    缺点: webpack如果需要合并js，还需要手动去改html的引用
</code></pre><h4 id="webpack踩坑"><a href="#webpack踩坑" class="headerlink" title="webpack踩坑"></a>webpack踩坑</h4><pre><code>一、安装完webpack后执行命令提示需要安装webpack

    webpack -h          // 提示没有装webpack-cli

    $ npm i webpack-cli --save-dev            // 如果全局没有安装就全局装一下 $ sudo npm i webpack-cli -g

    https://segmentfault.com/a/1190000013699050
</code></pre>
        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
