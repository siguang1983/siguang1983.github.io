<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/babel/">Babel</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/babel/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>涉及知识点</p>
<p>babel安装<br>ES6转ES5 babel-preset-es2015<br>jsx文件的转换 npm i babel-preset-react<br>.babelrc 文件配置 presets来解析<br>加UMD模块，可以自带模块代码</p>
</blockquote>
<h4 id="一、babel"><a href="#一、babel" class="headerlink" title="一、babel"></a>一、babel</h4><pre><code>1、安装：

    npm install babel-cli

    包括了: babel、babel-node、babel-core、babel-register


        1) babel-register模块改写require命令，为它加上一个钩子。require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。

            npm install --save-dev babel-register

            // 先加载babel-register，这样就会不在对index.js进行转码了
            require(&quot;babel-register&quot;);
            require(&quot;./index.js&quot;);

        2) 浏览器环境

            下载babel-core: npm install babel-core@5

            &lt;!-- 引用browser.js --&gt;
            &lt;script src=&quot;node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt;
            &lt;!-- type值为text/babel --&gt;
            &lt;script type=&quot;text/babel&quot;&gt;
                // 这里写es6的代码
            &lt;/script&gt;


2、    babel用处

    1）将ES6转成ES5代码在安装 babel-preset-es2015

        npm i babel-preset-es2015 --save-dev

        需要创建一个 .babelrc 文件
        {
              &quot;presets&quot;: [&quot;es2015&quot;]
        }

    2）babel-polyfill: 可以在在浏览器直接解析    npm i babel-polyfill --save-dev

    3）React的JSX代码: npm i babel-preset-react --save-dev

        对.babelrc文件配置
        {
              &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
        }


2、执行编译

    # babel main.js     // 将文件直接编译

    # babel main.js --out-file  main-component.js     // 将main.js编译成一个main-component.js, 缩定--out-file 写成 -o

    # babel src --out-dir build   // 将 src目录下的所有文件编译到build目录下，--out-dir简写 -d

    # babel --watch main.js --out-file main-component.js  --source-maps  // --watch 侦听文件的变化，--source-maps 会在文件打出文件的目录, 简写 -w

    # babel src --out-dir lib  // 编译目录，src目录下的所有文件进行编辑并放到lib文件夹中


3、浏览器上直接编译 browser.js

    可以直接转换，不需要执行编译命令

    1、加载需要文件
        babel-core/browser.js 
        babel-core/browser-polyfill.js     // 修补浏览器工具的，浏览器不支持的时候需要它

    2、&lt;script&gt;调用
        type中必须写成 &apos;text/babel&apos;
        &lt;script src=&quot;main.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;


4、brower-sync 创建一个server环境

    命令：brower-sync start --server
</code></pre><h4 id="二、使用模块plugins"><a href="#二、使用模块plugins" class="headerlink" title="二、使用模块plugins"></a>二、使用模块plugins</h4><pre><code>1、对模块的处理

UMD模块，可以将代码转成模块化的模式

npm install --save-dev babel-plugin-transform-es2015-modules-umd

.babelrc文件
{
    &quot;plugins&quot;: [&quot;transform-es2015-modules-umd&quot;]
}

index.js:

    export default 42;

output:

    (function (global, factory) {
        if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
            define([&quot;exports&quot;], factory);
        } 
        else if (typeof exports !== &quot;undefined&quot;) {
            factory(exports);
        } 
        else {
            var mod = {
                exports: {}
            };
            factory(mod.exports);
            global.actual = mod.exports;
        }
    })(this, function (exports) {
        &quot;use strict&quot;;

        Object.defineProperty(exports, &quot;__esModule&quot;, {
            value: true
        });

        exports.default = 42;
    });
</code></pre><h4 id="二、Balel与Gulp结合"><a href="#二、Balel与Gulp结合" class="headerlink" title="二、Balel与Gulp结合"></a>二、Balel与Gulp结合</h4><pre><code>下载gulp和gulp-bable包

npm i gulp gulp-babel --save

gulpFile:

    var gulp = require(&apos;gulp&apos;);
    var babel = require(&apos;gulp-babel&apos;);

    gulp.task(&apos;babel&apos;, function(){
        return gulp.src(&apos;./src/*.js&apos;)
            .pipe(babel())
            .pipe(gulp.dest(&apos;build&apos;))
    })

    gulp.task(&apos;default&apos;,[&apos;babel&apos;]);
</code></pre><h4 id="三、Babel与Webpack结合"><a href="#三、Babel与Webpack结合" class="headerlink" title="三、Babel与Webpack结合"></a>三、Babel与Webpack结合</h4><pre><code>下载webpack和babel需要的包

npm install babel-loader babel-core babel-preset-es2015 webpack --save-dev

webpack.config.js:

    var webpack = require(&apos;webpack&apos;);
    var path = require(&apos;path&apos;);

    module.exports = {

        /* 页面入口 - 单入口文件 */
        entry: {
            index : &apos;./src/js/webpackPackMain.js&apos;          // 单入口文件
        },

        output: {
            path: &apos;./dist/js/&apos;,
            filename: &apos;[name].min.js?[hash]&apos;            // [hash] 将文件输出后加一个hash值
        },

        //加载器配置
        module: {
            loaders: [
                &lt;!-- { test: /\.css$/, loader: &apos;style-loader!css-loader&apos;},
                { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},
                { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;}, --&gt;

                // es6转es5
                {
                    test: /\.js$/,
                    exclude: /(node_modules|bower_components)/,
                    loader: &apos;babel-loader&apos;,
                    query: {
                        presets: [&apos;es2015&apos;]
                    }
                }
            ]
        }
    };
</code></pre><h4 id="四、相关插件"><a href="#四、相关插件" class="headerlink" title="四、相关插件"></a>四、相关插件</h4><pre><code>babel-preset-es2015     将ES6编译成ES5的代码

babel-preset-react        用于React中JSX语法的转码 不需要使用jsx-loader

{
    &quot;presets&quot;: [
        &quot;es2015&quot;,
        &quot;react&quot;
    ],
    &quot;plugins&quot;: []
}
</code></pre><h4 id="五、babel-preset-stage-x"><a href="#五、babel-preset-stage-x" class="headerlink" title="五、babel-preset-stage-x"></a>五、babel-preset-stage-x</h4><pre><code>http://www.cnblogs.com/chris-oil/p/5717544.html

用于ES7的提案

这个流程分为 5（0－4）个阶段。 随着提案得到越多的关注就越有可能被标准采纳，于是他们就继续通过各个阶段，最终在阶段 4 被标准正式采纳。

以下是4 个不同阶段的（打包的）预设：

babel-preset-stage-0
babel-preset-stage-1
babel-preset-stage-2
babel-preset-stage-3

注意 stage-4 预设是不存在的因为它就是上面的 es2015 预设。

以上每种预设都依赖于紧随的后期阶段预设。例如，babel-preset-stage-1 依赖 babel-preset-stage-2，后者又依赖 babel-preset-stage-3。.

Stage 0：

    Function Bind Syntax：函数的绑定运算符
    String.prototype.at：字符串的静态方法at

Stage 1：

    Class and Property Decorators：Class的修饰器
    Class Property Declarations：Class的属性声明
    Additional export-from Statements：export的写法改进
    String.prototype.{trimLeft,trimRight}：字符串删除头尾空格的方法

Stage 2：

    Rest/Spread Properties：对象的Rest参数和扩展运算符

Stage 3

    SIMD API：“单指令，多数据”命令集
    Async Functions：async函数
    Object.values/Object.entries：Object的静态方法values()和entries()
    String padding：字符串长度补全
    Trailing commas in function parameter lists and calls：函数参数的尾逗号
    Object.getOwnPropertyDescriptors：Object的静态方法getOwnPropertyDescriptors

Stage 4：

    Array.prototype.includes：数组实例的includes方法
    Exponentiation Operator：指数运算符

使用的时候只需要安装你想要的阶段就可以了： $ npm install --save-dev babel-preset-stage-2

添加 .babelrc 配置文件。
  {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;react&quot;,
      &quot;stage-2&quot;
    ],
    &quot;plugins&quot;: []
  }
</code></pre><blockquote>
<p>参考资料</p>
<p><a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a>            // 官网</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/移动端的那些积累/">移动端的那些积累</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/移动端的那些积累/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/移动端/">移动端</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="webkit-常用属性"><a href="#webkit-常用属性" class="headerlink" title="-webkit- 常用属性"></a>-webkit- 常用属性</h4><pre><code>http://ued.ctrip.com/webkitcss/   整理的webkit属性集合

&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalabel=no&quot;&gt;

1、-webkit-appearance: none;     // 用于移IOS下移除原生样式

2、text-size-adjust: 100%;       // webkit内核浏览器可以让终端字体小于12px

    iPhone 和 Android 的浏览器纵向和橫向时自动调整字体大小的功能。通过 text-size-adjust 设为 none 或者 100% 关闭字体大小自动调整功能.
    html {
        font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, Arial, sans-serif;
        -ms-text-size-adjust: 100%;
        -webkit-text-size-adjust: 100%; 
    }

3、overflow-scrolling  硬件加速, 在body中设置

    body {
        /*height: 100%;*/
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch; 
    }

4、tap-highlight-color  用户点击iOS的Safari浏览器中的链接或JavaScript的可点击的元素时，覆盖显示的高亮颜色

    a {
        -webkit-tap-highlight-color: transparent;
    }

5、touch-callout  当触摸并长按住的时候，禁止或显示系统默认菜单

    a {
        -webkit-touch-callout: none
    }

    window.ontouchstart = function(e) {
        if (e.target.tagName === &apos;img&apos;)
             e.preventDefault();
    }

6、pointer-events:none;
</code></pre><h4 id="viewport-视图"><a href="#viewport-视图" class="headerlink" title="viewport 视图"></a>viewport 视图</h4><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;

    width - 设置viewport宽度，为一个正整数，或字符串‘device-width’

    height - 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置

    initial-scale - 默认缩放比例，为一个数字，可以带小数

    minimum-scale - 允许用户最小缩放比例，为一个数字，可以带小数

    maximum-scale - 允许用户最大缩放比例，为一个数字，可以带小数

    user-scalable - 是否允许手动缩放
</code></pre><h4 id="不同屏幕的适配方案"><a href="#不同屏幕的适配方案" class="headerlink" title="不同屏幕的适配方案"></a>不同屏幕的适配方案</h4><pre><code>通过响应式技术，在不同设备上使用同一套代码来展示

1、设置@media      2、rem       3、vw

一、@media 媒体查询 

    @media screen and(min-width: 500px){    // 大于500px执行下面代码
        ...
    }

二、rem

    rem是根据页面的根元素&lt;html&gt;的fontSize的一个相对单位，需要运用js来计算根据屏幕宽度或来计算html的赋值

    1、普通CSS写法

        html { font-size: 16px; }
        div { width: 2rem; }

    2、Sass的工程: 

        前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即: 
        @function px2rem($px){
            $rem : 37.5px;
            @return ($px/$rem) + rem;
        }

        调用
        height: px2rem(90px);
        width: px2rem(90px);

三、vw、vh

    上面两种不是特别完美，媒体查询不能做到等比例响应，rem需要js与css耦合在一起，而且vw/vh就不需要

    计算vm方法: 16 / 750 * 100 = 2.13vw;        // 16是px转rem的值，750

        html {
            font-size: 2.13vw;
        }

    vw: 视窗的宽度，视窗的宽度是100vw

    vh: 视窗的高度，视窗的高度是100vh

    vmin: 选取vw和vh中最小的那个

    vmax: 选取vw和vh中最大的那个

https://zhuanlan.zhihu.com/p/23968868
https://juejin.im/entry/59b00e46f265da2491513bcc
</code></pre><h4 id="移动端概念"><a href="#移动端概念" class="headerlink" title="移动端概念"></a>移动端概念</h4><pre><code>一、物理像素: 物理像素是屏幕的实际尺寸

二、设备独立像素: 设备像素与CSS像素之间的关系

三、设备像素比 dpr: 设备像素比 = 物理像素 / 设备独立像素;

    js获取设备像素比: window.devicePixelRatio        // devicePixelRatio = 物理像素 / 实际像素;

    iphoneX是3倍屏，其它都是2倍屏

    retina屏是超高像素密度屏，同样大小的屏幕上显示的像素点由1个变为多个，同样苹果设备的retina屏中，像素点1个变为4个

    1、根据不同的设备像素比来加载不同的图片

        // 例如图片宽高为: 200px*200px，那么写法如下
        .css{ width:100px;height:100px;background-size:100px 100px; }

        // 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px
        .css{ font-size:20px }

        // image-set设计Rentina背景图
        image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。
        .css {
            background: url(images/bg.jpg) no-repeat center;
            background: -webkit-image-set(
            url(images/bg.jpg) 1x,     //支持image-set普通屏
            url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan
        }

        // javscript的解决方案
        $(document).ready(function(){
            if (window.devicePixelRatio &gt; 1) {
                var lowresImages = $(&apos;img&apos;);

                images.each(function(i) {
                    var lowres = $(this).attr(&apos;src&apos;);
                    var highres = lowres.replace(&quot;.&quot;, &quot;@2x.&quot;);
                    $(this).attr(&apos;src&apos;, highres);
                });
            }
        });

    https://www.jianshu.com/p/c88e9489b583

四、设置不同像素比的响应样式

    /* 2倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 2.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
        }
    }

    /* 3倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 3.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
        }
    }
</code></pre><h4 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h4><pre><code>1、空白页基本meta标签

    &lt;!-- 设置缩放 --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;

    &lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注: IOS7.0版本以后，safari上已看不到效果） --&gt;
    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;

    &lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;
    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;

    &lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;
    &lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;


2、其他meta标签

    &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;
    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;

    &lt;!-- 避免IE使用兼容模式 --&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;

    &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;
    &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;

    &lt;!-- 微软的老式浏览器 --&gt;
    &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;

    &lt;!-- uc强制竖屏 --&gt;
    &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;

    &lt;!-- QQ强制竖屏 --&gt;
    &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;

    &lt;!-- UC强制全屏 --&gt;
    &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;

    &lt;!-- QQ强制全屏 --&gt;
    &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;

    &lt;!-- UC应用模式 --&gt;
    &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;

    &lt;!-- QQ应用模式 --&gt;
    &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;

    &lt;!-- windows phone 点击无高光 --&gt;
    &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre><h4 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h4><pre><code>一、dns-prefetch 预加载

    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://g.alicdn.com&quot;&gt;

    dns-prefetch, DNS解析往往导致了网站加载速度慢。现代浏览器针对这个问题开发了处理方式，它将域名缓存后，当用户点击其它页面地址后自动的获取


二、prefetch 连接网页预先加载

    当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用。prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。

    &lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;

三、preconnect 

    和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）

    &lt;link rel=&quot;preconnect&quot; href=&quot;http://css-tricks.com&quot;&gt;


http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/
</code></pre><h4 id="打电话发短信写邮件怎么实现"><a href="#打电话发短信写邮件怎么实现" class="headerlink" title="打电话发短信写邮件怎么实现"></a>打电话发短信写邮件怎么实现</h4><pre><code>一、打电话
    &lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;

二、发短信，winphone系统无效
    &lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;

三、写邮件

    // 注: 在添加这些功能时，第一个功能以&quot;?&quot;开头，后面的以&quot;&amp;&quot;开头

    1.普通邮件
    &lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）
    &lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;

    3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）
    &lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址
    &lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    5.包含主题，用?subject=
    &lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;

    6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 
    &lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;

    7.内容包含链接，含http(s)://等的文本自动转化为链接
    &lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;

    8.内容包含图片（PC不支持）
    &lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;

    9.完整示例
    &lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;
</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>一、美化表单元素

    // 使用appearance改变webkit浏览器的默认外观
    input,select { -webkit-appearance:none; appearance: none; }

    // winphone下，使用伪元素改变表单元素默认外观
    1、禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰
        select::-ms-expand { display:none; }

    2、禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰
        input[type=radio]::-ms-check,
        input[type=checkbox]::-ms-check { display:none; }

    3、禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰
        input[type=text]::-ms-clear,
        input[type=tel]::-ms-clear,
        input[type=number]::-ms-clear { display:none; }


二、其它实用的css

    1、去掉webkit的滚动条——display: none;
        // 其他参数
        ::-webkit-scrollba //滚动条整体部分
        ::-webkit-scrollbar-thumb   //滚动条内的小方块
        ::-webkit-scrollbar-track   //滚动条轨道
        ::-webkit-scrollbar-button  //滚动条轨道两端按钮
        ::-webkit-scrollbar-track-piece  //滚动条中间部分，内置轨道
        ::-webkit-scrollbar-corner       //边角，两个滚动条交汇处
        ::-webkit-resizer            //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件

    2、禁止长按链接与图片弹出菜单
        a,img { -webkit-touch-callout: none }    

    3、禁止ios和android用户选中文字
        html,body {-webkit-user-select:none; user-select: none; }

    4、改变输入框placeholder的颜色值
        ::-webkit-input-placeholder { /* WebKit browsers */color: #999; }
        :-moz-placeholder { /* Mozilla Firefox 4 to 18 */color: #999; }
        ::-moz-placeholder { /* Mozilla Firefox 19+ */color: #999; }
        :-ms-input-placeholder { /* Internet Explorer 10+ */color: #999; }
        input:focus::-webkit-input-placeholder{ color:#999; }

    5、android上去掉语音输入按钮
        input::-webkit-input-speech-button {display: none}

    6、阻止windows Phone的默认触摸事件
        /*说明: winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如: */
        html { -ms-touch-action:none; } //禁止winphone默认触摸事件

        取消input在ios下，输入的时候英文首字母的默认大写
        &lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;

    7、手机拍照和上传图片
        // IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持
        &lt;input type=&quot;file&quot; accept=&quot;images/*&quot; /&gt;
        &lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;
</code></pre><h4 id="播放视频不全屏"><a href="#播放视频不全屏" class="headerlink" title="播放视频不全屏"></a>播放视频不全屏</h4><pre><code>&lt;!--
    1.ios7+支持自动播放
    2.支持Airplay的设备（如: 音箱、Apple TV)播放
    x-webkit-airplay=&quot;true&quot; 
    3.播放视频不全屏
    webkit-playsinline=&quot;true&quot; 
--&gt;
&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt;
</code></pre><h4 id="bug修改"><a href="#bug修改" class="headerlink" title="bug修改"></a>bug修改</h4><pre><code>android 2.3 bug
// 1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉
// 2.after和before伪类无法使用动画animation
// 3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值
// 4.translate百分比的写法和scale在一起会导致失效，例如: 
-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)

android 4.x bug
// 1.三星 Galaxy S4中自带浏览器不支持border-radius缩写
// 2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分
// 3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色
// 4.android无法同时播放多音频audio

一、消除transition闪屏
    .css {
        -webkit-transform-style: preserve-3d;
        -webkit-backface-visibility: hidden;
        -webkit-perspective: 1000;
    }

二、开启硬件加速

    //目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。
    .css {
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
    }

三、渲染优化

    1、禁止使用iframe（阻塞父文档onload事件）

    2、禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）

    3、使用CSS3代码代替JS动画

    4、开启GPU加速

    5、使用base64位编码图片(不小图而言，大图不建议使用),以减少网络请求。比较耗费CPU。小图标优势在于: 减少HTTP请求、避免文件跨域、修改及时生效
</code></pre><p>—————————– 移动端的JS ——————————–</p>
<h4 id="移动端touch事件（区分webkit和winphone）"><a href="#移动端touch事件（区分webkit和winphone）" class="headerlink" title="移动端touch事件（区分webkit和winphone）"></a>移动端touch事件（区分webkit和winphone）</h4><pre><code>一、当用户手指放在移动设备在屏幕上滑动会触发的touch事件

    1、以下支持webkit

        touchstart: 当手指触碰屏幕时候发生。不管当前有多少只手指
        touchmove: 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生: 阻止页面滚动
        touchend: 当手指离开屏幕时触发
        touchcancel: 系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用

    2、TouchEvent对象 : 

        touches: 屏幕上所有手指的信息
        targetTouches: 手指在目标区域的手指信息
        changedTouches: 最近一次触发该事件的手指信息
        touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息

        event.changedTouches[0].clientX  获取移动端事件

    3、参数信息(changedTouches[0])

        clientX、clientY在显示区的坐标
        target: 当前元素

    4、事件响应顺序

        ontouchstart  &gt; ontouchmove  &gt; ontouchend &gt; onclick

    5、以下支持winphone 8

        MSPointerDown: 当手指触碰屏幕时候发生。不管当前有多少只手指
        MSPointerMove: 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生: 阻止页面滚动
        MSPointerUp: 当手指离开屏幕时触发


二、移动端的web页面click事件会产生200-300ms的延时响应

    移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。

    原因: 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。

        比如在点击一个&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;时，浏览器先捕获是单击还是双击缩放，所以捕获一次单击后，浏览器会hold一段时间来看是否有下一次点击，这个时间间隔就是300ms，这就是延时的由来，所以使用click来触发事件需要延时300ms后才生效

    解决方案: 
        fastclick可以解决在手机上点击事件的300ms延迟
        zepto的touch模块，tap事件也是为了解决在click的延迟问题
</code></pre><h4 id="屏幕旋转的事件orientationchange"><a href="#屏幕旋转的事件orientationchange" class="headerlink" title="屏幕旋转的事件orientationchange"></a>屏幕旋转的事件orientationchange</h4><pre><code>JS处理

    function orientInit(){
        var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight ? &apos;landscape&apos; : &apos;portrait&apos;;
        if(orientChk ==&apos;lapdscape&apos;){
            //这里是横屏下需要执行的事件
        }
        else{
            //这里是竖屏下需要执行的事件
        }
    }

    orientInit();
    window.addEventListener(&apos;onorientationchange&apos; in window?&apos;orientationchange&apos;:&apos;resize&apos;, function(){
        setTimeout(orientInit, 100);
    },false)    


CSS处理

    // 竖屏时样式
    @media all and (orientation:portrait){   }

    // 横屏时样式
    @media all and (orientation:landscape){   }
</code></pre><h4 id="audio元素和video元素在ios和andriod中无法自动播放"><a href="#audio元素和video元素在ios和andriod中无法自动播放" class="headerlink" title="audio元素和video元素在ios和andriod中无法自动播放"></a>audio元素和video元素在ios和andriod中无法自动播放</h4><pre><code>// 音频，写法一
&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;

// 音频，写法二
&lt;audio controls=&quot;controls&quot;&gt; 
    &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt;
    &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt;
    优先播放音乐bg.ogg，不支持在播放bg.mp3
&lt;/audio&gt;

// JS绑定自动播放（操作window时，播放音乐）
$(window).one(&apos;touchstart&apos;, function(){
    music.play();
})

// 微信下兼容处理
document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () {
    music.play();
}, false);

// 小结
// 1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常
// 2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间
</code></pre><h4 id="重力感应事件"><a href="#重力感应事件" class="headerlink" title="重力感应事件"></a>重力感应事件</h4><pre><code>// 运用HTML5的deviceMotion，调用重力感应事件
if(window.DeviceMotionEvent){
    document.addEventListener(&apos;devicemotion&apos;, deviceMotionHandler, false)
}   

var speed = 30;
var x = y = z = lastX = lastY = lastZ = 0;
function deviceMotionHandler(event){
    var acceleration = event.accelerationIncludingGravity;
    x = acceleration.x;
    y = acceleration.y; 
    z = acceleration.z;
    if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed ){
        //这里是摇动后要执行的方法 
        yaoAfter();
    }
    lastX = x;
    lastY = y;
    lastZ = z;
}

function yaoAfter(){
    //do something
}
</code></pre><h4 id="设备判断"><a href="#设备判断" class="headerlink" title="设备判断"></a>设备判断</h4><pre><code>一、JS判断设备

    function deviceType(){
        var ua = navigator.userAgent;
        var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];    
        for(var i=0; i&lt;len,len = agent.length; i++){
            if(ua.indexOf(agent[i])&gt;0){   
                return agent[i];     
                break;
            }
        }
    }
    deviceType();
    window.addEventListener(&apos;resize&apos;, function(){
        deviceType();
    })

二、JS判断微信浏览器

    function isWeixin(){
        var ua = navigator.userAgent.toLowerCase();
        if(ua.match(/MicroMessenger/i)==&apos;micromessenger&apos;){
            return true;
        }else{
            return false;
        }
    }
</code></pre><h4 id="前端动画的几种方式"><a href="#前端动画的几种方式" class="headerlink" title="前端动画的几种方式"></a>前端动画的几种方式</h4><pre><code>一、动画方式

    1、css3的transition 和 animattion

    2、定时器, 最原始的“window.setTimout()”或者“window.setInterval()” 不断更新元素的状态位置等来实现动画

    3、requestAnimationFrame方法

    4、canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现

    5、SVG、WebGL

二、requestAnimationFrame  注意 Android不支持此方法

    requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。

    设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。

    1、对requestAnimationFrame方法处理兼容:

        window.requestAnimFrame = (function(){
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element){
                    window.setTimeout(callback, 1000 / 60);
                };
        })();

    2、Example

        &lt;div id=&quot;demo&quot; style=&quot;position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;&quot;&gt;&lt;/div&gt;
        &lt;script&gt;
            var demo = document.getElementById(&apos;demo&apos;);
            function render(){
                demo.style.left = parseInt(demo.style.left) + 1 + &apos;px&apos;; //每一帧向右移动1px
            }
            var requestID = requestAnimationFrame(function(){
                render();
                //当超过300px后才停止
                if(parseInt(demo.style.left) &lt;= 300) {
                    requestAnimationFrame(arguments.callee);        // arguments.callee调用函数本身，或者给函数一个名，参数传个名
                }
            });

            // cancelAnimationFrame(requestID);      // 停止动画重绘
        &lt;/script&gt;

三、常用动画库

    Ani.js -- 基于CSS动画的生命处理库
    Dynamics.js -- 创建具有物理运动效果动画的js库
    Animate.css -- 齐全的CSS3动画库
    Three.js -- 让用户通过javascript入手进入搭建webgl项目的类库

    http://www.tuicool.com/articles/uUfYry
    http://www.jianshu.com/p/280e0ef90b96
</code></pre><h4 id="fetch-新一代ajax"><a href="#fetch-新一代ajax" class="headerlink" title="fetch 新一代ajax"></a>fetch 新一代ajax</h4><pre><code>一、fetch的请求设置与响应

    fetch(&apos;/some/url&apos;, {
        method: &apos;get&apos;
    })
    .then(function(response) {
        // 成功
    })
    .catch(function(err) {
        // 出错了;等价于 then 的第二个参数,但这样更好用更直观 :(
    });


二、设置Header头

    fetch(&apos;https://www.baidu.com/search/error.html&apos;, {
        method: &apos;POST&apos;,
        headers: new Headers({
            &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;     // 指定提交方式为表单提交
        }),
        body: new URLSearchParams([[&quot;foo&quot;, 1],[&quot;bar&quot;, 2]]).toString()
    })
    .then((res)=&gt;{
        return res.text()
    })
    .then((res)=&gt;{
        console.log(res)
    })
</code></pre><h4 id="其它API"><a href="#其它API" class="headerlink" title="其它API"></a>其它API</h4><pre><code>一、querySelector()、querySelectorAll()

    获取元素 document.querySelector(&apos;#app&apos;);

二、window.devicePixelRatio 获取设备像素比，也叫做dpr

    这个属性是系统自动算出来的值返回给window.devicePixelRatio，公式就是

    // 比如ipone6 750px物理像素 / 375px设备像素，所以dpr为2，有这个属性不用我们就不用去算
    window.devicePixelRatio = 物理像素 / 设备独立像素;

三、getBoundingClientRect  js判断可视区域

    var htmlWidth = document.documentElement.getBoundingClientRect().width;     // html文档的宽度
    var top = document.documentElement.getBoundingClientRect().top;      // 元素顶端到可见区域顶端的距离
    var se = document.documentElement.clientHeight; // 浏览器可见区域高度。

四、document.documentElement、document.body

    document.body 获取body文档

    document.documentElement 获取HTML整个文档，从&lt;!DOCTYPE html&gt;开始

五、document.documentElement.getBoundingClientRect().width   获取html文档宽度

    获取文档可视区宽度

    问题
        document.body.clientWidth;   // 这里取的是body的宽度，如果body的宽度被改变
        window.innerWidth;      // 这里获取的是整个宽口的宽度，包括滚动条

    解决方法: document.documentElement.getBoundingClientRect().width
</code></pre><h4 id="问题收集"><a href="#问题收集" class="headerlink" title="问题收集"></a>问题收集</h4><pre><code>一、keydown侦听输入个数时，中文输入法输入个数的问题 

    let username = document.querySelector(&apos;#username&apos;);

    // 如果输入中文，输入法比如输 &quot;物品&quot; 五笔需要输入 &quot;trkk&quot;，这样size为4，这样对中文判断长度会有问题
    $(&apos;#username&apos;).on(&apos;keydown&apos;, function(){
        let size = $(this).val().length;
        console.log(size);    
    })

    // 解决方法，侦听compositionend事件，返回的size正常
    $(&apos;#username&apos;).on(&apos;compositionend&apos;, function(){
        let size = $(this).val().length;
        console.log(size);  
    })

    http://www.alloyteam.com/2017/03/moves-the-input-box-fill-series-a/
    http://www.alloyteam.com/2016/12/alloytouch-full-screen-scroll-plugin-released-30-seconds-to-get-smooth-page-h5/


二、一像素边框处理

    高清屏，1px实际是2x2个像素来渲染，有的还是3x3，所以border: 1px 移动端会渲染为2px或3px

    &lt;div class=&quot;bor-box&quot;&gt;
        &lt;div class=&quot;bor-querymidea&quot;&gt;通过伪类创建边框，在通过媒体查询来适配&lt;/div&gt;
    &lt;/div&gt;

    .bor-box{
        position: relative;
    }

    /* 这个就用1像素 */
    .bor-querymidea::after{
        content: &quot; &quot;;
        position: absolute;
        left: 0;
        bottom: 0;
        width: 100%;
        height: 1px;
        background-color: #000;
        -webkit-transform-origin: left bottom;
        transform-origin: left bottom;
    }

    /* 2倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 2.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
        }
    }

    /* 3倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 3.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
        }
    }


三、设置viewport 缩放比例

    (function(doc, win) {
        var scale = 1.0;
        if (win.devicePixelRatio === 2) {
            scale *= 0.5;
        }
        if (win.devicePixelRatio === 3) {
            scale *= 0.333333;
        }
        var text = &apos;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale +&apos;, minimum-scale=&apos; + scale + &apos;, width=device-width, user-scalable=no&quot; /&gt;&apos;;
        doc.write(text);       
    })(document, window);

    https://www.cnblogs.com/stella1024/p/7199832.html
</code></pre><h4 id="收集工具"><a href="#收集工具" class="headerlink" title="收集工具"></a>收集工具</h4><pre><code>1、browsersync 多端浏览器同步测试工具  http://www.browsersync.cn/

2、lib-flexible 处理根据屏幕的尺寸将Html中的font-size的值自动转换  https://github.com/amfe/lib-flexible

3、sublime的px转rem的插件   https://github.com/flashlizi/cssrem
</code></pre><p>| <a href="http://www.uigreat.com/page/guifan" target="_blank" rel="noopener">http://www.uigreat.com/page/guifan</a>            // 移动端屏幕尺寸集合<br>| <a href="http://cubic-bezier.com/#.55,.01,.38,.99" target="_blank" rel="noopener">http://cubic-bezier.com/#.55,.01,.38,.99</a>         // 调节css3动画效果并导出代码<br>| <a href="https://segmentfault.com/a/1190000007075834" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007075834</a>   // Retina屏<br>| <a href="http://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=404009356&amp;idx=1&amp;sn=e3218b95b78a5f043e7b0e3df49703d3&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=404009356&amp;idx=1&amp;sn=e3218b95b78a5f043e7b0e3df49703d3&amp;scene=4#wechat_redirect</a><br>| <a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html</a><br>| <a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/#prettyPhoto" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/#prettyPhoto</a>  rem</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/DOM/">DOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/DOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h4><pre><code>DOM 文档对象模型     D - Document      O - Object      M - Model
</code></pre><h4 id="Node-对象属性"><a href="#Node-对象属性" class="headerlink" title="Node 对象属性"></a>Node 对象属性</h4><pre><code>1、nodeType: 节点类型

    e.target.nodeType 来获取节点的类别

    1、Element 1

    2、Attr  2

    3、Text  3

    4、注释  8

    5、Document 9


2、nodeName: 节点名称   返回的是大写 &apos;DIV&apos;

3、nodeValue: 节点的类型

    元素节点的 nodeValue 是 undefined 或 null
    文本节点的 nodeValue 是文本本身
    属性节点的 nodeValue 是属性值

    &lt;p&gt;dfsdfsdf&lt;/p&gt;

    let oP = document.querySelector(&apos;p&apos;);   
    // 这里注意oP是元素如果直接写成oP.nodeValue返回是null，写成oP下的第一个节点才找到文本元素
    oP.firstChild.nodeValue;            

4、parentNode: 返回当前节点的父节点   e.target.parentNode.nodeName

    document.querySelector(&apos;ul&apos;).parentNode     // &lt;div class=&quot;box&quot;&gt;...&lt;/box&gt;

5、childNodes、children: 返回所有子节点元素，不包括孙节点

    &lt;ul id=&quot;list&quot;&gt;
        &lt;li&gt;111&lt;/li&gt;
        &lt;li&gt;222&lt;/li&gt;
        &lt;li&gt;
            &lt;ul&gt;
                &lt;li&gt;333&lt;/li&gt;
                &lt;li&gt;444&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;

    let oList = document.querySelector(&quot;#list&quot;);
    let lis = oList.children;
    for(let i=0; i&lt;lis.length; i++){
        console.log(lis[i].nodeName);   // output LI LI LI
    }

    ** childeNodes与children区别 ** 

        childeNodes: 包括空行的文本节点, 如果是空行的节点返回是一个text节点
        children: 不包括空行之类的节点

6、hasChildNodes(): 判断是否有子节点，返回Booleanw值

7、firstChild、lastChild: 返回子节点的第一个节点、最后一个节点

    firstChild 相当于 children[0]

    lastChilde 相当于 children[node.children.length-1]

    &lt;div id=&quot;car&quot;&gt;&lt;p&gt;aaa&lt;/p&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;/div&gt;

    let oCars = document.querySelector(&quot;#car&quot;);
    console.log(oCars.firstNode, oCars.lastNode);   //&lt;p&gt;aaa&lt;/p&gt; 、 &lt;span&gt;ccc&lt;/span&gt;

8、previousSibling、nextSibling: 当前节点的前一个节点、后一个节点

    注意: 如果是空行返回的是 text

9、innerHTML: 获取或修改HTML元素内容

    Element.innerHTML = &apos;&lt;div&gt;xxxxx&lt;div&gt;&apos;;

10、innerText: 获取或修改的是除去html的文本

11、outerHTML、outerText: 与innerHTML、innerText相当，不同的是它包含当前节点元素，inner只包含子节点元素

12、offsetParent: 获取当前元素定位的父元素  找到基于设置position的父元素

     document.querySelector(&apos;ul&apos;).offsetParent
</code></pre><h4 id="Node-对象的方法"><a href="#Node-对象的方法" class="headerlink" title="Node 对象的方法"></a>Node 对象的方法</h4><pre><code>一、节点操作方法

    1、getElementById(): 获取指定ID的元素

    2、getElementsByTagName(): 获取指定标签名称的所有元素

    3、getElementsByClassName(): 获取指定类名的元素

    4、appendChild(): 追加子节点  注意这里插入的是一个节点，而不是HTML的字符串 parent.appendChild(children);

    5、removeChild(): 删除子节点，不能删除孙子节点    (removeNode 只支持IE)

        删除节点 并返回删除的节点
        let oSubCar = document.querSelector(&apos;#subCar&apos;);
        document.querySelector(&apos;body&apos;).removeChild(oSubCar);        // &lt;div id=&quot;subCar&quot;&gt;...&lt;/div&gt;

    6、cloneNode(Boolean): 复制节点  如果参数为true复制指定节点下包括所有子节点，如果不写只复制当前节点不手包子节点

        &lt;div class=&quot;car&quot;&gt;
            &lt;ul id=&quot;box&quot;&gt;
                &lt;li&gt;aaa&lt;/li&gt;
                &lt;li&gt;bbb&lt;/li&gt;
                &lt;li&gt;ccc&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div id=&quot;subCar&quot;&gt;&lt;/div&gt;

        &lt;script&gt;
            // 将id=box所有的节点插入到id=subCar中
            let boxList = document.querySelector(&apos;#box&apos;).cloneNode(true);
            var oSubCar = document.querySelector(&apos;#subCar&apos;);
            oSubCar.appendChild(boxList);
        &lt;/script&gt;

    7、hasAttributes(): 判断当前节点是否拥有属性

        &lt;div id=&quot;miniCar&quot;&gt;&lt;/div&gt;
        &lt;div&gt;swsss&lt;/div&gt;

        let isAttribute = document.getElementsByTagName(&apos;div&apos;)[1].hasAttributes();
        console.log(isAttribute);   // false

    8、hasChildNodes(): 判断当前节点是否拥有子节点

    9、insertBefore(newitem, ex): 在指定节点之前插入

        insertAfter(): 这个需要自己来写没有这个方法

        let oMain = document.querySelector(&apos;#main&apos;);
        let oP = document.querySelector(&apos;p&apos;);
        let oUl = document.querySelector(&apos;.uls&apos;).cloneNode(true);
        oMain.insertBefore(oUl, oP);    将ul元素内所有节点复制并插入到oP元素之前

    10、replaceChild(newNode, oldNode): 替换节点

        document.querySelector(&apos;body&apos;).replaceChild(oMiniCar, oSubCar)


二、创建元素方法

    1、createAttribute(): 创建属性节点

    2、createElement(): 创建元素节点

    3、createTextNode(): 创建文本节点


三、操作属性方法

    1、getAttribute(): 获取属性值

    2、setAttribute(): 设置属性值
</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>1、style：获取或设置style值   Element.style.color = &apos;blue&apos; 

2、currentStyle、getCurrentStyle()获取样式中每个属性的值

    var oBox = document.querySelector(&apos;#box&apos;);
    var getStyle = function(obj, attr){
        return window.getComputedStyle ? window.getComputedStyle(obj, null)[attr] : obj.currentStyle[attr];
    }

    var attrTxt = getStyle(oBox, &apos;width&apos;);          // &apos;100px&apos;;

    注意: (1)中style只能获取元素中的内联样式，而currentStyle、getCurrentStyle()无论是内联样式还是在class中都可以找到

3、getComputedStyle(元素， 伪类): 获取指定元素值，currentStyle（ie独有） 

    &lt;script&gt;
        function getStyle(element, attr) {
            if(window.getComputedStyle) {
                return window.getComputedStyle(element, null)[attr];
            } else {
                return element.currentStyle[attr];
            }
        }

        // 获取class=position-node元素上的position值
        var dom = document.querySelector(&quot;.position-node&quot;);
        var style = getStyle(dom);
        console.log(style.position);    // 返回relative
    &lt;/script&gt;


    *** element.getComputedStyle与element.style的区别

    element.getComputedStyle: 只读
    element.style: 可读写

4、className: 获取或设置元素的类名  Element.addClass = &apos;classname&apos;
</code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><pre><code>1、write(): 向输出流写文本或html

2、document.title: 返回标题

4、&quot;javascript:&quot; : 伪协议 来调用javascript http协议(http://)，FTP协议(ftp://)

5、对象检测: 可以测试浏览器是否支持当前对象

    if(document.getElementById){ ...}
</code></pre><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><pre><code>1、createDocumentFragment: 创建文档碎片

    Example: 创建节点并插入到body中，如果不使用文档碎片，每次都需要重新插入一次

    var oFragment = document.createDocumentFragment();
    for(var i = 0 ; i &lt; 10; i ++) {
        var p = document.createElement(&quot;p&quot;);
        var oTxt = document.createTextNode(&quot;段落&quot; + i);
        p.appendChild(oTxt);
        oFragment.appendChild(p);
    }
    document.body.appendChild(oFragment);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、表单事件：

    submit事件

    reset事件

    click事件

    change事件

    focus事件（不冒泡） （IE和ES5支持冒泡的focusin）

    blur事件（不冒泡） （IE和ES5支持冒泡的focusout）

    input事件（ES5 textinput提供更方便的获取输入文字的方案）


2、Window事件

    load: 资源全部加载完成后触发事件（图片、css、js）

    DOMContentLoaded事件: Document对象构建完后就开始调用此事件

    readyStatechage事件:

    unload事件: 关闭borwser的时候触发

    beforeunload事件

    resize: 浏览器窗口发生改变触发

    scroll: 滚动条有变化时触发


3、鼠标事件

    click: 点击事件

    dbclick：双击事件

    mouseover: 鼠标移入事件（冒泡）

    mouseout: 鼠标移出事件（冒泡）

    mousedown: 鼠标按下事件

    mouseup: 鼠标放开事件

    contextmenu: 上下文本菜单事件

    mouseenter: 事件（不冒泡）

    mouseleave: 事件（不冒泡）

    mousewheel: 事件（FF DOMMouseScroll事件、DOM3 wheel事件）


4、键盘事件

    keydown事件

    keyup事件

    keypress事件
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/正则表达式/">正则表达式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/正则表达式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="特殊字符和转义序列"><a href="#特殊字符和转义序列" class="headerlink" title="特殊字符和转义序列"></a>特殊字符和转义序列</h4><pre><code>1、[...] 位于括号内的任意字符            

    /[abcde]/.test(&apos;aboot&apos;);     // 只要含有任意一个字符返回 true

    /a[bo]t/.test(&apos;abot&apos;);        // false 中间只能含有其中一个字符，匹配&apos;abt&apos;或&apos;aot&apos;

2、[^...] 不在括号中之中的任意字符

    /a[^bo]t/.test(&apos;ast&apos;);        // true a|t之间不含有b、o期中一个字符

*3、. 除了换行和Unicode行止符之外的任意字符

    /a.t/.test(&apos;a*t&apos;);        // true , &apos;a\nt&apos;换行false，使用 \.来进行转义

4、\w 任何ASCII字符,等于[a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // true, 不含有其它字符

5、\W 任何非ASCII字符单字字符，等于[^a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // false, 至少需要有一个特殊字符

6、\s 任何空格

    /\s/.test(&apos;I think&apos;);    // true

7、\S 不包含空格

    /\s/.test(&apos;I think&apos;);    // false, 非空格为true

8、\d 任何数字，等于[0-9]

9、\D 除了数字之外的任意字符

* 10、\b 独立部分 

* 11、\B 独立部分 
</code></pre><h4 id="指定匹配的位置"><a href="#指定匹配的位置" class="headerlink" title="指定匹配的位置"></a>指定匹配的位置</h4><pre><code>1、^ 匹配字符串的开头

    /^ab/.test(&apos;absolute&apos;);        // true 以ab开头

2、$ 匹配字符串的结尾

    /te$/.test(&apos;absolute&apos;);        // true 以te结尾

* 3、? ! 一个反前向声明者，含义与反前向声明相反
</code></pre><h4 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h4><pre><code>1、| 用于分隔选择的字符，相当于或

    /oa|on|op/.test(&apos;option&apos;);    // true，只要带有oa、on、op都匹配

2、(...) 分组，相当于并且

    /(\d+&amp;)([a-zA-Z]+%)/.test(&apos;1234&amp;abcde%&apos;);        // true, 必须包含数据+&amp;，并且还包含英文字母+%

* 3、(?...) 只组合，把项组合到一个单元，但不记忆与该组匹配的字符

    (?:):

    (?!):

    (?&lt;=):

    (?&lt;!):
</code></pre><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><pre><code>1、{ } 匹配一个字符的重复  **** 注意{3,10} 逗号后不能有空格, 如{3, 10}        

    /^\d{1,3}$/: 最少2个数字，最多4个数字

    /^\d{4,}$/: 最少有4个数字

    /^\d{4}$/: 只能有4个数字

2、* 表示0次或多次重复,等价于{0, }    /^\d*$/

3、？最少0次, 最多1次重复，等价于{0,1}   

4、+ 表示最少出现1次，等价于{1,}

5、\1、\2 重复的子项

    var reg = /(a)(b)(c)\1/;
    var str = &quot;abca&quot;;

    // 返回 true： \1是重复第一个子项(a)，相当于/(a)(b)(c)(a)/.     \2就是第二项(b)
    console.log(reg.test(str));
</code></pre><h4 id="修饰符，高级匹配"><a href="#修饰符，高级匹配" class="headerlink" title="修饰符，高级匹配"></a>修饰符，高级匹配</h4><pre><code>1、g 匹配的是全局，检索字符串的所有匹配

    如果不加g只匹配第一个后就退出

    let reg = /你妈的|去你妈|傻逼/g;
    let content = &apos;你妈的房子傻逼是用来住的你妈的不是用来炒的去你妈的吧&apos;;
    content = content.replace(reg, &apos;***&apos;);
    console.log(content)            // ***房子***是用来住的***不是用来炒的***的吧

2、i 匹配忽略大小写

    /java/i.test(&apos;JavdaScript&apos;);        // true

3、m 进行多行匹配
</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>1、match(reg) 将匹配结果返回一个数组

    var arr = &apos;123kasdo34kk234k234234k&apos;.match(/\d+/g);        // 如果不加g，只返回第一个
    console.log(arr);        // [&quot;123&quot;, &quot;34&quot;, &quot;234&quot;, &quot;234234&quot;]

2、test() 如果没有匹配返回false否则返回true

3、search(reg) 查找并返回所在的位置，如果没有匹配的返回-1

    var result = &apos;房地产行业究竟是白银时代还是钻石时代&apos;.search(/钻石/); 
    console.log(result);        // 返回 8

4、content.replace(reg, str) 用于执行检索和替换操作

5、exec() [ɪɡ&apos;zek] 如果找到返回一个数组并存放匹配的结果，如果没有找到返回null

    var result = /白银|钻石/g.exec(&apos;房地产行业究竟是白银时代还是钻石时代&apos;); 
    console.log(result);        // [&apos;&apos;]
</code></pre><h4 id="整理经验"><a href="#整理经验" class="headerlink" title="整理经验"></a>整理经验</h4><pre><code>1、如果检查全部需要前后加匹配

    /\d+/  只对字符中存在数字就匹配

    /^\d+$/  对字符中全部为数字的进行匹配


2、test()、exec()是对每一个字符串进行匹配，如果为true就不会往下执行，并返回true

    例如: 匹配字符中不能带有.字符
    /[^\.]/.test(&apos;123123.&apos;);    // 返回true，因为第一个字符就不是.返回true不在往下执行

    /[\.]/.test(&apos;23412.34&apos;);    // 如果存在就返回true
    或者
    /^[^\.]$/g.test(&apos;asdfa.sdf&apos;) // 返回true

3、| 或符号只能用到()中，不能在[]中使用
</code></pre><h4 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h4><pre><code>1、密码强度

    // 弱密码 - 纯数字、纯字母或纯特殊字符
    /^(?:\d+|[a-zA-Z]+|[!@#$%^&amp;*]+)$/

    // 中密码 - 字母+数字，字母+特殊字符，数字+特殊字符
    /^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$/

    // 强密码 - 必须有数字、小写字母、大写字母和特殊字符
    /^(?=.*((?=[!@#$%^&amp;*_]+)[^A-Za-z0-9]))(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[^\u4e00-\u9fa5]{8,16}$/


2、手机号码验证

    /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139|186|185|170|156|155|130|131|132|189|180|170|153|133)(\d){8}$/.test(&apos;13012345678&apos;)

    移动号段: /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139)(\d){8}$/;     

    联通号段: /^(186|185|170|156|155|130|131|132)(\d){8}$/

    电信号段: /^(189|180|170|153|133)(\d){8}$/


3、验证Email - /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/

4、验证中文 - /^[\u4e00-\u9fa5]+$/

5、域名验证 - /^(http(s)?:\/\/)(www)?\.\w+\.(com|cn|net|org)$/

6、手机号前带86或是+86 - /^((\+86)|(86))?(13)\d{9}$/

7、电话号码与手机号码同时验证 - /(^(\d{3,4}-)?\d{7,8})$|(13[0-9]{9})/

8、验证IP地址 - /^((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)$/;    //  匹配0-255, 匹配&apos;255.255.255.255&apos;

9、邮政编码 - /[1-9]{1}(\d+){5}/

10、身份证号码 - /\d{18}|\d{15}/

11、双字节字符串(汉字) - /[^\x00-\xff]*/

12、去除两端空格 - /^\s*|\s*$/

数字正则

    /^\d+$/ - 非负整数（正整数 + 0)

    /^[1-9](\d)+$/ - 正整数(不可以以0开头)  

    /^-(\d)+$/ - 非正整数（负整数 + 0） 

    /^-[1-9]?(\d){0,}$/ - 负整数(-12345), 不可以-012312

    /^[1-9]?(\d)+\.(\d)+$/ - 浮点数   

    ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$    //正浮点数   
    ^((-\\d+(　　//非正浮点数（负浮点数 + 0）   
    ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$  //负浮点数  

    /^[A-Za-z]+$/ - 由26个英文字母组成的字符串   

    /^[A-Z]+$/ - 由26个英文字母的大写组成的字符串   

    /^[a-z]+$/ - 由26个英文字母的小写组成的字符串  

    /^[A-Za-z0-9]+$/ - 由数字和26个英文字母组成的字符串   

    /^\w+$/ - 由数字、26个英文字母或者下划线组成的字符串
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/javascript设计模式/">设计模式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/javascript设计模式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/设计模式/">设计模式</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 面向对象(类型判断、封装、多态、闭包、高阶函数)<br>| 单例模式 - 命名空间、只被实例化一次<br>| 工厂模式 - 加工在输厂的过程<br>| 外观模式 - 将复杂的接口统一，用于低层兼容<br>| 适配器模式 - 将一个接口转化为另一个接口<br>| 代理模式 - 一个对象不能直接访问另一个对象时，使用代理对象<br>| 装饰者模式 - 不改变原有对象的，并对其进行拓展<br>| 桥接模式 - 提取公用的方法，并通过桥接来进行连接<br>| 享元模式 -<br>| 观察者模式 -<br>| 状态模式 -<br>| 访问者模式 -<br>|<br>| 组合模式<br>| 策略模式 - 将一组算法封装起来，使其可以相互之间替换<br>| 中介者模式</p>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><pre><code>只能将带有duckSinging()方法的对象加入到 choir 数组中

&lt;script&gt;

    // 方法一
    var duck = {
        duckSinging: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 方法二
    var chicken = {
        chicken: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 存储带有duckSinging()方法的对象
    var choir = [];

    var joinChoir = function(animal){
        if(animal &amp;&amp; typeof animal.duckSinging == &apos;function&apos;){        // 只能加入带有duckSinging()方法的对象
            choir.push(animal);
            console.log(&apos;恭喜入合唱团&apos;);
            console.log(&apos;合唱团已有成员数量&apos;, choir.length);
        }
    }

    joinChoir(duck);
    joinChoir(chicken);

&lt;/script&gt;
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>封装: 目的是将信息隐藏, 其它语言通过private、public、protected来处理访问权限

js没有这些关键字通过变量的作用域来实现封装

&lt;script&gt;
    var Book = funtcion(id, bookname, price){
        // 私有属性
        var name = 1;

        // 私有方法
        function checkId(){ }

        // 公有属性
        this.id = id;
        this.bookname = bookname;

        // 公有方法
        this.copy = function(){}

        // 特权方法
        this.getName() = function{ return name }
    }

    // 在原型 (prototype) 来添加属性和方法，有两种方式
    // 1、为原型一一添加属性和方法
    // 2、将一个对象赋给原型

    Book.prototype.display = function(){
        // 展示这本书
    }

    Book.prototype = {            // 这种方法会将prototype下的constructor被覆盖掉
        display: function(){
            // 展示这本书
        }
    }
&lt;/script&gt;

&lt;script&gt;
    // 闭包实现 1
    var Book = (function(){
        // 静态私有变量
        var bookNum = 0;

        // 静态私有方法
        function checkBook(name){}

        // 返回构造函数
        return function(newId, newName, newPrice){
            var name, price;
            function checkId(name){}
        }
    });

    Book.prototype = {
        isJSBook: false,
        display: function(){}
    }


    // 闭包实现 2
    var Book = (function(){

        // 私有变量
        var bookNum = 0;

        // 私有方法
        function checkBook(name){ }

        // 创建类
        function _book(newId, newName, newPrice){}
        _book.prototype = {}

        return _book
    })();
&lt;/script&gt;
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code>一、类式继承

    将父类的实例赋给子类的原形，类式继承的原因: 类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问

    &lt;script&gt;

        // 父类
        function Parent(){
            this.name = &apos;siguang&apos;
        }

        Parent.prototype.say = function(){ 
            console.log(this.name);
        }

        // 子类                
        function Childer(){}

        Childer.prototype = new Parent();   // 类式继承

        // 上一步执行后prototype的constructor会指向Parent，因为constructor指向还是在Paremt类上
        Childer.prototype.constructor = Childer;

        Childer.prototype.getSubValue = function(){
            console.log(&apos;getSubValue&apos;)
        }

        // 实例
        var oParent = new Parent();
        var oChilder = new Childer();

        oParent.say();                // siguang
        oChilder.say();                // siguang
        console.log(oChilder.name); // siguang
        oChilder.name = &apos;haha&apos;;
        oChilder.say();                // haha
        oChilder.getSubValue();        // getSubValue
    &lt;/script&gt;


二、构造函数式继承

    /*
    * 构造函数继承
    * 继承非prototype下的属性和方法
    */
    &lt;script&gt;
        // 父类继承
        function SuperClass(id){
            this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;];
            this.id = id;
            this.showId = function(){
                console.log(this.id);
            }
        }
        SuperClass.prototype.showBooks = function(){
            console.log(this.books);
        }

        // 声明子类
        function SubClass(id){
            // 继承父类所有公用属性和方法（this下的内容），但不继承prototype下的属性和方法
            SuperClass.call(this, id);
        }

        // SubClass.prototype.constructor = SubClass;

        var sub1 = new SubClass(10);
        var sub2 = new SubClass(20);

        sub1.books.push(&apos;设计模式&apos;);    
        console.log(sub1.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;设计模式&apos;]
        console.log(sub1.id);            // 10
        // sub1.showBooks();            // 报错，不
        sub1.showId();                    // 10

        console.log(sub2.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]
        console.log(sub2.id);            // 20
    &lt;/script&gt;


总结: 类似继承与构造函数式继承的区别

    1、类似继承: ChildreClass.prototype = new ParentClass();

        继承父类的公用属性和方法（this.的内容）和 prototype下的属性和方法, 需要改变constructor的名字

    2、构造函数式继承: ParentClass.call(this);

        只能继承公用属性和就去，不能继承父类prototype下的属性和方法, 不需要改变constructor的名字


三、原型继承

    通过一个继承方法，创建一个过渡对象，将继承的父对象赋给过渡对象的原型，在返回过渡对象的实例

    &lt;script&gt;
        var Parent = function(){
            this.blod = 20;
            this.level = 1;
        }
        Parent.prototype.getBlod = function(){
            console.log(this.blod, this.level);
        }

        Object.create = Object.create || function(obj){
            var F = function(){};        // 声明一个过渡对象
            F.prototype = obj;            // 过渡对象的原型继承父对象
            return new F();                // 返回过渡对象的一个实例，该实例的原型继承了父对象
        }

        var oParent = new Parent();
        var oChilde = Object.create(oParent);

        oChilde.blod = 30;    // 如果clone不设置blod属性，会到prototype的指向中找，最终会在oParent中找到属性
        oChilde.getBlod();    // 30 1

        oParent.getBlod();    // 20 1
    &lt;/script&gt;


四、寄生式继承

    就是将原型继承在二次封装，并返回一个对象

    &lt;script&gt;

        // 寄生式继承
        // 声明基对象
        var book = {
            name: &apos;js book&apos;,
            alikeBook: [&apos;css book&apos;, &apos;html book&apos;]
        }

        function createBook(obj){
            // 通过原型继承方式创建新对象
            var o = new inhreitObject(obj);
            // 拓展新对象
            o.getName = function(){
                console.log(this.name);
            }

            // 返回拓展新对象
            return o;
        }

        function inhreitObject(obj){
            var F = function(){};
            F.prototype = obj;
            return new F();
        }


        var oCreateBook = createBook(book);
        oCreateBook.getName();            // &apos;js book&apos;

    &lt;/script&gt;


五、多继承

    只适用于对象，不适用构造函数，继承某一个类，和继承多个类

    &lt;script&gt;

        // 单继承 属性复制
        // 这种是浅复制，象jquery等框架实现了深度复制
        var extend = function(target, source){
            // 遍历源对象中的属性
            for(var property in source){
                // 将源对象中的属性复制到目标对象中
                target[property] = source[property];
            }

            // 返回目标对象
            return target;
        }


        var book = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }
        var anotherBook = {
            color: &apos;blue&apos;
        }

        extend(anotherBook, book);
        console.log(anotherBook.name);
        console.log(anotherBook.alike);
        console.log(book, anotherBook);



        // 多继承 多个对象继承 属性复制
        var mix = function(){
            var i = 1,                    // 从第二个参数起为被继承的对象
                len = arguments.length,    // 获取参数长度
                target = arguments[0],    // 第一个对象为目标对象
                arg;                    // 缓存参数对象

            // 遍历被继承的对象
            for(; i&lt;len; i++){
                // 缓存当前对象
                arg = arguments[i];
                // 遍历被继承对象中的属性
                for(var property in arg){
                    // 将被继承对象中的属性复制到目标对象中
                    target[property] = arg[property];
                }
            }
            return target;
        }


        var book1 = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }

        var book2 = {
            tag: &apos;书&apos;
        }

        var book3 = {
            detail: &apos;产品优势&apos;
        }

        var newBook = mix(book1, book2, book3);

    &lt;/script&gt;
</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><pre><code>多态: 就是调用同一对象，通过参数发出不同指令，执行不同的结果

&lt;script&gt;

    var googleMap = {
        show: function(){
            console.log(&apos;开始渲染谷歌地图&apos;);
        }
    }

    var baiduMap = {
        show: function(){
            console.log(&apos;开始渲染百度地图&apos;);
        }
    }

    // 渲染地图
    var renderMap =  function(map){

        // 如果对象下有show方法就执行
        if(map.show instanceof Function){        
            map.show();
        }

        // 另一个判断类型模式
        // if(map &amp;&amp; typeof map.show == &apos;function&apos;){
        //     map.show();
        // }
    }

    renderMap(googleMap);
    renderMap(baiduMap);

&lt;/script&gt;
</code></pre><h4 id="闭包、高阶函数"><a href="#闭包、高阶函数" class="headerlink" title="闭包、高阶函数"></a>闭包、高阶函数</h4><pre><code>高阶函数至少满足以下条件之一

一、函数可以作为参数被传递

    &lt;script&gt;
        var getUserInfo = function(userId, callback){
            $.ajax(&apos;http://xx.com/user?uid=&apos;+userId, function(data){
                if(typeof callback == &apos;function&apos;){
                    callback();
                }
            })
        }
    &lt;/script&gt;

二、函数可以作为返回值输出

    &lt;script&gt;

        // 函数作为返回值输出
        var isType = function(type){
            return function(obj){
                return Object.prototype.toString.call(obj) === &apos;[object &apos;+ type +&apos;]&apos;
            }
        } 

        var str = &quot;sdfsdf&quot;
        var isString = isType(&apos;String&apos;);
        console.log(isString(str));        // true
    &lt;/script&gt;
</code></pre><h4 id="全局变量的解决方法"><a href="#全局变量的解决方法" class="headerlink" title="全局变量的解决方法"></a>全局变量的解决方法</h4><pre><code>避免全局函数: 1、对象方法   2、函数对象    3、构造函数

&lt;script&gt;

    // 都是全局变量
    function checkName(){
        // 验证姓名
    }

    function checkEmail(){
        // 验证邮箱
    }

    function checkPassword(){
        // 验证密码
    }

    /*
    * 方法一 对象收编全局变量
    */
    var ChceckObject = {
        checkName: function(){
            // 验证姓名
        },
        checkEmail: function(){
            // 验证邮箱
        },
        checkPassword: function(){
            // 验证密码
        }
    }


    /*
    * 方法二 函数对象
    */
    var CheckObject = function(){
        return {
            checkName: function(){
                // 验证姓名
            },
            checkEmail: function(){
                // 验证邮箱
            },
            checkPassword: function(){
                // 验证密码
            }
        }
    }

    // 调用
    var oCheck = CheckObject();
    oCheck.checkName();


    /*
    * 方法三 构造函数写法
    */
    var CheckObject = function(){
        this.checkName = function(){
            // 验证姓名
        }
        this.checkEmail = function(){
            // 验证邮箱
        }
        this.checkPassword = function(){
            // 验证密码
        }
    }

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 创建型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><pre><code>单例模式: 又被称为单体模式，只允许实例化一次的对象类

全局变量 var a = {};    属于单例对象, 不属于单例模式

jquery就是一个很大的单例,js载入时被初始化一次

    (function(){
        var jquery = (function(){})();
        window.jQuery = window.$ = jQuery;
    })(window);


一、最简单的单例就是一个对象

    var app = {
        util: {},
        tool: {},
        ajax: {}
    }


二、私有变量的单例模式，减少全局变量方法

    1、使用命名空间

        var MyApp = {};

        MyApp.namespace = function(name){
            var parts = name.split(&apos;.&apos;);
            var current = MyApp;
            for(var i in parts){
                if(!current[parts[i]]){
                    current[parts[i]] = {}
                }
                current = current[parts[i]];
            }
        }

        MyApp.namespace(&apos;event&apos;);
        MyApp.namespace(&apos;dom.style&apos;);


    2、使用闭包封装私有变量

        var user = (function(){
            var _name = &apos;sven&apos;,
                _age = 30;

            return {
                getUserInfo: function(){
                    return _name +&apos;-&apos;+ _age;
                }
            }
        })();


三、惰性单例模式

    &lt;script&gt;

        // 惰性单例模式  只有在需要的时候才会创建
        var createLoginLayer = (function() {
            var div;
            return function() {
                if (!div) {
                    div = document.createElement(&apos;div&apos;);
                    div.className = &apos;dialog&apos;;
                    div.innerHTML = &apos;我是登录窗口&apos;;
                    div.style.display = &apos;none&apos;;
                    document.body.appendChild(div);
                }

                return div
            }
        })();

        var oLoginBtn = document.querySelector(&apos;#loginBtn&apos;);
        oLoginBtn.onclick = function(){
            var oLayer = createLoginLayer();
            oLayer.style.display = &apos;block&apos;;
        }

    &lt;/script&gt;
</code></pre><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><pre><code>工厂模式: 将不同的参数传入到工厂方法中，进行加工后，然后在返回新的产品

// 创建一个工厂函数，并将结果返回
function createPerson(name, age, sex){
    var createObject = {};

    // 加工
    createObject = {    
        name: name,
        age: age,
        sex: sex,
        showInfo: function(){
            console.log(&apos;姓名:&apos;+ this.name +&quot;  年龄:&quot; + this.age);
        }
    }

    // 返回成品
    return createObject;
}

var person = createPerson(&apos;siguang&apos;, 30, &apos;男&apos;);
person.showInfo();
</code></pre><h4 id="建造者模式-builder"><a href="#建造者模式-builder" class="headerlink" title="建造者模式 builder"></a>建造者模式 builder</h4><pre><code>将一个复杂对象的构建层与表示层相互分离
</code></pre><h4 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h4><pre><code>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性及方法

&lt;script&gt;

    // 定义一个基本的图片轮播对象
    var LoopImages = function(imgArr, container){
        this.imgArr = imgArr;
        this.container = container;
    }
    LoopImages.prototype = {
        // 创建
        createImage: function(){
            console.log(&apos;loopImage createImage function&apos;);
        },
        // 切换方法
        changeImage: function(){
            console.log(&apos;LoopImage changeImage function&apos;);
        }
    }

    // 定义一个上下滑动的效果
    var SliderLoopImage = function(imgArr, container){
        LoopImages.call(this, imgArr, container);
    }
    SliderLoopImage.prototype = new LoopImages();            // 就是类似继承，并将要改变的方法重写

    // 重写切换方法
    SliderLoopImage.prototype.changeImage = function(){
        console.log(&apos;SlideLoopImg changeImage function&apos;);
    }

    var oSlider = new SliderLoopImage([&apos;1.jpg&apos;, &apos;2.jpg&apos;], &apos;#box&apos;);
    oSlider.createImage();
    oSlider.changeImage();

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 结构型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><pre><code>外观模式: 为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易

// 外观模式实现
function addEvent(dom, type, fn){
    if(dom.addEventListener){
        dom.addEventListener(type, fn, false);
    }
    else if(dom.attachEvent){
        dom.attachEvent(&apos;on&apos;+type, fn);
    }
    else{
        dom[&apos;on&apos;+type] = fn;
    }
}

var myInpurt = document.querySelector(&apos;#myinput&apos;);

addEvent(myInpurt, &apos;click&apos;, function(){
    console.log(&apos;绑定第一个事件&apos;)
})
</code></pre><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><pre><code>适配器模式: 将一个类的接口转化成另外一个接口，使类之间的接口不兼容问题通过适配器得以解决

一、如果有jQuery框架，现在A框架与jQuery框架基本相同可以将两种框架适配

    // 定义A框架
    var A = jQuery || {};

    A.g = function(id){
        return document.getElementById(id);
    }

    A.on = function(id, type, fn){
        var dom = typeofi id === &apos;String&apos; ? A.g(id) : id;
        if(dom.addEventListener){
            dom.addEventListener(type, fn, false);
        }
        else if(dom.attachEvent){
            dom.attachEvent(&apos;on&apos;+type, fn);
        }
        else{
            dom[&apos;on&apos;+type] = fn;
        }
    }

二、jquery适配器

    window.A = A = jQuery;

三、参数适配

    function doSomeThing(obj){
        var adapter = {
            name: &apos;雨夜&apos;,
            titel: &apos;设计&apos;,
            age: 30,
            color: &apos;pink&apos;,
            size: 100,
            prize: 50
        }

        for(var key in adapter){
            adapter[key] = obj[key] || adapter[key];        // 处理如果obj没有的参数
        }
        return adapter;            // 也可以使用extend();
    }
</code></pre><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><pre><code>代理模式: 由于一个对象不能直引用另一个对象，所以需要一个代理对象来为两个对象之间起到中介作用

&lt;script&gt;
    var Flower = function(){};

    var xiaoming = {
        sendFlower: function(target){
            var flower = new Flower();
            target.receiveFlower(flower);
        }
    }

    // B代理小明去给A送花
    var B = {
        receiveFlower: function(flower){
            A.listenGoodModd(function(){        // 侦听A的心情
                A.receiveFlower(flower);
            })
        }
    }

    // A接收小明的花
    var A = {
        receiveFlower: function(flower){
            console.log(&apos;收到花&apos;+ flower);
        },
        listenGoodModd: function(fn){
            setTimeout(function(){
                fn()
            }, 10000);
        }
    }

    xiaoming.sendFlower(B);
&lt;/script&gt;
</code></pre><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><pre><code>装饿者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求

&lt;p&gt;姓名: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;username&quot; /&gt;&lt;span id=&quot;usernameError&quot;&gt;Error username xxxx&lt;/span&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;密码: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;password&quot; /&gt;&lt;span id=&quot;passwordError&quot;&gt;Error password xxxx&lt;/span&gt;&lt;/p&gt;

&lt;script&gt;

    /*
    * 装饰者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求
    */

    // 点击文本框，显示提示信息，并保留原input上的事件
    var username = document.querySelector(&apos;#username&apos;);
    var password = document.querySelector(&apos;#password&apos;);

    // 基础需求，点击文本框后会加入文本内容
    username.onclick = function(){
        this.value = &apos;初始化username&apos;;
    }.bind(username);

    password.onclick = function(){
        this.value = &apos;初始化password&apos;;
    }.bind(password);


    // 新增的需求，点击后需要有提示消息，这里不破坏原有的功能
    // 装饰者方法
    var decorator = function(input, fn){
        var input = document.querySelector(input);

        // 判断事件是否已经绑定事件
        if(typeof input.onclick == &apos;function&apos;){
            // 缓存input本身的处理的事件
            var oldClickFn = input.onclick;

            // 为事件定义新的事件, 执行将新好的方法全执行
            input.onclick = function(){
                oldClickFn();
                fn();
            }
        }
        else{
            input.onclick = fn;
        }
    }

    // 调用
    decorator(&apos;#username&apos;, function(){
        document.querySelector(&quot;#usernameError&quot;).style.display = &apos;block&apos;;
    })
    decorator(&apos;#password&apos;, function(){
        document.querySelector(&quot;#passwordError&quot;).style.display = &apos;block&apos;;
    })

&lt;/script&gt;
</code></pre><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><pre><code>桥接模式: 将一个功能有共用的部分抽取出来，将实现与抽出来共用方法，通过桥接方法链接在一起，这就是桥接模式

&lt;div class=&quot;box&quot;&gt;
    &lt;span&gt;最新回答&lt;/span&gt;
    &lt;span&gt;热门回答&lt;/span&gt;
    &lt;span&gt;等待回答&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
    var box = document.querySelector(&apos;.box&apos;);
    var spans = box.getElementsByTagName(&apos;span&apos;);

    // 抽出的公用
    function changeColor(dom, color, bg){
        dom.style.color = color;
        dom.style.backgroundColor = bg;
    }

    // 桥接模式
    function bindSpan(){
        var i = 0;
        var len = spans.length;

        for(i; i&lt;len; i++){
            spans[i].onmouseover = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#ffbb96&apos;);
            }
            spans[i].onmouseout = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#fff2e8&apos;);
            }                
        }
    }

    bindSpan();
&lt;/script&gt;
</code></pre><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><pre><code>享元模式: 运用共享技术有效地支持大量细粒的对象，避免对象间有相同内容造成多余的开销
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 行为型设计模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>观察者模式 - 又称发布订阅模式或消息机制
</code></pre><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><pre><code>状态模式 - 当一个对象内部状态发生改变时，会导致行为改变

状态模式是解决程序中臃肿的分支判断语句问题，将每个分支转化一种状态独立出来

&lt;script&gt;

    // 创建一个玛丽类
    var MarryState = function(){

        // 存储内部状态
        var _currentState = {};

        // 动作与状态方法映射
        var states = {
            jump: function(){
                console.log(&apos;jump&apos;);
            },
            move: function(){
                console.log(&apos;move&apos;);
            },
            shoot: function(){
                console.log(&apos;shoot&apos;);
            },
            squat: function(){
                console.log(&apos;squat&apos;);
            }
        };

        // 动作控制类
        var Action = {

            // 改变状态方法
            changeState: function(){
                var arg = arguments;
                _currentState = {};
                if(arg.length){
                    for(var i=0, len=arg.length; i&lt;len; i++){
                        _currentState[arg[i]] = true;
                    }
                }
                return this;
            },

            // 执行动作
            goes: function(){
                console.log(&apos;触发一次动作&apos;);
                for(var i in _currentState){
                    states[i] &amp;&amp; states[i]();       // 如果动作存在并执行
                }
                return this;
            }
        }

        return {
            change: Action.changeState,
            goes: Action.goes
        }
    }


    MarryState()
        .change(&apos;jump&apos;, &apos;shoot&apos;)
        .goes()

&lt;/script&gt;
</code></pre><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><pre><code>策略模式: 定义一系列算法，把他们封装起来，并使它们可以相互替换

策略模式由两部分组成:

    1、策略类，策略类封装了具体的算法，并负责具体的计算过程

    2、环境类，接受客户的请求，把请求委托给一个策略类

Example:

    &lt;script&gt;
        // 需求根据KPI等级返回奖金金额

        // 定义策略类
        var strategies = {
            &apos;S&apos;: function(salary){
                return salary * 4;
            },
            &apos;A&apos;: function(salary){
                return salary * 3;
            },
            &apos;B&apos;: function(salary){
                return salary * 2;
            }
        }

        // 环境类
        var calculateBonus = function(level, salary){
            return strategies[level] &amp;&amp; strategies[level](salary);
        }

        console.log(calculateBonus(&apos;B&apos;, 2000));        // 4000
        console.log(calculateBonus(&apos;S&apos;, 5000));        // 20000

    &lt;/script&gt;
</code></pre><h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><pre><code>职责链模式 - 解决请求的发送者与请求的接受者之间的耦合
</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><pre><code>命令模式 - 将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数
</code></pre><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><pre><code>迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部

&lt;script&gt;
    var isType = function(type){
        var callType =  Object.prototype.toString.call(type);

        switch(callType){
            case &apos;[object Object]&apos;:
                return &apos;object&apos;;
                break;

            case &apos;[object Array]&apos;:
                return &apos;array&apos;;
                break;

            default: 
                return false;
                break;
        }
    }

    var each = function(arr, callback){
        if(isType(arr) == &apos;object&apos;){
            for(var key in arr){
                callback.call(arr[key], key, arr[key]);
            }
        }
        else if (isType(arr) == &apos;array&apos;){
            for(var i=0; i&lt;arr.length; i++){
                callback.call(arr[i], i, arr[i]);
            }
        }
    }

    each([1, 2, 3], function(index, val){
        console.log(index, val);
    })

    each({name: &apos;siguang&apos;, age: 32, sex: &apos;男&apos;}, function(key, val){
        console.log(key, val);
    })
&lt;/script&gt;
</code></pre><h4 id="发布订阅模式模式"><a href="#发布订阅模式模式" class="headerlink" title="发布订阅模式模式"></a>发布订阅模式模式</h4><pre><code>发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变，所有依赖于它的对象都将得到通知.

js中事件模型来替代传统的发布订阅模式
</code></pre><p>| <a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/ES5/">ES5</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/ES5/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h4><pre><code>1、async: 异步下载当前脚本，不阻塞后续代码的执行

2、charset: 字符集

3、defer: 表示当前脚本延迟到文档完全被解析和显示后在执行 defer=&quot;defer&quot;

4、src: 文件路径

5、language: 语言

6、type: 脚本类型

&apos;use strict&apos; 严格模式
</code></pre><h4 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h4><pre><code>作用域: 变量和函数可访问的范围，作用域分为局部和全局，函数中声明的变量叫局部变量，在window对象下定义的变量为全局变量

作用域链: 决定哪些变量能够被当前函数访问及访问顺序

    函数对象有一个[[Scope]]属性，包含了函数被创建作用域中对象的集合，集合被称为函数的作用域链scope chain，它决定了哪些数据能被函数访问

    function doSomething(){
        var blogName=&quot;Jessica&quot;;
        function innerSay(){
            alert(blogName);
        }
        innerSay();
    }
    alert(blogName);        //脚本错误
    innerSay();             //脚本错误
</code></pre><h4 id="js预解析"><a href="#js预解析" class="headerlink" title="js预解析"></a>js预解析</h4><pre><code>JS执行时先将代码中所有 var定义变量和function(){} 进行提取，函数内部变量除外。

将var的变量赋为undefined

将函数都为函数本身function getName(){}，所以在调用函数时无论在前还是在后都会被调用。

Example:
    var add = &apos;bbb&apos;; 
    function add(){console.log(&apos;aaa&apos;)} 

    add();      报错
</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code>闭包: 函数嵌套，内部函数调用外部函数的局部变量，内部函数执行完后自动消毁，外部函数的变量不会被回收一直保存在内存中.

&lt;script&gt;
    var fun = function(){
        var a = 1;
        return function(){
            a++;
            alert(a);
        }
    }

    var f = fun();        // 这里返回了匿名函数的引用，里面的局部变量就不会被消毁
    f();    // 2
    f();    // 3
    f();    // 4
&lt;/script&gt;
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>1、函数没有重载: 当两个函数名相同，后面的函数会覆盖掉之前的函数

    function getUserName(){
        console.log(&apos;a&apos;);
    }

    function getUserName(){
        console.log(&apos;b&apos;);
    }

    getUserName();      // &apos;b&apos;


2、声明函数和匿名函数: 

    function person() {  ...  };          // 声明
    var person = function() {  ...  }     // 匿名

    Example:

        getName();          // b
        var getName = function(){       // 优先级要高于声明函数，但要必须执行到这里才有效
            console.log(&apos;a&apos;);
        };

        getName();          // a

        function getName(){
            console.log(&apos;b&apos;);
        }
        getName();          // a


3、函数参数

    1) 形参、实参

        function add(a, b){ return a+b }    // 形参

        add(1,2)    // 实参


    2) arguments数组: 函数参数的数组

    3) callee 函数的调用当前函数的本身，可以使用arguments.caller(), 可以用于递归

        function factorial(num){
            if(num &lt; 1){
                return 1;
            }
            else{
                return num * arguments.callee(num-1);
            }
        }

    4) caller 返回被调用函数的本身

        function outer() {
            inner();
        }

        function inner() {
            alert(arguments.callee);        // function inner(){ ... }
            alert(arguments.callee.caller); // function outer(){ ... }
        }

        outer();
</code></pre><h4 id="call-、apply"><a href="#call-、apply" class="headerlink" title="call()、apply()"></a>call()、apply()</h4><pre><code>Function.prototype.call() 和 Function.prototype.apply() 用于改变函数的this指向

1、无参

    var obj1 = {
        name: &apos;siguang&apos;,
        getName: function(){
            return this.name;
        }
    }

    var obj2 = {
        name: &apos;lulu&apos;
    }

    console.log(obj1.getName());  // siguang

    // 注意这里是将getName中的this指定指向了obj2，并且执行了getName()函数
    var n1 = obj1.getName.call(obj2);
    console.log(n1);        // lulu

2、有参

    var objA = {
        num: 10,
        add: function(a, b){
            return a + b + this.num;
        }
    }
    var objB = {
        num: 20
    } 

    var n1 = objA.add(1, 2);
    console.log(n1);    // 13

    var n2 = objA.add.call(objB, 1, 2);     // 如果objA.add.apply(objB, [1,2]);
    console.log(n2)     // 23
</code></pre><h4 id="void-0"><a href="#void-0" class="headerlink" title="void(0)"></a>void(0)</h4><pre><code>这个操作符允许插入一个计算结果等效于undefined的表达式。

void操作符经常仅仅是用来获得undefined值，比如经常使用到的“void(0)”(这等效于“void 0”)

当浏览器遇到一个javascript:URI，它会运算带有URI的代码，然后将计算结果替换当前页面的内容，除非它的返回值是undefined。void操作符可以被用于返回undefined

&lt;a href=&quot;javascript:void(0);&quot;&gt;
    Click here to do nothing
&lt;/a&gt;
</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>一、 数据类型包括

    Number、String、Boolean、null、undefined

    获取数据的类型: 返回的值（number、string、boolean、array、object、function、undefined、null）

    Object.prototype.toString.call(val)

    // 判断类型
    function returnType(val) {
        let typeName;
        if (typeof val === &apos;object&apos;) {
            let typeName = Object.prototype.toString.call(val);

            if (typeName == &apos;[object Array]&apos;) {
                return &apos;array&apos;
            } else if (typeName == &apos;[object Object]&apos;) {
                return &apos;object&apos;
            }
            else if(typeName == &apos;[object Null]&apos;){
                return &apos;null&apos;
            }
        } else {
            return typeof val;
        }
    }


二、NaN 非数值

    isNaN() 是否是一个NaN非数值， 如果是数字返回false, 否则返回true

        isNaN(NaN);     // true
        isNaN(10);      // false
        isNaN(&apos;10&apos;);    // false 转换后是一个数字
        isNaN(&apos;blue&apos;);  // true 转换后不会是一个数字
        isNaN(true);    // false true转换后为1是一个数字


    数值转换:
        Number() 布尔转换成1或0，null返回0，undefined返回NaN，
        parseiInt()
        parseFloat()


toString(): 将该对象的原型始以字符串形式返回   xx.toString();       // &apos;xx&apos;

valueOf(): 返回最适合该对象的类型的原始值
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>var testA = 3 &amp;&amp; 2;             // 返回 2，如果左侧为真返回右侧，否则返回左侧

var testB = 0 || 3;             // 返回3，如果左侧为假返回右侧

var a = 1; console.log(!!a);    // 返回true，!!强制转换成布尔值

var a = &apos;123.563&apos;; console.log( +a );  // 123.563，+转换成数值类型
</code></pre><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><pre><code>for(var i=0; i&lt;10; i++){}

do{....} while(express)

while(){ ... }

for( in ){}

break 退出整个循环        continue 跳出当前循环，继续执行下一个循环

switch case default
</code></pre><h4 id="定时器的运行机制"><a href="#定时器的运行机制" class="headerlink" title="定时器的运行机制"></a>定时器的运行机制</h4><pre><code>JS的执行机制: 

    JS引擎执行JS的机制是基于事件循环，JS是单线程，同一时间只能执行一个任务，其它任务就得排队，后续任务需要前一个任务结束才能执行

    为了避免一些长时间任务造成的无意义等待，JS引入了异步，用另一个线程来管理异步任务

    同步任务在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程，等主线程队列执行完后，在去异步队列查询是否有可执行的异步任务

异步 - ajax、定时器、Promise

Example:

    // HTML5规范规定最小时间不能小于4ms(毫秒)，如果小于4会被当4来处理，Chrome可以设置1ms
    setTimeout(function(){
        console.log(1);
    }, 0);
    console.log(2);         // 先log出2，在log出1
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、事件机制: 事件捕获 和 事件冒泡, IE11之前没有捕获

2、事件委托

    事件委托（也称事件代理）: 将事件绑定到父元素上，利用冒泡机制来对点击的元素进行处理

    &lt;div id=&quot;boxList&quot;&gt;
        &lt;ul&gt;
            &lt;li data-attr=&quot;a1&quot;&gt;aaa&lt;/li&gt;
            &lt;li data-attr=&quot;a2&quot;&gt;bbb&lt;/li&gt;
            &lt;li data-attr=&quot;a3&quot;&gt;ccc&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var oList = document.querySelector(&apos;#boxList&apos;);
        oList.onclick = function(e){
            var arrtName = e.target.getAttribute(&apos;data-attr&apos;);
            console.log(arrtName);
        }
    &lt;/script&gt;


3、自定义事件

4、onLoad与DOMContentLoaded事件的区别

    onLoad: 是当所有资源都加载完成后在执行onLoad函数内的程序

    DOMContentLoaded: 是当DOM树加载完成后就执行此函数内的程序


5、onmouseover、onmouseout与onmouseEnter、onmouseLeave

    onmouseover、onmouseout 会冒泡

    onmouseEnter、onmouseLeave 不会冒泡


6、addEventListener(事件类型, 执行函数, boolear): 第三个参数，如果是true表示在捕获取中调用事件，false冒泡时调用

    这里执行的函数不会被重载

    var oSendBtn = document.querySelector(&apos;#sendBtn&apos;);      // 点击会输出&apos;aa&apos;, &apos;bb&apos;

    oSendBtn.addEventListener(&apos;click&apos;, function(){
        console.log(&apos;aa&apos;);
    }, false);

    oSendBtn.addEventListener(&apos;click&apos;, function(){
        console.log(&apos;bb&apos;);
    }, false);
</code></pre><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>1、加载非阻塞脚本:  

    浏览器遇到 &lt;script&gt; 标签时，页面加载都会停下来，先执行js代码，然后在继续加载（因为不知道脚本里有没有document.wirte()
    来向页面写内容，所以会需要先执行完js文件在继续）

    使用动态创建DOM元素，将脚本加载放到&lt;/body&gt;之前来加载，这样不会影响页面的内容展示


2、按需加载: 可以分图片按需加载，js文件按需加载、数据接需加载

    图片按需加载使用的lazyload

    JS按需加载类似模块化开发，只对依赖的文件进行加载


3、图片预加载: 通过new Images()来创建图像对象提前将图片进行加载

    function preloadImg(url) {
        var img = new Image();
        img.src = url;
        if(img.complete) {
            //接下来可以使用图片了
            //do something here
        }
        else {
            img.onload = function() {
                //接下来可以使用图片了
                //do something here
            };
        }
    }
</code></pre><h4 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h4><pre><code>由于同源策略，安全性，ajax不同域下的数据不可以调用

跨域的产生: 1、同域名不同端口        2、同域名不同协议        3、主域和子域之间        4、子域和子域之间

解决跨域的方法: 

1、JSONP

    JSONP利用script标签中的src属性，src属性没有跨域限制，通过url的参数将回调函数的名称和数据请求给服务器，服务器接收到url参数进行处理，并将数据挂载到回调函数的参数并执行回调函数，客户端有与回调函数名相同，来处理这些数据

    // 处理回调函数数据的函数
    function doSomething(data) {
        // 对data处理
    }
    var script = document.createElement(&quot;script&quot;);
    script.src = &quot;http://www.b.com/b.html?callback=doSomething&quot;;
    document.body.appendChild(script);


2、document.domain: 

    适用于主域相同子域不同，比如 www.renrendai.com 和 action.renrendai.com

    例如: 两个域下各有a.html和b.html, a通过iframe嵌到另一个子域b.html是无权访问b.html文档内的元素, 所以通过document.domain来设置

    a.html: 
        document.domain = &quot;www.we.com&quot;;
        var iframe = document.createElement(&quot;iframe&quot;);
            iframe.src = &quot;http://a.we.com/b.html&quot;;
            document.body.appendChild(iframe);
            iframe.onload = function() {
                console.log(iframe.contentWindow....); // 在这里操作b.html里的元素数据
        }

    b.html:
       document.domain = &quot;www.we.com&quot;;       // b页面必须要设置a.html


3、HTML5 postMessage() 处理iframe跨域问题

    如果在一个主域中的a.html嵌套个 &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

    postMessage有两个接口: postMessage(send) 发送数据和 onmessage接收数据事件通过e.data来获取到

    Example: 
        // a.html
        &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot; id=&quot;messageId&quot;&gt;&lt;/iframe&gt;

        var oMessage = document.getElementById(&apos;messageId&apos;);
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收b的数据
            }, false);
            oMessage.postMessage(&apos;发送给b的数据&apos;, &apos;http://www.b.com/b.html&apos;);
        }

        // b.html
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收a的数据
            })
            window.parent.postMessage(&apos;发送给a的数据&apos;, &apos;http://www.a.html/a.html&apos;);
        }

    传统的iframe跨域使用方法: http://www.cnblogs.com/snandy/p/3900016.html


4、window.name + iframe

    window.name原理是利用同一个窗口在不同页面共用一个window.name，这个需要在a.com下建立一个代理文件c.html，使同源后a.html能获取c.html的window.name.

        // a.html
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.b.com/b.html&quot;;
        document.body.appendChild(iframe); // 现在a.html里建一个引用b.html的iframe，获得b的数据

        var flag = true;
        iframe.onload = function() {
            if (flag) {
                iframe.src = &quot;c.html&quot;;          // 这里在去加载c.html

                  // 判断是第一次载入的话，设置代理c.html使和a.html在同目录同源，这样才能在下面的else取到data
                flag = false;
            } 
            else { 
                // 第二次载入由于a和c同源，a可以直接获取c的window.name
                alert(iframe.contentWindow.name);

                iframe.contentWindow.close();
                document.body.removeChild(iframe);
                iframe.src = &apos;&apos;;
                iframe = null;
            }
        }

        // b.html
        window.name = &quot;这是 b 页面的数据&quot;;


5、window.location.hash + iframe

    b.html将数据以hash值的方式附加到c.html的url上，在c.html页面通过loaction.hash获取数据后传到a.html

    // a.html
    var iframe = document.createElement(&quot;iframe&quot;);
    iframe.src = &quot;http://www.b.com/b.html&quot;;
    document.body.appendChild(iframe); // 在a页面引用b
    function check() { 
        // 设置个定时器不断监控hash的变化，hash一变说明数据传过来了
        var hashs = window.location.hash;
        if (hashs) {
            clearInterval(time);
            alert(hashs.substring(1));
        }
    }
    var time = setInterval(check, 30);

    //b.html
    window.onload = function() {
        var data = &quot;this is b&apos;s data&quot;; 
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.a.com/c.html#&quot; + data;         
        document.body.appendChild(iframe); // 将数据附加在c.html的hash上
    }

    //c.html
    // 获取自身的hash再传到a.html的hash里，数据传输完毕
    parent.parent.location.hash = self.location.hash.substring(1);
</code></pre><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><pre><code>1、CORS概念: 是指跨域资源共享, 用于解决前端跨域问题, 使用自定义头部让浏览器与服务器进行沟通, 来进行请求成功或失败

    原理: 服务器对header设置一个Access-Control-Allow-Origin: *, 开启跨域请求。

    *表示接受所有域名的请求。也可以指定特定的域名 Access-Control-Allow-Origin: http://www.client.com。


2、CORS优点: 跨域最常用的是JSONP但这种方式是通过Get的方式请求src完成的，很多跨域问题JSONP无法解决，比如: 

    1) post请求跨域

    2) &quot;script error&quot; 的脚本错误提示

    3) canvas中无法获取跨域图片的信息，如果使用CORS上面几个问题就可以解决


3、CORS缺点: 

    1）cookie不会随请求发送，也不会响应

    2）不能设置请求头的Content-Type字段

    3）不能访问响应头信息
</code></pre><h4 id="Promise异步编程"><a href="#Promise异步编程" class="headerlink" title="Promise异步编程"></a>Promise异步编程</h4><h4 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h4><pre><code>同步: 就是代码逐行执行

异步: Promins、Ajax、setTimeout 来实现，执行到异步的代码时不会等待返回结果后在执行之后的代码，会直接往下执行。

同步和异步是针对单线程来讲的象JS，象Java一般不会说同步和异步，而是阻塞和非阻塞。
</code></pre><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><pre><code>面向对象的特点: 封装、继承、多态

对象组件: 私有、公有属性、方法和特权方法

1、constructor属性: 指向这个原型的构造函数，如果是类式继承需要修改子类的constructor的指向，如果不改子类会指向父类.

2、原型和原型链: 

    prototype原型: 在创建函数的时候JS会为这个函数自动加上prototype属性

    原型链: 每一个构造函数都有一个prototype, prototype包含一个指向构造函数的指针, 而实例包含指向原型的对象的指针, 都是通过 __proto__ 属性来指向

    1）构造函数实例化后，prototype下的所有属性和方法都为公用的一套, 这样为了节省资源提高性能

    2）优先级: 如果同时在构造函数内或prototype中定义相同的属性或方法名, 会先找到执行构造函数内的属性或方法, 如果没有在到prototype中查找。

        __proto__属性: __proto__是实例与prototype之间的链接，实例的__proto__指向构造函数的prototype.function F(){}; 

        var f = new F(); 
        console.log(f.__proto__ === F.prototype);           // true
        Object.prototype是顶级对象，所有对象都继承它

3、继承

    每个对象都是由Object.prototype对象继承的

    继承分为: 类式继承、原型链继承、拷贝继承。

    1）类式继承: 

        function Parent(){}
        Parent.prototype.say = function(){ 
            console.log(&apos;haha&apos;)
        }

        function Childer(){}

        /* 将第一个类的实例赋给第二个类的原形，类式继承的原因
        *  类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问
        */
        Childer.prototype = new Parent();   

        // 上一步执行后prototype的constructor会指向Parent，所以需要修正回来
        Childer.prototype.constructor = Childer;    
        Childer.prototype.getAuthor = function(){ console.log(&apos;siguang&apos;) }


    2）原型链继承: 

        // 原型链式继承
        /*
        * 流程:
        * 1、clonePlan调用blood属性会在clonePlan查找所有属性，
        * 2、如果没有找到在看clonePlan的__proto__指象哪里，这里指向了F，到F对象下的prototype下查找
        * 3、plane将prototype赋给了F的prototype所以最终找到了blood属性
        */

        function extend(obj){
            var F = function(){};
            F.prototype = obj;
            return new F();
        }

        // 定义一个类
        var Plane = function(){
            this.blood = 100;
            this.attackLevel = 1;
            this.defenseLevel = 1;
        }
        Plane.prototype = {
            getBlood: function(){
                console.log(this.blood);
            },
            getAttackLevel: function(){
                console.log(this.attackLevel)
            }
        }
        var plane = new Plane();

        // 将类通过extend函数继承过来
        var clonePlan = extend(plane);
        clonePlan.blood = 1234;
        clonePlan.attackLevel = 4567;

        clonePlan.getBlood();               // 1234
        clonePlan.getAttackLevel();         // 4567


    3）拷贝继承

        function extend(parent, childer){
            for(var key in parent){
                childer[key] = parent[key];
            }
        }

        extend(a.prototype, b.prototype);


    4）Object.create()继承

        function Car(desc){
            this.desc = desc;
            this.color = &apos;red&apos;
        }

        Car.prototype = {
            getInfo: function(){
                return `color: ${this.color}, desc: ${this.desc}`
            }
        }

        // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
        var child = Object.create(Car.prototype);
        child.desc = &apos;aaa&apos;;
        child.color = &apos;bbb&apos;;

        // 改变子类不会影响到父类
        console.log(child);
        var childCar = child.getInfo();
        console.log(childCar)       // color: bbb, desc: aaa


        var oCar = new Car(&apos;ccc&apos;);
        console.log(oCar.getInfo());    /// color: red, desc: ccc


4、SuperClass.prototype = {} 与 SuperClass.prototype.getName = function(){} 区别

    一个是将对象覆盖prototype, 一个是将方法添加到prototype中

    存在的问题，SuperClass.prototype = {}这种方式，实例的对象没有constructor,
</code></pre><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><pre><code>一、XMLHttpRequrest 缓存

    缓存只有在get请求中存在，如果服务端设置了缓存，如果在缓存失效前请求就会取到缓存的数据，解决有两种方法:

    1、加If-Modified-Since头

        xhr.setRequestHeader(&apos;If-Modified-Since&apos;, &apos;0&apos;);

        jquery中设置  $.ajax({ cache: false })

    2、给请求的URL后加参数 

        let sendUrl = &quot;http://host/getUser&quot;+&quot;?&quot;+Math.random();


// 创建一个XMLHttpRequest对象
var xhr = window.XMLHttpRequrest ? new XMLHttpRequrest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);   

属性: 服务器响应

    1、reponseText: 字符串响应数据

    2、responseXML: 获取XML响应数据

    3、timout: 设置超时请求时间

    4、responseType: 设置返回数据类型

        1、text: 字符串      2、document: Document对象       3、json: json数据       4、blob: 二进制对象       5、arrayBuffer: 二进制

方法: 

    1、open(请求类型，请求地址，同步/异步): 请求类型

    2、send(): 请求发送到服务器

    3、setRequestHeader(key，value): 设置请求头

    4、getResponseHeader(header)、getAllResponseHeaders(): 获取响应头

事件: 

    1、onabort: 停止传输

    2、onerror: 错误

    3、onload: 

    4、ontimout: 超时执行的事件

    5、onreadystatechange: 请求发送到服务器时，接收一些响应

        readyState: XMLHttpRequest的状态，

            0: 请求未初始化    1、服务器连接已建立      2、请求已接收     3、请求处理中     4、请求已完成，已响应

        status:  200: 成功  404:  未找到资源

        xhr.onreadystatechange = function(e){
            if(this.readyState == 4 &amp;&amp; this.state == 200){
                console.log(this.reponseText)
            }
        }

    6、upload: 上传 XMLHttpRequestUpload

        function uploadFile() {  
            // 创建FormData对象
            var fd = new FormData();
            // 添加值
            fd.append(&quot;fileToUpload&quot;, document.getElementById(&apos;fileToUpload&apos;).files[0]); 

            // 创建XMLHttpRequest()请求
            var xhr = new XMLHttpRequest();  
            // 文件上传时侦听progress事件
            xhr.upload.addEventListener(&quot;progress&quot;, uploadProgress, false);  

            xhr.addEventListener(&quot;load&quot;, uploadComplete, false);    // 载入 
            xhr.addEventListener(&quot;error&quot;, uploadFailed, false);     // 错误
            xhr.addEventListener(&quot;abort&quot;, uploadCanceled, false);   // 终止

            // 请求方式和地址
            xhr.open(&quot;POST&quot;, &quot;test2.php&quot;);  
            // 发送请求到服务器
            xhr.send(fd);  
        }

        function uploadProgress(evt) { 
            // evt.loaded 当前上传的大小， evt.total 文件总大小
            if (evt.lengthComputable) {  
                var percentComplete = Math.round(evt.loaded * 100 / evt.total);  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = percentComplete.toString() + &apos;%&apos;;  
            }  
            else {  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = &apos;unable to compute&apos;;  
            }
        }

        function uploadComplete(evt) {  
            /* This event is raised when the server send back a response */  
            alert(evt.target.responseText);  
        }

        function uploadFailed(evt) {  
            alert(&quot;There was an error attempting to upload the file.&quot;);  
        }

        function uploadCanceled(evt) {  
            alert(&quot;The upload has been canceled by the user or the browser dropped the connection.&quot;);  
        }
</code></pre><h4 id="content-type四种类型"><a href="#content-type四种类型" class="headerlink" title="content-type四种类型"></a>content-type四种类型</h4><pre><code>get请求包括请求头、状态行

post请求包括请求头、状态行、请求主体（主体类型设置就是content-type来处理）

Content-Type:

1、application/x-www-form-urlencoded: 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据

    jquery和ajax的默认的方式 content-type:「application/x-www-form-urlencoded;charset=utf-8」

    header:
    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/x-www-form-urlencoded;charset=utf-8 

    ** Form Data

        incomeTime: &quot;16:25:13&quot;
        serialNumber: &quot;223&quot;
        incomeBank: &quot;中央银行&quot;
        incomeAccount: &quot;穷逼&quot;


2、multipart/form-data: 一般用来上传文件，必须让 form 的 enctyped 等于这个值

    content-type: multipart/form-data

    POST http://wwwexamplecom HTTP/11 
    Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA 

    ** Request Payload

        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
        Content-Disposition: form-data; name=&quot;text&quot; 

        title 
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
        Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chromepng&quot; 
        Content-Type: image/png 

        PNG  content of chromepng  
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 


3、application/json: 告诉服务端消息主体是序列化后的 JSON 字符串

    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/json;charset=utf-8 

    // ajax请求
    var data = {&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]};
    $ajaxpost(url, data)success(function(result){

    });

    // 发送
    POST http://wwwexamplecom HTTP/11
    Content-Type: application/json;charset=utf-8

    ** Request Payload

        {&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]}


4、text/xml: XML文件作为编码方式的需要用到的类型

    POST http://wwwexamplecom HTTP/11
    Content-Type: text/xml

    ** Request Payload


5、HTML5中的fromData异步上传表单

    这里注意需设置 content-type:false 和 processData: false

    function upThumbSubmit() {
        if(!windowFormData) {　
            alert(&apos;your brower is too old&apos;);
            return false;
        }
        var formData = new FormData($( &quot;#upForm&quot; )[0]);
        var upLoadFile = documentquerySelector(&apos;upfile&apos;)files[0];
        formDataappend(&apos;file&apos;: upLoadFile);

        $ajax({
            url:&apos;?c=api&amp;a=upload&apos;,
            type:&apos;post&apos;,
            data:formData,
            processData: false,        // 不会被序列化
            contentType: false,        
            dataType:&apos;json&apos;,
            success:function(data){
                alert(data);
                return false;

            }
        });
    }
</code></pre><h4 id="iframe父子页面的通信"><a href="#iframe父子页面的通信" class="headerlink" title="iframe父子页面的通信"></a>iframe父子页面的通信</h4><pre><code>Example:

    parent.html:
        &lt;body&gt;
            &lt;iframe src=&quot;child.html&quot; frameborder=&quot;0&quot; id=&quot;child&quot;&gt;&lt;/iframe&gt;
        &lt;/body&gt;

    childe.html:
        &lt;body&gt;
            &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
        &lt;/body&gt;

一、父页面获取子页面

    &lt;script&gt;
        var myIframe = document.querySelector(&apos;#child&apos;), 
            childDocument;

        if(myIframe.document){
            childDocument = myIframe.docuemnt;
        }
        else{
            childDocument = myIframe.contentWindow.docuemnt;
        }

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;
    &lt;/script&gt;

    1、先获取iframe节点

        var myIframe = document.querySelector(&apos;#child&apos;);        // 或 myIframe = window.frames[&apos;child&apos;];

    2、获取iframe页面的document对象

        // ie浏览器
        var childDocument = myIframe.docuemnt;

        // 其它浏览器
        var childWindow = myIframe.contentWindow;     // 获取iframe的window对象
        var childDocument = myIframe.contentWindow.docuemnt;    // 获取iframe的document对象
        var childDocuemnt = myIframe.contentDocument;   // 也是获取document对象  与 myIframe.contentWindow.docuemnt 相同

    3、向id=&apos;box&apos;设置内容

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;


二、子页面获取父页面

    1、获取父页面的document对象

        var parentDocument = window.parent.document;

    2、如果iframe嵌套多个iframe，想直接取到最顶层的iframe

        var selfDocument = window.self.document;
</code></pre><p>——————— ES5 API ————————</p>
<h4 id="提供全局的JSON对象"><a href="#提供全局的JSON对象" class="headerlink" title="提供全局的JSON对象"></a>提供全局的JSON对象</h4><pre><code>1、JSON.parse(): 将字符串转成对象

2、JSON.stringify(): 将对象转成字符串
</code></pre><h4 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h4><pre><code>1、push(): 向数组最后插入内容   unshift():向数据最前面插入一项

2、pop(): 删除数组最后一项内容  shift(): 删除数组第一项内容

    var arr = [1, 2, 3];   
    console.log(arr.pop());     // 3
    console.log(arr)    // [1, 2]

3、reverse(): 数组顺序颠倒

4、sort(): 排序

    let arr = [1, 123, 23, 4, 125, 6, 2, 31];
    arr.sort(function(v1, v2) {
        return v1 &lt; v2 // 从大到小排列
    })

5、concat(): 两个数组进行合并, 也可以拷贝成为一个新数组，而不是带指向

        var arrA = [1,2,3];
        var arrB = arrA.concat();
        arrB.push(5,6,7);
        console.log(arrA);  // [1,2,3]
        console.log(arrB);  // [1,2,3,5,6,7]

6、slice(开始，结束): 返回一个子数组,  如果结束参数不传为从开始取到最后的值

    let arr = [125, 123, 31, 23, 6, 4, 2, 1];
    let newArr = arr.slice(2, 5);  
    console.log(newArr, arr);        // [31, 23, 6]    [125, 123, 31, 23, 6, 4, 2, 1]

7、splice(): 用于替换、插入、删除

    splice(1,3): 删除 下标1-3的数据
    splice(3,0, &apos;insert&apos;): 插入 在位置3一个&apos;insert&apos;字符串
    splice(2,4, &apos;replce&apos;): 替换 将2-4的数组用 &apos;replce&apos;符

8、indexOf(): 查找数组中指定的字位的位置，未找到返回-1

    var arr = [1,2,3,4,5,6];  arr.indexOf(3);         // 返回2

9、lastIndexOf(): 查找数组中指定的字位的位置，从后向前查找，未找到返回-1


* 迭代方法

10、every(): 每一项为true，结果返回true

    // 数组中是否包含大于2的数
    var num = [1,2,3,2,1];
    var result = num.every(function(item,index,array) {    // item: 1, index: 0, array: [1,2,3,2,1]
        return (item &gt; 2);
    })
    console.log(result);        // true


11、some(): 有一项为true就不会往下执行，并返回true

    var dwarfPlanets = [&quot;ceres&quot;, &quot;pluto&quot;, &quot;haumea&quot;, &quot;makemake&quot;, &quot;eris&quot;];
    var result = dwarfPlanets.some(function(element) {
        return (element === &quot;pluto&quot;);
    });   
    console.log(result)     // true


5、filter(): 条件中返回true结果，重新返回一个新数组

    var arr = [1, 2, 3, 2, 5, 7];
    var result = arr.filter(function(item,index,array){
        return (item &gt; 2);
    })
    console.log(result);        // [3, 5, 7];


6、forEach(): 遍历数组, forEach无法跳出循环, 只能通过try...catch

    var arr = [&apos;lulu&apos;, &apos;siguang&apos;, &apos;mama&apos;, &apos;baba&apos;];
    arr.forEach(function(item, index, arr){  // lulu  0  [&quot;lulu&quot;, &quot;siguang&quot;, &quot;mama&quot;, &quot;baba&quot;]
        console.log(&apos;name:&apos;+item, index, arr);
    })


7、map(): 将每次return的数据，最终组成一个数组返回

    var srcColors = [
        {r: 255, g: 255, b: 255 },
        {r: 128, g: 128, b: 128 },
        {r: 0,   g: 0,   b: 0   }
    ];

    var newColor = srcColors.map(function(item, index, arr){         
        return item.r;
    })
    console.log(newColor);        // 返回 [255, 128, 0]


8、reduce(上次执行的结果，当前值，当前索引，数组对象)、reduceRight(): 归并数组，每次循环都会返回上一次值和当前值

    var val = [1,2,3,4,5];
    var sum = val.reduce(function(prev, cur, index, arr){   // prev 第一次执行的是1, 第二次执行的就是上次1+2返回的结果
        return prev + cur;   
    })
    console.log(sum);   // 15
</code></pre><h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><pre><code>1、__proto__: 对象实例与prototype之间的连接，原型链

2、prototype: 原型，公用的，节省内存开支，查找先去对象本身找属性和方法，如果没有到prototype下查找

3、constructor: 保存用于创建当前对象的构造函数名

4、toString()、valueOf()

5、delete: 删除对象属性

6、hasOwnProperty(propertyName): 用来判断属性是否在对象中（而不是原型中） var obj = {name: &apos;aaa&apos;}; obj.hasOwnProperty(&apos;name&apos;)

    var o = { name: &apos;siguang&apos;, getName: function(){ console.log(this.name) } };
    o.hasOwnProperty(&apos;name&apos;);       // true

    判断对象的属性或方法是否存在
    var obj = {};

    判断属性
        obj.name    // 如果属性不存在返回 undefined，也就是false

    判断方法
        typeof obj.getName == &apos;function&apos;      // 如果存在返回true


7、isPrototypeOf(object): 判断一个对象的原型是否是在指定对象的原型链中

    var o = new Object();
    Object.prototype.isPrototypeOf(o)


8、instanceof: 用来判断一个构造函数的prototype属性是否在另一个检测对象的原型链上

    A instanceof B   // 检测B的prototype是否存在于A的原型链上

9、in: 属性是否在对象中能访问，返回true或false

    function Persion(){
        var sex = &apos;男&apos;;
        this.name = &apos;siguang&apos;;
    }
    Persion.prototype.age = &apos;haha&apos;;

    var p1 = new Persion();
    console.log(&apos;name&apos; in p1);      // true
    console.log(&apos;age&apos; in p1);       // true
    console.log(&apos;sex&apos; in p1);       // false;


10、Object.create(o, p): 可以创建一个干净的对象，给o对象创建一个prototype，如果p对象存在

    var oA = Object.create(null);    // 创建一个干净的对象，没有__proto__属性
    var oB = {};        // 存储__proto__

    function Car(desc){
        this.desc = desc;
        this.color = &apos;red&apos;
    }

    Car.prototype = {
        getInfo: function(){
            return `color: ${this.color}, desc: ${this.desc}`
        }
    }

    // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
    var child = Object.create(Car.prototype);
    child.desc = &apos;aaa&apos;;
    child.color = &apos;bbb&apos;;

    // 改变子类不会影响到父类
    console.log(child);
    var childCar = child.getInfo();
    console.log(childCar)       // color: bbb, desc: aaa

    var oCar = new Car(&apos;ccc&apos;);
    console.log(oCar.getInfo());    /// color: red, desc: ccc


11、Object.defineProperty(obj, prop, descriptor): 对象新增或修改一个属性会执行set()、get()方法来通知

    参数: obj 目标对象     prop需要定义的属性      descriptor该属性拥有的特性，可设置的值有

    descriptor的值: 

        value 属性的值，默认为 undefined。

        writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。

        get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。

        set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。

        configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。

        enumerable 是否能在for...in循环中遍历出来或在Object.keys中列举出来。默认为 false。

    Example:
        var obj = {};
        Object.defineProperty(obj, &apos;name&apos;, {
            get: function(){
                debugger;
                // this.name;  
                return 23;
            },
            set: function(newValue){
                debugger
            }
        })

        Object.defineProperty(obj, &apos;sex&apos;, {
            get: function(){
                debugger;
                return &apos;女&apos;;
            },
            set: function(newValue){
                debugger
            }
        })

        obj.name = &apos;sss&apos;;           // 调用set()
        console.log(obj.name);      // 调用get()   23

        obj.sex = &apos;男&apos;;
        console.log(obj.sex);       // 女


    MVVM的核心: 

        &lt;div&gt;
            &lt;p&gt;你好，&lt;span id=&apos;nickName&apos;&gt;&lt;/span&gt;&lt;/p&gt;
            &lt;div id=&quot;introduce&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;

            // 视图控制器
            var userInfo = {};
            Object.defineProperty(userInfo, &quot;nickName&quot;, {
                get: function(){
                    return document.getElementById(&apos;nickName&apos;).innerHTML;
                },
                set: function(nick){
                    document.getElementById(&apos;nickName&apos;).innerHTML = nick;
                }
            });

            Object.defineProperty(userInfo, &quot;introduce&quot;, {
                get: function(){
                    return document.getElementById(&apos;introduce&apos;).innerHTML;
                },
                set: function(introduce){
                    document.getElementById(&apos;introduce&apos;).innerHTML = introduce;
                }
            })

            userInfo.nickName = &quot;siguang&quot;;
            userInfo.introduce = &quot;我是&quot;+ userInfo.nickName +&quot;，我来自黑龙江，...&quot;

        &lt;/script&gt;

    https://segmentfault.com/a/1190000004346467


12、Object.defineProperties: 与defineProperty相同就是可以设置多个属性

    let book = { year: 2004, edit: 1}
    Object.defainProperyies(book, {
        year:{
            get: function(){},
            set: function(){}
        },
        edit: {
            get: function(){},
            set: function(){}
        }
    })


13、Object.getPrototypeOf(object): 调用父类原型上的方法

    // 定义一个父类
    function PersonA(){
        this.methodA = function(){ 
            alert(&quot;a&quot;);
        }
    }
    PersonA.prototype.methodB = function(){
        alert(&apos;b&apos;);
    }

    // 定义一个子类
    function Man(){
        this.m1 = function(){
            //getPrototypeOf只有继承父类的时候才可以调用其方法
            Object.getPrototypeOf(this).methodA();        
        }
    }

    Man.prototype = new PersonA();
    Man.prototype.m2 = function(){
        Object.getPrototypeOf(this).methodB();
    }

    var man = new Man();
    man.m1();        // a
    man.m2();        // b


14、Object.keys(obj): 将对象obj下所有的属性的key，返回一个数组，用可以用它来判断是数组是否为空

    Object.keys(obj).length 是否等于0

15、Object.getOwnPropertyDescriptor(): 
</code></pre><h4 id="Function扩展"><a href="#Function扩展" class="headerlink" title="Function扩展"></a>Function扩展</h4><pre><code>1、bind(): 一个函数绑定之后，可以保持传递this的上下文

    var obj = {
        nameStr: 20,
        getName: function(){
            setTimeout(function(){
                console.log(this.nameStr);
            }.bind(obj), 10)
        }
    }

    // 输出20，如果不加bind()，this指向window所以输出的是undeined
    obj.getName();
</code></pre><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><pre><code>var od = new Date();    // 创建当前中国标准时间 Thu Apr 27 2017 18:39:17 GMT+0800 (CST)
var od = new Date(&apos;2017-04-27 18:40:00&apos;);   // 指定时间 返回当前标准时间 Thu Apr 27 2017 18:40:00 GMT+0800 (CST)

1、getTime(): 返回当前毫秒数

2、setTime(): 以毫秒设置时期

    var od = new Date(); 
    od.setTime(12312312312332); 
    console.log(od);        // Mon Feb 29 2360 22:45:12 GMT+0800 (CST)

3、getFullYear()、setFullYear(): 获取或设置年份

4、getMonth()、setMonth(): 获取或设置月份，值需要+1

5、getDate()、setDate(): 获取或设置日

6、getDay(): 返回星期几，值是0-6

7、getHours(): 小时

8、getMinutes(): 分钟

9、getSeconds(): 秒
</code></pre><h4 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h4><pre><code>1、toFixed(): 将值格式化小数点后几位
</code></pre><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><pre><code>1、length: 字符串长度

2、charAt(): 返回指定位置的字符  &apos;abcde&apos;.charAt(3)  &apos;d&apos;

3、chartCodeAt(): 返回指定位置的字符编码

4、concat(): 两个字符串拼接

5、split(): 将字符串以什么为分割，并返回为一个数组

截取

6、slice(begin,end): 截取字符串指定开始和结束位置的字符并返回， 可以接受负数

7、substring(begin,end): 截取字符串从开始到结束，

8、substr(begin, length): 返回一个指定开始到一个结束长度的字符

位置

9、indexOf(): 查找指定字符所在的位置

10、lastIndexOf(): 从后向前查找指定字符的位置

11、trim(): 删除前后空格  str.replace(/^\s*|$\s*/g, &apos;&apos;);

12、toLocaleUpperCase(): 转成小写字母

13、toUpperCase(): 转成大写字母

正则

14、search(reg): 搜索正则中匹配字符的位置，没有返回-1

15、match(reg): 将匹配的正则返回一个数组

    let text = &quot;cat, bat, sat, fat&quot;;
    let om = text.match(/.at/g);        // [&quot;cat&quot;, &quot;bat&quot;, &quot;sat&quot;, &quot;fat&quot;]

16、exec():

17、replace(reg, 替换字符): 替换指定字符
</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><pre><code>1、min()、max(): 返回最小、最大值

舍入

2、ceil(): 向上舍入

3、floor(): 向下舍入

4、round(): 四舍五入

5、random(): 随机数 0-1之间

6、abs(): 绝对值

7、sin()、cos()
</code></pre><h4 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h4><pre><code>encodeURI()、encodeURIComponent()
</code></pre><h4 id="前端动画实现种类"><a href="#前端动画实现种类" class="headerlink" title="前端动画实现种类"></a>前端动画实现种类</h4><pre><code>1、纯粹的CSS3: transition/animation+transform（大名鼎鼎的animate.css）

2、JS+CSS3 transition或者animation: 这里第一种一样，只是通过js里add class和remove class去增加或者移除对应的动画

3、纯粹JS控制时间轴: 第一和第二种都是自带时间轴，使用 setInterval / setTimeout / requestAnimationFrame 不断地修改 DOM 的 style 属性产生动画
</code></pre><p>| 参考资料<br>| <a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es5/</a>    ES5兼容表<br>| <a href="https://segmentfault.com/a/1190000000515151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000515151</a><br>| <a href="https://segmentfault.com/a/1190000005653355" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005653355</a><br>| <a href="https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx</a><br>| <a href="http://www.alloyteam.com/2016/05/javascript-timer/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/05/javascript-timer/</a>        js运行机制</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/BOM/">BOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/BOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><pre><code>BOM   浏览器对象模型    B - Browser    O - Object     M - Model

BOM包含: history、location、navigator、screen 对象
</code></pre><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><pre><code>1、hash: 返回hash值

    https://xxx.com/#sdfsdf       // &apos;#sdfsdf&apos;

2、host: 返回主机地址  &apos;xxx.com&apos;

3、hostname: 返回主机名  &apos;xxx.com&apos;

4、href: 整个url地址  &quot;https://xxx.com/search?q=BOM&quot;

5、origin: 起源  &apos;https://xxx.com&apos;

6、pathName: 路由名

    &quot;https://xxx.com/search?q=BOM&quot;   &apos;/search&apos;

7、port: 端口

8、protocol: 协议  &apos;https&apos;

9、search: 参数 &apos;?q=BOM&apos;

10、reload(): 刷新浏览器

    location.reload(); // 重新加载（有可能从缓存中加载）
    location.reload(true); // 重新加载（从服务器重新加载）
</code></pre><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><pre><code>1、width、height: 整天个屏幕的宽、高

2、avaiWidth、avaiHeight: 返回显示屏幕的宽、高 除dock和系统上面的菜单栏

3、pixelDepth: 返回显示屏幕的颜色分辨率

4、updateInteval: 设置或返回屏幕刷新率
</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><pre><code>1、length: 历史记录的个数

2、go(): 指定跳转的历史、-1后退一页，1前进一页

3、back()、forward(): 后退和前进一页
</code></pre><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><pre><code>1、appCodeName: 浏览器代码名 &apos;Mozilla&apos;

2、appName: 浏览器名称    &apos;Netscape&apos;

3、appVersion: 浏览器版本  &apos;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;

4、browserLanguage: 浏览器语言

5、cookieEnabled: 是否启用了cookie 返回Boolean

    如果浏览器关闭cookie，当获取cookie时， document.cookie 返回的是空字符串

6、cpuClass: 返回浏览器系统的cpu等级

8、onLine: 是否处于脱机模式，Boolean

9、platform: 浏览器的操作平台

10、systemLanguage: 系统语言

11、userAgent: 客户机发送服务器的 user-agent 头部的值

12、userLanguage: 返回 OS 的自然语言设置


** 检测插件  ie无效
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

** 检测Flash
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

function hasIEPlugin(name){
    try{
        new ActiveXObject(name);
        return true;
    }catch(ex){
        return false;
    }
}

function hasFlash(){
    var result = hasPlugin(&quot;Flash&quot;);
    if (!result){
        result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);
    }
    return result;
}

console.log(hasFlash()) //true
</code></pre><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><pre><code>1、window.open(url, target, param): 打开一个新窗口

2、window.close(): 关闭一个窗口

3、setInterval()、clearInterval()

4、setTimeout()、clearTimeout()

5、screenLeft、screenTop: 浏览器当前窗口居屏幕的左、上角的位置  

    兼容:
    screenLeft || screenX
    screenTop || screenY

6、innerWidth、innerHeight: 浏览器可视区的宽高、包括滚动条

    let winHeight = window.innerHeight;

7、moveTo(x, y): 移动到屏幕左上角的位置

8、moveBy(0, 100): 向下移动100像素

9、resizeTo(x,y)、resizeBy(w, h)
</code></pre><h4 id="offset-页面元素偏移量"><a href="#offset-页面元素偏移量" class="headerlink" title="offset 页面元素偏移量"></a>offset 页面元素偏移量</h4><pre><code>1、offsetWidth、offsetHeight: 获取当前元素宽高，相当于 width + padding + border

2、offsetLeft、offsetTop: 获取元素到父级元素定位的左、上偏移，如果父级不是定位就以body元素为定位

3、offsetParent: 获取最近一个带有定位的父级元素

4、clientWidth、clientHeight: 元素本身的宽高、不包括padding和border

    兼容
    document.documentElement.clientWidth || document.body。clientWidth
    document.documentElement.clientHeight || document.body。clientHeight
</code></pre><h4 id="scroll-滚动类"><a href="#scroll-滚动类" class="headerlink" title="scroll 滚动类"></a>scroll 滚动类</h4><pre><code>窗口滚动条或带滚动条元素

1、scrollWidth、scrollheight: 对象内部实际内容的宽、高

2、scrollTop、scrollLeft: 被卷部分的顶部和左侧部分

    只挂载到了Element元素中，window和document下都没有

    let topValue = document.documentElement.scrollTop || document.body.scrollTop;       // 获取整个页面巻上去的高度和兼容方法

    let topValue = document.querySelector(&apos;#sider&apos;).scrollTop;      // 针对某个元素


3、onscroll: 侦听滚动条事件
</code></pre><h4 id="client-鼠标所在的可视区坐标"><a href="#client-鼠标所在的可视区坐标" class="headerlink" title="client 鼠标所在的可视区坐标"></a>client 鼠标所在的可视区坐标</h4><pre><code>1、clientX、clientY: 获取鼠标可视区的位置  clientX = width + padding

2、clientLeft、clientTop: 获取鼠标在可视区域的位置

3、pageX、pageY: 获取鼠标在页面中的位置， pageX = clientX + 页面滚动出的距离

node.onclick = function(evt){
    let evt = evt || window.evnet;
    console.log(evt.pageX, evt.pageY);
    console.log(evt.pageX, evt.pageY);
}
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、target: 点击的目标阶段事件，ie8之前使用srcElement

    var oT = evt.target || srcElement; console.log(oT);     // &lt;p&gt;xxxx&lt;/p&gt;

2、currentTarget: 事件流的捕获，目标及冒泡阶段

3、addEventListener()、attachEvent(): 注册事件

    addEventListener(&apos;click&apos;, fn, false);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/weex/">Weex</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/weex/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Weex/">Weex</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="Native调研"><a href="#Native调研" class="headerlink" title="Native调研"></a>Native调研</h1><h3 id="目前主流的应用大体分成三类：Native-App-Web-App-Hybrid-App"><a href="#目前主流的应用大体分成三类：Native-App-Web-App-Hybrid-App" class="headerlink" title="目前主流的应用大体分成三类：Native App, Web App, Hybrid App."></a>目前主流的应用大体分成三类：Native App, Web App, Hybrid App.</h3><h3 id="三类主流的优点"><a href="#三类主流的优点" class="headerlink" title="三类主流的优点"></a>三类主流的优点</h3><pre><code>1、native App

    性能好
    用户体验也比较好
    开发成本高，无法跨平台
    升级困难(审核),维护成本高

2、Web App特点:

    开发成本低,更新快,版本升级容易,自动升级
    跨平台，Write Once , Run Anywhere
    无法调用系统级的API
    临时入口，用户留存度低
    性能差,体验差,设计受限制
    相比Native App，Web App体验中受限于以上5个因素：网络环境，渲染性能，平台特性，受限于浏览器，系统限制。

3、Hybrid App(混合app)特点:

    Native App 和 Web App 折中的方案，保留了 Native App 和 Web App 的优点。
    但是还是性能差。页面渲染效率低，在Webview中绘制界面，实现动画，资源消耗都比较大,受限于技术,网速等因素
</code></pre><h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h3><pre><code>weex是阿里巴巴公司与2016年6月开源的一种用于构建移动跨平台的UI框架

特点:

    1、一次性编写代码多端运行，

    2、使用的vue的语法，RN使用的react语法

    3、轻量级,语法简单,易于使用

    4、可扩展,丰富内置组件,可扩展的API

    5、High Performance: 高性能


缺点: 只调研IOS

    1、weex开源比较晚资料也比较少，资料也不太容易看懂;

    2、没有对硬件调用的直接接口，需要swift进行modul的扩展（）;

    3、支持的组件也不完善;

    3、开发完成后对xcode不了解，所以在生成项目这块和导出包这块一直也没有解决(github上有人将创建了一个完整的项目);


weex流程:

    需要xcode、cocoapods、

    创建weex-cli  =&gt;  




基于JS开发框架:

    weex基于vue.js


性能对比:
</code></pre><div style="width:200px;"><br>    <img src="./img/1.png"><br></div>


<h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本:"></a>学习成本:</h4><pre><code>1.环境配置：

    ReactNative需要按照文档安装配置很多依赖的工具，相对比较麻烦。 weex安装cli之后就可以使用


2.vue vs react:

    react模板JSX学习使用有一定的成本 vue更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css
</code></pre><h4 id="weex-使用"><a href="#weex-使用" class="headerlink" title="weex 使用"></a>weex 使用</h4><pre><code>1、手机下载

    Weex Playground  可以通过二维码来看服务 


集成IOS

需要安装 iOS 开发环境 和 CocoaPods  


2、Cocoapods安装  http://blog.csdn.net/showhilllee/article/details/38398119/

    需要Ruby环境，Mac本身就自带Ruby

    $ sudo gem install cocoapods
</code></pre><p>思考:</p>
<pre><code>1、与web app 相比 navtive是不是可以不用考虑页面兼容问题（不同设备和系统）

2、cocoapads，xcode的一些处理，打包是否不用处理，还是只考虑写vue这块的内容就可以

3、weex怎么调用硬件设备

4、如果是原生与weex结合怎么来进行通信

5、weex不适用于做什么，和优、缺点是什么
</code></pre><p>|<br>| <a href="https://weex.apache.org/cn/" target="_blank" rel="noopener">https://weex.apache.org/cn/</a>      weex官网<br>| <a href="https://market.dotwe.org/ext/list.htm#6" target="_blank" rel="noopener">https://market.dotwe.org/ext/list.htm#6</a><br>| <a href="https://github.com/joggerplus/awesome-weex" target="_blank" rel="noopener">https://github.com/joggerplus/awesome-weex</a><br>| <a href="https://github.com/weexteam/weex-hackernews/blob/master/README.zh.md" target="_blank" rel="noopener">https://github.com/weexteam/weex-hackernews/blob/master/README.zh.md</a><br>| <a href="https://github.com/weexteam" target="_blank" rel="noopener">https://github.com/weexteam</a><br>| <a href="http://i.youku.com/i/UNDEzMDY2NjI0MA==/videos" target="_blank" rel="noopener">http://i.youku.com/i/UNDEzMDY2NjI0MA==/videos</a><br>| <a href="http://www.jianshu.com/p/cb6de4b85ea3" target="_blank" rel="noopener">http://www.jianshu.com/p/cb6de4b85ea3</a><br>| <a href="http://www.apicloud.com/" target="_blank" rel="noopener">http://www.apicloud.com/</a><br>| <a href="https://yq.aliyun.com/articles/57996" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57996</a>   react native与weex<br>| <a href="http://div.io/topic/1478" target="_blank" rel="noopener">http://div.io/topic/1478</a><br>| <a href="https://github.com/Elemefe/weex-vue-starter-kit" target="_blank" rel="noopener">https://github.com/Elemefe/weex-vue-starter-kit</a><br>|<br>|<br>| <a href="http://reactnative.cn/" target="_blank" rel="noopener">http://reactnative.cn/</a>         react native<br>| <a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="noopener">https://github.com/jondot/awesome-react-native</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之基础篇/">React Native之基础篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之基础篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React Native 介绍"></a>React Native 介绍</h4><pre><code>一、Native的类别

    React Native 编译后是原生应用，v0.22.0热更新hot reloading

    Hybrid  混合应用

    phoneGap 包皮应用，一次编写，到处运行，依然是网页，只是将页面内容内嵌到webView中，用中间件来对网页进行通信，对一些动画会有性能上的问题


二、实时加载（Live Reload）和热加载（Hot Reload）的区别

    http://www.jianshu.com/p/1fa6e9c0799f

    Enable Live Reload  实时加载，应用于更新时需要刷新当前页面，可以看到全局刷新效果

    Enable Hot Reloading   热加载，当布局修改时会自动更新模拟器，看不出来刷新效果类似买局部刷新

三、React Native 应用部署/热更新 codePush

    http://blog.csdn.net/fengyuzhengfan/article/details/52003798
</code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>1、安装 XCode

    $ xcode-select --install  检查xcode是否安装, 如果未安装会出现提示

    android 下载 android studio  https://developer.android.google.cn/index.html


2、安装 homebrew

    用于包管理，与npm类似

    $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;

    $ sudo chown -R `whoami` /usr/local   解决/usr/local目录不可写的权限问题  

    Homebrew将工具安装到 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。


3、安装 watchman 和 flow

    watchman是facebook的开源项目用于监视文件并且记录文件的改动情况

    flow 是js的静态类型检查器，用于找出js代码中的类型错误

    $ brew install watchman

    $ brew install flow


4、安装 NodeJS

5、安装 react-native 

    $ npm install -g react-native-cli      // Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载

6、vscode中react-native插件
</code></pre><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><pre><code>1、创建项目

    $ react-native init 项目名  // 创建项目

    $ react-native run-ios     // 运行 react-native run-ios --simulator &quot;iPhone 4s&quot;  定义模拟器类型

        或者在ios目录 AwesomeProject.xcodeproj  双击打开


2、查看命令

    $ react-native -h   所有命令

    $ react-native -v   版本


3、安装第三方插件

    $ npm i react-native-elements lodash query-string sha1 react-native-audio react-native-video react-native-image-picker react-native-progress react-native-sk-countdown react-native-swiper react-native-barcodescanner --save


4、link 命令

    link的原因：以下组件都是原生开发，wrapper了一层js，因此需要link .a到project中

    $ react-native link

    或 rnpm link     需要先安装rnpm     npm install rnpm -g --save-dev


5、模拟器调试技巧

    http://blog.csdn.net/quanqinyang/article/details/52215652  

    # 模拟器打开后可以通过cmd+1/2/3/4来调整窗口大小

    # 模拟器在所有窗口置顶 window -&gt; stay in front

    # ISO cmd + D 打开调试菜单，Android cmd + M

    # comond + T  show Animate 呼出菜单cmd+D会变成慢动画


    # Reload 重新bundle代码 cmd + R

    # Debug JS Remotely   调试模式 chrome Developer Tools调试

    # Enable Live Reload  实时加载，应用于更新时需要刷新当前页面，可以看到全局刷新效果

    # Enable Hot Reloading   热加载，当布局修改时会自动更新模拟器，看不出来刷新效果类似买局部刷新


    # 警告

        红错误 - console.error(&apos;&apos;)

        关闭警告 - console.disableYellowBox = true;    显示警告 - console.warn(&apos;YellowBox is disabled.&apos;);

    # 日志 - react-native log-ios      react-native log-android

    # chrome开发工具 - debug js Remotely  可以跟进代码
</code></pre><h4 id="react-native-目录"><a href="#react-native-目录" class="headerlink" title="react-native 目录"></a>react-native 目录</h4><pre><code>.
├── .DS_Store
├── .babelrc            // ES6转换的配置
├── .buckconfig
├── .flowconfig         // 做js代码类型检查 
├── .watchmanconfig     // 监听文件改变watchman的配置
├── .gitattributes
├── .gitignore          // 对哪些文件被git忽略不显示
├── node_modules        // 存储资源包    
├── __tests__
├── android             // android原生文件目录
├── ios                 // ios的原生文件目录 运行reactNative会将文件打包到这个目录，然后xcode调用的就是这里的项目文件
├── app.json
├── index.android.js    // android文件入口
├── index.ios.js        // ios文件入口
├── package.json        // 依赖文件
└── yarn.lock
</code></pre><h4 id="AppRegistry-注册模块，用来告诉RN哪个组件被注册为根窗口"><a href="#AppRegistry-注册模块，用来告诉RN哪个组件被注册为根窗口" class="headerlink" title="AppRegistry 注册模块，用来告诉RN哪个组件被注册为根窗口"></a>AppRegistry 注册模块，用来告诉RN哪个组件被注册为根窗口</h4><pre><code>AppRegistry是js运行RN应用的入口，通过registerComponent()来注册方法

AppRegistry.registerComponent(&apos;项目名&apos;, () =&gt; 入口组件名)  注册入口

AppRegistry.runApplication 来真正运行应用
</code></pre><h4 id="React-Native-生命周期"><a href="#React-Native-生命周期" class="headerlink" title="React Native 生命周期"></a>React Native 生命周期</h4><pre><code>第一阶段，初始化

    getDefaultProps -&gt; getInitialState -&gt; componentWillMount -&gt; render -&gt; componentDidMount

       获取配置参数        获取初始状态值         通知要开始渲染        渲染       告诉组件已经完成


第二阶段，运行阶段 组件运行中

    1、state变化 -&gt; shouldComponentUpdate -&gt; componentWhllUpdate -&gt;  render -&gt; componentDidUpdate

       状态变化    判断组件是否要更新true/false     需要更新就触发           渲染         更新组件

    2、props变化 -&gt; componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWhllUpdate -&gt;  render -&gt; componentDidUpdate

       props变化         属性改变调用             判断组件是否要更新true/false       需要更新就触发        渲染           更新组件


第三阶段 卸载

    unmount -&gt; componentWillUnmout -&gt; 结束 
</code></pre><p><img src="images/lifecycle.png" alt="组件生命周期"></p>
<h4 id="props、state"><a href="#props、state" class="headerlink" title="props、state"></a>props、state</h4><pre><code>一、props属性: 父组件传值给子组件

    &lt;Greeting name=&apos;Rexxar&apos; /&gt;      父组件调用子组件

    &lt;Text&gt;Hello {this.props.name}!&lt;/Text&gt;   子组件接收

    1、defaultProps定义默认的props

        class Smiple extends Component{
            static defaultProps = {     // 定义默认props静态属性
                name: &apos;siguang&apos;
            }

            static propsTypes = {       // 检测props的类型
                name: &apos;String&apos;
            }

            render(){
                return (
                    &lt;View&gt;
                        &lt;Text&gt; {this.props.name} &lt;/Text&gt;
                    &lt;View&gt;
                )
            }
        }


二、state状态、setState()改变状态，组件中可以改变的值

    export default class rrdProject extends Component {
        constructor(props){
            super(props);

            // 定义state对象
            this.state = { 
                showText: &apos;&apos;
            }
        }

        // state = {  };     // RN也支持ES7 类的静态属性写法

        render() {
            return(
                &lt;View style={styles.container}&gt;
                    &lt;Text&gt;这里有内容: {this.state.showText}&lt;/Text&gt;
                &lt;/View&gt;
            );
        }
    }
</code></pre><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><pre><code>通过ref来获取真实的DOM

import childComponent from &apos;./childComponent&apos;;

class Simple extends Component {
    clickChild(){
        var size = this.refs.childRef.getSize();       // 获取childComponent组件的getSize()方法
    }

    render() {
        return (
            &lt;View&gt;
                &lt;Text&gt;Simple 基本页面&lt;/Text&gt;
                &lt;button onPress={this.clickChild} title=&quot;点击&quot; /&gt;

                &lt;childComponent ref=&quot;childRef&quot; /&gt;
            &lt;/View&gt;
        )
    }
}
</code></pre><h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><pre><code>http://blog.csdn.net/sbsujjbcy/article/details/50017029
http://www.cnblogs.com/wonyun/p/5481134.html

1、直接写样式

    &lt;View style={{width: 193, height: 110}}&gt;&lt;/View&gt;     {{}} 两个括号可以直接写样式
    &lt;View style={styles.red}&gt;&lt;/View&gt;                    {} 一个括号需要来调用样式类
    const styles = StyleSheet.create({
        red: {
            color: red
        }
    })

2、写多个样式

    &lt;Text style={[styles.btn, styles.color]}&gt;立即体验&lt;/Text&gt;

    // 支持表达式
    &lt;Text style={[styles.btn, styles.color &amp;&amp; this.props.dotColor]}&gt;立即体验&lt;/Text&gt;


2、styleSheet.create({}) 定义样式

    const styles = StyleSheet.create({
        rootView:{
            height: &apos;100%&apos;,
            width: &apos;100%&apos;,
            backgroundColor: &apos;#eff0f3&apos;
        },
        big: {
            color: &apos;blue&apos;,
            fontSize: 30
        }
    })
    &lt;View style={styles.rootView}&gt;      // 多个样式 style={[styles.rootView, styles.big]}
        &lt;Text&gt;REACT NATIVE ELEMENTS&lt;/Text&gt;
    &lt;/View&gt;


3、颜色支持

    &apos;#ccc&apos;、 &apos;rgba(0,0,0,.4)&apos;、 &apos;transparent&apos;、 &apos;red&apos;


4、RN样式与css样式的异同

    View类型div，会默认占用窗口的100%宽度

    绝对定位和相对定位不需要父元素设置positioin，也没有zIndex配置

    不能将RN的inline元素设置maginTop、marginBottom

    样式继承只存在Text元素内的Text元素

        &lt;Text style={{color:'red'}}&gt;
             &lt;Text&gt;父：我是white还是red{&apos;\n&apos;}
                 &lt;Text&gt;子：那我是神马颜色&lt;/Text&gt;
             &lt;/Text&gt;
       &lt;/Text&gt;
</code></pre><h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h4><pre><code>直接给组件指定宽、高   &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;
http://www.devio.org/2016/08/01/Reac-Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/#和而不同

一、父视图属性:

    1、flexDirection(&apos;row&apos;, &apos;column&apos;,&apos;row-reverse&apos;,&apos;column-reverse&apos;)- 布局子元素的排列方向，默认是column不是row

        &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;
            &lt;View style={{flex:1, height: 50, backgroundColor: 'powderblue'}} /&gt;
            &lt;View style={{flex:2, height: 50, backgroundColor: 'skyblue'}} /&gt;
            &lt;View style={{flex:3, height: 50, backgroundColor: 'steelblue'}} /&gt;
        &lt;/View&gt;

        重要:  
            &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;  
            父组件没设置flexDirection=row，默认布局为列，子组件设置flex:1是没用的，子组件只能设置width
            父组件设置为flexDirection=row，子组件可以设置flex:1

    2、flexWrap (&apos;wrap&apos;, &apos;nowrap&apos;) - 定义子元素是否允许多行排列

    3、justifyContent (&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;space-between&apos;, &apos;space-around&apos;) - 定义子元素如何对齐

    4、alignItems (&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) - 定义子元素在侧轴对齐的


    justifyContent - 子元素沿主轴的排列方式

        justifyContent: flex-start、center、flex-end、space-around以及space-between
        &lt;View style={{ flex: 1,  flexDirection: 'row' justifyContent: center}}&gt;

    alignItems - 


二、子视图属性：

    1、alignSelf (&apos;auto&apos;, &apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) - 

    2、flex - 
</code></pre><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><pre><code>RN里网络请求分为: Fetch、WebSocket、XMLHttpRequest
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>onPress: 点击

onLongPress: 长按

maximumZoomScale和minimumZoomScale: 双指缩放

http://reactnative.cn/docs/0.42/panresponder.html
</code></pre><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><pre><code>1、LayoutAnimation 用于全局的布局动画

2、Animated 用于创建更精细的交互控制的动画

    Animated 封装了四个可以动画的组件: View、Text、Image和ScrollView

    start/stop 方法来控制动画按顺序执行
</code></pre><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><pre><code>setTimeout, clearTimeout
setInterval, clearInterval
setImmediate, clearImmediate
requestAnimationFrame, cancelAnimationFrame
</code></pre><h4 id="RN与原生通信"><a href="#RN与原生通信" class="headerlink" title="RN与原生通信"></a>RN与原生通信</h4><pre><code>http://blog.csdn.net/zww1984774346/article/details/71167775

rn与IOS原生通信的三部分

    1、属性        2、原生模块      3、原生UI组件封装

    原生要写到AppDelegate.m文件中

    # 属性是最简单的跨组件通信，从原生组件传递属性到React Native 或 React Native到原生组件

        原生中添加imageList:

            NSArray *imageList = @[@&quot;https://facebook.github.io/react/img/logo_og.png&quot;,
                        @&quot;https://facebook.github.io/react/img/logo_og.png&quot;];

            NSDictionary *props = @{@&quot;images&quot; : imageList};

            RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                        moduleName:@&quot;AwesomeProject&quot;
                                        initialProperties:props             // 这里initialProperties:props]传递给RN
                                        launchOptions:launchOptions];

        RN中接收与props传值一样:

            &lt;View&gt;
                {
                    this.props.images.map(function(items){
                        return &lt;Image 
                            source={{uri:items}} 
                            style={{width:100,height:100}}&gt;&lt;/Image&gt; 
                    })
                }
            &lt;/View&gt;


1、RN访问OC

    // 创建原生模块实例
    var NativeModule = require(&apos;react-native&apos;).NativeModules.NativeTest;

    // 调用原生的doSomething()方法
    NativeModule.doSomething(&apos;ReactNative&apos;);


2、OC访问RN

http://www.jianshu.com/p/9d7dbf17daa5
</code></pre><h4 id="生成测试包"><a href="#生成测试包" class="headerlink" title="生成测试包"></a>生成测试包</h4><pre><code>iOS—最全的真机测试教程   http://www.cocoachina.com/ios/20160711/17004.html

团队开发的Xcode配置和生成包

    xCode -&gt; Preferencse -&gt; Accounts -&gt; + 填加 选择 add apple ID 将账号和密码输入

    点击工程目录 -&gt; General 
        -&gt; Identity面板下的 Bundle Identifler 填写权限 “com.ucredit.paydayloan” 
        -&gt; 在 Signing面板中的 Team 中选择&quot;ZhongChengXingyu of......&quot;

    将手机与mac连接，将Device选择当前手机设备，点击 运行，写读取设备成功后，在运行一次这次是执行build
</code></pre><h4 id="原生组件"><a href="#原生组件" class="headerlink" title="原生组件"></a>原生组件</h4><pre><code>两种方法加载原生组件

1、react-native link 命令

    不仅会将第三方模块的原生组件代码链接入 Android/IOS 中，还会将字体等文件移动相应的目录中

2、通过Xcode来导入组件

    http://www.cnblogs.com/shaoting/p/6148085.html

3、Flow

    Flow是 Facebook出品的表态类型语言，可以将RN内部也支持ES 7的类属性的写法

        // 就可以不用在象ES 6将静态属性写到constructor中
        class MyComponent extends Component {
            constructor(props){
                super(props);

                // 私有属性
                this.isField = 1;   
                // state
                this.state = {
                    username: &apos;siguang&apos;
                }
            }

            render(){
                return (
                    &lt;View&gt;
                        {this.username}
                    &lt;/View&gt;
                )
            }
        }

        class MyComponent extends Component {
            isField = 1;
            state = {
                username: &apos;siguang&apos;
            }

            render(){
                return (
                    &lt;View&gt;
                        {this.usernmae}
                    &lt;/View&gt;
                )
            }
        }
</code></pre><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><pre><code>1、Command+R  重新刷新

2、Command+D  打开菜单 

3、Debug JS Remotely 用chrome浏览器调试,Alt+Command+j出现浏览器debug窗口

4、Disable Live Reload 时实刷新，代码修改保存后会就刷新

5、show Perf Monitor 打开FPS监控器

6、show Inspector 用于查看页面结构及属性
</code></pre><p>XCode装证书<br><a href="http://www.cocoachina.com/ios/20160711/17004.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160711/17004.html</a></p>
<p>| 相关文章<br>| <a href="https://github.com/jondot/awesome-react-native#videos" target="_blank" rel="noopener">https://github.com/jondot/awesome-react-native#videos</a><br>| <a href="http://reactnative.cn/docs/0.44/getting-started.html" target="_blank" rel="noopener">http://reactnative.cn/docs/0.44/getting-started.html</a><br>| <a href="http://www.devio.org/" target="_blank" rel="noopener">http://www.devio.org/</a><br>| <a href="https://github.com/crazycodeboy/RNStudyNotes/" target="_blank" rel="noopener">https://github.com/crazycodeboy/RNStudyNotes/</a><br>| <a href="http://blog.csdn.net/quanqinyang/article/details/52215652" target="_blank" rel="noopener">http://blog.csdn.net/quanqinyang/article/details/52215652</a>   调试方法<br>| <a href="http://lib.csdn.net/base/reactnative/structure" target="_blank" rel="noopener">http://lib.csdn.net/base/reactnative/structure</a><br>| <a href="http://www.jianshu.com/p/5b185df2d11a" target="_blank" rel="noopener">http://www.jianshu.com/p/5b185df2d11a</a><br>| <a href="http://www.lcode.org/react-native/" target="_blank" rel="noopener">http://www.lcode.org/react-native/</a><br>| <a href="http://blog.csdn.net/column/details/reactnative2016.html?&amp;page=3" target="_blank" rel="noopener">http://blog.csdn.net/column/details/reactnative2016.html?&amp;page=3</a><br>| <a href="http://lib.csdn.net/article/reactnative/63268" target="_blank" rel="noopener">http://lib.csdn.net/article/reactnative/63268</a>   打包到真机<br>|<br>| 示例<br>| <a href="https://github.com/react-native-community" target="_blank" rel="noopener">https://github.com/react-native-community</a><br>| <a href="https://github.com/ljunb/react-native-iShiWuPai" target="_blank" rel="noopener">https://github.com/ljunb/react-native-iShiWuPai</a>       示例<br>| <a href="https://github.com/sunnylqm" target="_blank" rel="noopener">https://github.com/sunnylqm</a><br>| <a href="https://github.com/DoctorQ/react-native-helloworld" target="_blank" rel="noopener">https://github.com/DoctorQ/react-native-helloworld</a><br>|<br>| <a href="http://blog.csdn.net/liu__520/article/category/6460088" target="_blank" rel="noopener">http://blog.csdn.net/liu__520/article/category/6460088</a><br>| <a href="http://www.devio.org/tags/#React" target="_blank" rel="noopener">http://www.devio.org/tags/#React</a> Native<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/ReactNative之积累篇/">React Native之积累篇</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/ReactNative之积累篇/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="IOS、Android的图标、app名称和启动图"><a href="#IOS、Android的图标、app名称和启动图" class="headerlink" title="IOS、Android的图标、app名称和启动图"></a>IOS、Android的图标、app名称和启动图</h4><pre><code>一、App名称修改

    Xcode中打开项目下info.plist -&gt; Bundle name 和 Bundle display name 都修改APP的名称

二、App图标

    方法1 Xcode中配置:

        Xcode工程目录下的Images.xcassets -&gt; AppIcon中将来加载图标，分别为120x120、180x180

    方法2 代码中配置

        1、使用icon psd模板右键 Edit me and save图层 ——&gt; 编辑内容 ——&gt; 编辑完后保存 ——&gt; 导出图片（窗口）——&gt; 动作 ——&gt; 右上角按钮选择载入动作将App Icon Template [3.3].atn文件载入 ——&gt; 选择导出动作中有两种一个都是圆角图标一个是方形图标

        2、将导出的图标添加到项目中 找到ios/gzApp/Images.xcassets ——&gt; 将所有导出的图标放到这个目录下

三、设置启动图

    方法1 Xcode中配置:

        Xcode工程下点击Images.xcassets -&gt; 进入后 右键 App Icons &amp; launch Image -&gt; New IOS Launch Image -&gt; 将启动图加载到各配置中（注意如果尺寸与当前不配置编译时会报错）

        在项目的General面板 Launch Images Source 选择刚才创建的launchImage, launch Screen File设置为空，App Icons Source就是图标的配置

    方法2 代码配置

        https://github.com/fbsamples/f8app/tree/master/ios/F8v2   // Base.lproj -&gt; LaunchScreen.xib

        在ios文件夹 -&gt; gzCar项目 -&gt; Base.Iproj -&gt; LaunchScreen.xib 使用文件替换，将Splash.png文件导入到项目中，启动


http://www.cnblogs.com/allenxieyusheng/p/5802179.html
http://www.jianshu.com/p/adpKye/
https://appicontemplate.com/ios9    图标尺寸导出  

转icon尺寸
http://www.zcool.com.cn/article/ZNjE1MTI=.html
http://makeappicon.com/
http://blog.csdn.net/leiyu231/article/details/52830151
</code></pre><h4 id="fetch-请求提示netWork-quest-failed"><a href="#fetch-请求提示netWork-quest-failed" class="headerlink" title="fetch 请求提示netWork quest failed"></a>fetch 请求提示netWork quest failed</h4><pre><code>在 Xcode 7.0 bata、ios9 中fetch默认https请求, 对http不起作用，需要修改info.plist配置

1、在Info.plist中添加 NSAppTransportSecurity 类型 Dictionary ; 
2、在 NSAppTransportSecurity 下添加 NSAllowsArbitraryLoads 类型Boolean ,值设为 YES;

http://blog.csdn.net/liyijun4114/article/details/51792179
</code></pre><h4 id="网络图片无法加载问题"><a href="#网络图片无法加载问题" class="headerlink" title="网络图片无法加载问题"></a>网络图片无法加载问题</h4><pre><code>在iOS9之后，网络请求默认为Https请求，如需支持Http，修改info.plist文件添加键值对设置允许http访问。

在App Transport Security Settings中添加 Allow Arbitrary Loads设置为 YES
</code></pre><h4 id="内测平台"><a href="#内测平台" class="headerlink" title="内测平台"></a>内测平台</h4><pre><code>https://www.pgyer.com/      蒲公英将测试包分发给多人的设备上进行测试

    在Xcode中倒出一个应用包，通过蒲公英上传进行分发多个设备

https://developer.apple.com/  苹果开发者账号申请

苹果开发者平台可以进行

苹果的安装包为 *.ipa 文件

1、先登录Account，注册苹果开发者账号个人或企业

2、Xcode 打包IOS文件 https://www.pgyer.com/doc/view/app_upload
</code></pre><h4 id="代码类"><a href="#代码类" class="headerlink" title="代码类"></a>代码类</h4><pre><code>一、render中调用方法将View返回

    class TabPage extends Component {

        _createNav(name, colorValue){
            return (
                &lt;View&gt;
                    &lt;Text style={{color: colorValue}}&gt;{name}&lt;/Text&gt;
                &lt;/View&gt;
            )
        }

        render(){
            return (
                &lt;View&gt;
                    {this._createNav(&apos;siguang&apos;, &apos;#ddd&apos;)}
                &lt;/View&gt;
            )
        }
    }
</code></pre><p>| 参考资料<br>|  react.parts/native<br>|</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
