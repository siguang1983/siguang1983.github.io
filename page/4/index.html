<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Mot-clés</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/26/handlebars模板/">Hanlebars.js 模板引擎</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/26/handlebars模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-26T07:45:55.000Z" itemprop="datePublished">2016-12-26</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 涉及知识点<br>|<br>|</p>
<h4 id="headlebars介绍"><a href="#headlebars介绍" class="headerlink" title="headlebars介绍"></a>headlebars介绍</h4><pre><code>Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。它采用&quot;Logic-less template&quot;（无逻辑模版）的思路，在加载时被预编译，而不是到了客户端执行到代码时再去编译， 这样可以保证模板加载和运行的速度。Handlebars兼容Mustache，你可以在Handlebars中导入Mustache模板。
</code></pre><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><pre><code>1、下载handlebars.js文件在页面中直接引用

2、通过npm下载，require(&apos;handlebars&apos;)直接引用
</code></pre><h4 id="使用Handlebars"><a href="#使用Handlebars" class="headerlink" title="使用Handlebars"></a>使用Handlebars</h4><pre><code>&lt;!-- 编译模板后输出的位置 --&gt;    
  &lt;div id=&quot;tableList&quot;&gt;&lt;/div&gt;

&lt;!-- 定义的模板 --&gt;
&lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    {{date.year}} 年 {{date.month}} 月 {{date.day}} 日 &lt;br&gt;
    &lt;table&gt;
      {{#each person}}
           &lt;tr&gt;
          &lt;td&gt;姓名:{{name}}, 年龄:{{age}}&lt;/td&gt;
        &lt;/tr&gt; 
      {{/each}}
      &lt;/table&gt;
&lt;/script&gt;

&lt;!--插件引用--&gt;
&lt;script src=&quot;js/lib/zepto.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/lib/handlebars.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  $(document).ready(function() {

    // 模拟的json对象
    var data = {
        date: {
            year: &apos;2016&apos;,
            month: &apos;12&apos;,
            day: &apos;26&apos;
        },
        person: [
            {name: &apos;siguang&apos;, age: 20},
            {name: &apos;lulu&apos;, age: 20},
            {name: &apos;haha&apos;, age: 20},
            {name: &apos;heihei&apos;, age: 20}
        ]
    }

     // 预编译模板
    var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());

    //将json对象用刚刚注册的Handlebars模版封装，得到最终的html，插入到基础table中。
    $(&apos;#tableList&apos;).html(myTemplate(data));

  });
&lt;/script&gt;
</code></pre><h4 id="handlebars语句"><a href="#handlebars语句" class="headerlink" title="handlebars语句"></a>handlebars语句</h4><pre><code>1、{{#each 对象 }}  循环数据

&lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
  {{#each student}}
    &lt;tr&gt;
      &lt;td&gt;{{name}}&lt;/td&gt;
      &lt;td&gt;{{sex}}&lt;/td&gt;
      &lt;td&gt;{{age}}&lt;/td&gt;
    &lt;/tr&gt; 
  {{/each}}
&lt;/script&gt;


2、{{#each }} 嵌套

    {{#each this}} each中的this

    &lt;!-- 定义的模板 --&gt;
    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        {{#each this}}
            {{#each info}}
                &lt;!-- 这里取name 使用../到上一层来取， info数组内容使用this来输出 --&gt;
                {{../name}}的{{this}}&lt;br&gt;
            {{/each}}
        {{/each}}
    &lt;/script&gt;


    &lt;script src=&quot;js/lib/zepto.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/lib/handlebars.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() {
        //模拟的json对象
        var data = [
             {
                &quot;name&quot;:&quot;张三&quot;,
                &quot;info&quot;:[
                    &quot;眼睛&quot;,
                    &quot;耳朵&quot;,
                    &quot;鼻子&quot;
                ]
            },
            {
                &quot;name&quot;:&quot;李四&quot;,
                &quot;info&quot;:[
                    &quot;爸爸&quot;,
                    &quot;妈妈&quot;,
                    &quot;妻子&quot;
                ]
            }
        ];

        var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());
        $(&apos;#dataList&apos;).html(myTemplate(data));
      });
    &lt;/script&gt;


3、@index 访问父级索引

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        &lt;table&gt;
        {{#each this}}
            &lt;tr&gt;
                &lt;td&gt;{{addOne @index}}.&lt;/td&gt;
                &lt;td&gt;{{name}}&lt;/td&gt;
                &lt;td&gt;{{sex}}&lt;/td&gt;
                &lt;td&gt;{{age}}&lt;/td&gt;
            &lt;/tr&gt;
        {{/each}}
        &lt;/table&gt;
    &lt;/script&gt;

    &lt;!--进行数据处理、html构造--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var data = [
            {
                name: &quot;张三&quot;,
                sex: &quot;男&quot;,
                age: 35
            },{
                name: &quot;李四&quot;,
                sex: &quot;男&quot;,
                age: 23
            },{
                name: &quot;甜妞&quot;,
                sex: &quot;女&quot;,
                age: 18
            }
        ];

        // 注册索引+1的helper
        var handleHelper = Handlebars.registerHelper(&quot;addOne&quot;,function(index){
            //返回+1之后的结果
            return index+1;
        });

        //解析模版
        var handle = Handlebars.compile($(&quot;#table-template&quot;).html());
        //生成html
        var html = handle(data);
        //插入到页面
        $(&quot;#dataList&quot;).append(html);
    &lt;/script&gt;


4、#with 循环时进行到某一个上下文

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    &lt;table&gt;
        {{#each this}}
        &lt;tr&gt;
            &lt;td&gt;{{name}}&lt;/td&gt;
            &lt;td&gt;{{sex}}&lt;/td&gt;
            &lt;td&gt;{{age}}&lt;/td&gt;
            &lt;td&gt;
                &lt;!-- 这里通过 #with 直接找到favorite数组 --&gt;
                {{#with favorite}}
                {{#each this}}
                &lt;p&gt;{{name}}&lt;/p&gt;
                {{/each}}
                {{/with}}
            &lt;/td&gt;
        &lt;/tr&gt; 
        {{/each}}
    &lt;/table&gt;

    &lt;/script&gt;

    &lt;!--进行数据处理、html构造--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() {
        //模拟的json对象
        var data = [
                {
                    &quot;name&quot;: &quot;张三&quot;,
                    &quot;sex&quot;: &quot;0&quot;,
                    &quot;age&quot;: 18,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;唱歌&quot;
                      },{
                        &quot;name&quot;:&quot;篮球&quot;
                      }
                    ]
                },
                {
                    &quot;name&quot;: &quot;李四&quot;,
                    &quot;sex&quot;: &quot;0&quot;,
                    &quot;age&quot;: 22,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;上网&quot;
                      },{
                        &quot;name&quot;:&quot;足球&quot;
                      }
                    ]
                },
                {
                    &quot;name&quot;: &quot;妞妞&quot;,
                    &quot;sex&quot;: &quot;1&quot;,
                    &quot;age&quot;: 18,
                    &quot;favorite&quot;:
                    [
                      {
                        &quot;name&quot;:&quot;电影&quot;
                      },{
                        &quot;name&quot;:&quot;旅游&quot;
                      }
                    ]
                }
            ];

        // 注册一个Handlebars模版，通过id找到某一个模版，获取模版的html框架
        var myTemplate = Handlebars.compile($(&quot;#table-template&quot;).html());

        // 将json对象用刚刚注册的Handlebars模版封装，得到最终的html，插入到基础table中。
        $(&apos;#dataList&apos;).html(myTemplate(data));
    });
    &lt;/script&gt;

5、{{#if }} 判断

     &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
        {{#each student}}
            {{#if name}}
                &lt;tr&gt;
                    &lt;td&gt;{{name}}&lt;/td&gt;
                    &lt;td&gt;{{sex}}&lt;/td&gt;
                    &lt;td&gt;{{age}}&lt;/td&gt;
                &lt;/tr&gt;
            {{/if}}
        {{/each}}
    &lt;/script&gt;


6、registerHelper() 注册handlebars

    需要用到js处理并返回数据需要用到注册，类似过滤器

    &lt;script id=&quot;table-template&quot; type=&quot;text/x-handlebars-template&quot;&gt;
    {{#each student}}
        {{#if name}}

            &lt;!-- compare 注册名， age 20 为参数 --&gt;
            {{#compare age 20}}
                &lt;tr&gt;
                    &lt;td&gt;{{name}}&lt;/td&gt;
                    &lt;td&gt;{{sex}}&lt;/td&gt;
                    &lt;td&gt;{{age}}&lt;/td&gt;
                &lt;/tr&gt;
            {{else}}
                &lt;tr&gt;
                    &lt;td&gt;?&lt;/td&gt;
                    &lt;td&gt;?&lt;/td&gt;
                    &lt;td&gt;?&lt;/td&gt;
                &lt;/tr&gt;
            {{/compare}}
        {{/if}}
    {{/each}}
    &lt;/script&gt;

    //注册一个比较大小的Helper,判断v1是否大于v2
    Handlebars.registerHelper(&quot;compare&quot;,function(v1,v2,options){
        if(v1&gt;v2){
            //满足添加继续执行
            return options.fn(this);
        }
        else{
            //不满足条件执行{{else}}部分
            return options.inverse(this);
        }
    });
</code></pre><p>| 参考资料<br>| <a href="http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之二)组件类/">React（之二）组件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之二)组件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| react-create-app 脚手架<br>| Router、Route<br>| Link、Links  router的导航组件，用来切换路由<br>| browserHistory、hashHistory<br>| activeStyle、activeClassName  路由设置样式<br>| query、params 变量<br>| Redirect</p>
<h4 id="react-create-app-脚手架"><a href="#react-create-app-脚手架" class="headerlink" title="react-create-app 脚手架"></a>react-create-app 脚手架</h4><pre><code>$ sudo npm i create-react-app -g            // 全局安装，以后在安装就直接使用create-react-app命令来创建就可以

$ create-react-app my-app            // 创建+创建项目目录名

$ cd my-app

$ yarn start

$ yarn start、yarn build             // 启动服务、打包

$ yarn add antd        // 安装Antd UI框架

    在index.js中引用ant公用样式
    import &apos;antd/dist/antd.css&apos;;

$ yarn add react-router-dom -D            // react-router是安装4.0之前版本，react-router-dom是4之后版本

$ yarn add redux react-router-redux -D

$ npm run eject            // 注意如果对构建工具和配置选择不满意可以使用eject运行, 这里是单项操作只能一次不能回去

一、create-react-app关闭eslint提醒

    需要先npm run eject 生成本地webpack配置文件，在修改package.json中的配置

    &quot;eslintConfig&quot;: {
        &quot;extends&quot;: &quot;react-app&quot;,
        &quot;rules&quot;: {
            &quot;no-undef&quot;: &quot;off&quot;,
            &quot;no-restricted-globals&quot;: &quot;off&quot;,
            &quot;no-unused-vars&quot;: &quot;off&quot;
        }
    }

二、配置反向代理

    &quot;proxy&quot;: {
        &quot;/api/*&quot;: {
            &quot;target&quot;: &quot;http://goucai.diyicai.com&quot;,
            &quot;pathRewrite&quot;: {
                &quot;^/api/&quot;: &quot;/&quot;
            },
            &quot;changeOrigin&quot;: true,
            &quot;secure&quot;: false
        }
    }

三、使用.scss文件

    1、$ npm install file-loader sass-loader node-sass --save-dev            // 安装包

    2、node_modules/react-scripts/config/webpack.config.dev.js 和 webpack.config.prod.js文件中module中配置下面两项

        {
            exclude: [/\.(js|jsx|mjs)$/, /\.html$/, /\.json$/, /\.scss/],            // 这里加添加一个/\.scss/
            loader: require.resolve(&apos;file-loader&apos;),
            options: {
                name: &apos;static/media/[name].[hash:8].[ext]&apos;,
            }
        },
        // 解析scss文件
        {
            test: /\.scss$/,
            loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;],
        }


四、引入样式

    1、&lt;div style={{width: "1000px"}}&gt;&lt;/div&gt;

    2、import &quot;./main.css&quot;

        &lt;div className=&quot;main&quot;&gt;&lt;/div&gt;

    3、import Styles from &apos;./main.css&apos;

        &lt;div className={Styles.main}&gt;&lt;/div&gt;


五、常见问题

    1、&lt;src&gt;引用本地图片无效

        import JzkUrl from &apos;../../assets/img/jzk.png&apos;

        &lt;img src={JzkUrl} /&gt;

六、build的打包的时候注意的地方

    在package.json中的有一个homePage: &apos;.&apos;，这个在打包的时候图片会成为相对路径，如果改成 homePage: &apos;/&apos;


七、修改webpack配置加一个全局配置

    function resolve (dir) {
        return path.join(__dirname, &apos;..&apos;, dir)
    }

    resolve: {
        alias: {
            &apos;react-native&apos;: &apos;react-native-web&apos;,
            &apos;@&apos;: resolve(&apos;src&apos;)
        }
    }

    在页面里可以直接引用@来找到src目录

        import User from &apos;@/views/User/&apos;
</code></pre><h4 id="PropTypes验证"><a href="#PropTypes验证" class="headerlink" title="PropTypes验证"></a>PropTypes验证</h4><pre><code>React.PropTypes 提供很多验证器来验证传入数据的有效性

当向 props 传入无效数据时，JavaScript 控制台会抛出警告。注意为了性能考虑，只在开发环境验证 propTypes。下面用例子来说明不同验证器的区别: 

Example:

    import PropTypes from &apos;prop-types&apos;;
    class Greeting extends React.Component {
        render() {
            return (
                &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
            );
        }
    }
    Greeting.propTypes = {
        name: PropTypes.string
    };

propTypes类型: {

    // 可以声明 prop 为指定的 JS 基本类型。默认
    // 情况下，这些 prop 都是可传可不传的。
    optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,

    // 所有可以被渲染的对象: 数字，
    // 字符串，DOM 元素或包含这些类型的数组。
    optionalNode: React.PropTypes.node,

    // React 元素
    optionalElement: React.PropTypes.element,

    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
    optionalMessage: React.PropTypes.instanceOf(Message),

    // 用 enum 来限制 prop 只接受指定的值。
    optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),

    // 指定的多个对象类型中的一个
    optionalUnion: React.PropTypes.oneOfType([
        React.PropTypes.string,
        React.PropTypes.number,
        React.PropTypes.instanceOf(Message)
    ]),

    // 指定类型组成的数组
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

    // 指定类型的属性构成的对象
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

    // 特定形状参数的对象
    optionalObjectWithShape: React.PropTypes.shape({
        color: React.PropTypes.string,
        fontSize: React.PropTypes.number
    }),

    // 以后任意类型加上 `isRequired` 来使 prop 不可空。
    requiredFunc: React.PropTypes.func.isRequired,

    // 不可空的任意类型
    requiredAny: React.PropTypes.any.isRequired,

    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接
    // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
    customProp: function(props, propName, componentName) {
        if (!/matchme/.test(props[propName])) {
            return new Error(&apos;Validation failed!&apos;);
        }
    }
}
</code></pre><h4 id="react-router-4-0"><a href="#react-router-4-0" class="headerlink" title="react-router 4.0"></a>react-router 4.0</h4><pre><code>v3到v4版本的变化是静态路由到动态路由的变化，并且页面的嵌套路路由嵌套决定

react-router: 是浏览器和原生应用的通用部分, 核心文件

react-router-dom: 用于浏览器

react-router-native: 是用于原生(react-native)应用的    

react-router-redux: React Router 和 Redux 的集成

react-router-config: 静态路由配置的小助手

一、安装

    $ npm i react-router react-router-dom --save

    import { BrowserRouter as Router, Route, Switch, Link, Redirect, withRouter } from &apos;react-router-dom&apos;;


二、使用路由

    1、react-router和react-router-dom，不需要都引用，只是后者多&lt;Link&gt; &lt;BrowserRouter&gt; 这样的 DOM 类组件

    2、如果搭配 redux ，你还需要使用 react-router-redux

    index.js: 在入口文件加上路由配置

        import React from &apos;react&apos;
        import { Router, Route, Link } from &apos;react-router&apos;

        // render中加入路由配置
        React.render((
            &lt;Router&gt;
                &lt;Route path=&quot;/&quot; component={App}&gt;
                    &lt;Route path=&quot;about&quot; component={About}/&gt;
                    &lt;Route path=&quot;users&quot; component={Users}&gt;
                        &lt;Route path=&quot;/user/:userId&quot; component={User}/&gt;
                    &lt;/Route&gt;
                    &lt;Route path=&quot;*&quot; component={NoMatch}/&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        ), document.body)


二、&lt;BrowserRouter&gt; HTML5 history路由组件

    1、basename - 为所有位置添加一个基准的url

        &lt;BrowserRouter basename=&quot;/minooo&quot; /&gt;
        &lt;Link to=&quot;/react&quot; /&gt; // 最终渲染为 &lt;a href=&quot;/minooo/react&quot;&gt;

    2、getUserConfirmation() - 导航到此页执行的函数

        const getConfirmation = (message, callback) =&gt; {
            const allowTransition = window.confirm(message)
            callback(allowTransition)
        }
        &lt;BrowserRouter getUserConfirmation={getConfirmation(&apos;Are you sure?&apos;, yourCallBack)} /&gt;

    3、forceRefresh - bool当浏览器不支持 HTML5 的 history API 时强制刷新页面

        const supportsHistory = &apos;pushState&apos; in window.history
        &lt;BrowserRouter forceRefresh={!supportsHistory} /&gt;    

    4、keyLength - 路由的长度

    5、children - 渲染唯一子元素


三、&lt;HashRouter&gt; 该技术只是用来支持旧版浏览器, Hash history 不支持 location.key 和 location.state


四、&lt;Route&gt; 最重要的组件，页面访问地址与Router的path进行匹配，渲染出对应的UI界面

    &lt;Route path=&quot;/&quot; component={Main}&gt; - 渲染的组件

    &lt;Route&gt; 自带三个 render method 和三个 props

    1、render methods 分别是：

        &lt;Route component&gt; - 当访问地址和路由匹配时，一个组件才会被渲染，此时此组件接受match、location、history

            * &lt;Route path=&quot;/home&quot; component={Home} /&gt;

        &lt;Route render&gt; - 适用于内联渲染，不会产生重复装载问题

            * &lt;Route path=&quot;/home&quot; render={() =&gt; &lt;h1&gt;Home&lt;/h1} /&gt;

        &lt;Route children&gt; -

    2、props分别是: match、location、history

            &lt;Route path=&quot;/:id&quot; component={ListBasic}&gt;&lt;/Route&gt;          // 参数传给子组件
            this.props.match.params.id            // 获取参数值

    3、path: 路由路径

         exact: true，表示独一无二的路由

            // 如果不加exact, &quot;/&quot; 时加载main, &quot;/login&quot; 会显示main和login两个组件，如果加了exact在&quot;/&quot;路由时只会显示main组件
            &lt;div style={{ height: "500px", backgroundColor: "#ccc"}}&gt;
                &lt;Route path=&quot;/&quot; exact component={Main} /&gt;
                &lt;Route path=&quot;/login&quot; component={Login} /&gt;
                &lt;Route path=&quot;/todoList&quot; component={TodoList} /&gt;
            &lt;/div&gt;

         strict: true，如果path为&apos;/one/&apos;将不能匹配&apos;/one&apos;，但可以匹配&apos;/one/two&apos;


五、路由跳转

    1、Link、NavLink

        &lt;Link to=&quot;/course&quot; /&gt;
        &lt;Link to={{
				pathname: '/course',
				search: '?sort=name',
				state: { price: 18 }
			}} /&gt;

        // 给导航使用的
        &lt;NavLink
            to=&quot;/about&quot;
            activeStyle={{ color: 'green', fontWeight: 'bold' }}
        &gt;MyBlog&lt;/NavLink&gt;

    2、JS跳转

        export default class SelectCard extends Component {
            constructor(props){
                super(props);
            }
            goHomePage(){
                this.props.history.push(&apos;/main&apos;);            // 跳转
            }
            render(){
                return {
                    &lt;div&gt;
                        &lt;button onClick={this.goHomePage.bind(this)}&gt;跳转&lt;/button&gt;
                    &lt;/div&gt;
                }
            }
        }

        /** 注意如果使用redux子组件会取不到this.props.history **/
        解决方法: 在子组件中
        import PropTypes from &apos;prop-types&apos;

        子组件名.contextTypes = {
            router: PropTypes.object.isRequired
        }

        console.log( this.context.router.history.push(&apos;/&apos;) );


六、&lt;switch&gt; 只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;

    // v3
    &lt;Route path=&apos;/&apos; component={App}&gt;
        &lt;IndexRoute component={Home} /&gt;
        &lt;Route path=&apos;about&apos; component={About} /&gt;
        &lt;Route path=&apos;contact&apos; component={Contact} /&gt;
    &lt;/Route&gt;

    v4中使用&lt;switch&gt;来取代&lt;IndexRouter&gt;, 当react渲染时switch下第一个子&lt;route&gt;会被渲染
    // v4
    const App = () =&gt; (
        &lt;Switch&gt;
            &lt;Route exact path=&apos;/&apos; component={Home} /&gt;
            &lt;Route path=&apos;/about&apos; component={About} /&gt;
            &lt;Route path=&apos;/contact&apos; component={Contact} /&gt;
        &lt;/Switch&gt;
    )


七、添加图像、字体和文件

    组件中加载图片
    import logo from &apos;./logo.png&apos;;        导入图片
    &lt;img src={logo} alt=&quot;Logo&quot; /&gt;;

    css中加载图片
    .logo{
        background-image: url(&apos;./logo.png&apos;);
    }


八、Redirect重定向 和 未匹配路由跳转到404

    // 跳404用法
    render() {
    return (
    &lt;Router&gt;
      &lt;div className=&quot;main-container&quot;&gt;
        &lt;Route path=&quot;/main&quot; component={Main} /&gt;
        &lt;Route component={Page404}/&gt;                // 没有定义path就是没有路径匹配时
      &lt;/div&gt;
    &lt;/Router&gt;
    )
    }

    // Redirect 用法不渲染组件直接重定到其它页面
    render() {
        if(!this.state.logined){
            return (
                &lt;Redirect to=&quot;/todoList&quot; /&gt;
            )
        }
        return (
            &lt;div&gt;
                这里是Login组件
            &lt;/div&gt;
        )
    }


九、动态路由

    1、路由变量

        定义变量: &lt;Route path=&quot;/:msg&quot; component={Message} /&gt;
        获取变量: props.match.params.定义的名

        &lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan
        &lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan
        &lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg

        Example:

            class Message extends Component {
                render(props){
                    return (
                        &lt;div&gt;
                            // 这里this.props.params.msg 接收的是to的名字
                            &lt;h1&gt;{this.props.match.params.jumpUrl || &apos;hello&apos;}&lt;/h1&gt;
                            &lt;Links /&gt;
                        &lt;/div&gt;
                    )
                }
            }

            const Links = () =&gt;{
                &lt;nav&gt;
                    &lt;Link to=&quot;/&quot;&gt;Hello&lt;/Link&gt;
                    &lt;Link to=&quot;/yong&quot;&gt;Yong&lt;/Link&gt;
                    &lt;Link to=&quot;/feng&quot;&gt;Feng&lt;/Link&gt;
                &lt;/nav&gt;
            }

            class ParamsRoute extends Component {
                render() {
                    return (
                        &lt;Router history={hashHistory}&gt;
                            &lt;Route path=&quot;/(:msg)&quot; component={Message} /&gt;
                        &lt;/Router&gt;
                    );
                }
            }
            export default ParamsRoute;


    2、query: 获取URL中的参数

        1) 获取参数

            http://localhost:8080/#/?message=ssssss

            const Page = (props) =&gt;
                &lt;div&gt;
                    &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;            // props.location.query.message输出 ssssss
                &lt;/div&gt;

        2) &lt;Link&gt;请求时带参数

            const Page = (props) =&gt;
                &lt;div&gt;
                    &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;
                &lt;/div&gt;

            const Links = () =&gt;
                &lt;nav&gt;
                    &lt;Link to={{ pathname: "/", query: {message: "ssssss"} }} /&gt;         
                &lt;/nav&gt;

        3) js中请求参数 

            goToMessage(){
                that.props.history.push({ 
                    pathname : &apos;/success&apos;,
                    query : { messageTitle: &apos;充值成功&apos;, messageContent: &apos;请取您的充值单请取您的充值单请取您的充值单&apos;} 
                })
            }


十、路嵌套和展示

    // v2/3版本 就是一个路由配置文件，在放子路由的地方使用
    &lt;div&gt;
        { this.props.childre }                // 加载子路由的位置
    &lt;/div&gt;

    // v4版本
    // router.jsx
    export default class Index extends Component {
        render() {
            return (
                &lt;Router&gt;
                    &lt;Switch&gt;
                        &lt;Layout /&gt;
                    &lt;/Switch&gt;
                &lt;/Router&gt;
            )
        }
    }

    // layout.jsx
    export default class Layout extends Component {
        render() {
            let menuHtml = () =&gt; {
                const menuItem = [];
                this.state.menuList.forEach(function(menu, idx, arr){
                    menuItem.push(
                        &lt;li&gt;
                            &lt;Link to={menu.path}&gt;{menu.title}&lt;/Link&gt;
                        &lt;/li&gt;
                    )
                })
                return menuItem
            }

            return (
                &lt;div&gt;
                    &lt;header style={{height: "100px"}}&gt;
                        菜单: { menuHtml() }
                    &lt;/header&gt;
                    &lt;main style={{ height: "500px", backgroundColor: "#ccc"}}&gt;
                        // 这下面都是子路由的展示位置
                        &lt;Route path=&quot;/&quot; exact component={Main} /&gt;
                        &lt;Route path=&quot;/login&quot; component={Login} /&gt;
                        &lt;Route path=&quot;/todoList&quot; component={TodoList} /&gt;
                        &lt;Route component={Page404}&gt;&lt;/Route&gt;                        // 注: 如果没有匹配路由指到到404页面, 不需要使用Redirect
                    &lt;/main&gt;
                &lt;/div&gt;
            )
        }
    }

    // login.jsx
    export default class Login extends Component {
        constructor(props){
            super(props);
            this.state = {
                logined: true
            }
        }

        render() {
            /* 这里可以不渲染组件直接重定到其它页面 */
            if(!this.state.logined){
                return (
                    &lt;Redirect to=&quot;/todoList&quot; /&gt;
                )
            }
            return (
                &lt;div&gt;
                    这里是Login组件
                &lt;/div&gt;
            )
        }
    }

https://www.jianshu.com/p/7bb4c1a0530d
https://www.jianshu.com/p/548674270455


十一、withRouter 

    withRouter是专门用来处理数据更新问题，否则可能会出现路由地址改变但页面没有相应改变的bug

    import React, { Component } from &apos;react&apos;
    import { withRouter } from &apos;react-router&apos;
    import { Route, Redirect } from &apos;react-router-dom&apos;

    class AuthRouter extends Component {
        render() {  
            const { component: Component, ...rest } = this.props
            const isLogged = sessionStorage.getItem(&quot;isLogin&quot;) === &quot;1&quot; ? true : false;

            return (
                &lt;Route {...rest} render={props =&gt; {
                    return isLogged
                        ? &lt;Component {...props} /&gt;
                        : &lt;Redirect to=&quot;/login&quot; /&gt;
                }} /&gt;
            )
        }
    }
    export default withRouter(AuthRouter);
</code></pre><h4 id="dva-react-Ant-蚂蚁金服脚手架"><a href="#dva-react-Ant-蚂蚁金服脚手架" class="headerlink" title="dva+react+Ant 蚂蚁金服脚手架"></a>dva+react+Ant 蚂蚁金服脚手架</h4><pre><code>单独加载ant UI框架，也可以使用dva-cli蚂蚁提供的脚手架，支持IE9及以上版本

一、单独添加ant  

    $ cnpm i antd --save

    import &apos;antd/dist/antd.css&apos;;         // 引入样式
    import { DatePicker } from &apos;antd&apos;;    // 这种方法的引用必须要添加babel-plugin-import的按需加载组件
    ReactDOM.render(&lt;DatePicker /&gt;, mountNode);            

二、按需加载插件 babel-plugin-import

    $ cnpm i babel-plugin-import --save

    .babelrc添加参数:
    {
        &quot;plugins&quot;: [
            [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }] // `style: true` 会加载 less 文件
        ]
    }

三、dva-cli安装

    $ cnpm i dva-cli    

    $ dva new [项目名] &amp;&amp; cd [项目名]        // 创建项目

    $ cnpm install antd babel-plugin-import --save        // 安装 ant 和 babel插件（用来按需加载 antd 的脚本和样式的）

        .webpackrc文件加参数
        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ]  
        }

四、运行

    $ npm start         // 生产环境运行

    $ npm run build        // 打包项目，发布线上环境在Dist目录下生成静态文件，js、css压缩

五、redux的使用

    有两个目录，models和components, model来定义state和action的，components来编写组件

    dva提供conect方法，将model和component串联起来

    import { connect } from &apos;dva&apos;;

    const Products = ({ dispatch, products }) =&gt; { ... }
    export default connect(({ products }) =&gt; ({
        products,
    }))(Products);

六、配置

    1、 .roadhogrc.mock.js  用于mock数据的配置

        export default {
            // 支持值为 Object 和 Array
            &apos;GET /api/users&apos;: { users: [1,2] },

            // GET POST 可省略
            &apos;/api/users/1&apos;: { id: 1 },

            // 支持自定义函数，API 参考 express@4
            &apos;POST /api/users/create&apos;: (req, res) =&gt; { res.end(&apos;OK&apos;); },
        };

    2、.webpackrc  

        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ],
            &quot;entry&quot;: &quot;src/index.js&quot;,        // 可以配置webpack的选项，参数见面下roadhog的文档连接
            &quot;proxy&quot;: {                        // 设置代理
                &quot;/api&quot;: {
                    &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;,
                    &quot;changeOrigin&quot;: true,
                    &quot;pathRewrite&quot;: { &quot;^/api&quot; : &quot;&quot; }
                }
            }
        }

    3、设置端口

        默认是8000，可以在package.json中设置
        &quot;scripts&quot;: {
               &quot;start&quot;: &quot;PORT=3000 roadhog server&quot;,        // windowns设置 set PORT=3000&amp;&amp;roadhog dev
        }

    4、public目录会在build的copy到dist目录下，存放一些静态文件

https://github.com/sorrycc/blog/issues/18            // dva
https://github.com/sorrycc/roadhog/blob/master/README_zh-cn.md    // roadhog


七、fatch请求

    dva-cli中utils目录中request.js中定义了一个通过fatch来发ajax请求的方法

    业务中调用:
    function IndexPage() {
        var getUser = () =&gt; {
            Request(&apos;/api/posts&apos;, {method: &apos;GET&apos;})
            .then((data)=&gt;{
                debugger;
            })
        }
        getUser()

        return (
            &lt;div className={styles.normal}&gt;
                ...
            &lt;/div&gt;
        );
    }
    exports default IndexPage;
</code></pre><h4 id="收集组件"><a href="#收集组件" class="headerlink" title="收集组件"></a>收集组件</h4><pre><code>1、react-transition-group - 页面切换过渡效果

https://github.com/reactjs?page=2
</code></pre><p>| <a href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener">https://facebook.github.io/create-react-app/</a>            // create-react-app 官网<br>| <a href="https://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">https://react-guide.github.io/react-router-cn/</a>        // React-router 中文网<br>| <a href="https://reacttraining.com/react-router/web/example/basic" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/example/basic</a>    // 官方示例**<br>| <a href="https://www.jianshu.com/p/25e9ba1ebafb" target="_blank" rel="noopener">https://www.jianshu.com/p/25e9ba1ebafb</a>                        // react源码分析<br>| <a href="https://github.com/YutHelloWorld/Blog/issues/4" target="_blank" rel="noopener">https://github.com/YutHelloWorld/Blog/issues/4</a>        // v2、3迁移v4<br>| <a href="https://www.jianshu.com/p/e0a0ed6c3b8a" target="_blank" rel="noopener">https://www.jianshu.com/p/e0a0ed6c3b8a</a>                // 路由跳转登录验证<br>| <a href="https://www.jianshu.com/p/e3adc9b5f75c/" target="_blank" rel="noopener">https://www.jianshu.com/p/e3adc9b5f75c/</a><br>| <a href="https://segmentfault.com/a/1190000009349377" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009349377</a>        // router ^4<br>| <a href="https://github.com/reactjs/react-router-redux" target="_blank" rel="noopener">https://github.com/reactjs/react-router-redux</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之三)Redux/">React（之三）Redux</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之三)Redux/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createStroe - 创建一个store<br>| reducer - 用来改变state的值，结合了action的动作来分别处理<br>| action - 要执行的事件<br>| combineReducers - 将多个reducer合到一起,赋给createStroe<br>| replaceReducer - 替换reducer，改变state修改逻辑<br>| subscribe - 侦听Store的变化<br>| store.getState - 获取Store中的state值<br>| store.dispatch - 触发action，改变state的值<br>| provider - 将Store传递给内部组件<br>| connect - 将组件与redux的状态、事件关联起来<br>| applyMiddleware - 加载中间件<br>| bindActionCreators - 直接调用dispatch(action)()<br>| react-redux - react与redux结合</p>
<h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><pre><code>react是纯View层的框架，需要数据流进行支撑, 单一的状态树,主流数据流框架: Flux、Redux

UI -&gt; action -&gt; reducer -&gt; store -&gt; state -&gt; UI

Redux是非异步的流程，如果需要使用异步操作使用 Redux-saga

一、Flux四部分

    1、Dispatcher - 处理动作分发，维持Store之间的依赖关系

    2、Store - 负责存储数据和处理数据相关逻辑

    3、Action - 驱动Dispatcher的JS对象

    4、View - 视图部分，负责显示用户界面

    Dispatcher相当于Controller，Stroe相当于Modle，View相当于View，Action相当于用户的行为


二、Redux三个基本原则

    1、唯一数据源 - 状态数据只存储在唯一的一个Store上

    2、保持状态只读 - 不能直接修改Store的状态，需要派发一个action对象完成

    3、数据改变只能通过纯函数完成
</code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>Facebook官方提出了Flux思想管理数据流，同时也给出了自己的实现方案Flux来管理React应用

实现Flux思想的类库 Redux、Flux、reflux

$ npm i redux --save                    // 安装redux

$ npm i react-redux --save            // redux与react结合

$ npm i react-router-redux --save     // redux-router

$ npm i redux-devtools-extension --save        // 安装可视化工具

    引用：import { composeWithDevTools } from &apos;redux-devtools-extension&apos;

    在chrome中下载redux-devtools插件

    https://github.com/zalmoxisus/redux-devtools-extension#usage

$ npm i redux-thunk --save

$ npm i redux-logger --save

引用redux: import { createStore } from &apos;redux&apos;

一、Redux流程:

    1、view直接触发dispatch

    2、dispatch将action发送到reducer中后，根节点上会更新props，改变全局view

    3、redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中    
</code></pre><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><pre><code>action指令并不能直接改变state，action必须是json

let todoId = 0;
export const addTodo = (text) =&gt; {
    return {
        type: &apos;ADD_TODO&apos;,    // 处理的类型(必要)
        id: todoId++,            // 存储数据当前的id标识
        text                            // 传入的内容
    }
}

通过 store.dispatch(action) 来派发到reducer中, 在reducer中改变state的值
</code></pre><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><pre><code>接收一个action值，纯方法不能定义ajax定义时间等，需要传入一个旧的状态在返回一个新的状态给action, 根据定义的action名对应处理state，并改变state值

let todo = (state, action) =&gt; {

    // 这里通过action的type的值对应不同的事来处理
    switch(action.type){
        case &apos;ADD_TODO&apos;:
            return {
                state + 1;
            }
            break;

        /* 上面只是单个add_todo, 这里要写成多个add_todo
        case &apos;ADD_TODO&apos;:
            return [
                {
                    id: action.id,
                    text: action.text,
                    completed: false
                },
                ...state
            ]
            break;            
        */

        case &apos;SUB_TODO&apos;:
            return {
                state - 1;
            }
            break;

        default: state;
    }
}

1、combineReducers - 将多个的reducer合成一个

    // 目录 reducer/index.js
    import {combineReducers} from &quot;redux&quot;;
    import reducerA from &quot;./reducerA&quot;;
    import reducerB from &quot;./reducerB&quot;;

    export default combineReducers({
        reducerA,
        reducerB,
    });

    // createStore调用reducer
    import reducers from &apos;./reducer/&apos;
    let store = createStore(reducers)
</code></pre><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><pre><code>Store是来保存数据的容器，只有一个Store，可以根据不同业务拆分成多个reducer， createStroe(reducer, 初始化的)

import { createStore } from &apos;redux&apos;;
import reducer from &apos;./reducers&apos;        // 获取定义的reducer

let stroe = createStroe(reducer);    // 使用createStore(reducer, initialState初始化state, 中间件传入)来创建一个数据仓库
store.dispatch();

方法:

    1、store.getState(): 获取State值

    2、store.dispatch(action): 触发action，修改state的值

    3、store.subscribe(listener)，用来订阅状态的变化

        添加一个变化的监听器，每当dispatch action的时候就会执行

        // App组件
        class App extends Component {
            constructor(props){
                super(props);
                this.state = {
                    num: 0
                }
            }

            componentDidMount() {
                store.subscribe(this.handleChange.bind(this));
            }

            handleChange(){
                this.setState({num: store.getState()})
            }

            addClick(){
                store.dispatch({type: &apos;add&apos;});
            }

            subClick(){
                store.dispatch({type: &apos;sub&apos;});
            }

            showState(){
                debugger;
                console.log(store.getState())
            }

            render() {
                return (
                    &lt;div className = &quot;box&quot; &gt;
                        {this.state.num}
                        &lt;input type=&quot;button&quot; onClick={this.addClick} value=&quot;+&quot; /&gt;
                        &lt;input type=&quot;button&quot; onClick={this.subClick} value=&quot;-&quot; /&gt;
                        &lt;input type=&quot;button&quot; onClick={this.showState} value=&quot;查看state&quot; /&gt;
                    &lt;/div&gt;
                )
            }
        }
</code></pre><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><pre><code>state用于存储数据，state是只读的，改变需要触发action

state树就是一个对象，所有的reducer的都会加到state中，取state值，store.getState().
</code></pre><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h4><pre><code>$ npm i react-reudx --save        // 安装

一、provider(store, children) - 将Store传到子组件中，一般用在入口文件

    import React from &apos;react&apos;;
    import ReactDOM from &apos;react-dom&apos;;
    import {Provider} from &quot;react-redux&quot;;
    import Store from &quot;src/store&quot;;
    import App from &apos;src/components/app&apos;;
    import Chat from &apos;src/pages/Chat/Index&apos;;

    // 1、使用Store让所有组件访问到
    ReactDOM.render(
        &lt;Provider store={Store}&gt;
            &lt;App&gt;
                &lt;Chat /&gt;
            &lt;/App&gt;
        &lt;/Provider&gt;,
        document.getElementById(&apos;app&apos;)
    );

    // 2、如果使用路由
    ReactDOM.render(
        &lt;Provider store={store}&gt;
            &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
                &lt;Route path=&apos;/&apos; component={Index}&gt;
                    &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        &lt;/Provider&gt;
    )


二、connect(mapStateToProps, mapDispatchToProps)(Component连接组件) - 连接react组件与redux store

    1、mapStateToProps(state, ownProps) - 侦听Store的变化

            state参数 - 如果Store中有变化此方法就会被调用，该回调函数返回一个纯对象，这个对象会与组件的props合并

            ownProps参数 - 该参数的值为会飞经到组件的props,

    2、mapDispatchToProps - 逻辑输出，相当于用store.dispatch(actionType) 来发出操作指令，来改变state值

    Example:

        // app.jsx
        &lt;Provider store={store}&gt;
            &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
                &lt;Route path=&apos;/&apos; component={Index}&gt;
                    &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        &lt;/Provider&gt;

        // Index.jsx
        import React, { Component } from &apos;react&apos;;
        import ReactDOM from &apos;react-dom&apos;;
        import { bindActionCreators } from &quot;redux&quot;;
        import { connect } from &quot;react-redux&quot;;
        import actions from &quot;src/actions&quot;;

        class wechat extends Component {
            constructor(props){
                super(props);
                this.state = {

                }
            }

            componentDidMount(){
                let { ACTIONS } = this.props;
                ACTIONS.chat_init();
            }

            render(
                // ...
            )
        }

        let mapStateToProps=(state)=&gt;{
            let {sessions,user} = state.chatIndex;
            return {
                _sessions:sessions,
                _user:user
            };
        }; 

        let mapDispatchToProps=(dispatch)=&gt;{
            return {
                ACTIONS: bindActionCreators(actions, dispatch)
            };
        };

        export default connect(mapStateToProps,mapDispatchToProps)(wechat);
</code></pre><h4 id="container组件"><a href="#container组件" class="headerlink" title="container组件"></a>container组件</h4><pre><code>引用Redux将组件分两类container和component

container - 组件中使用redux获取数据，状态更新，从Redux获取state
</code></pre><h4 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators()"></a>bindActionCreators()</h4><pre><code>是通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用）

import * as oldActionCreator from &apos;./action.js&apos;

let newAction = bindActionCreators(oldActionCreator,dispatch)
</code></pre><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><pre><code>两种方法 1、下载redux-devtools包      2、chrome or Firfix 下载 Redux DevTools插件

1、使用Redux DevTools插件 代码中需要加配置

    https://github.com/zalmoxisus/redux-devtools-extension

    /* eslint-disable no-underscore-dangle */        // +
    let store = createStore(
        comput,
        window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()        // +
    )
    /* eslint-enable */                                // +


2、redux-devtool 包的使用 https://github.com/gaearon/redux-devtools
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>|- src
|-- reduxs     // redux
|------ actions
|------ reducers
|-- router    // 路由
|-- util    // 工具
</code></pre><h4 id="react-router-redux路由"><a href="#react-router-redux路由" class="headerlink" title="react-router-redux路由"></a>react-router-redux路由</h4><pre><code>redux管理的是应用状态（state），router管理的是路由，react-router-redux是保持路由与应用状态（state）同步

$ npm install --save react-router-redux        // 安装

原理：允许使用react router库中的api，使用redux一样去管理应用状态state

https://www.jianshu.com/p/bccca5bb6338
http://blog.csdn.net/isaisai/article/details/78086913
https://segmentfault.com/a/1190000007862103

http://blog.csdn.net/sinat_17775997/article/details/69218382
</code></pre><p>| <a href="http://cn.redux.js.org/index.html" target="_blank" rel="noopener">http://cn.redux.js.org/index.html</a>                // Redux中文文档<br>| <a href="http://www.liuyiqi.cn/2016/01/19/r2-counter/" target="_blank" rel="noopener">http://www.liuyiqi.cn/2016/01/19/r2-counter/</a><br>| <a href="https://github.com/lewis617/react-redux-tutorial" target="_blank" rel="noopener">https://github.com/lewis617/react-redux-tutorial</a><br>| <a href="https://github.com/xgrommx/awesome-redux" target="_blank" rel="noopener">https://github.com/xgrommx/awesome-redux</a><br>| <a href="https://www.jianshu.com/p/bccca5bb6338" target="_blank" rel="noopener">https://www.jianshu.com/p/bccca5bb6338</a>        // react－router－redux 保持路由与应用状态（state）同步<br>| <a href="http://www.redux.org.cn/" target="_blank" rel="noopener">http://www.redux.org.cn/</a>                        // react-redux<br>| <a href="https://www.jianshu.com/p/1a2f3db4af61" target="_blank" rel="noopener">https://www.jianshu.com/p/1a2f3db4af61</a>        // react-redux<br>| <a href="https://www.jianshu.com/p/9873d4ccb891" target="_blank" rel="noopener">https://www.jianshu.com/p/9873d4ccb891</a>        // connect 原理<br>| <a href="https://github.com/GuoYongfeng/redux-complete-sample" target="_blank" rel="noopener">https://github.com/GuoYongfeng/redux-complete-sample</a><br>| <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">https://github.com/gaearon/redux-devtools</a><br>| <a href="http://www.aliued.com/?p=3204" target="_blank" rel="noopener">http://www.aliued.com/?p=3204</a><br>| <a href="http://blog.csdn.net/liwusen/article/details/54138854" target="_blank" rel="noopener">http://blog.csdn.net/liwusen/article/details/54138854</a>         // bindActionCreators<br>| <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a><br>| <a href="https://github.com/allan2coder/React-SPA/blob/master/src/store/configureStore.dev.js" target="_blank" rel="noopener">https://github.com/allan2coder/React-SPA/blob/master/src/store/configureStore.dev.js</a>            // 示例 router3.0</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/ES6/">ES6</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/ES6/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/ES6/">ES6</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| let块级作用域、 const常量<br>| 解构赋值<br>| 箭头函数、default、rest、spread<br>| 模板字符串<br>| class: extends、super、constructor、静态属性和方法、实例属性<br>| Promise、Generator、async/await<br>| 模块化: import、export、as、*、default export<br>| 数据结构: Set不重复值的集合、Map<br>| Proxy 对象的拦截器<br>| Symbol<br>| symbol 独一无二的值<br>| Set、Map数据结构</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><pre><code>一、let 声明变量

    let完全可以取代var, 特性: 1、let不允许重复声明        2、没有预解析功能        3、块级作用域

    1、预解析功能

        console.log(a);        // 报错, 如果是原来的var声明这里会是undeined, 所以let没有预解析功能
        let a = 20;

    2、块级作用域 在{ }中声明的变量只能在括号里使用

        var name = &apos;lulu&apos;;
        function prsone(){
            let name = &apos;siguang&apos;;
        }

        prsone();
        console.log(name);            // &apos;lulu&apos;

        // 输出的都是10
        for(var i=0; i&lt;10; i++){
            setTimeout(function(){
                console.log(i);        // 使用var声明的i都会打印出9，如果使用let输出的就是0到10
            })
        }

二、const常量

    1、常量只允许赋一次值不能被修改        2、常量声明都为大写        3、与let相当只在块级作用域有效

    const NAME = &apos;siguang&apos;;        // 不能变化的值
    NAME = &apos;lulu&apos;;                // 报错

    if (true) {
        const MAX = 5;
    }
    MAX            // 报错，const与let相同都是在块内使用
</code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><pre><code>允许从数组和对象中提取的值，对变量进行赋值，被称为解构赋值

一、数组解构使用[]

    let [a, b, c] = [1, 2, 3];    // a=1, b=2, c=3

    // 默认值
    let [x, y = &apos;b&apos;] = [&apos;a&apos;];     // x=&apos;a&apos;, y=&apos;b&apos;


二、对象解构使用{}

    // 对象是按名字来解析赋值
    let obj = {
        getName: function(){}, 
        foo: &apos;aaa&apos;, 
        bar: &apos;bbb&apos;
    };
    let {foo, bar} = obj        // foo=&apos;aaa&apos;, bar=&apos;bbb&apos;

    // 对象的解构赋值，先找到同名，在将值赋给对应的变量
    let { foo: val, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };  
    console.log(val, bar)        // foo=&apos;undefined&apos;, val=&apos;aaa&apos;, bar=&apos;bbb&apos;


三、字符串的解构赋值

    const [a, b, c, d, e] = &apos;hello&apos;;    // a=h, b=e, c=l, d=l, e=o
    const [...tail] = &apos;hello&apos;;            // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]

    # length属性
    let {length: len} = &apos;hello&apos;;        // length = 5


四、默认参数 default

    # 参数作为数组
    function add([x, y]){
        return x * y
    }
    add([3,2]);        // 6

    # 参数作为对象，对x、y的默认初始值
    function move({x = 0, y = 0}) {
        return [x, y];
    }
    move({x: 3, y: 8}); // [3, 8] 


五、不定参数 Rest

    function f(x, ...y) {
        // y是一个数组
        return x * y.length;
    }
    f(3, &quot;hello&quot;, true) == 6


六、扩展运算符 Spread

    function f(x, y, z) {
        return x + y + z;
    }
    // 将数组中的每个元素展开为函数参数
    f(...[1,2,3])            // 6
</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>一、写到`...`之间，值的输出使用 ${...} 

二、可以写多行字符串，只写到`...`之间就可以

三、${...}可以解析变量、对象的值、表达式、函数返回

    let name = &apos;siguang&apos;;
    let obj = {
        age: 33
    }
    console.log(`你的名字是: ${ name } 你的年龄是:  ${ obj.age }`)

四、标签模板

    let a=10, b=20;
    dialog`Hello ${a+b} world ${a*b}`;        // 等同于 dialog()
</code></pre><h4 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h4><pre><code>一、箭头函数

    1、箭头函数的注意问题: 

        * 箭头函数里的this不是指向调用者，而指向对象
        * 不能当构造函数来用, 不能使用new
        * 函数内不存在arguments对象
        * 不可以使用yield命令，箭头函数不能用作Generator函数

        arr.sort(function(){  ...  }) 相当于 arr.sort((a, b) =&gt; a-b);

        // 箭头函数的this，不是指向调用者
        const Template = {
            test(){
                console.log(this);        // this指向Template

                document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                    /* 如果非箭头函数this应该指向 #showThis */
                    /* 这里箭头函数不是指向调用者，所以指向了 Template */
                    console.log(this);    
                }
            }
        }
        Template.test();

    2、var f = function(v){ return v; }

        // ES6写法
        var f = v =&gt; v;

    3、var sum = function(num1, num2){
            return num1 + num2;
        }

        // ES6写法
        var sum = (num1, num2) =&gt; {
            return num1 + num2;
        }

    4、对象中方法的简写

        var obj = {
            name: &apos;haha&apos;,
            getName(){                // 是getName: function(){}的简写
                console.log(this.name);
            },
            setName(name){
                this.name = name;
                console.log(this.name);
            }
        }


二、函数参数默认值

    function fn(a, b = 2){
        // b如果不传相当于2，等同于 var b = arguments.length &gt; 1 &amp;&amp; arguments[1] == undefined ? arguments[1] : 2;
        return {a, b}
    }
    console.log(fn(10));        // 返回{a: 10, b: 2}

    // 如果没有参数默认值时还需要在函数体内做兼容
    function fn(name){
        var getName = name || 20;
    }
    fn();


三、参数的解构赋值

        const full = ({ first, last }) =&gt; first + &apos; &apos; + last;    
        full({first: 20, last: 30})

        // 等同于
        // function full(person) {
        //      return person.first + &apos; &apos; + person.last;
        // }


四、rest 获取多余参数

    以&apos;...变量名&apos; 来获取多余的参数，返回一个数组，这样就不需要arguments对象了

    function person(...rest){
        console.log(rest);        // [1,2,3,4,5]
    }
    person(1,2,3,4,5);

    function person(a, ...rest){
        console.log(a);            // 1
        console.log(rest);        // [2,3,4,5]
    }
    person(1,2,3,4,5);


五、spread 扩展操作符 ...  与rest相反

    function add(x, y) {
        return x + y;        // 4+38
    }
    var numbers = [4, 38];            // 只能为数组不能为对象
    add(...numbers)         // 42

    # 可以将字符串转成数组
    let arr = [...&apos;hello&apos;];        // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]


六、name属性

    funciton foo(){ ... }
    foo.name;        // &apos;foo&apos; 返回函数名


七、::运算符

    箭头函数可以绑定this对象，减少显式this对象的写法(call、apply、bind)

    ES7提出了函数绑定来取代&quot;call、apply、bind&quot;调用，使用两个&quot;::&quot;

    foo::bar;        // 等同于 bar.bind(foo);
    foo::bar(...arguments);        // 等同于 bar.apply(foo, arguments);
</code></pre><h4 id="类、继承"><a href="#类、继承" class="headerlink" title="类、继承"></a>类、继承</h4><pre><code>一、类的一些特性

    1、对象方法的简写方法
        class Cat{
            getName(){        // 老写法 getName: function(){}
                ...
            }
        }

    2、通过__proto__属性可以直接调用父类
        var parent = {
            getParentName(){
                console.log(&apos;parent&apos;)
            }
        }

        var childer = {
            __proto__: parent,            // 通过__proto__指向parent, 就可以直接调用parent类中的方法
            getChildeName(){
                console.log(&apos;childer&apos;);
            }
        }

        childer.getChildeName();    // childer
        childer.getParentName();    // parent


二、创建类

    class Cat {
        // ES6中新型构造器, 用来初始化时这里接收参数
        constructor(name){ 
            this.name = name;
        }

        getName(){        // 公有方法
            console.log(this.name);
        }

        static bar(baz){        // 私有方法
            debugger;
            return this.name = baz;
        }

        * gen(){
            let arg = 10;
            yield arg;
        }
    }

    Cat.userName = &apos;siguang&apos;;

    var oCat = new Cat(&apos;哈哈&apos;);
    oCat.getName();
    oCat.bar(&apos;lulu&apos;);                // 报错静态方法调用不到，并且不会被继承
    oCat.gen().next()


三、继承 extends

    // 创建一个类
    class Person {
        constructor(name){
            this.name = name;
        }

        getName(){
            console.log(this.name);
        }
    }

    // 继承这个类
    class Children extends Person {
        constructor(name, color){
            super(name);                // super指向继承的构造函数Person的constructor
            this.color = color;
        }

        getColor(){
            console.log(this.name, this.color);
        }
    }

    // 实例化
    var op = new Person(&apos;siguang&apos;);
    op.getName();            // &apos;siguang&apos;

    var oc = new Children(&apos;lulu&apos;, &apos;red&apos;);        
    oc.getColor();        // &apos;red&apos;
    oc.getName();            // &apos;lulu&apos;


四、static 静态属性和方法

    类似构造函数，直接挂载到函数下的叫对象的属性和方法，而写到构造函数内部的叫构造函数的属性和方法

    1、静态方法前面需要加上&apos;static&apos;关键字，相当于只是函数下的方法而不是prototype的方法，静态方法可以被子类继承，

        class Foo{
            static methodName(){
                return &apos;hello&apos;
            }
        }
        Foo.methodName();    // hello

        var foo = new Foo();
        foo.methodName();    // 报错

    2、静态属性

        ES6中没有静态属性，只能声明静态方法，ES7中可以直接写到类内在进行转码

        class Foo {
            constructor(...arg){
                this.args = args;
            } 
            outputUserName(){
                console.log(this.username);    // 这里username未定义，除非在constructor中定义 this.username
            }
        }
        Foo.username = &apos;siguang&apos;;       // 类的静态属性

        var foo = new Foo();
        console.log(foo.personName);  // undefined
        foo.outputUserName();               // undefined 


五、实例属性

    注意: 一定要将实例属性和静态属性区分，实例属性写到constructor中this.username, new后的实例时候可以被实例方法调用，而静态属性只挂到了类下直接通过类来调取，Foo.username

    class Foo{
        constructor(){
            this.username = &apos;siguang&apos;;
        }
        showName(){
            console.log(this.username);     // siguang
            console.log(Foo.username);      // lulu
        }
    }
    Foo.username = &apos;lulu&apos;;

    var foo = new Foo();
    foo.showName();

    ****** ES7 中静态属性和实例属性的定义 ******
    class MyClass{
        usernameA = &apos;siguang&apos;;        // 实例属性

        showName(){
            console.log(this.usernameA);
        }
    }


六、super()方法

    继承时必须调用一次super方法，否则constructor中的this为undefined，调用父类的构造器进行初始化, 子类调用父类的构造函数

    class BaseModel {
        constructor(options, data) { // class constructor，node.js 5.6暂时不支持options = {}, data = []这样传参
            this.name = &apos;Base&apos;;
            this.url = &apos;http://azat.co/api&apos;;
            this.data = data;
            this.options = options;
        }
        getName() { // class method
            console.log(`Class name: ${this.name}`);
        }
    }

    class AccountModel extends BaseModel {
        constructor(options, data) {
            super({private: true}, [&apos;3333&apos;, &apos;4444&apos;]); 
            this.name = &apos;Account Model&apos;;
            this.url +=&apos;/accounts/&apos;;
        }
        getAccountsData() {
            return this.data;
        }
    }

    let accounts = new AccountModel(5);
    accounts.getName();         // Account Model
    console.log(&apos;Data is %s&apos;, accounts.getAccountsData);        // {private: true}

    let base = new BaseModel({public: true}, [&apos;111&apos;, &apos;2222&apos;]);
    console.log(base.getName());        // Base


七、class中的Generator方法

    方法前面加&quot; * &quot; 号表示该方法是Generator函数

    class MyClass = {
        constructor(){
            ...
        }

        * getName(){
            ...
        }
    }
</code></pre><h4 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h4><pre><code>一、import: 模块加载

    // 取整个对象
    import $ from &apos;jquery&apos;;

    // 通过解构取对象
    import {name1, name2, nam3} from &apos;./user.js&apos;;

    // 通过逗号分两整体和解构分别来取
    import React, { Component, PropTypes } from &apos;react&apos;;

    // 重命名
    import * as React from &apos;react&apos;;        // * 对整体模块加载，并通过as转换一个名

    // 按需加载
    button.addEventListener(&apos;click&apos;, event =&gt; {
        imoprt(&apos;dialog.js&apos;)
            .then(dialog =&gt; {
                dialog.show();
            }).
            catch(err =&gt;{
                // error
            })
    }, false)


    不同写法

        1、普通写法

            meat.js
                export function beef(){
                    return &apos;牛肉&apos;;
                }
                export function pork(){
                    return &apos;猪肉&apos;;
                }

            main.js

                import { beef, pork } from &apos;meat.js&apos;;
                console.log(beef());        // 牛肉
                console.log(pork());        // 猪肉


        2、key的简写

            var fn1 = function(){
                console.log(&apos;fn1&apos;);
            }
            var fn2 = function(){
                console.log(&apos;fn2&apos;);
            }

            export {fn1, fn2}         // 对象名与key相同可以写成一个


二、export: 模块输出

    1、使用对象简写方式

        var name1 = &apos;aaa&apos;;
        var name2 = &apos;bbb&apos;;
        var name3 = &apos;ccc&apos;;
        export {name1, name2, name3} 

        // 也可以写成    
        export var name1 = &apos;aaa&apos;;
        export var name2 = &apos;bbb&apos;;
        export var name3 = &apos;ccc&apos;;


    2、可以直接输出变量、函数或类

        export function person(){ ... }

        // 不能直接输出变量名
        var name = &apos;siguang&apos;;
        export name;            // 报错

        写成: export var name = &apos;siguang&apos;;        
        写成: var name = &apos;siguang&apos;;   export {name};    


    3、跨模块常量

        const常量只能在当前代码下使用，通过export可以进行跨模块常量，多个文件都可以使用

        export const name = &apos;siguang&apos;;
        export const age = 33;

        import * as info from &apos;userinfo&apos;;        // 或 import { name, age } from &apos;userinfo&apos;


三、as 关键字来修改名字

    meat.js

        export function beef(){
            return &apos;牛肉&apos;;
        }

        export function pork(){
            return &apos;猪肉&apos;;
        }

    main.js

        // * 代表meat.js下所有的对外接口，转换成meat对象下，这样就可以通过meat来调用meat下的
        import * as meat from &apos;./meat.js&apos;;        
        console.log(meat.beef());        // 牛肉
        console.log(meat.pork());        // 猪肉


四、* 将somModule内的所有导出接口

    import * as newSome from &apos;./someModule&apos;        // 将someModule类的所有接口更改到newSome下


五、export default指定匿名

    不使用default在import加载定义名与导出名必须相同，否则无法加载，如果指定默认输出使用export default，在import导入的时候不用在关心命名的问题

    1、meat.js

        // 倒出匿名函数
        export default function() {
            console.log(&apos;foo&apos;);
        }

        简写
        export default(){        // export default {}  写成默认对象

        }

    main.js

        // 导入时可以任意起名
        import beef from &apos;./meat.js&apos;


    2、default与不写default输出的区别

        // 使用default来输出，import不需要使用{}
        export default function crc32() {
            // ...
        }
        import crc32 from &apos;crc32&apos;;

        // 不使用default来输出，import需要使用 {}
        export function crc32() { // 输出
            // ...
        };
        import {crc32} from &apos;crc32&apos;; // 输入
</code></pre><h4 id="Set、Map数据结构"><a href="#Set、Map数据结构" class="headerlink" title="Set、Map数据结构"></a>Set、Map数据结构</h4><pre><code>一、Set(): 类似数组的一种新结构，成员都是唯一的值没有重复值，相当于数组去重

    # 数组去重的新方法
    let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
    console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
    let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    特性: 
        1、不允许数组里有重复数据

    方法: 
        1、set.size: 获取数据的长度

        2、set.add(value): 添加值

        3、set.delete(value): 删除set的实例值

        4、set.has(value): 传入的参数是否为set的成员

        5、set.clear(): 删除set的所有成员


二、Map(): 将二维数组转成对象

    var map = new Map([[&apos;username&apos;, &apos;siguang&apos;], [&apos;password&apos;, &apos;ssssss&apos;]]);
    map.get(&apos;username&apos;);        // siguang

    /* new Map([[&apos;usernmae&apos;, &apos;aaa&apos;, &apos;password&apos;, &apos;ssssss&apos;], [&apos;aaaa&apos;, 1111]]);  注意一个数组中只有两个下标的值，这里只能get到username, password不会取到 */

    特性: 不允许有重复的key值

    方法: 
        1、map.size: 成员总数

        2、map.set(&apos;key&apos;, &apos;value&apos;): 添加成员

        3、map.get(): 获取

        4、map.clear(): 清除所有
</code></pre><h4 id="对象扩展-Object"><a href="#对象扩展-Object" class="headerlink" title="对象扩展 Object"></a>对象扩展 Object</h4><pre><code>一、简写

    1、对象属性和值相同可以写成一个

        var foo = { name: &apos;siguang&apos;};
        var baz = {
            foo            // foo: foo 相同
        };
        console.log(baz.foo.name);    // siguang

    2、对象中函数简写

        var o = {
            name: &apos;momo&apos;,
            getName(){            // 等同于 getName: function(){}
                retrun this.name;
            }
        }

    3、参数作为对象返回

        function f(x, y) { return {x, y}; }

        // 等同于
        function f(x, y) {
            return {x: x, y: y};
        }
        f(1, 2)     // Object {x: 1, y: 2}

        // 2、CommonJS模块输出变量
        const getItem = function(){ ... }
        const setItem = function(){ ... }
        const clear = function(){ ... }
        module.exports = { getItem, setItem, clear };

        // 等同于
        // module.exports = {
        //   getItem: getItem,
        //   setItem: setItem,
        //   clear: clear
        // };


二、[] 属性名表达式

    // 对象的属性名可以用&apos;[]&apos;字符串拼接
    var sex = &apos;男&apos;;
    var obj = {
        name: &apos;momo&apos;,
        [sex]: false,
        [&apos;get&apos;+&apos;Name&apos;](){
            console.log(this.name, this[&apos;男&apos;]);        // 返回 momo false
        }
    }
    obj.getName();


三、getter 赋值器、setter 取值器

    let cat = { 
        name: &apos;喵喵&apos;, 
        get name(){ return this.name },   
        set name(value){
            if(Object.prototype.toString.call(&apos;xxx&apos;) == &apos;[object String]&apos;){
                this.name += value
            }
        }
    }


四、Object.is(): 用于对比两个数字或字符串是否相等，相当于 === ，可以正确比较 -0和0，NaN和

    &apos;==&apos;与&apos;===&apos;的缺点:

        相等运算符（==）缺点: 自动转换数据类型
        和严格相等运算符（===）缺点: NaN不等于自身，以及+0等于-0

    Objetc.is(0, -0);        // false
    Object.is(NaN, NaN);    // true


五、Object.assign(目标对象， 被合并对象B, 被合并对象C): 合并对象

    /* 注意: 被合并对象与合并目标对象的属性相同会赋盖掉前面的对象的值 */
    var objA = {a: 1, b:2}, objB = {b: 3, c: 4}; 
    let req = Object.assign(objA, objB);         // {a:1, b:3, c:4}

    添加对象的方法: 
        Object.assign(SomeClass.prototype, {
            someMethod(arg1, arg2){
                // ...
            },
            anotherMethod(){
                // ...
            }
        })

        相当于
        SomeClass.prototype.someMethod = function(arg1, arg2){ // ... }
        SomeClass.prototype.anotherMethod = function(){ // ... }

    克隆对象: 
        function clone(obj){
            return Object.assign({}, obj);
        }

    注意点: 

        1、assign 是浅拷贝

        2、同名属性替换


六、getPrototypeOf(object)、setPrototype(object, 谁的prototype): 获取、设置对象的prototype

    var Cat = function(name){
        this.name = name;
    }

    Cat.prototype.showName = function(){
        return this.name;
    }

    var c1 = new Cat(&apos;momo&apos;);
    c1.showName();

    console.log(Object.getPrototypeOf(c1))

    // 设置prototype
    var Person = function(nationality){
        this.nationality = nationality;
    }
    Person.prototype = {
        showNationality: function(){
            return this.nationality;
        }
    }
    Object.setPrototypeOf(c1, Person.prototype);
    console.log(Object.getPrototypeOf(c1));


七、keys()、values()

    获取对象的所有keys或所有值, 并返回一个数组

    var obj = {name: &apos;siguang&apos;, age: 33};
    console.log(Object.keys(obj));        // [name, age]
    console.log(Object.values(obj));    // [&apos;siguang&apos;, 33]


八、__proto__属性

    用来读取或设置当前对象的prototype对象

    var Person = function(name){
        this.name = name;
    }
    Person.prototype = {
        constructor: Person,
        getName(){
            console.log(this.name);
        }
    }
    var op = new Person(&apos;lulu&apos;);

    // 继承
    var PersonChilder = function(){}; 
    PersonChilder.__proto__ = op;
    var opc = new PersonChilder(); 
    console.log(opc.getName())

    增强的对象字面量

    // 通过对象字面量创建对象
    var human = {
        breathe() {
            console.log(&apos;breathing...&apos;);
        }
    };

    var worker = {
        __proto__: human, //设置此对象的原型为human,相当于继承human
        company: &apos;freelancer&apos;,
        work() {
            console.log(&apos;working...&apos;);
        }
    };

    human.breathe();        // 输出 ‘breathing...’

    // 调用继承来的breathe方法
    worker.breathe();        // 输出 ‘breathing...’


九、遍历属性的方法

    1、for...in 循环

    2、Object.keys(obj): 返回obj对象的所有key, 返回是一个数组
</code></pre><h4 id="字符串对象扩展"><a href="#字符串对象扩展" class="headerlink" title="字符串对象扩展"></a>字符串对象扩展</h4><pre><code>1、repeat(): 复制字符串 

    var str = &apos;哈哈哈！&apos;.repeat(3);        // str输出 &apos;哈哈哈！哈哈哈！哈哈哈！&apos;

2、includes()、startsWith()、endsWith(): 查找三个方法

    var str = &apos;siguang 1983&apos;;
    str.includes(&apos;o&apos;);        // 查找字符串中是否包含值，包含返回true否则返回false
    str.startsWith(&apos;s&apos;);    // 第一个字符是不是s，如果是返回true
    str.endsWith(&apos;d&apos;);        // 最后一个字符是不是 d，返回布尔值

3、padStart(): 补全长度从开头, &apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;

4、padEnd(): 补全长度从结尾, &apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;
</code></pre><h4 id="Number、Math对象扩展"><a href="#Number、Math对象扩展" class="headerlink" title="Number、Math对象扩展"></a>Number、Math对象扩展</h4><pre><code>一、Math扩展

    1、trunc(): 去除小数部分 Math.trunc(123.123123);    // 123

    2、sign(): 判断是正数还是负数，如果是正数返回1，负数返回-1，0返回0

    3、Math.sign(-234);    // -1

    4、hypot(): 返回所有参数的平方和的平方根，Math.hypot(3,4);    // 5 勾股定理

二、Number对象扩展

    1、isFinite(): 是否是无穷数

    2、Number.isNaN(): 是否是NaN

    3、parseInt(&apos;12.34&apos;): es5的写法   Number.parseInt(&apos;12.34&apos;): es6的写法，为了减少全局方法

    4、Number.isInteger(num): 判断是否是一个整数
</code></pre><h4 id="数组扩展-Array"><a href="#数组扩展-Array" class="headerlink" title="数组扩展 Array"></a>数组扩展 Array</h4><pre><code>一、form(): 将对象转成数组

    var obj = {&apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;};
    var arr =  Array.form(obj); console.log(arr);        // [a, b, c]


二、of(): 将一组值转成数组

    var arrA = new Array(1, 2, 3);    // 生成一个[1,2,3]
    var arrB = new Array(3);                // arrB.length  等于3 如果传一个参数这样会生成一个3个空值
    var arrC = Array.of(3);                    // [3] 解决了new Array的问题


三、find(): 找出第一个符合条件的数据元素

    // 找出数组中值大于3的第一个数
    var arr = [1,2,3,4,5,6];
    var n = arr.find(function(value, index){
        return value &gt; 3;
    })
    console.log(n);        // 4


四、findIndex(): 找出第一个符合条件的位置，也就是所引值

五、fill(填充内容, 填充开始的位置, 填充结束的位置): 填充数组

    var arr = [1,2,3,4,5,6];
    arr.fill(7);        // 数组里全部为7
    arr.fill(7, 1, 3);    // 数组下标从1-3的值为7
    console.log(arr);


六、for...of: 遍历数组、字符串的值，但不能遍历对象

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr){
        console.log(value);        // 1,2,3,4,5,6 只能将遍历出数组的值
    }


七、keys()和values(): 返回数组的Key或value

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr.key()){
        console.log(value);
    }


八、entries(): 将数组的key和value一块输出

    var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];
    for(var [key, value] of arr.entries()){
        console.log(key, value);
    }

    返回: 
        0 &quot;a&quot;
        1 &quot;b&quot;
        2 &quot;c&quot;
        3 &quot;d&quot;
        4 &quot;e&quot;
        5 &quot;f&quot;


九、includes(): 查看数组中是否包含指定的值

    var arr = [1, 2, 3, 4, 5];
    arr.includes(3);        // true
</code></pre><h4 id="二进制数组-ArrayBuffer对象"><a href="#二进制数组-ArrayBuffer对象" class="headerlink" title="二进制数组 ArrayBuffer对象"></a>二进制数组 ArrayBuffer对象</h4><pre><code>二进制数组由三类对象组成: 

    ArrayBuffer对象: 代表原始的二进制数据。

    TypedArray视图: 用来读写简单类型的二进制数据。

    DataView视图: 用来读写复杂类型的二进制数据。


一、ArrayBuffer 对象

    它不能直接读写，只能通过（TypedArray和DataView）来读写。

    ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。

    var buf = new ArrayBuffer(32);        // 生成一段32字节的内存区域，每个字节默认为0


    属性和方法: 

    1、byteLength: 返回分配内存的字节长度

        var buffer = new ArrayBuffer(32);

        buffer.byteLength;        // 32


    2、slice(): 拷贝字节

        var buffer = new ArrayBuffer(8);

        var newBuffer = buffer.slice(0, 3);     //拷贝`buffer`对象的前三个字节（从0到3前结束），生成一个新的ArrayBuffer对象: newBuffer


    3、isView(): 返回一个布尔值，表示参数是否为ArrayBuffer的视图实例

        var buffer = new ArrayBuffer(8);
        ArrayBuffer.isView(buffer) // false

        var v = new Int32Array(buffer);
        ArrayBuffer.isView(v) // true


二、TypedArray 视图

    TypedArray数组只提供9种固定的构造函数
</code></pre><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><pre><code>JS新的数据类型，独一无二的值，凡是属性名属于Symbol类型，就是独一无二的

# 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();

s1 === s2         // false

# 有参数的情况
var s1 = Symbol(&apos;foo&apos;);
var s2 = Symbol(&apos;foo&apos;);

s1 === s2         // false

一、不能与其它值进行运算

    var sym = Symbol(&apos;My symbol&apos;);
    console.log(&quot;your symbol is &quot; + sym);        // 报错


二、toString()转成字符串

    let sym = Symbol(&apos;my symbol&apos;);
    sym.toString()    // &quot;Symbol(my symbol)&quot;
</code></pre><h4 id="Proxy对象拦截器"><a href="#Proxy对象拦截器" class="headerlink" title="Proxy对象拦截器"></a>Proxy对象拦截器</h4><pre><code>可以监听对象身上发生变化，对操作对象属性读取时做一个拦截器

&lt;script&gt;
    let obj = {
        a: 1,
        b: 2
    }

    // 相当于操作对象属性时的一个拦截器
    let oProxy = new Proxy(obj, {
        get(obj, key) {
            return obj[key];
        },
        set(obj, key, value) {
            // 这里来做拦截，如果修改的key=a 并且 value值小于10不会就将值修改
            if (key == &apos;a&apos; &amp;&amp; value &lt; 10) {
                obj[key] = value;
            }
        }
    })

    // 设置属性
    oProxy.a = 9; // {a: 9, b: 2}
    oProxy.a = 20; // {a: 9, b: 2}
    oProxy.b = 10; // {a: 9, b: 20}

    // 获取属性值
    console.log(oProxy.a, oProxy.b);    
&lt;/script&gt;
</code></pre><h4 id="Promise异步"><a href="#Promise异步" class="headerlink" title="Promise异步"></a>Promise异步</h4><pre><code>// resolve: 成功、reject: 失败
var pro = new Promise(function(resolve, reject){        // resolve成功, reject失败
    // 将一个耗时长的任务放到执行器里
    setTimeout(function(){
        resolve();            // 4毫秒后执行成功
    }, 400)
})

pro.then(
    function(){                        // reslove回调
        console.log(&apos;成功执行&apos;);
    },
    function(){                        // reject回调
        console.log(&apos;失败执行&apos;);
    }
)
.catch(function(e){            // 捕获异常，如果then中的两个方法成功失败有报错就会走catch
    console.log(e)
})

// 如果不需要reslove的回调可以设置为null
por.then(null, functino(){
    console.log(&apos;失败执行&apos;)
})


方法: 
一、Promise.all([实例1，实例2，实例3]): 用于多个promise实例，当三个实例都为真的时候all这个结果为真

    var p1 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p1完成&quot;);
        }, 400);
    })

    var p2 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p2完成&quot;);
        }, 1000);
    })

    var p3 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p3完成&quot;);
        }, 4000);
    })

    var p4 = Promise.all([p1, p2, p3]);
    p4.then(function(){
        console.log(&apos;三个全部执行成功&apos;)
    }, function(){
        console.log(&apos;失败&apos;)
    })

二、Promise.race([实例1，实例2，实例3]): 只要有一个为成功，p4为成功，与all()方法正反

https://www.jianshu.com/p/c98eb98bd00c
</code></pre><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><pre><code>Generator是一个状态机，封装了多个内部状态, 也是一个遍历对象生成函数，返回遍历器对象

Example: 

    function* ouputGenerator() {
        yield &apos;hello&apos;;            // 调用后不会马上执行，只有调用next()才会返回
        yield &apos;world&apos;;
        return &apos;ending&apos;;
    }
    let gen = ouputGenerator();

    console.log(gen.next());     // {value: &quot;hello&quot;, done: false}  value就是返回值
    console.log(gen.next());     // {value: &quot;world&quot;, done: false}
    console.log(gen.next());     // {value: &quot;ending&quot;, done: true}  done为true就是后面没有yeild的定义


一、Generator的特征:

    1、function 关键字与函数名之间有一个&quot;*&quot;号

    2、函数体内有 yield 语句

    3、可以执行暂停

    4、generator也可以不用yield, 但需要执行一次next()


二、属性和方法

    1、next() 可以带一个参数，参数可以是上一个yield的返回值

        done为true 表示结束  Object {value: &quot;ending&quot;, done: true}

    2、value: 就是next返回的值，done为false表示已经结束

    3、yield: 定义表达式


三、Generator与Promise的区别

    promise如果写多个嵌套会很麻烦:

        getArticleList()
            .then(articles =&gt; getArticle(articles[0].id))
            .then(article =&gt; getAuthor(article.authorId))
            .then(author =&gt; {
                alert(author.email);
            });

        function getAuthor(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/E105pDLh&quot;,{
                    author: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticle(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/EkI02vUn&quot;,{
                    id: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticleList(){
            return new Promise(function(resolve, reject){
            $.ajax(
                &quot;http://beta.json-generator.com/api/json/get/Ey8JqwIh&quot;)
                .done(function(result){
                    resolve(result);
                }); 
            });
        }


    Generator的写法:

        function* run(){
            var articles = yield getArticleList();
            var article = yield getArticle(articles[0].id);
            var author = yield getAuthor(article.authorId);
            console.log(author.email);  
        }

        var gen = run();
        gen.next().value
            .then(articles =&gt; {
                gen.next(articles).value.then(article =&gt; {
                    gen.next(article).value.then(author =&gt; {
                    gen.next(author)
                })
            })
        })
</code></pre><h4 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h4><pre><code>async 是ES7引入的函数，使的异步变得更加方便

await: 命令后面是一个Promise对象

Generator函数执行必须靠执行器，也就是需要调next()，async函数有自带的执行器，async返回的是Promise对象

一、async的多种声明

    // 函数声明
    async function foo() {}

    // 函数表达式
    const foo = async function () {};

    // 对象的方法
    let obj = { async foo() {} };
    obj.foo().then(...)

    // Class 的方法
    class Storage {
        constructor() {
            this.cachePromise = caches.open(&apos;avatars&apos;);
        }

        async getAvatar(name) {
            const cache = await this.cachePromise;
            return cache.match(`/avatars/${name}.jpg`);
        }
    }

    // 箭头函数
    const foo = async () =&gt; {};

二、async函数返回一个Promise对象，函数内部有return返回值，可以通过then方法来接收

    async function f(){
        return &apos;hello world&apos;
    }

    f().then( v =&gt; {
        console.log(v);
    })

Example:

    async function getStockPriceByName(name) {
        var symbol = await getStockSymbol(name);
        var stockPrice = await getStockPrice(symbol);
        return stockPrice;
    }

    getStockPriceByName(&apos;goog&apos;).then(function (result) {
        console.log(result);
    });
</code></pre><p>| <a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/babel.html</a><br>| <a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/style</a><br>| <a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之一)基础/">React（之一）基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之一)基础/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 创建组件<br>| render<br>| props、propType、state、setState()、replaceState()<br>| 获取DOM this.refs.xxx 或 ReactDOM.findDOMNode(this.refs.xxx)<br>| React.Children 获取父组件传的DOM<br>| mixin</p>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><pre><code>React包括几个概念: 1、组件       2、JSX     3、虚拟DOM     4、单向数据绑定        5、受控组件

1、核心是封装组件，只关注UI，状态变更重新渲染整个组件

2、JSX: HTML代码可以直接嵌到JS代码中，这就是React提出的叫JSX的语法，原来前端以表现和逻辑层分离为主，但HTML是组件的一部分所以不能分割，JSX 将动态值放到 { ... }

3、单向数据流: 当数据更新会渲染整个app

    React的渲染方式: 用户输入 ~&gt; 从API获取数据 ~&gt; 将数据传给顶层组件 ~&gt; React将每个组件渲染出来, 不会象MVC一样的双向数据绑定、和数据模型的脏值检测、不会有确切的DOM操作

4、虚拟DOM树: React重建一个DOM树，找到与上一个版本的DOM的差异，计算出新的DOM更新操作，从操作队列中指执行DOM更新操作

    http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/      // 前沿技术解密——VirtualDOM

5、IE浏览器要在8.0版本以上

rrc 创建带redux组件
rcc 创建react组件
rca 创建action
reducer 创建reduer
</code></pre><h4 id="react引用方式"><a href="#react引用方式" class="headerlink" title="react引用方式"></a>react引用方式</h4><pre><code>// Component作为所有组件的基类，提供很多组件共有的功能
import React, { Component } from &apos;react&apos;;
import { reactDom } from &apos;react-dom&apos;;

// 定义组件
class SimpleComponent extends Component {
    render(){
        return &lt;div&gt; React，我们来了... &lt;/div&gt;;
    }
}
export default SimpleComponent;

// 组件渲染
reactDom.render(&lt;HelloMessage /&gt;, document.getElementById(&apos;app&apos;));
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>组件的生命周期三个过程

    装载过程(Mount) - 把组件第一次在DOM树中渲染的过程

    更新过程(Update) - 当组件被重新渲染的过程

    卸载过程(Unmount) - 组件从DOM中删除的过程


一、装载过程

    1、constructor - ES6每个类的构造函数，创建一个组件就会先调用对应的构造函数

    2、getInitialState() - 初始化this.state，(ES6不起作用)

    3、getDefaultProps - 设置默认的props (ES6不起作用)

    4、componentWillMount() - 组件挂载前（调用render方法之前触发, 没有任何渲染，就算调用了this.setState()也不会引发绘制）

    5、render() - 创建虚拟dom，进行diff算法，更新dom树，如果不需要渲染可以将render函数返回一个null或false

    6、componentDidMount() - 组件渲染后已经装载到DOM树中，这时候可以refs操作获取或操作DOM节点


二、更新过程(当props或state被修改时就会引发组件的更新过程)

    1、componentWillReceiveProps(nextProps) - 当父组件改变了传递给子组件props的值，这时候子组件此方法会被调用

    2、shouldComponentUpdate(nextProps, nextState) - react性能环节，父组件传给子组件的props值改变，子组件中的shouldComponentUpdata()方法会先调用，前后两个props相同返回false阻止更新，不需要在创建新的dom树在进行diff算法，默认为true

        shouldComponentUpdate(nextProps, nextState){
            return nextProps.name === nextState.name        // 如果返回false就算父组件传递的props值改变，也不会执行render
        }

    3、componentWillUpdate() - 与装载过程相同 

    4、render() - 与装载过程相同

    5、componentDidUpdate() - 与装载过程相同


三、卸载组件

    1、componentWillUnmount() - 卸载前调用
</code></pre><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><pre><code>一、注释

    {/* 这里用于单多行注释 */}


二、根元素只能有一个

    class ComponentDemo extends Component {
        render(){
            // 以下写法直接报错
            return (
                &lt;div&gt;
                    hello
                &lt;/div&gt;
            );
        }
    }


三、属性名不能和 js 关键字冲突

    1、class =&gt; className

    2、read =&gt; readOnly

    3、for =&gt; htmlFrom 不能直接使用for

        &lt;div htmlFor=&apos;male&apos;&gt;Male&lt;/div&gt;


四、JSX spread

    { ...spreadObj } 可以直接将spreadObj的对象传递过去

    import SpreadDemo from &apos;./components/spread&apos;;
    const spreadObj = {
        name: &apos;siguang&apos;,
        carType: &apos;卡宴&apos;
    }
    render(&lt;SpreadDemo {...spreadObj} /&gt;, document.querySelector(&apos;#app&apos;));


五、渲染HTML

    const elements = &apos;&lt;p&gt;aaa&lt;/p&gt;&lt;p&gt;bbb&lt;/p&gt;&lt;p&gt;ccc&lt;/p&gt;&apos;;
    &lt;p dangerouslySetInnerHTML={{ __html: elements }}&gt;&lt;/p&gt;

http://lib.csdn.net/article/react/22655
</code></pre><h4 id="class和style"><a href="#class和style" class="headerlink" title="class和style"></a>class和style</h4><pre><code>一、class

    方法1:
        import &apos;./admin.css&apos;
        render() {
            return (
                &lt;div className=&quot;container&quot;&gt;            // 注意这里的值为字符串而不是{}
                    &lt;div className=&quot;sild&quot;&gt;xxxx&lt;/div&gt;
                &lt;/div&gt;
            );
        }

    方法2:
        import styles from &apos;./admin.css&apos;
        render() {
            return (
                &lt;div&gt;
                    &lt;div className={style.sild}&gt;xxxx&lt;/div&gt;
                &lt;/div&gt;
            );
        }


二、style 行内样式

    方法1:
        const container = {
            display: flex;
            height: 100%;
        }

        render() {
            return (
                &lt;div style={container}&gt; xxx &lt;/div&gt;
            );
        }

    方法2: &lt;div style={{ width: '100px', float: 'left'}}&gt;       // 注意这里属性值要使用引号
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>一、组件创建

    1、类式组件

        import React, { Component } from &apos;react&apos;
        import ReactDom, { render } from &apos;react-dom&apos;

        // 所有创建的组件都继承于Component对象
        class ShowMessage extends Component{
            constructor(props){
                super(props);
            }
            render(){
                return &lt;div&gt;Hello name {this.props.name}&lt;/div&gt;
            }
        }
        export default ShowMessage;


    2、函数式组件

        const Welcome = (props) =&gt; {
            return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
        }
        &lt;Welcome username=&quot;this.state.username&quot; /&gt;


    函数组件与类式组件的区别:

        类组件有state, 函数组件没有state

        类组件有生命周期函数


二、组件注意的地方

    1、组件名首字母必须大写

    2、根元素只能有一个标签元素

        class ComponentDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;boxA&quot;&gt;            {/* 根元素只能有一个 */}
                        aaaaaaaa
                        &lt;div class=&quot;boxB&quot;&gt;
                            bbbbbb
                        &lt;/div&gt;
                    &lt;/div&gt;
                )
            }
        }
        export default ComponentDemo;

    3、可以使用es6的 spread 变量传递 {...obj}

        let person = &lt;Person name={window.isLoggedIn ? window.name : &apos;&apos;} /&gt;

    4、refs属性获取真实的DOM节点

        组件并不是真实的DOM节点，而是在内存中的一种数据结构叫虚拟DOM，如果要从组件内获取真实的DOM节点，需要用到refs属性
</code></pre><h4 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h4><pre><code>childList.jsx:

    class ChildrenA extends Component{
        constructor(props){
            super(props);
        }
        render(){
            return (&lt;div&gt;
                {/* 这里是子组件A   this.props.children获取组件的内容，相当前于vue中的solt */}
                {
                    React.Children.map(this.props.children, function(c){        // React.Children是获取组件中的元素
                        return &lt;p&gt;{c}&lt;/p&gt;
                    })
                }
            &lt;/div&gt;)
        }
    }

    class ParentComponent extends Component{
        render(){
            return &lt;div&gt;
                &lt;ChildrenA&gt;
                    &lt;p&gt;福特&lt;/p&gt;
                    &lt;p&gt;丰田&lt;/p&gt;
                    &lt;p&gt;本田&lt;/p&gt;
                &lt;/ChildrenA&gt;
            &lt;/div&gt;
        }
    }
    export default ParentComponent;

index.js:

    import ParentComponent from &apos;./components/ParentComponent&apos;
    render(&lt;ParentComponent /&gt;, docuemnt.querySelector(&apos;#box&apos;));
</code></pre><h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><pre><code>一、组件之间通信的几种情况

    1、父组件向子组件通信

    2、子组件向父组件通信

    3、跨级组件之间通信

    4、非嵌套组件间通信


二、父向子通信 通过props

    parent.jsx
        &lt;child message={this.state.sayMessage} /&gt;

    child.jsx
        {this.props.message}        // 接收


三、子向父通信

    parent.jsx
        &lt;child getMessage={this.getMessage.bind(this)} /&gt;
        getMessage(msg){
            this.setDate({message: msg})
        }

    child.jsx
        this.props.getMessage(&apos;这里告诉父组件消息&apos;)


四、跨级组件

    父组件向很深的几层子组件通信有两种方法: 1、props一层一层传   2、使用context对象


五、events非嵌套组件通信, 使用事件订阅

    $ npm i events --save

    1、创建一个ev.js

        import { EventEmitter } from &apos;events&apos;
        export default new EventEmitter();

    2、brotherA.jsx

        // 在组件装载完成以后
        componentDidMount(){
            // 声明一个自定义事件        
            this.eventEmitter = emitter.addListener(&quot;callMe&quot;, (msg)=&gt;{
                this.setState({
                    msg
                })
            });
        }

        // 组件销毁前移除事件监听
        componentWillUnmount(){
            emitter.removeListener(this.eventEmitter);
        }

        render(){
            return (
                &lt;div&gt;
                    {this.state.message}
                &lt;/div&gt;
            )
        }

    3、brotherB.jsx

        sendBrotherMessage(){
            return emitter.emit(&quot;callMe&quot;, &quot;Hello&quot;);     // callMe为自定义函数，hello为发的消息参数
        }
        &lt;input type=&quot;button&quot; value=&quot;向A子组件发消息&quot; onClick={this.sendBrotherMessage.bind(this)} /&gt;


六、redux或其它状态管理库
</code></pre><h4 id="Context对象"><a href="#Context对象" class="headerlink" title="Context对象"></a>Context对象</h4><pre><code>context对象来跨级传递

context与react版本分两种写法，以下为react v16.3版本的示例

一、React.crateContext() - 创建一个Context

二、初始化createContext下的方法

    1、provider - 父组件中传递的值

    2、consumeer - 子组件接收的值

三、示例:

    创建一个contextStor.js:
        import React, { Component } from &apos;react&apos;
        export const { Provider, Consumer } = React.createContext(&quot;Light&quot;);        // 默认主题是Light

    parentPage.jsx:
        import Ca from &apos;./cA&apos;
        import { Provider } from &apos;./ccontextStor&apos;;

        export default class ParnentPage extends Component {
            render () {
                return (
                    &lt;Provider value={{contextVal: '这里是context的传递的内容'}}&gt;
                        &lt;h1&gt;这里是Parent组件&lt;/h1&gt;
                        &lt;Ca /&gt;
                    &lt;/Provider&gt;
                )
            }
        }

    cA.jsx:
        import Cb from &apos;./cB&apos;
        export default class Ca extends Component {
            render () {
                return (
                    &lt;div&gt;
                        &lt;h2&gt;这里是CA&lt;/h2&gt;
                        &lt;Cb /&gt;
                    &lt;/div&gt;
                )
            }
        } 

    cB.jsx:
        import { Consumer } from &apos;./ccontextStor&apos;;
        export default class Cb extends Component {
            render () {
                return (
                    &lt;div&gt;
                        &lt;h3&gt;这里子CB&lt;/h3&gt;
                        &lt;Consumer&gt;
                            {
                                context =&gt; {
                                    return (
                                        &lt;div&gt;{context.contextVal}&lt;/div&gt;
                                    )
                                }
                            }
                        &lt;/Consumer&gt;
                    &lt;/div&gt;     
                )
            }
        }
</code></pre><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><pre><code>React是单向数据流，数据从父组件传到子组件，子组件通过props获取数据，顶层组件改变了props，React会遍历整个组件树，重新渲染整个组件

数据流包括: Props 和 State
</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>{ this.props.name } 读取props的值

一、props API:

    this.props.children - 所有子组件的内容

        &lt;ChildrenComponent&gt;
            &lt;p&gt;aa&lt;/p&gt;
            &lt;p&gt;bb&lt;/p&gt;
            &lt;p&gt;cc&lt;/p&gt;
        &lt;/ChildrenComponent&gt;

    this.props.map

    this.props.filter 


二、设置一个默认的props

    /* 通过 defaultProps 来定义 */
    class PropsDemo extends Component {
        constructor(props) {
    super(props);        // 调用父类，如果不写会调不到
       }
        render(){
            return (
                &lt;div class=&quot;box&quot;&gt;
                    name: {this.props.name}, age: {this.props.age}
                &lt;/div&gt;
            )
        }
    }

    // 初始化props
    PropsDemo.defaultProps = {
        name: &apos;123123&apos;        // 默认一个name值，如果父组件没有传值就会取默认值
    }


三、propsType 校验props类型

    $ npm install --save prop-types

    import React, { Component, PropTypes } from &apos;react&apos;;

    class PropTypesDemo extends Component {
        render(){
            return &lt;b&gt;{this.props.title}&lt;/b&gt;
        }
    }

    // 静态属性定义propTypes, title只能为string
    PropTypesDemo.propTypes = {
        title: React.PropTypes.string.isRequired
    }

    export default PropTypesDemo;


四、Example

    PropsComponent组件:

        class PropsComponent extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}         {/* 这里接收props值 */}
                    &lt;/div&gt;
                )
            }
        }

        // 输出组件接口
        export default PropsComponent;

    index.js:

        import PropsComponent from &apos;../components/props&apos;;

        // 要传的值
        let obj = {
            name: &apos;haha&apos;,
            age: &apos;300&apos;
        }

        // 方法1、直接传给属性
        render(&lt;PropsComponent name={obj.name} age={obj.age} /&gt;, document.querySelector(&apos;body&apos;));

        // ...obj 来对多值进行解析赋值
        render(&lt;PropsComponent {...obj} /&gt;, document.querySelector(&apos;body&apos;));


五、this.props.children 访问自定义子节点

    // 将组件下的所有子节点通过map获取到，并重新包装
    import React, { Component } from &apos;react&apos;;

    class UseChildren extends Component {
        render(){
            return  &lt;ul&gt;
                {
                    // 会将UseChildren组件下所有的元素取出
                    React.Children.map(this.props.children, function(c){
                        return &lt;li&gt; {c} &lt;/li&gt;
                    })
                }
            &lt;/ul&gt;
        }
    }

    class ChildrenDemo extends Component {
        render(){
            return (
                &lt;UseChildren&gt;
                    &lt;a href=&quot;#&quot;&gt;Facebook&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Google&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Space&lt;/a&gt;
                &lt;/UseChildren&gt;
            )
        }
    }
    export default ChildrenDemo;


六、this.props.content 可以传任意结构的JSX结构

    // 父组件通过content传值
    &lt;ContentChildrenComponent content={
        &lt;div&gt;
            &lt;h2&gt;React.js 小书&lt;/h2&gt;
            &lt;div&gt;开源、免费、专业、简单&lt;/div&gt;
            订阅：&lt;input /&gt;
        &lt;/div&gt;
    } /&gt;

    // 子组件调用
    render() {
        return (
            &lt;div&gt;
                { this.props.content }
            &lt;/div&gt;
        );
    }


七、组件传值

    &lt;ChildComponent propsData={this.state.username} /&gt;

    &lt;LikeButton wordings={{likedText: '已赞', unlikedText: '赞'}} onClick={() =&gt; console.log(&apos;Click on like button!&apos;)}/&gt;
</code></pre><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><pre><code>每一个React组件都有一个自己的state对象，与props区别是state只能在当前组件内部使用，props可以将数据传递给子组件

一、初始化state

    class StateDemo extends Component {
        constructor(){
            super();            // 继承Component

            // 这里初始化state
            this.state = { 
                userName: &apos;siguang&apos; 
            }
        }

        setUserName: function(){
            this.setState({userName: &apos;lulu&apos;});        // 修改state值
        },

        render(){
            return (
                &lt;div&gt;
                    这里是props获取的值 {this.state.userName};        // 获取state的值
                    &lt;input type=&quot;button&quot; onClick={this.setUserName.bind(this)} value=&quot;点击修改state&quot; /&gt;
                &lt;/div&gt;
            )
        }
    }


二、setState中this的指向

    1、&lt;Button type=&quot;primary&quot; onClick={ this.addCar.bind(this) }&gt;开始&lt;/Button&gt;
         &lt;Button type=&quot;primary&quot; onClick={ (e) =&gt; this.addCar(e) }&gt;开始&lt;/Button&gt;        // 渲染中箭头函数

    2、&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;

    3、addCar = () =&gt; {
            this.setState(function(state, porps){
                return {
                    car: state.car + 1
                }
            })
        }
        &lt;Button type=&quot;primary&quot; onClick={ this.addCar }&gt;开始&lt;/Button&gt;


三、setState()异步的问题

    setState()是异步导致如果直接在下面在取state值还没变过来，所以第二个回调是当state值设置成功后在执行的函数

    this.setState(
        { username: uname }, 
        () =&gt; {  console.log(this.state.username); }        // 这里还是为之前的值而不是「sg」
    );
</code></pre><h4 id="refs操作真实DOM"><a href="#refs操作真实DOM" class="headerlink" title="refs操作真实DOM"></a>refs操作真实DOM</h4><pre><code>获取ref: this.refs.xxx

Example:

    class RefsDemo extends Component {
        componentDidMount(){
            // refs直接获取
            const contentB = this.refs.content;
            console.log( contentB.innerHTML );
        }

        render(){
            return(
                &lt;div&gt;
                    &lt;h3&gt;React操作DOM&lt;/h3&gt;
                    &lt;p ref=&quot;content&quot;&gt;这里是DOM元素的内容&lt;/p&gt;        // 这里定义ref访问的名
                &lt;/div&gt;
            )
        }
    }
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>通过mixin可以将组件间共享代码，将两个组件共同的属性、方法存储到mixin对象中

mixin不支持ES6的声明组件方式

ES5写法

    import React from &apos;react&apos;;

    // 抽取出的公用方法
    var SetIntervalMixin = {
        componentWillMount: function() {
            this.intervals = [];
        },
        setInterval: function() {
            this.intervals.push(setInterval.apply(null, arguments));
        },
        componentWillUnmount: function() {
            this.intervals.forEach(clearInterval);
        }
    };

    var MixinDemo = React.createClass({

        // 这里加载mixin
        mixins: [SetIntervalMixin],

        getInitialState: function() {
            return {seconds: 0};
        },

        componentDidMount: function() {
            // Call a method on the mixin
            this.setInterval(this.tick, 1000);
        },

        tick: function() {
            this.setState({seconds: this.state.seconds + 1});
        },

        render: function() {
            return (
                &lt;p&gt;
                    计时器已经运行了:  {this.state.seconds} 秒.
                &lt;/p&gt;
            );
        }
    });

    export default MixinDemo;
</code></pre><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><pre><code>一、defaultValue 与 value 的区别

    &lt;input type=&quot;text&quot; value={this.state.inputValue} /&gt;

    如果使用 value来绑定state的值，输入值时不会被改变，使用 defaultValue 值会被改变

    class App extends Component {
        constructor(props) {
            super(props);
            this.state = {
                username: &apos;&apos;
            }
        }
        handleUsername(e){
            const val = e.target.value;
            this.setState({username: val});
        }
        getName(){
            alert(this.state.username)
        }
        render() {
            return (
                &lt;div className=&quot;App&quot;&gt;
                    &lt;input placeholder=&quot;Basic usage&quot; defaultValue={this.state.username} onChange={this.handleUsername.bind(this)} /&gt;
                    &lt;button type=&quot;primary&quot; onClick={this.getName.bind(this)}&gt;Primary&lt;/button&gt;
                &lt;/div&gt;
            );
        }
    }

二、react表单组件与html的不同

    1、value、checked: 属性设置值后，用户输入无效

    2、textarea: 的值要设置在value属性

        &lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt;

    3、select: value属性可以是数据，不建使用option的selected属性

        &lt;select multiple={true} value={[&apos;B&apos;, &apos;C&apos;]}&gt;
            &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt;
            &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt;
            &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt;
        &lt;/select&gt;

    4、radio/checkbox/option 点击后触发 onChange
</code></pre><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><pre><code>受控组件就是为某个form表单组件添加value属性；非受控组件就是没有添加value属性的组件

一、受控组件

    &lt;input&gt;，&lt;textarea&gt;以及&lt;select&gt;通常保持自己的状态和基于用户输入更新它

    handleChange(event) {
        this.setState({value: event.target.value});
    }
    &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;


二、不受控制组件

    this.input = React.createRef();                    // 创建不受控组件
    &lt;input type=&quot;text&quot; ref={this.input} /&gt;    // 绑定
    this.input.current.value                                // 调用不受控组件

    class NameForm extends React.Component {
        constructor(props) {
            super(props);
            this.handleSubmit = this.handleSubmit.bind(this);

            // 创建不受控组件
            this.input = React.createRef();
        }

        handleSubmit(event) {
            alert(&apos;A name was submitted: &apos; + this.input.current.value);
            event.preventDefault();
        }

        render() {
            return (
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;label&gt;
                        Name:
                        &lt;input type=&quot;text&quot; ref={this.input} /&gt;
                    &lt;/label&gt;
                    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
                &lt;/form&gt;
            );
        }
    }
</code></pre><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><pre><code>render的时候需要有一个父的元素，如果组件嵌套会多出来无用的元素，可以使用&lt;React.Fragment&gt; ... &lt;/React.Fragment&gt;

class Columns extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;td&gt;Hello&lt;/td&gt;
                &lt;td&gt;World&lt;/td&gt;
            &lt;/div&gt;
        );
    }
}
class Table extends React.Component {
    render() {
        return (
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;Columns /&gt;                    // 输出&lt;div&gt; ... &lt;/div&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        );
    }
}

可以写成

class Columns extends React.Component {
    render() {
        return (
            &lt;React.Fragment&gt;
                &lt;td&gt;Hello&lt;/td&gt;
                &lt;td&gt;World&lt;/td&gt;
            &lt;/React.Fragment&gt;
        );
    }
}
</code></pre><h4 id="React脚手架搭建"><a href="#React脚手架搭建" class="headerlink" title="React脚手架搭建"></a>React脚手架搭建</h4><pre><code>一、可以使用官网的 create-react-app、ant或自己搭  https://github.com/facebook/create-react-app

二、使用的JSX和ES6所以需要转换，使用版本:

    react: &quot;^15.4.2&quot;, react-dom: &quot;^15.4.2&quot;, react-router: &quot;^2.0.0&quot;&quot;, webpack: &quot;^3.10.0&quot;, webpack-dev-server: &quot;^2.11.1&quot;

    react 16以上版本和 react-router 4以上版本会有问题

三、搭建

    $ npm init

    $ npm i react react-dom react-router --save

    $ npm i webpack webpack-dev-server --save

    2、安装插件

    $ npm i babel babel-loader babel-core babel-preset-es2015 babel-preset-react --save

    $ npm i node-sass file-loader url-loader css-loader sass-loader style-loader --save

    $ npm i react-hot-loader prop-types events react-slot --save             // react组件，热更新、检测props类型、事件用来通信包、slot

    $ npm i html-webpack-plugin open-browser-webpack-plugin --save            // 自动引入静态资源到相应的html、自动打开浏览器

    $ touch .babelrc webpack.config.js

    $ mkdir src &amp;&amp; cd src &amp;&amp; touch index.html app.js

    $ .babelrc 加入

        {
            &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
        }

    $ webpack.config.js

        /**
        * User: siguang
        * Date: 2016/12/28
        * Time: 15:04
        */
        const webpack = require(&apos;webpack&apos;);
        const path = require(&apos;path&apos;);
        const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
        const openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);

        const basePath = __dirname;
        const appPath = path.resolve(basePath, &apos;src&apos;);
        const buildPath = path.resolve(basePath, &apos;build&apos;);

        module.exports = {
            entry: {
                app: path.resolve(appPath, &apos;app.js&apos;)
            },

            output: {
                path: buildPath,
                filename: &apos;[name].min.js?[hash]&apos;,
                // chunkFilename: &quot;[name].min.js?[hash]&quot;
            },

            module: {
                loaders: [

                    // 处理require()引入的css文件，并将代码显示到页面的&lt;style&gt;中
                    { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; },

                    // 将scss文件转成css文件
                    { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                    // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                    { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;},

                    // ES6 转 ES5
                    {
                        test: /\.jsx?$/,
                        exclude: /node_modules/,
                        loader: &apos;babel-loader&apos;,
                        query: {
                            presets: [&apos;es2015&apos;,&apos;react&apos;]
                        }
                    }
                ]
            },


            plugins: [

                // 压缩打包的文件
                new webpack.optimize.UglifyJsPlugin({
                    compress: {
                        //supresses warnings, usually from module minification
                        warnings: false
                    }
                }),

                // html
                new HtmlWebpackPlugin({
                    // 改变页面的&lt;title&gt;标签的内容
                    title: &apos;Hello World app&apos;,
                    // 模版地址
                    template: path.resolve(appPath, &apos;index.html&apos;),
                    // 构建后的文件名和目录
                    filename: &apos;index.html&apos;,
                    //chunks这个参数告诉插件要引用entry里面的哪几个入口
                    // chunks:[&apos;app&apos;],
                    //要把script插入标签里
                    inject:&apos;body&apos;
                }),

                // 热启动
                new webpack.HotModuleReplacementPlugin(),
                // 自动打开浏览器
                new openBrowserWebpackPlugin({ url: &apos;http://localhost:3000&apos; })
            ],

            // 查找依赖
            resolve:{

                // require或alias时不需要写后缀
                extensions: [&quot;.js&quot;, &quot;.jsx&quot;, &quot;.css&quot;, &quot;.json&quot;],
            },

            // webpack-dev-server 配置
            devServer: {
                port: 3000,                 // 端口
                contentBase: &apos;build&apos;,       // 内容目录
                hot: true,                    // 热刷新
                inline: true
            }
        }`

$ package.json

    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
        &quot;dev&quot;: &quot;webpack-dev-server --progress --profile --colors --hot --inline --history-api-fallback&quot;,
        &quot;build&quot;: &quot;webpack --progress --profile --colors --config webpack.production.config.js&quot;
    },

$ 运行

    $ npm run dev     生产环境，并打开webpack服务器

    $ webpack        执行打包到build目录线上环境使用

https://segmentfault.com/a/1190000005969488
</code></pre><h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><pre><code>当组件更新时候，react会创建一个新的虚拟dom树并会和之前的dom树进行比较，这个过程就用到了diff算法
</code></pre><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><pre><code>https://github.com/enaqx/awesome-react#boilerplates

1、路由 - react-router

2、布局 - react-blocks     http://whoisandie.github.io/react-blocks/

3、拖拽 - react-dnd        https://github.com/react-dnd/react-dnd

4、代码编辑器 - react-codemirror        https://github.com/JedWatson/react-codemirror

5、富文本编辑器 - react-quill react-draft-wysiwyg        https://github.com/jpuri/react-draft-wysiwyg

6、拾色器 - rc-color-picker、react-color        https://github.com/react-component/color-picker        http://casesandberg.github.io/react-color/

7、响应式 - react-responsive、react-media    https://github.com/contra/react-responsive        https://github.com/ReactTraining/react-media

8、复制到剪贴板 - react-copy-to-clipboard       https://github.com/nkbt/react-copy-to-clipboard

9、管理 document head - react-helmet          https://github.com/nfl/react-helmet

10、Font Awesome 图标 - react-fa        https://github.com/andreypopp/react-fa

11、二维码 -  qrcode.react         https://ant.design/docs/react/recommendation-cn

12、不在使用className - styled-components

    http://www.alloyteam.com/2017/05/guide-styled-components/
    https://github.com/styled-components/styled-components

13、react写动画效果 - css3transform-react

    $ npm install css3transform-react
    http://www.alloyteam.com/2016/12/react-animations-difficult-to-write-try-react-transformjs/

react-slot - react中写solt    http://npm.taobao.org/package/react-slot
</code></pre><h4 id="积累问题"><a href="#积累问题" class="headerlink" title="积累问题"></a>积累问题</h4><pre><code>1、jsx中for循环出标签并插入到render中, 或使用map

    class SideBar extends Component {
        constructor(props) {
            super(props);
            this.state ={
                menu: [
                    {
                        path: &apos;/home&apos;,
                        name: &apos;主页&apos;
                    },
                    {
                        path: &apos;/parentToChild&apos;,
                        name: &apos;将父向子组件传数据&apos;
                    },
                ]
            }
        }

        render() {
            // 定义一个返回菜单html内容的方法
            let renderMenuHtml = () =&gt; {
                let homeHtml = [];
                this.state.menu.forEach(function(item, idx, arr){
                    homeHtml.push(&lt;li&gt;
                        &lt;Link to={item.path}&gt;{item.name}&lt;/Link&gt;
                    &lt;/li&gt;)
                })
                return homeHtml
            }

            // 另一种写法map推荐
            {/*
                var renderMenuHtml = this.state.menu.map(function(c){
                    return(
                        &lt;li&gt;
                            &lt;Link to={item.path}&gt;{item.name}&lt;/Link&gt;
                        &lt;/li&gt;
                    );
                });
            */}

            return (
                &lt;div className=&quot;side-box&quot;&gt;
                    &lt;ul&gt;
                        {renderMenuHtml()}        {/* 插入内容 */}
                    &lt;/ul&gt;
                &lt;/div&gt;
            );
        }
    }


2、使用redux子组件会取不到 this.props.history

    因为redux会将值传给props，所以就需要通过context来获取

    解决方法: 在子组件中
    import PropTypes from &apos;prop-types&apos;

    子组件名.contextTypes = {
        router: PropTypes.object.isRequired
    }

    console.log( this.context.router.history.push(&apos;/&apos;) );


3、子组件调用父组件中的方法

    class ComponentClider extends Component {
        constructor(props){
            super(props);
        }

        render(){
            return(
                &lt;div&gt;{ this.props.add(111,555) }&lt;/div&gt;
            )
        }
    }

    export default ComponentParent extends Component {
        add(a, b){
            return a + b;
        }

        sub(a, b) {
            return a - b;
        }

        render(){
            return (
                &lt;div&gt;
                    {/* 这里可以父组件中自己的方法直接调用 */}
                    { this.add(100, 200) }
                    { this.sub(200, 10) }

                    &lt;ComponentClider add={(a, b) =&gt; this.add(a, b)} sub={(a, b) =&gt; this.sub(a, b)}&gt;&lt;/ComponentClider&gt;
                &lt;/div&gt;
            )
        }
    } 

    &lt;!-- 父组件也可以写成 --&gt;
    export default ComponentParent extends Component {
        multiplicative(a, b) {
            return a * b
        }

        add = (a, b) =&gt; {
            return a + b;
        }

        sub = (a, b)  =&gt;  {
            return a - b;
        }

        render(){
            const propsFun = {
                add: this.add,
                sub: this.sub
            }

            return (
                &lt;div&gt;
                    {/* 这里可以父组件中自己的方法直接调用 */}
                    { this.multiplicative(100, 200) }

                    &lt;ComponentClider {...propsFun}&gt;&lt;/ComponentClider&gt;
                &lt;/div&gt;
            )
        }
    } 


4、react原生动态添加多个className会报错

    // 下面的引用会报错
    import style from &apos;./style.css&apos;
    &lt;div className={style.class1 style.class2}&lt;/div&gt;

    // 解决 使用classnames
    $ npm install classnames --save

    import classnames from &apos;classnames&apos;
    import styles from &apos;./index.less&apos;;

    const clsString = classNames(styles.submit, className);
    &lt;div className={clsString}&gt;&lt;/div&gt;
</code></pre><h4 id="常用插件-1"><a href="#常用插件-1" class="headerlink" title="常用插件"></a>常用插件</h4><pre><code>1、react-document-title    根据不同的路由改变文档的title
    https://www.jianshu.com/p/07ed93350483

2、react-container-query   媒体查询 响应式组件

3、classnames      react引用多个className会报错问题
</code></pre><h4 id="Antd-UI组件问题收集"><a href="#Antd-UI组件问题收集" class="headerlink" title="Antd UI组件问题收集"></a>Antd UI组件问题收集</h4><pre><code>1、Table的每页条数  通过pagination属性来控制分页的内容

    &lt;Table pagination={{ pageSize: this.state.queryInfo.pageSize }} rowSelection={rowSelection} columns={columns} dataSource={data}  /&gt;

    https://www.cnblogs.com/jenifurs-blog/p/6020737.html
</code></pre><p>| <a href="https://react.docschina.org/docs/hello-world.html" target="_blank" rel="noopener">https://react.docschina.org/docs/hello-world.html</a><br>| <a href="http://www.css88.com/react/docs/try-react.html" target="_blank" rel="noopener">http://www.css88.com/react/docs/try-react.html</a><br>| <a href="https://juejin.im/post/5a9410c25188257a61325eda" target="_blank" rel="noopener">https://juejin.im/post/5a9410c25188257a61325eda</a>          // react 新老context<br>| <a href="https://www.jianshu.com/p/fb915d9c99c4" target="_blank" rel="noopener">https://www.jianshu.com/p/fb915d9c99c4</a>                          // 组件通信<br>| <a href="http://huziketang.com/books/react/" target="_blank" rel="noopener">http://huziketang.com/books/react/</a><br>| <a href="http://blog.csdn.net/liwusen/article/category/6522963" target="_blank" rel="noopener">http://blog.csdn.net/liwusen/article/category/6522963</a><br>| <a href="http://react-china.org/" target="_blank" rel="noopener">http://react-china.org/</a>           中文社区<br>| <a href="https://github.com/BruceCham/react-cli" target="_blank" rel="noopener">https://github.com/BruceCham/react-cli</a>                            // 全家桶<br>| <a href="http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/" target="_blank" rel="noopener">http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/</a>        // virturalDOM 虚拟DOM<br>| <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">https://github.com/gaearon/redux-devtools</a>                        // redux-devtools<br>| <a href="https://guoyongfeng.github.io/book/" target="_blank" rel="noopener">https://guoyongfeng.github.io/book/</a><br>| <a href="http://uprogrammer.cn/react-tutorial-cn/" target="_blank" rel="noopener">http://uprogrammer.cn/react-tutorial-cn/</a><br>| <a href="http://huziketang.com/books/react/lesson1" target="_blank" rel="noopener">http://huziketang.com/books/react/lesson1</a><br>| <a href="https://github.com/hyy1115/react-redux-webpack2" target="_blank" rel="noopener">https://github.com/hyy1115/react-redux-webpack2</a><br>| <a href="https://github.com/zhbhun/react-learning/tree/master/boilerplate" target="_blank" rel="noopener">https://github.com/zhbhun/react-learning/tree/master/boilerplate</a><br>| <a href="http://blog.csdn.net/u013063153/article/details/52497271" target="_blank" rel="noopener">http://blog.csdn.net/u013063153/article/details/52497271</a>      // 事件<br>| <a href="https://github.com/gaearon/babel-plugin-react-transform#transforms" target="_blank" rel="noopener">https://github.com/gaearon/babel-plugin-react-transform#transforms</a>       // babel-plugin-react-transform 相关插件<br>| <a href="http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/</a><br>| <a href="https://juejin.im/post/5a84682ef265da4e83266cc4" target="_blank" rel="noopener">https://juejin.im/post/5a84682ef265da4e83266cc4</a>            // 源码解析<br>| <a href="https://www.jianshu.com/p/ec7c2bab16cc?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/ec7c2bab16cc?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation</a>      // vscode 调试react 通过debugger for chrome</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/CSS3深入理解/">深入理解CSS3</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/CSS3深入理解/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/CSS3/">CSS3</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 选择器<br>| 文字样式: text-shadow、word-break、word-wrap、font-face、wrod-spacing、letter-spacing、text-overflow<br>| 盒模型: calc计算属性值、box-sizing元素的宽高是否包括padding、border的值、box-shadow、box-reflect、resize<br>| 布局: dispay:flex布局、dispay:box 弹性盒模型<br>| 分栏布局: column-width、column-count、column-gap、column-rule<br>| 背景: background-clip、background-size<br>| 变形: transform: scale、skew、translate、rotate、matrix，transform-origin<br>| 动画: transition: transition-property、transition-duration、transition-timing-function、transition-delay，animation</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><pre><code>一、基本选择器

    1、 * 通配符: 用于html的所有结点 -&gt; * { width:200px; }

    2、 元素选择器: 页面的元素 -&gt; li { border:1px #fff solid; }

    3、 类选择器: 所有指定的类别 -&gt; .cla { width:200px; height:30px; }

    4、 id选择器: #k0 { background-color:#000; }

    5、 m n{} 后代选择器: .nav li { width:200px; }    // .nav下的所有li元素

    6、 m &gt; n 子选择器: ie6不支持 -&gt; .nav &gt; li { width:200px; }    // 只匹配.nav下的子li元素，孙li不匹配

    7、 m + n 相邻选择器: ie6不支持 -&gt; .nav + div { background-color:#ccc; }    // 匹配.nav相邻的div元素

    8、 m ~ n 兄弟选择器: ie6不支持 -&gt; .nav ~ li { background-color:#ccc; }    // 与.nav所有的同辈元素

    9、 m, m, m 群组选择器: .nav1, .nav2, .nav3 { width: 2000px; }    // 群组选择器将每个选择器用&quot;，&quot;号分开


二、属性选择器

    1、[attr]: 指定属性名

    2、[attr==val]: 指定属性等于匹配

    3、[attr*=val]: 匹配属性具有attr并且包含val指定值

    4、[attr^=val]: 匹配指定属性的值，以val开头

    5、[attr$=val]: 匹配指定属性的值，以val结尾        如果id=&quot;abc-1&quot;，匹配[attr $= \-1]使用转义\


三、元素

    1、:first-line: 为某个元素第一行文字的使用样式

    2、:first-letter: 用于首字母

    3、:before: 用于在某个元素之前插入一些内容，如: 元素:before { content: &quot;插入的文字&quot; };

    4、:after: 用于在某个元素之后插入一些内容，如: 元素:after{ content: &quot;插入的文字&quot; };

    5、:root: 选择器将样式绑定到页面的根元素中，根元素是指位于文档树中最顶层结构的元素.

    6、:not: 对某个结构元素使用样式，但排除这个结构元素下面子结构元素，让它不使用这个样式可以使用not。

    7、:empty: 指定元素为空白时使用的样式

    8、:target: 

    9、:first-child: 指定元素中第一个子元素

    10、:last-child: 指定元素中的最后一个子元素

    11、:nth-child(3): 指定元素中的第3个元素.   li:nth-child(3) { background: yello; }   可以指定even奇数、odd偶数

    12、:nth-last-child(3): 指定元素中从后数第3个元素

    13、:nth-of-type: 找标签下指定的第几个子元素，例: .box p:nth-of-type(2): 找出个box下的第二个p元素

    14、:nth-last-of-type(): 从后找

    15、:only-child: 父元素中只有一个子元素.

        *** nth-child与nth-of-type的区别 *** 

        nth-child 从子元素的第一个开始无论不会指定元素
        nth-of-type 所有子元素的序列，而不是指定某一元素下查找

        &lt;style&gt;
            body { margin: 0; }
            .box li:nth-child(2) { background-color: #ccc; }         // 影响 &lt;li&gt;bbb&lt;/li&gt;
            .box li:nth-of-type(2) { background-color: #ccc; }         // 只对子元素li的第2个 影响 &lt;li&gt;ccc&lt;/li&gt;
        &lt;/style&gt;

        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;p&gt;aaa&lt;/p&gt;
                &lt;li&gt;bbb&lt;/li&gt;
                &lt;li&gt;ccc&lt;/li&gt;
                &lt;li&gt;ddd&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;


四、伪类选择器

    什么是伪类选择器: 使用类选择器把相同元素定义成不同样式，如

        p.right { text-align: right; }
        p.left {text-align: lef; }

    1、E:hover: 当鼠标指针移动到元素上所使用样式

    2、E:active: 用来指定元素被激活（鼠标在元素上按下还没有松开）时使用样式

    3、E:focus: 元素获得光标时使用

    4、E:enabled: 元素可用时状态使用

    5、E:disabled: 元素不可用状态时样式

    6、E:read-only: 元素只处于只读状态下时使用

    7、E:read-write: 元素处于非只读状态时使用

    8、E:checked: 指定单选或多选

    9、E:default: 用来指定当页面打开时默认处于选取状态的单选或多选框

    10、E:indeterminate: 用来指定页面打开时，一组单选中任何一个单选框都没有设定为选取状态.

    11、E::selection: 用来指定当元素处于选中状态时的样式

    12、E:target: 显示的两条

    13、~: 兄弟元素选择器
</code></pre><h4 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h4><pre><code>伪类 - 用于已有元素处于某个状态，为其添加对应的样式，比如用户悬停 通过 :hover

伪元素 - 用于创建一些不在文档树中的元素，并为其添加样式，如 :before来在一个元素前增加一些文本

一、伪类 用于向某些选择器添加特殊效果

    a:link: 未被访问过
    a:visited: 已经被访问的链接
    a:hover: 鼠标指针移动到的链接
    a:active: 被点击的链接
    :first-chidle: 向元素的第一个子元素添加样式


二、伪类元素 用于向某些选择器添加特殊效果

    ::first-letter: 设置第一个字符的样式属性

    ::first-line: 设置第一行的样式

    ::before 和 ::after: 用于在元素前和元素后配置content属性添加内容

        .box::before { content: &apos;这里是在box元素之前显示&apos;}
        .box::after { content: &apos;这里是在box元素之后显示&apos; }


三、css3规则伪类使用一个&quot;:&quot;, 伪元素使用两个&quot;::&quot;

    : 用于css2的伪类，:: 用于css3的伪类
</code></pre><p><img src="/images/伪类.png" alt="伪类"><br><img src="/images/伪元素.png" alt="伪元素"> </p>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><pre><code>一、text-shadow: 文字阴影  text-shadow: 横向 纵向 模糊半径 颜色

    多阴影: text-shadow: 10px 10px 2px #ccc, 20px 20px 3px #c3c3c3; 以逗号分割.


二、word-break: 文字自动换行

    normal: 使用浏览器的默认行为

    keep-all: 只能在半角空格或连接符处换行

    break-all: 允许在单词内换行


三、word-wrap: 长单词与URL地址自动换行

    normal: 浏览器默认，只有在半角空格或连接符处换行

    break-word: 长单词或URL地址内进行换行


四、@font-face: 服务器端字体

    @font-face {
        font-family: &apos;iconfont&apos;;
        src: url(&apos;iconfont.eot&apos;);                 /* IE9 */
        src: url(&apos;iconfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */
        url(&apos;iconfont.woff&apos;) format(&apos;woff&apos;),     /* chrome、firefox */
        url(&apos;iconfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
        url(&apos;iconfont.svg#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */
    }

    // 使用字体
    .iconfont{ font-family:&quot;iconfont&quot;; font-size:16px;font-style:nrmal; }


五、word-spacing: 设置单词字段间距, 修复 IE6、7 中始终存在的 1px 空隙，减少单词间的空白（即字间隔）

    .main{
        font-size:0;
        *word-spacing:-1px;
    }

六、letter-spacing: normal;  /* 设置字母、字间距为0 */ 

七、text-overflow: 溢出的文本末尾加省略标记

    clip: 不显示省略号

    ellipsis: 文字溢出时显示 ...

    ellipsis-word: 
</code></pre><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><pre><code>一、display: 定义盒类型

    block: 转成块元素

    inline: 转成内联元素

    inline-block: 属于block的一种，也具有inline的特点

    inline-table: 

    flex、inline-flex: flex弹性布局

    box、inline-box: box弹性盒模型，父元素上加此属性


二、box-sizing: 指定元素的宽与高度的计算方法

    1、content-box: border和padding不计算width之内（标准盒模型）

    2、border-box: border和padding计算入width之内，元素的宽高 = border + padding + content + width/height

    3、padding-box: padding计算入内（怪异盒模型）

    好处: 如果我设置两列都为50%，如果之前我加入了边距，加了内边距等，这个百分比计算就不好撑控了，

         所以有了box-sizing就可以不用管内边距的值是多少边框值是多少，最后都为50%

    -webkit-box-sizing、-moz-box-sizing、box-sizing


三、calc 给属性的值做计算

    Android不支持

    例: height: calc(100% - 80px);

    rule:

        使用“+”、“-”、“*” 和 “/”四则运算;
        可以使用百分比、px、em、rem等单位；
        可以混合使用各种单位进行计算；
        表达式中有“+”和“-”时，其前后必须要有空格，如&quot;width: calc(12%+5em)&quot;这种没有空格的写法是错误的；
        表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。


四、盒相关属性

    1、box-shadow: 盒阴影    box-shadow: 横向距离 纵向距离 模糊半径 颜色 inset（内阴影）

    2、box-reflect: 倒影 

        box-reflect: 方向 距离 渐变

            方向: above: 倒影在上边     below: 倒影在下边     left: 倒影在左边         right: 倒影在右边

        Example: -webkit-box-reflect: below   0   -webkit-linear-gradient(transparent,transparent 50%,rgba(255,255,255,.3));

    3、resize: 自由绽放, 可以使用当前元素用鼠标进行宽度的缩放

        both: 水平垂直都可以缩放

        horizontal: 水平方向可以缩放

        vertical: 垂直都可以缩放

        注意: 一定要加overflow: auto 才可以缩放
</code></pre><h4 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h4><pre><code>布局分类: 1、静态 px        2、流式 fluid        3、自适应（弹性布局）flex        4、响应式 responsive

    box-sizing是先出来的，flexbox是过渡版，flex最新语法，一个特性是flex没有的，文字可以垂直居中

    .box{
        display: -webkit-flex; /* Safari/Chrom */
        display: flex;
    }


任何一个容器都可以设置flex布局  # 父元素设置display: flex;  行内元素设置 display: inline-flex;    

display: flex 或 inline-flex;   // 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。

一、父容器上设置的属性: 

    1、flex-direction: 子元素的排列方向

        row 水平方向，起点在左端 | row-reverse 水平方向，起点在右端 | column 垂直方向，起点在上沿 | column-reverse 垂直方向，起点在下沿

    2、flex-wrap: 是否换行显示  nowrap 不换行 | wrap 换行第一行在上方 | wrap-reverse 换行，第一行在下方        

    3、flex-flow: flex-direction属性 和 flex-wrap

    4、justify-content: 子元素的对齐方式 

        flex-start 左对齐 | flex-end 右对齐 | center 居中 | space-between 两端对齐 | space-around 每个项目两侧间隔相等

    5、align-items: 主轴对齐方式，指定伸缩项目沿主轴对齐方式 （水平方向）

        flex-start 交叉轴的起点对齐。

        flex-end 交叉轴的终点对齐。

        center 交叉轴的中点对齐。

        baseline 项目的第一行文字的基线对齐。

        stretch（默认值）如果项目未设置高度或设为auto，将占满整个容器的高度。

    6、align-content: 侧轴对齐方式，指定伸缩项目沿着侧轴对齐方式 (垂直方向)


二、栏目的属性

    1、order: 栏目排列顺序。数值越小，排列越靠前，默认为0

    2、flex-grow: 放大比例，默认为0，即如果存在剩余空间，也不放大。

    3、flex-shrink: 项目的缩小比例

    4、flex-basis: 项目占据的主轴空间

    5、flex: 设置列所在容器的比例

            flex: 1，相当于flex: 1 1 auto, 如果想指定一个列的宽度，flex: 0 0 100px;

            .boxA { flex:1 } .boxB{ flex: 2 }

    6、align-flex: 允许单个项目有与其他项目不一样的对齐方式,可覆盖align-items属性。

    7、align-self: 指定多行伸缩容器的对齐，可以单独伸缩子元素，会覆盖align-items


Example:

    .row{width:200px;
        height: 50px;
        /*加上厂商前缀，目前使用方式都有三种写法: 1，旧的2，过度的3，新的*/
        display: -webkit-box;
        display: -webkit-flex;
        display: -ms-flexbox;
        display: flex;
        -webkit-flex-flow: row nowrap;
        -ms-flex-flow: row nowrap;
        flex-flow: row nowrap;}

    .row div{ 
        width:50px;height:50px;
        -webkit-box-flex: 1; 
        -webkit-flex: 1; 
        -ms-flex: 1;
        flex: 1; 
        text-align: center;
        line-height: 5rem;
        background-color: #f69f75;
    }

https://github.com/ccforward/cc/issues/60
http://www.alloyteam.com/2015/05/xi-shuo-flexbox-dan-xing-he-zi-bu-ju/
</code></pre><h4 id="box弹性盒模型"><a href="#box弹性盒模型" class="headerlink" title="box弹性盒模型"></a>box弹性盒模型</h4><pre><code>一、display: box 父元素加值

    display中加 box 或 inline-box: 使用弹性盒模型时使用

    box-orient: 定义盒模型的布局方向  horizontal 水平显示  vertical 垂直显示

    box-direction: 元素排列顺序  normal 正序   reverse 倒序

    box-ordinal-group: 设置元素的具体位置 

        .box div:nth-of-type(1){ --webkit-box-ordinal-group: 2 }    // 将第一个元素放到第二个位置显示 

二、box-flex: 定义盒子的弹性空间

    .boxB div { height: 100px; background-color: red; border: 1px #fff solid;}
    .boxB div:nth-of-type(1){ -webkit-box-flex: 1; }        // 这里可以写固定宽度
    .boxB div:nth-of-type(2){ -webkit-box-flex: 2; }
    .boxB div:nth-of-type(3){ -webkit-box-flex: 3; }
    .boxB div:nth-of-type(4){ -webkit-box-flex: 4; }
    .boxB div:nth-of-type(5){ -webkit-box-flex: 5; }

三、box-pack: 对盒子富裕空间管理，让盒子左侧、右侧还是居中显示，相当于float:left right

    star: 所有子元素在盒左侧显示，富余空间在右侧

    end: 所有子元素在盒右侧显示，富余空间在左侧

    center: 所有子元素居中

    justify: 富余空间在子元素之间平均分布

四、box-align: 垂直方向对元素的位置进行管理

    start: 所有元素居顶

    end: 所有元素居底

    center: 所有元素居中
</code></pre><h4 id="分栏布局"><a href="#分栏布局" class="headerlink" title="分栏布局"></a>分栏布局</h4><pre><code>给要分栏内容的父级上加入下面属性对文字进行分栏显示

1、column-width: 栏目宽度

2、column-count: 栏目列数

3、column-gap: 栏目距离

4、column-rule: 栏目间隔线
</code></pre><h4 id="mask蒙版"><a href="#mask蒙版" class="headerlink" title="mask蒙版"></a>mask蒙版</h4><pre><code>#box {
    width: 100%;
    height: 300px;
    background: url(../img/eric.jpg) no-repeat;
       -webkit-mask-repeat: no-repeat;
}

.mask_img_1 {
    -webkit-mask-box-image: url(../img/apple.png) 10 20 30 40 round round;
}

1、mask-box-image: 定义图片遮罩

2、mask-composite: 定义同一个元素上有多个图片遮罩的顺序

3、mask-clip: 定义图片遮罩延伸的位置

4、mask-repeat: 定义遮罩是否重复

5、mask-size: 定义遮罩的大小    
</code></pre><h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><pre><code>一、linear-gradient: 线性渐变

    background: -webkit-linear-gradient(top, #000 0%, #fff 100%);  // (起始位置, 开始颜色 占多少比例, 结束颜色  占多少比例) 

    1、起始位置可以写成 (top left) 从左上开始，也可以写成angle 角度值 45deg, background: -webkit-linear-gradient(45deg, #ccc 50%, #000 50%);

    2、(left top, #ccc 50%, #000 50%) - 写成50%百分比两个颜色没有过渡，如果成写100px两个颜色有过渡色

    简写: background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #000), color-stop(100%, #fff));

二、radial-gradient: 径向渐变

三、color-stop(透明度, reg): 从一个颜色到另一个颜色的渐变，需要color-stop

http://www.zhangxinxu.com/wordpress/2013/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css3-gradient%E6%96%9C%E5%90%91%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98/
</code></pre><h4 id="背景和边框"><a href="#背景和边框" class="headerlink" title="背景和边框"></a>背景和边框</h4><pre><code>背景: 
    1、background-clip: 指定背影的范围

        border-box 背景图以边框线为开始     padding-box 背景图已padding以开始    content-box 背景以内容为开始    text 文字中嵌背景图，文字外没有背景图

    2、background-origin: 绘制背影图像起点

        border-box 以边框线为起点    padding-box 以padding为起点     content-box  以内容区为起点

    3、background-size: 指定背影图像的尺寸

        auto: 背景图真实的大小

        cover:背景图像缩放,保留图像原有的比例/长宽比,不管背景图像大于还是小于背景区域，都会覆盖背景区域,图像的宽度或高度等于或超过背景区域,再次,根据背景图像的比例是否匹配的背景区域,背景图像的某些部分可能不在背景区域内。

        contain:背景图像缩放,同时保留图像原有的比例/长宽比,无论是图像的宽度或高度超过背景区域,以尽可能大的覆盖背景区域。因此,根据背景图像的比例是否匹配背景区域,可能会有一些背景图像覆盖不到背景地区。

        指定值: background-size: 100px 200px;  or    background-size: 50% 80%;

    4、background-break: 指定内联元素的背景平时循环方式

边框: 
    1、border-radius[ˈreɪdiəs]: 圆角的半径

    2、border-image: 图像边框
</code></pre><h4 id="transform-2D"><a href="#transform-2D" class="headerlink" title="transform 2D"></a>transform 2D</h4><pre><code>一、transform分类: 

    1、缩放: scale(0.5) 0-1之间  transform: scale(0.5)

    2、倾斜: skew实现文字或图像的倾斜  transform: skew(30deg, 30deg)

    3、移动: translate移动元素  transform: translate(50px, 50px;)

    4、旋转: rotate[ˈroʊteɪt]旋转元素  transform: rotate(45deg)

    5、矩阵: matrix


二、旋转基准点: 

    transform-origin: left top;     以左上为基础点
</code></pre><h4 id="transform-3D"><a href="#transform-3D" class="headerlink" title="transform 3D"></a>transform 3D</h4><pre><code>一、transform-style: 指定3D空间呈现，主要有两个属性值: flat 和 preserve-3d。

    1、flat: 值为默认值，表示所有子元素在2D平面呈现

    2、preserve-3d: 表示所有子元素在3D空间中呈现

        2）perspective: 景深

        3）perspective-origin: 景深基点

        4）backface-visibility: 隐藏背面

        5）Transform中的3D: 

二、perspective [pəˈspektɪv]: 200; 景深的远近，数越小景深越明显

三、perspective-origin: 50% 50%;   景深基点, 中间

四、backface-visibility: hidden 隐藏背面

五、3D元素

    1、translateX、translateY、translateZ

    2、rotateX、rotateY、rotateZ

    transform: translate3d(x, y, z)


Example:

    &lt;style&gt;
        .container {
            /* 告诉引擎使用的是3D */
            -webkit-transform-style: -webkit-preserve-3d;

            /* 设置景深和景深基点 */
            -webkit-perspective: 200;
            -webkit-erspective-origin: 50% 50%;
        }

        .boxA {
            width: 200px;
            height: 200px;
            margin: 100px auto;
            background-color: #7cb305;

            transform: rotateX(45deg);
        }
    &lt;/style&gt;

    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;boxA&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;


https://www.qianduan.net/high-performance-css3-animations/
https://segmentfault.com/a/1190000005071819
</code></pre><h4 id="css开启硬件加速"><a href="#css开启硬件加速" class="headerlink" title="css开启硬件加速"></a>css开启硬件加速</h4><pre><code>大多数电脑的显卡都支持硬件加速、可以发挥GPU的力量，CSS animations, transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行

一、开启硬件加速

    将元素转成3D变化就可以来欺骗浏览器开启硬件加速

    .cube {
        -webkit-transform: translate3d(0, 0, 0);
        -moz-transform: translate3d(0, 0, 0);
        -ms-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

二、解决使用transform或animator时页面闪烁的问题

    .cube {
        -webkit-backface-visibility: hidden;
        -moz-backface-visibility: hidden;
        -ms-backface-visibility: hidden;
        backface-visibility: hidden;

        -webkit-perspective: 1000;
        -moz-perspective: 1000;
        -ms-perspective: 1000;
        perspective: 1000;
    }
</code></pre><h4 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h4><pre><code>一、transition 允许块级元素属性，在指定时间内平滑改变

    transition: 过渡属性名  过渡时间  过渡模式  延迟时间

    .box { transition: all 2s linear 3s; }

        transition-property: all;     // 设置过渡效果，all或指定一个css属性; 如果是all就是所有属性只要有变化的就执行过渡效果

        transition-duration: 2s;     // 动画完成的时间

        transition-timing-function: // 过渡模式

        transition-delay: 2s;         // 延迟时间

    # 多个过渡通过逗号分割 .box { transition: width 2s linear, height 3s linear 2s; }

    # transition事件: 

        obj.addEventListener(&apos;transitionend&apos;, function(){}, false);
        obj.addEventListener(&apos;WebkitTransitionend&apos;, function(){}, false);

    过渡模式: ease、linear、ease-in、ease-out、ease-in-out

二、animation: 能够在样式中创建多个关键帧来编写样式

    1、按百分比来做不同的样式处理

        @-webkit-keyframes myColor {
            0%{
                background-color: red;
            }
            50%{
                background-color: yellow;
            }
            100%{
                background-color: red;
            }
        }

        .box { animation: myColor 5s linear; }

三、from...to，从0%到100%

    animation: inpEffect .4s linear;

    @-webkit-keyframes inpEffect {
        from { top:0px; }
        to { top:200px; }
    }

四、将animation动画执行到100%后停住，animation-fill-mode: forwards;  

    animation: inpEffect .4s linear;        // 或者加到animation中 animation: inpEffect .4s linear forwards;
    animation-fill-mode: forwards;

    @-webkit-keyframes inpEffect {
        to {
            transform: scaleX(1); 
        }
    }

兼容前缀

    -webkit-: 指对chrome这种webkit内核的浏览器

    -moz-: 指对Firefox浏览器

    -o-: 指对Opera浏览器
</code></pre><h4 id="Media-Queries-查询媒体"><a href="#Media-Queries-查询媒体" class="headerlink" title="Media Queries  查询媒体"></a>Media Queries  查询媒体</h4><pre><code>一、&lt;meta&gt;标签

    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;

    1、width=device-width: 宽度等于设备宽度

    2、initial-scale: 初始缩放比例   initial[ɪˈnɪʃəl]

    3、minimum-scale、maximum-scale: 允许用户缩放最小、大比例

    4、user-scalable: 是否允许用户缩放


二、css定定义

    媒体查询: @media 设备类型 and (设备特性) { 样式代码 }

    1、设备类型: 

        1) all 所有媒体
        2) braille 盲文触觉设备
        3) embossed 盲文打印机
        4) print 手持设备
        5) projection 打印预览
        6) screen 彩屏设备
        7) speech &apos;听觉&apos;类似的媒体类型
        8) tty 不适用像素的设备
        9) tv 电视

    2、and | not | only

    3、min-width、max-width 最小、大宽度

    4、device-width、device-height: 设备屏幕的宽、高度。 device[dɪˈvaɪs]

    引用不同样式: 

        @media screen and (mim-width:480px){    // 窗口宽高大于480时调用下面样式
            .ads {
                display:none;
            }
        }

        @media screen and (min-width: 500px) and (max-width: 800px){    // 窗口宽度500-800之间执行下面样式
            .ads {
                display:none;
            }
        }

三、引用样式文件表

    引用不同样式表 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;a.css&quot; meida=&quot;screen and (min-width: 800px)&quot;&gt;
</code></pre><h4 id="css性能"><a href="#css性能" class="headerlink" title="css性能"></a>css性能</h4><pre><code>一、尽可能少使用box-shadows与gradients，投影和渐变都是性能杀手

二、将动画元素不在文档流中，以减少重排，使用

    position: fixed;  
    position: absolute;
</code></pre><p>| <a href="https://segmentfault.com/a/1190000006878700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006878700</a><br>| <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</a>    flex布局<br>| <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a><br>| <a href="http://www.cnblogs.com/module/p/5578533.html" target="_blank" rel="noopener">http://www.cnblogs.com/module/p/5578533.html</a><br>| <a href="https://isux.tencent.com/css3/tools.html" target="_blank" rel="noopener">https://isux.tencent.com/css3/tools.html</a>         // 动画工具生成代码<br>|<br>| <a href="https://github.com/zhiqiang21/blog/issues/2" target="_blank" rel="noopener">https://github.com/zhiqiang21/blog/issues/2</a><br>| <a href="http://div.io/topic/1348" target="_blank" rel="noopener">http://div.io/topic/1348</a><br>| <a href="https://github.com/tj?page=2&amp;tab=repositories" target="_blank" rel="noopener">https://github.com/tj?page=2&amp;tab=repositories</a><br>| <a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/</a>  伪类、伪元素<br>| <a href="https://zhuanlan.zhihu.com/p/33984503" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33984503</a>            // z-index<br>| <a href="https://cases.aotu.io/" target="_blank" rel="noopener">https://cases.aotu.io/</a>        h5活动案例<br>| <a href="https://zhuanlan.zhihu.com/p/25070186" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25070186</a>            // 布局<br>| <a href="https://zhuanlan.zhihu.com/p/25068655" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25068655</a>            // 居中布局</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/Babel/">Babel</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/Babel/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| babel安装<br>| ES6转ES5 babel-preset-es2015<br>| jsx文件的转换 npm i babel-preset-react<br>| .babelrc 文件配置 presets来解析<br>| 加UMD模块，可以自带模块代码</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><pre><code>$ npm install babel-cli         // babel的命令行cli

$ npm install --save-dev babel-preset-react        // 转换JSX语法并去掉注释

    .babelre配置  { &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;, &quot;stage-2&quot;] }


$ npm install --save-dev babel-preset-env        // 转义器将JS的 ES6、7转成ES5，官方废弃了ES2015/ES2016/ES2017使用babel-preset-env 来代替

    .babelre配置  { &quot;presets&quot;: [&quot;env&quot;] }

$ npm install --save-dev babel-loader            // webpack的使用babel的加载器

$ npm install -save-dev babel-polyfill        // babel默认只转新的javascript语法，不会转新的API, 如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，需要使用babel-polyfill
</code></pre><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><pre><code>babel支持的使用场景非常多，可以在浏览器中使用（browser）也可以在命令行（cli），还可以是我们常见的gulp和webpack中

一、安装：

    $ npm install babel-cli  babel-preset-env                    // 包括了: babel、babel-node、babel-core、babel-register

    // PolyFill 用于语法转换（如箭头函数）
    $ npm install --save-dev babel-polyfill                

    // babel-preset-react用于JSX语法转换Flow
    $ npm install --save-dev babel-preset-react                // .babelrc中需要加react

    $ touch .babelrc

        { &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;] }


        1、babel-register模块改写require命令，为它加上一个钩子。require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。

            npm install --save-dev babel-register

            // 先加载babel-register，这样就会不在对index.js进行转码了
            require(&quot;babel-register&quot;);
            require(&quot;./index.js&quot;);

        2、浏览器环境

            下载babel-core: npm install babel-core@5

            &lt;!-- 引用browser.js --&gt;
            &lt;script src=&quot;node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt;
            &lt;!-- type值为text/babel --&gt;
            &lt;script type=&quot;text/babel&quot;&gt;
                // 这里写es6的代码
            &lt;/script&gt;


二、babel用处

    1、将ES6转成ES5代码 babel-preset-es2015

        npm i babel-preset-es2015 --save-dev

        需要创建一个 .babelrc 文件
        {
              &quot;presets&quot;: [&quot;es2015&quot;]
        }

    2、babel-polyfill: 可以在在浏览器直接解析    npm i babel-polyfill --save-dev

    3、React的JSX代码: npm i babel-preset-react --save-dev

        对.babelrc文件配置
        {
              &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
        }


三、执行编译

    # babel main.js     // 将文件直接编译

    # babel main.js --out-file  main-component.js     // 编译文件 - 将main.js编译成一个main-component.js, 缩定--out-file 写成 -o

    # babel src --out-dir build   // 编译目录 - 将src目录下的所有文件编译到build目录下，--out-dir简写 -d

    # babel --watch main.js --out-file main-component.js  --source-maps  // --watch 侦听文件的变化，--source-maps 会在文件打出文件的目录, 简写 -w

    # babel src --out-dir lib  // 编译目录，src目录下的所有文件进行编辑并放到lib文件夹中


四、浏览器上直接编译 browser.js

    可以直接转换，不需要执行编译命令

    1、加载需要文件
        babel-core/browser.js 
        babel-core/browser-polyfill.js     // 修补浏览器工具的，浏览器不支持的时候需要它

    2、&lt;script&gt;调用
        type中必须写成 &apos;text/babel&apos;
        &lt;script src=&quot;main.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h4><pre><code>Babel 附带一个内置的 CLI，可用于从命令行编译文件, 用于执行命令

// 安装
$ npm install --save-dev babel-cli

// 执行
package.json中配置

    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;babel src -d build&quot;,        // 通过babel将src目录下的文件全部转译到build目录
    },
</code></pre><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><pre><code>将运行代码分三个阶段：解析、转换、生成

.babelrc文件

    {
        &quot;presets&quot;: [
            &quot;es2015&quot;,            // es2015、es2016、es2017
            &quot;react&quot;,
            &quot;stage-2&quot;            // stage-0...stage-4
        ]
    }
</code></pre><h4 id="Stage-X-阶段"><a href="#Stage-X-阶段" class="headerlink" title="Stage-X 阶段"></a>Stage-X 阶段</h4><pre><code>$ npm install --save-dev babel-preset-stage-0        // 安装

.babelrc
{
    &quot;presets&quot;: [&quot;stage-0&quot;] 
}

Stage 0 - 稻草人: 只是一个想法，可能是 babel 插件

Stage 1 - 提案: 初步尝试

Stage 2 - 初稿: 完成初步规范

Stage 3 - 候选: 完成规范和浏览器初步实现

Stage 4 - 完成: 将被添加到下一年度发布
</code></pre><h4 id="Balel-与-Gulp结合"><a href="#Balel-与-Gulp结合" class="headerlink" title="Balel 与 Gulp结合"></a>Balel 与 Gulp结合</h4><pre><code>// 安装gulp 和 gulp-bable包
$ npm i gulp gulp-babel --save

gulpFile:

    var gulp = require(&apos;gulp&apos;);
    var babel = require(&apos;gulp-babel&apos;);

    gulp.task(&apos;babelTask&apos;, function(){
        return gulp.src(&apos;./src/*.js&apos;)
            .pipe(babel())
            .pipe(gulp.dest(&apos;babelTask&apos;))
    })

    gulp.task(&apos;default&apos;,[&apos;babelTask&apos;]);
</code></pre><h4 id="Babel-与-Webpack结合"><a href="#Babel-与-Webpack结合" class="headerlink" title="Babel 与 Webpack结合"></a>Babel 与 Webpack结合</h4><pre><code>// 安装webpack和babel需要的包
$ npm install babel-loader babel-core babel-preset-es2015 webpack --save-dev

webpack.config.js:

    var webpack = require(&apos;webpack&apos;);
    var path = require(&apos;path&apos;);

    module.exports = {

        /* 页面入口 - 单入口文件 */
        entry: {
                index : &apos;./src/js/webpackPackMain.js&apos;          // 单入口文件
        },

        output: {
                path: &apos;./dist/js/&apos;,
                filename: &apos;[name].min.js?[hash]&apos;            // [hash] 将文件输出后加一个hash值
        },

        //加载器配置
        module: {
                loaders: [
                    &lt;!-- { test: /\.css$/, loader: &apos;style-loader!css-loader&apos;},
                    { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},
                    { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                    // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                    { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;}, --&gt;

                    // es6转es5
                    {
                        test: /\.js$/,
                        exclude: /(node_modules|bower_components)/,
                        loader: &apos;babel-loader&apos;,
                        query: {
                            presets: [&apos;es2015&apos;]
                        }
                    }
                ]
        }
    };
</code></pre><p>| <a href="https://babel.docschina.org/" target="_blank" rel="noopener">https://babel.docschina.org/</a>            // 官网</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/HTML、CSS深入理解/">HTML、CSS深入理解</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/HTML、CSS深入理解/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/HTML-CSS/">HTML/CSS</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>—————– CSS —————–</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><pre><code>内联元素与块元素的区别

    内联元素: 

        1、与其它内联元素都在并列同一行     

        2、不能设置宽、高

        3、不能设置上下外边距、内边距 margin-top、margin-bottom 和  padding-top、padding-bottom ，设置内边距也不会撑起父级高度

    块元素: 

        1、不指定宽度，会继承父元素的宽度，每个块元素都是独立一行

        2、元素的宽高都可以设置，如果不设置宽度就为100%;


一、display属性: 

    1、inline: 内联元素        2、block: 块元素

    3、inline-block: 具有block的宽高特性，又具有inline的同行元素特性

    4、table-cell: 文字的垂直居中，类似表格的单元格

    5、box: 弹性盒模型的过渡版本，现在用flex替换

    5、flex: flex是一个弹性布局的最新版本，老版本使用的box

        flex布局，子元素的float、clear、vertical-align属性将失效

        主要属性有两大类: 容器属性和项目属性


二、visibility 隐藏时可以保留元素的空间, display不会保留

    visible: 可视        hidden: 对象隐藏


三、overflow 

    overflow-x、overflow-y: 分别处理水平或垂直

    1、hidden: 隐藏溢出的内容

    2、scroll: 溢出的内容以滚动条显示
</code></pre><h4 id="BFC浮动"><a href="#BFC浮动" class="headerlink" title="BFC浮动"></a>BFC浮动</h4><pre><code>BFC概念: Block Formatting context(块级格式化上下文) 页面中一块渲染区域，并且有一套渲染规则，决定子元素如何定位，以及他们之间的关系和相互作用

触发BFC - 只要元素满足下面任一条件即可触发 BFC 特性：

    body 根元素

    浮动元素：float 除 none 以外的值

    绝对定位元素：position (absolute、fixed)

    display 为 inline-block、table-cells、flex

    overflow 除了 visible 以外的值 (hidden、auto、scroll)


如果子元素设置了浮动 float:left; 那么浮动的元素就会脱离普通文档流, 不会撑起父元素的高度, 容器只剩下2px的边距高度

    &lt;div style=&quot;border: 1px slid #000&quot;&gt;        // 添加overflow: hidden
        &lt;div style=&quot;width: 100px; height: 100px; background: #eee; float: left&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;


一、float 浮动

    left、right 左右浮动  浮动问题: 会使父级的高度失效，使用清除浮动来解决


二、clear 清除浮动

    both: 不允许有浮动对象     left: 不允许左边有浮动        right: 不允许有右边浮动

    /* 万能清除浮动 */
    .clear:after { content:&apos;&apos;; display:block; clear:both; height:0; overflow:hidden; visibility:hidden; }
    .clear { zoom:1; }

    after伪类： 元素内部末尾添加内容；
        :after{content&quot;添加的内容&quot;;} IE6，7下不兼容

    zoom 缩放 
        a、触发 IE下 haslayout，使元素根据自身内容计算宽高。
        b、FF 不支持；
</code></pre><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><pre><code>一、padding: 内边距 padding不支持负值

二、margin: 外边距 支持负值

    margin存在的问题: 

    1、适用于block元素，不起作用的absolute、fixed、inline、table-cell元素

    2、margin-top和margin-bottom 兄弟之间的会重叠

        解决方法:
            1、给当前元素加浮动 float: left
            2、给当前元素加 

    3、margin-top: 会影响到父元素（标准浏览器会影响，IE正常）

        解决方法: 给父元素加一个padding、border或overflow:hidden 即上面代码里的注释部分

三、border: 边框线
</code></pre><h4 id="position-定位"><a href="#position-定位" class="headerlink" title="position 定位"></a>position 定位</h4><pre><code>一、absolute: 绝对定位，查找父子以上的元素是否定义了position，如果没有就以window为定位基准

二、relative: 相对定位

三、fixed: 始终以window为定位，固定到屏幕的某个位置，浏览器滚动也跟随

四、static: 

五、z-index: 层级堆叠顺序，值越高越在最上面，最小值为0，最大值为2147483647
</code></pre><h4 id="background-背景"><a href="#background-背景" class="headerlink" title="background 背景"></a>background 背景</h4><pre><code>1、background-attachment: 背景图是随着滚动还是固定

    fixed: 相对窗体固定

    scroll: 背景图以元素固定，元素内容滚动时图像不会跟随滚动

2、transparent: 背景透明

background-color: 背景颜色 
background-image: 背景图片
background-repeat: 背景重复
background-position: 背景位置
</code></pre><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><pre><code>1、word-spacing: 单词与单词之间的间隔

2、letter-spacing: 字母与字母之间的间隔

3、word-wrap: 属性允许长单词或 URL 地址换行到下一行    @ break-word 在需要换行时才换

    如果不加些属于英文不会换行

4、word-break: 断字点进行换行

    break-all: 让英文象中文一样可以在行内做任意字间换行

    keep-all: 让中文向英文的换行方式接近，只在空格或英文标点符号才换行

5、white-space: 指定超出父级盒子宽度，文本进行换行(中、英文)，white-space: nowrap;

6、text-overflow: 文本的溢出时隐藏，test-overflow: ellipsis;  溢出用省略号来修剪

    p {width: 100px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;}

7、text-indent: 文本的首行缩进

8、vertical-align: 文本的对齐方式

    * 只应用于inline水平以及table-cell元素  别把他放到div或p的块元素内

    1、线类

        baseline: 默认，元素的基线与父元素的基线对齐

        top、bottom、middle: 居上、下、中

    2、文本

        text-top、text-bottom: 

    3、上标下标类

        super: 上标   sub: 下标   不过位置都不太兼容，需要重写

    4、数值百分比

        vertical-align: 20px;

9、color: 文本颜色

10、text-align: 文本对齐 left right center justify

11、text-decoration: 文本装饰 overline 上划线  underline 下划线  line-through 从中间穿过的线

12、direction: 文字方向 rtl 从右向左    ltr 从左向右

13、line-height: 行高
</code></pre><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><pre><code>table: margin可以使用，除非设置 display: inline-table

1、border-collape: 表格或单元格边框合并到一起

    separate: 边框独立        collapse: 相邻合并

2、border-spacing: 表格或单元格之间的距离

表格单线条:

    .tab { border-spacing: 0;  border-collapse: collapse;}
    .tab td, .tab th { border-collapse: collapse; border: 1px #ccc solid; border-spacing: 0; padding: 10px 20px; }
</code></pre><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><pre><code>rem: 是相对于根元素(html)的font-size值为基准，em是相对父级元素变化，px是物理像素

vw/vh: 根据屏幕不同变化的

em: 相对长度，相对于父元素
</code></pre><h4 id="语法与规则"><a href="#语法与规则" class="headerlink" title="语法与规则"></a>语法与规则</h4><pre><code>1、!important 提升优先级

2、@import url(&quot;global.css&quot;); 导入外部样式表

3、@charset &apos;uft-8&apos; 编码
</code></pre><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><pre><code>p{...} 元素选择器

.className{...} 类选择器

#idName{...} id选择器

.user[id=&apos;username&apos;]{...} 属性选择器

.claA .claB{...} 后代选择器

.clsA &gt; .clsB {...} 子选择器

.clsA + .clsB {...} 相邻选择器

.clsA, .clsB{...} 选择器分组
</code></pre><h4 id="伪类、伪元素"><a href="#伪类、伪元素" class="headerlink" title="伪类、伪元素"></a>伪类、伪元素</h4><pre><code>伪类 用于向某些选择器添加特殊效果

    a:link: 未被访问过
    a:visited: 已经被访问的链接
    a:hover: 鼠标指针移动到的链接
    a:active: 被点击的链接

    :first-childe: 向元素的第一个子元素添加样式


伪类元素 用于向某些选择器添加特殊效果

    :first-letter: 设置第一个字符的样式属性  ::first-letter

    :first-line: 设置第一行的样式    ::first-line

    :before 和 :after: 用于在元素前和元素后配置content属性添加内容    ::before   ::after

        .box::before { content: &apos;这里是在box元素之前显示&apos;}
        .box::after { content: &apos;这里是在box元素之后显示&apos; }


css3规则伪类使用一个&quot;:&quot;, 伪元素使用两个&quot;::&quot;

    : 用于css2的伪类，:: 用于css3的伪类
</code></pre><h4 id="css基础属性"><a href="#css基础属性" class="headerlink" title="css基础属性"></a>css基础属性</h4><pre><code>字体

    font-size: 字体大小

    font-family: 使用的字体

    font-style: 字体风格  @ italic 斜体

    font-weight: 字体重量

    font: 简写 

        按顺序 也可以设置第六个值为line-hgith
        font-style
        font-variant
        font-weight
        font-size/line-height
        font-family

链接

    a:link: 未被访问过

    a:visited: 已经被访问的链接

    a:hover: 鼠标指针移动到的链接

    a:active: 被点击的链接

列表

    list-style-image: 将图像设置为列表标志

    list-style-position: 标志的位置

    list-style-type: 标志类型  @circle 圆  @square 方块

    list-style: 简写属性

尺寸

    width、height: 宽高

    max-width、max-height: 最大宽高

    min-width、min-height: 最小宽高

透明度

    opacity: 0.4;

    filter: alpha(opacity=40); /* 针对 IE8 以及更早的版本 */
</code></pre><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><pre><code>1、body高度为100%，html继承了浏览器的高度，body继承了html的高度，这样body就为100%了

    html{ height: 100%; }
    body { height: 100%; margin: 0;}
    .box { width: 100%; height: 100%; background-color: #ccc; }

2、浏览器hack

    .box { width: 100px\9; }

    浏览器（加粗表示支持）    CSS hack
    IE6        _background-color:#38DB24;
    IE6、7    *background-color:#38DB24;
    IE6、7    +background-color:#38DB24;
    IE6、7    #background-color:#38DB24;
    IE6、7    background-color:#38DB24 !ie;
    IE6、7、8、9、10    background-color:#38DB24\9;
    IE7、8、9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari        html&gt;body .ie78910-all-hack { background-color: #38DB24 }
    IE8、9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari        html&gt;/**/body .ie8910-all-hack { background-color: #38DB24 }
    IE8、9、10&amp;Opera    background-color:#38DB24\0;
    IE9、10    :root .ie910-hack { background-color:#38DB24\9; }
    IE9、10    background-color:#38DB24\9\0;
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    body:nth-of-type(1) .ie910-all-hack {background-color:#38DB24 ;}
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    @media all and (min-width: 0px) { .ie910-all-2-hack{ background-color:#38DB24 ;} }
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    @media all and (min-width: 0px) { .ie910-all-3-hack{background-color:#38DB24 ;} }
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    :root *&gt; .ie910-all-4-hack { background-color:#38DB24 }
    IE10    @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) { .ie10-hack{background-color:#38DB24 ;} }
    Firefox    @-moz-document url-prefix() { .firefox-hack{background-color:#38DB24 ;} }
    Chrome&amp;Safari    @media screen and (-webkit-min-device-pixel-ratio:0) {.chrome-safari-hack{background-color:#38DB24 ;} }

3、条件注释

    lt : 就是Less than的简写，也就是小于的意思。

    lte : 就是Less than or equal to的简写，也就是小于或等于的意思。

    gt : 就是Greater than的简写，也就是大于的意思。

    gte: 就是Greater than or equal to的简写，也就是大于或等于的意思。

    !: 就是不等于的意思，跟javascript里的不等于判断符相同。

    1、只有IE能识别
        &lt;!--[if IE]&gt;
            &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;
        &lt;![endif]--&gt;

    2、指定版本
        &lt;!--[if IE 8]&gt; 
            &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;   
        &lt;![endif]--&gt;

    3、低于指定版本才能识别
        &lt;!--[if lt IE 7]&gt; 
            &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;   
        &lt;![endif]--&gt;


4、layout: IE的私有概念

5、zoom: 用于处发layout

    zoom: 1;
</code></pre><h4 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h4><pre><code>http://alloyteam.github.io/gopng

http://fis.baidu.com

http://gruntjs.com
</code></pre><p>—————– HTML —————–</p>
<h4 id="HTML标记"><a href="#HTML标记" class="headerlink" title="HTML标记"></a>HTML标记</h4><pre><code>1、&lt;!DOCTYPE html&gt; 声明文档解析类型，指定浏览器用哪个版本来解析页面

    解析类型有两种模式:  

    1、怪异模式: 浏览器使用自己的怪异模式解析渲染页面（如果不声明doctype就是怪异模式）

    2、标准模式: 使用严格模式，以W3C的标准解析渲染页面

    HTML 4.01 规定了三种文档类型: Strict、Transitional 以及 Frameset。


2、&lt;html&gt; 定义文档  &lt;body&gt; &lt;head&gt; 定义文档信息

3、&lt;title&gt;、&lt;style&gt;

4、&lt;meta&gt;: 文档元信息

5、&lt;link&gt;: 文档与外部资源

6、&lt;script&gt;: 定义脚本

7、&lt;div&gt;

8、&lt;iframe&gt;: 内联框架

9、&lt;img&gt;: 定义图像

文本:

10、&lt;p&gt;: 段落

11、&lt;span&gt;: 文档中的节

12、&lt;a&gt;: 定义锚，属性 href、title

13、&lt;b&gt;: 定义粗体

14、&lt;i&gt;: 斜体

15、&lt;em&gt;&lt;strong&gt;: 强调内容 斜体、粗体

16、&lt;u&gt;: 下划线文字

17、&lt;big&gt;、&lt;small&gt; 大字体和小字体   

    &lt;h2&gt;标准属性&lt;small&gt;id, class, title, style, dir, lang&lt;/small&gt;&lt;/h2&gt;

18、&lt;bdo&gt; 定义字体显示的方法 

    文字翻转显示 &lt;bdo dir=&quot;rtl&quot;&gt;Here is some text&lt;/bdo&gt;  

19、&lt;br&gt;: 换行

20、&lt;del&gt;: 被删除的文本

21、&lt;hr&gt;: 定义水平线

22、&lt;ins&gt;: 定义被插入文本

23、&lt;sub&gt;: 下标文本

24、&lt;sup&gt;: 上标文本

25、&lt;var&gt;: 文本的变量部分

26、&lt;code&gt;&lt;pre&gt;

标题

27、&lt;h1&gt;...&lt;h6&gt;    

列表

28、&lt;ul&gt;: 无序列表

29、&lt;ol&gt;: 有序列表

30、&lt;li&gt;: 列表的项目

31、&lt;dl&gt;、&lt;dt&gt;、&lt;dd&gt;: 定义列表

表单

32、&lt;form&gt;

33、&lt;fieldset&gt;、&lt;legend&gt;: 定义围绕表单中元素的边框。

    &lt;fieldset&gt;
        &lt;legend&gt;健康信息&lt;/legend&gt;
        身高: &lt;input type=&quot;text&quot; /&gt;
    &lt;/fieldset&gt;

34、&lt;input&gt;

35、&lt;label&gt;: input元素的标注

36、&lt;select&gt;: 下拉菜单 &lt;option&gt;菜单内容

37、&lt;button&gt;: 按钮

38、&lt;textarea&gt;: 多行文本

表格

39、&lt;table&gt;

40、&lt;tr&gt;、&lt;td&gt;: 行、列

41、&lt;caption&gt;: 定义表格标题

42、&lt;th&gt;: 表格头单元

43、&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;: 表格头和主体

窗口框架

44、&lt;frame&gt;: 定义框架集窗口或框架

45、&lt;frameset&gt;: 定义框架集

46、&lt;object&gt;、&lt;param&gt;
</code></pre><p>| <a href="http://www.css88.com/book/css/" target="_blank" rel="noopener">http://www.css88.com/book/css/</a><br>| <a href="http://www.w3cplus.com/" target="_blank" rel="noopener">http://www.w3cplus.com/</a><br>| <a href="https://www.nihaoshijie.com.cn/index.php/page/3" target="_blank" rel="noopener">https://www.nihaoshijie.com.cn/index.php/page/3</a><br>| <a href="http://jixianqianduan.com/page6/" target="_blank" rel="noopener">http://jixianqianduan.com/page6/</a><br>| <a href="http://www.css88.com/archives/category/js-and-ria" target="_blank" rel="noopener">http://www.css88.com/archives/category/js-and-ria</a><br>| <a href="http://www.w3cplus.com/solution/index/index.html" target="_blank" rel="noopener">http://www.w3cplus.com/solution/index/index.html</a><br>| <a href="https://github.com/csswizardry/inuit.css/tree/master/base" target="_blank" rel="noopener">https://github.com/csswizardry/inuit.css/tree/master/base</a><br>| <a href="https://github.com/GumbyFramework/Gumby" target="_blank" rel="noopener">https://github.com/GumbyFramework/Gumby</a><br>| <a href="http://www.shejidaren.com/css-written-specifications.html" target="_blank" rel="noopener">http://www.shejidaren.com/css-written-specifications.html</a><br>| <a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25321647</a>        BFC</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/HTML5深入理解/">HTML5深入理解</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/HTML5深入理解/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/HTML5/">HTML5</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 文件API FileList对象上传文件信息、FileReader()文件读取对象、FormData()异步上传文件<br>| 拖放API<br>| 离线应用 manifest<br>| postMessage 跨文档消息传送<br>| webScoket<br>| 本地存储localStorage、sessionStorage<br>| 多线程 web workers<br>| 获取地理位置 geolocation<br>| video、audio<br>| canvas绘图<br>| History 历史管理</p>
<h4 id="新增语义化标签"><a href="#新增语义化标签" class="headerlink" title="新增语义化标签"></a>新增语义化标签</h4><pre><code>1、header: 用于头部

2、footer: 用于页尾

3、nav: 用于导航

4、aside: 定义页面区域

5、article: 用来显示一块独立的文章内容

6、section: 文档的节

7、hgroup: 标题元素进行组合
</code></pre><h4 id="表单类"><a href="#表单类" class="headerlink" title="表单类"></a>表单类</h4><pre><code>一、表单属性

    1、placeholder: 内容为空时的提示 &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt;

    2、autofocus: 指定控件自动获取焦点 &lt;input type=&quot;text&quot; autofocus &gt;

    3、autocomplate: 自动完成功能，on和off两个值 &lt;input type=&quot;text&quot; autocomplate=&quot;on&quot;&gt; 只有Opera支持

    4、require: 如果该元素为空，则无法提交表单 &lt;input type=&quot;text&quot; required /&gt;


二、表单类型

    1、search: 用于搜索关键词 &lt;input type=&quot;search&quot; vlaue=&quot;&quot; &gt; 

    2、email: 需要输入正确的电子邮件地址

    3、number: 只能输入数字，配合min、max属性

    4、range: 数值范围

        &lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;-360&quot; max=&quot;360&quot; class=&quot;rang&quot; id=&quot;lateZ&quot; /&gt;

        事件: onchange: 触发后执行,只触发一次        oninput: 最真实触发，拖动就触发

    5、tel: 点击只提供数字键盘

    6、url: 输入url

    7、pattern: 正则表达式     &lt;input type=&quot;email&quot; pattern=&quot;[^ @]*@[^ @]*&quot; value=&quot;&quot;&gt;


邮件链接: &lt;a href=&quot;mailto:cxz@126.com&quot;&gt;发送邮件&lt;/a&gt;
电话链接: &lt;a href=&quot;tel:15012345678&quot;&gt;打电话&lt;/a&gt;
</code></pre><h4 id="dataList数据列表"><a href="#dataList数据列表" class="headerlink" title="dataList数据列表"></a>dataList数据列表</h4><pre><code>通过数据列表来实现自动补全的功能

&lt;form action=&quot;/server&quot; method=&quot;post&quot;&gt;
    &lt;input list=&quot;jslib&quot; name=&quot;jslib&quot;&gt;
    &lt;datalist id=&quot;jslib&quot;&gt;
        &lt;option value=&quot;jQuery&quot;&gt;
        &lt;option value=&quot;Dojo&quot;&gt;
        &lt;option value=&quot;Prototype&quot;&gt;
        &lt;option value=&quot;Augular&quot;&gt;
    &lt;/datalist&gt;
    &lt;input type=&quot;submit&quot; value=&quot;完成&quot; /&gt;
&lt;/form&gt;
</code></pre><h4 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h4><pre><code>FileList、FileReader()、FormData() 三个API对象

一、FileList对象、File对象: 读取本地文件

    HTML4: &lt;file&gt;控件内只允许放置一个文件，HTML5: 加入multipe属性，允许file添加多个文件

    Example:
        &lt;input type=&quot;file&quot; id=&quot;fileLoad&quot; /&gt; 
        &lt;input type=&quot;file&quot; id=&quot;fileLoad&quot; multiple /&gt;          // mutiple 可以进行多个文件的选取
        &lt;script&gt;
            oUpFile.onclick = function(){
                var oFileLoad = document.querySelector(&apos;#fileLoad&apos;).files[0];        // 返回的是FileList对象列表
                for(var k in oFileLoad){
                    console.log(k, oFileLoad[k]);
                }
            }
        &lt;/script&gt;

        FileList返回: 
        {
            name: f82f4a858d04d0a68f528e4602120c05.jpg,        // 文件名
            lastModified: 1462944176000,                    // 最后修改日期
            lastModifiedDate: Wed May 11 2016 13:22:56 GMT+0800 (CST),// 最后修改日期
            webkitRelativePath,
            size: 554902,                        // 文件大小 
            type: image/jpeg                    // 文件名型
        }

    https://segmentfault.com/a/1190000004084956


二、FileReader() 文件读取对象

    FileReader() 将文件读入内存，并且转成不同类型（二进制、DataURL、文本）

    方法: 
        1、readAsBinaryString: 将文件读取为二进制码

        2、readAsDataURL: 将文件读取为DataURL，一段是以data:开头的 Base64位图片编码

        3、readAsText: 将文件读取为文本，第2个参数为编码类型，默认为UTF-8

        4、abort: 中断读取

    Example:
        var oFile = document.querySelector(&quot;oFile&quot;).files[0];        // 返回FileList对象

        reader = new FileReader();        // 创建FileReader()对象读取文件
        reader.readAsDataURL(oFile);    // 将文件以什么格式读入页面
        reader.onload = function(e){
            $(&quot;#oimg&quot;).attr(&apos;src&apos;, e.target.result);    // e.target.result 来获取文件的格式
            $(&quot;#fileText&quot;).text(e.target.result);
        }


三、FormData() 对象

    FormData()可以异步上传二进制文件, 只能传文件、图片的二进制等

    &lt;form&gt;表单的enctype属性有三个值:

        1、application/x-www-form-urlencoded: 用来设置表单传输，默认也是这个值，所以form中不写enctype属性也是按这个默认去传的

        2、multipart/form-data: 用来传输图片或MP3等文件, 会以request payload提交数据

        3、text/plain: 用于传输文本，邮件用此编码        

    API:
        1、创建FormData , var formData = new FormData(&apos;表单名&apos;)

        2、get(key): 获取存储的字段的值

        3、append(key, value): 存储字段

        4、set(key, value): 修改值

        5、has(key): 判断是否存已经有了key

        6、delete(key): 删除数据

        7、formData.entries(): 遍历FormData

        8、next(): 遍历时所用下一个节点数据，如果没有返回undefined

        9、发送数据: 通过XHR

            var xhr = new XMLHttpRequest();
            xhr.open(&apos;post&apos;, &apos;login&apos;);
            xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);
            xhr.send(formData);

    Example:

        &lt;form id=&quot;upFileForm&quot; method=&quot;post&quot; enctype=”multipart/form-data”&gt;
            &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;upFile&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;upFile&quot; value=&quot;上传&quot;&gt;
        &lt;/form&gt;

        &lt;script&gt;                
            let from = document.querySelector(&apos;#upFileForm&apos;)[0];
            let uploadFile = document.querySelector(&quot;#upFile&quot;);
            let formData = new FormData(from);

            formData.append(&apos;file&apos;, uploadFile.files[0]);
            console.log(formData)

            $.ajax({
                url: &apos;/remittanceDetail/import&apos;,
                type: &quot;post&quot;,
                data: formData,
                processData: false,     // 告诉jQuery不要去处理发送的数据
                  contentType: false,     // 告诉jQuery不要去设置Content-Type请求头
                success: function(res) {
                    console.log(&apos;err&apos;, res)
                },
                error: function(res){
                    if(res == 0){
                        console.log(&apos;err&apos;, res) 
                    }
                    console.log(&apos;err&apos;, res)                      
                }
            });
        &lt;/script&gt;

    https://segmentfault.com/a/1190000002680797
    https://segmentfault.com/a/1190000006716454
    http://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html
</code></pre><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><pre><code>ArrayBuffer是一段连续的长度固定的字节序列，如：通过实例化ArrayBuffer对象在内存中创建一段二进制存储空间（或叫二进制缓冲区），

// 创建一段字节长度为8的内存空间
var buffer = new ArrayBuffer(8);
// 获取字节长度
console.log(buffer.byteLength); // 8
</code></pre><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><pre><code>处理对二进制的方法，通过Blob来操作二进制数据

var abc = new ArrayBuffer(80);        // ArrayBuffer ES6用来在内存中存一段二进制数据
var blob = new Blob([abc], {type: &apos;text/plain});

方法:

1、slice(): 将大文件分片，用于分片上传

https://www.cnblogs.com/hhhyaaon/p/5928152.html
https://github.com/eligrey/FileSaver.js
</code></pre><h4 id="拖放API"><a href="#拖放API" class="headerlink" title="拖放API"></a>拖放API</h4><pre><code>拖放过程由两个部分构成:

    被拖拽的元素，之后简称为子项（item）
    放置被拖拽元素的元素，之后简称为容器（container）

1、draggable属性: 将想要拖放对象元素加入引属性设置为true

2、拖放事件: 

    子项事件: 
        1）dragstart - 拖拽开始

        2）drag - 拖拽过程中不断触发

        3）dragend - 拖拽结束，无论有没有拖进容器（ 鼠标松开就触发 ）

    容器事件:
        1）dragenter - 子项进入容器范围

        2）dragover - 子项在容器范围内不断触发

        3）dragleave - 子项离开容器范围

        4）drop - 拖拽结束，且子项成功拖进容器


    Example:
        &lt;script&gt;
            var oBox = document.querySelector(&apos;#box&apos;);            // 容器
            var oDragBlcok = document.querySelector(&apos;#dragBlcok&apos;);    // 拖拽块

            oDragBlcok.addEventListener(&apos;dragstart&apos;, function(e){
                e.dataTransfer.setData(&apos;name&apos;, &apos;siguang&apos;);
            })

            oDragBlcok.addEventListener(&apos;dragend&apos;, function(e){
                var name = e.dataTransfer.getData(&apos;name&apos;);
                console.log(name);
            })    
        &lt;/script&gt;


3、拖拽事件对象

    e.dataTransfer: 拖拽文件的信息

        files: FileList对象，相当于input的type=&quot;file&quot;的内容

            astModified:1494234931000
            lastModifiedDate:
            Mon May 08 2017 17:15:31 GMT+0800 (CST)
            name:&quot;chongwutupianxiaotuxiaom.jpg&quot;
            size:20926type:&quot;image/jpeg&quot;
            webkitRelativePath:&quot;&quot;


4、DataTransfer对象: 拖拽时需要传递一些数据，DataTransfer就可以来对数据进行传输，绑定在拖放事件的Event中

    1）dataTransfer.items: 一个数据集合

    2）dataTransfer.setDragImage(element, x, y): 拖拽过程中定义一个元素替换原有的，可以看到拖拽元素跟随的效果。

    3）dataTransfer.setData(key, val): 添加自定义数据

    4）dataTransfer.getData(key): 获取自定义数据

    5）dataTransfer.clearData(): 清除自定义数据

    6）dataTransfer.getData(format): 播放文件列表
</code></pre><h4 id="离线应用"><a href="#离线应用" class="headerlink" title="离线应用"></a>离线应用</h4><pre><code>在没有网络的情况下，可以使用本地缓存的离线数据也可以使web应用运行进来

1、离线与缓存的区别

    两都都是为了更好的缓存各种文件以提高读取速度，两者对网络环境有要求: 

    1、网页缓存依赖有网络的情况，离线应用在离线下仍然可用

    2、网页缓存主要缓存当前页面的内容，离线应用是缓存的指定文件，在离线状态下仍可以访问


2、manifest（[ˈmænəˌfɛst]显示）文件

    通过manifest文件来管理哪些文件需要缓存

    设置完后所有本地缓存的文件存储到Application Cache中，如果段网时在Network中查看缓存的文件为（from cache）

    offline.manifest:
        CACHE MANIFEST // 必要，把文件的作用告诉给浏览器，让文件支持text/cache-manifest
        #Version 1.0
        CACHE:  // chche，指定需要被缓存的资源，浏览器会对这些设置的资源
            index.html  
            style.css
            images/2.jpg
            default.js

        NETWORK:    // 指定不进行缓存的资源，如果为“*”通配符，表示所有资源都不被缓存
            # 1.jpg
            images/1.jpg            

        FALLBACK:             // 每行指定两个资源，如果
            /js/test/index.html   /js/test/404.html


3、需要在html页面中的&lt;html&gt;标签加入manifest=&quot;offline.manifest&quot;

    &lt;html lang=&quot;en&quot; manifest=&quot;offline.manifest&quot;&gt;


4、applicationCache对象

    1）检测是否支持离线应用

        if(window.applicationCache){
            // 支持
        }

    2）属性: 

        applicationCache.status返回: 离线缓存状态
            0: 无缓存
            1: 闲置
            2: 检查中
            3: 下载中
            4: 更新完成
            5: 废弃

    3）事件: 
        checking: 检查缓存更新时；
        error: 检查更新或下载资源时发声错误
        noupdate: 描述文件无变化
        downloading: 开始下载应用缓存资源
        progress: 下载缓存资源过程中
        updateready: 下载完毕
        cached: 应用缓存完整可用时

        applicationCache.addEventListener(&apos;updateready&apos;, function(){  // 资源下载中  }, false)

    4）applicationCache.update(): 让离线缓存检查更新上面的事件


5、检测是否有网络 online 和 offline

    // navigator.onLine如果设置为true表示能上网
    if (navigator.onLine) {
        // statement if online
    } else {
        // statement if offline
    }

    // 侦听当网络变化的时候触发
    window.addEventListener(&apos;online&apos;, function(){
        console.log(&apos;在线&apos;);
    }, false);

    window.addEventListener(&apos;offline&apos;, function(){
        console.log(&apos;离线&apos;);
    }, false);
</code></pre><h4 id="postMessage-跨文档消息传输"><a href="#postMessage-跨文档消息传输" class="headerlink" title="postMessage() 跨文档消息传输"></a>postMessage() 跨文档消息传输</h4><pre><code>HTML5来进行两个不同跨域的页面来消息传递（iframe不同域）

1、postMessage(&apos;发送数据&apos;, 要发送到的URL): 发送消息

2、message: 事件来接收消息，其中event对象

    evt.origin: 发送消息所在的域

    evt.data: 接收到的数据

    evt.source: 向来源可以在回执信息


Example:

    &lt;iframe id=&quot;myframe&quot; src=&quot;originPage.html&quot;&gt;&lt;/iframe&gt;
    &lt;button id=&quot;sendBtn&quot;&gt;发送消息&lt;/button&gt;

    &lt;script&gt;

        // 接收originPage.html页面消息
        window.addEventListener(&apos;message&apos;, function(evt){

            // ev.origin 获取消息的URL，如果不是taobao就不执行
            if(ev.origin != &quot;http://www.taobao.com&quot;){
                return false;
            }

            // ev.data 传输的数据
            alert(&quot;那里传来的消息: &quot; + ev.data)

        }, false);

        // 向originPage.html页面 发送消息
        var oSendBtn = document.querySelector(&apos;#sendBtn&apos;);
        oSendBtn.onclick = function(){
            var iframWindow = document.querySelector(&apos;#myframe&apos;);

            // postMessage()
            iframWindow.postMessage(&quot;A secret&quot;, &quot;http://www.w3cmm.com&quot;);        // window.parent.postMessage(data,&apos;*&apos;);
        }    

    &lt;/script&gt;


iframe的父子窗口操作:

    iframe获取父窗体的元素: window.parent.xxxx

        如果iframe嵌套多层，直接获取最顶层的窗体 window.top.xxxx

    父窗体获取iframe内的元素: oIfr.contentWindow.document.body.offsetHeight
</code></pre><h4 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h4><pre><code>webScoket提供了浏览器和服务器之间的长链接通信，只有一方提出断开socket才会断开，否则使终链接状态

传统使用Ajax轮询来定时获取服务器的数据，缺点是每隔一断时间就需要请求一次服务器，都需要创建一次TCP和断开一次TCP连接，HTTP请求，会对服务器有压力，
使用webScoket就可以省去连接的步聚，客户端可以一直侦听服务器端推送的数据来进行处理就可以了.

创建WebSocket对象 var oWebSocket = new WebSocket(&apos;ws://192.168.1.1:8005/socket&apos;);

属性: 
    1、readyState: 获取socket的状态 [&quot;正在连接&quot;, &quot;已建立连接&quot;, &quot;正在关闭连接&quot;, &quot;已关闭连接&quot;]

方法: 
    1、send(data): 向服务器发送数据

    2、close(): 关闭socket连接


事件: 
    1、onmessage(): 接收服务器发送的消息

    2、onopen(): 侦听打开socket

    3、onclose(): 侦听关闭socket时

示例: 
    &lt;script&gt;
         var statusArr = [&quot;正在连接&quot;, &quot;已建立连接&quot;, &quot;正在关闭连接&quot;, &quot;已关闭连接&quot;];

        var oSocket = new WebSocket(&quot;ws//www.baidu.com:8089&quot;);            // 必须使用ws或wss开头

        // 侦听socket打开事件
        oSocket.onopen = function(evt){
            console.log(statusArr[oSocket.readyState]);
        }

        // 侦听socket关闭
        oSocket.onclose = function(evt){
            console.log(statusArr[oSocket.readyState]);
        }

        // 侦听接收服务器端传来的数据
        oSocket.onmessage = function(evt){
            var data = evt.data;
            console.log(data);
        }

        // 向服务器发送数据
        $(&quot;#box&quot;).click(function(){
            oSocket.send(&quot;向服务器发送数据&quot;)
        })

        // 断开与服务器的socket连接
        $(&quot;#close&quot;).click(function(){
            oSocket.close();
        })
    &lt;/script&gt;
</code></pre><h4 id="本地存储-localStorage、sessionStorage"><a href="#本地存储-localStorage、sessionStorage" class="headerlink" title="本地存储 localStorage、sessionStorage"></a>本地存储 localStorage、sessionStorage</h4><pre><code>本地存储与cookie的区别

    cookie: 存储量比较少（浏览器不同，大致4k），有个数限制，会随请求发送到服务器

    localStorage: 永久存储，每个域存储（5MB，浏览器不同），总体数量无限制

    sessionStorage: 只在session内有限，存储没有限制

方法: 
    1、setItem(key, value): 保存数据

    2、getItem(key): 获取数据

    3、clear(): 清空存储中的所有数据

    4、removeItem(key): 删除存储中的一项

    5、key(n): 返回存储中的第n个键名

    length: 返回存储数量

监听: 
    window.addEventListener(&apos;storage&apos;, showStorageEvent, false);
</code></pre><h4 id="web-Workers-多线程"><a href="#web-Workers-多线程" class="headerlink" title="web Workers 多线程"></a>web Workers 多线程</h4><pre><code>js是单线程，页面有大量计算就很容易阻塞页面的执行，H5可以使用web workers来处理.

创建web workers对象:  new Worker(&apos;work.js&apos;);

方法: 
    1、postMessage(data): 向web workers传送数据

事件: 
    1、onmessage(): 监听处理完发送的数据

    2、onerror(): 错误时处理的事件

Example: 

    main.js: 
        var oWorker = new Worker(&apos;js/worker.js&apos;);
        oWorker.postMessage(1000000);    // 发送要处理的数据
        oWorker.onmessage = function(ev){
            var od = ev.data;            // 接收处理完的值
        }

    worker.js
        onmessage = function(ev){    // 侦听传来的数据
            var od = ev.data;
            var num = 20;
            for(var i=0; i&lt;od; i++){
                num *= i;
            }
            postMessage(num);        // 多处理处理完返回的数据
        }


注意: 
    1、多线程必须要在服务环境下进行开发，否则会报错   
    2、处理线程的JS文件，没有window，document，DOM等对象。但是可以使用navigator，location，XMLHttpRequest等对象。
        这些限制导致了Web Worker一般用于有耗时较长的业务中，比如有大量计算的页面
</code></pre><h4 id="Geoloation-地理位置"><a href="#Geoloation-地理位置" class="headerlink" title="Geoloation 地理位置"></a>Geoloation 地理位置</h4><pre><code>处于安全考虑，地理位置信息属于用户隐私，当浏览器获取设备信息需要得到用户的确认

检测是否可以使用:

    if(navigator.geoloation){
        // 支持地址位置信息
    }

一、Geoloation方法: 

    1、getCurrentPosition(      // 首次取得当前地理位置
            function(position){
                // 返回坐标回调 position对象
                pos.latitude
            },
            function(error){
                // 错误显示
            },
            {对象用来处理如何获取位置}
        }

    2、watchPosition(): 监听不断变化的移动设备，原理与steInterval差不多，用法与getCurrentPosition一样也是三个参数

    3、clearWatch(): 删除监听watchPosition()

    Example:
        navigator.geoloation.getCurrentPosition(function(pos){
            // pos.coords.latitude;        // 当前纬度
        })


二、position对象: 获取地理位置成功后返回position对象

    属性: 
        1、latitude: 纬度

        2、longitude: 经度

        3、altitude: 海拔

        4、accuracy: 纬度或纬度的精度（以米为单位）

        5、altitudeAccurancy: 获取到海拔高度的精度（以米为单位）

        6、heading: 设备前进方向，以旋转角度来表示

        7、speed: 设备前进的速度（以米/秒为单位）

        8、timestamp: 获取地理位置信息的时间

    错误返回三种值: 1 = 用户拒绝了位置服务、 2 = 获取不到位置信息、3 = 获取信息超时错误

    timeout: 几秒后获取不到返回失败

    maxmumAge: 对地理位置 进行缓存的有效时间（毫秒）

    Example:
        &lt;script&gt;
            var oBox = getId(&quot;box&quot;);
            var sHtml = [];

            function getId(id){
                return document.getElementById(id);
            }

            function successFun(position){
                console.log(&quot;地理位置是: &quot; +position.coords.latitude+&quot;，&quot;+position.coords.longitude);
            }

            function errorFun(err){
                // console.log(err.message); // 错误信息
                // console.log(err.code);    // 错误码

                switch(err.code){
                    case 1:
                        alert(&quot;用户拒绝了位置服务&quot;);
                        break;
                    case 2:
                        alert(&quot;获取不到位置信息&quot;);
                        break;
                    case 3:
                        alert(&quot;获取信息超时错误&quot;);
                        break;
                }
            }

            // 创建geolocation对象
            function createGeolocation(){
                if(navigator.geolocation){  // 标准浏览器支持

                    // 获取坐标
                    navigator.geolocation.getCurrentPosition(successFun, errorFun, {
                        // 设置缓存有效时间为2分钟
                        maximumAge : 60*1000*2,

                        // 5秒内未获取到地理位置则返回错误
                        timeout : 10000
                    })
                }
                else{
                    alert(&quot;你使用的是非标准浏览器&quot;);
                }
            }

            createGeolocation();
        &lt;/script&gt;

http://www.alloyteam.com/2015/08/mobile-phone-location-on-the-sensor/
</code></pre><h4 id="Video-和-audio-多媒体"><a href="#Video-和-audio-多媒体" class="headerlink" title="Video 和 audio 多媒体"></a>Video 和 audio 多媒体</h4><h4 id="canvas绘图"><a href="#canvas绘图" class="headerlink" title="canvas绘图"></a>canvas绘图</h4><h4 id="History-历史管理"><a href="#History-历史管理" class="headerlink" title="History 历史管理"></a>History 历史管理</h4><pre><code>可以在添加一条记录到历史记录的列表中，或者在没有刷新时，可以更新地址栏的URL。单页面的的跳转就用到了这里

例Vue的路由有两种模式: hash和history, history就用到了历史管理，使url改变不会去请求http

一、JS对象

    1、length: 浏览器历史列表url的数量

    2、back(): 向后一个url

    3、forward(): 向前一个url

    4、go(-1): 指定跳转到哪个历史


二、HTML5提供两个新方法: 

    可以通过新增的方法做到页面跳转不重新请求页面

    1、history.state: 当前url下对应状态信息，如果当前url不是通过pushState或replaceState添加的, state 

    2、history.pushState(state, title, url): 在不刷新页面的情况下，添加历史记录，可以前进和后退

        state: 存储JSON字符串

        title: 浏览器不支持设置null

        url: 更新浏览器的地址

    3、history.replaceState(): 与pushState基本上同，不同的是不可以前进和后退

    4、popstate 事件: 侦听前进和后退

    Example:

        window.addEventListener(&apos;popstate&apos;, function(e){
            getContent(location.pathname, false);
        })

        var getContent=(url, addEnter) =&gt; {
            $.get(url, function(dat){
                history.pushState(null, null, url)
            })
        }

https://segmentfault.com/a/1190000002468274
http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/
http://www.cnblogs.com/flash3d/archive/2013/10/23/3384823.html
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/移动端的那些积累/">移动端的那些积累</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/移动端的那些积累/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/移动端积累/">移动端积累</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="移动端特性"><a href="#移动端特性" class="headerlink" title="移动端特性"></a>移动端特性</h4><pre><code>手机端的web页(H5)

跨平台（手机端、PC端）

基于webview
</code></pre><h4 id="webkit-常用属性"><a href="#webkit-常用属性" class="headerlink" title="-webkit- 常用属性"></a>-webkit- 常用属性</h4><pre><code>http://ued.ctrip.com/webkitcss/   整理的webkit属性集合

&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalabel=no&quot;&gt;

1、-webkit-appearance: none;     // 用于移IOS下移除原生样式

2、text-size-adjust: 100%;       // webkit内核浏览器可以让终端字体小于12px

    iPhone 和 Android 的浏览器纵向和橫向时自动调整字体大小的功能。通过 text-size-adjust 设为 none 或者 100% 关闭字体大小自动调整功能.
    html {
        font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, Arial, sans-serif;
        -ms-text-size-adjust: 100%;
        -webkit-text-size-adjust: 100%; 
    }

3、overflow-scrolling  硬件加速, 在body中设置

    body {
        /*height: 100%;*/
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch; 
    }

4、tap-highlight-color  用户点击iOS的Safari浏览器中的链接或JavaScript的可点击的元素时，覆盖显示的高亮颜色

    a {
        -webkit-tap-highlight-color: transparent;
    }

5、touch-callout  当触摸并长按住的时候，禁止或显示系统默认菜单

    a {
        -webkit-touch-callout: none
    }

    window.ontouchstart = function(e) {
        if (e.target.tagName === &apos;img&apos;)
                    e.preventDefault();
    }

6、pointer-events:none;
</code></pre><h4 id="viewport-视图"><a href="#viewport-视图" class="headerlink" title="viewport 视图"></a>viewport 视图</h4><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;

width - 设置viewport宽度，为一个正整数，或字符串‘device-width’

height - 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置

initial-scale - 默认缩放比例，为一个数字，可以带小数

minimum-scale - 允许用户最小缩放比例，为一个数字，可以带小数

maximum-scale - 允许用户最大缩放比例，为一个数字，可以带小数

user-scalable - 是否允许手动缩放
</code></pre><h4 id="不同屏幕的适配方案"><a href="#不同屏幕的适配方案" class="headerlink" title="不同屏幕的适配方案"></a>不同屏幕的适配方案</h4><pre><code>通过响应式技术，在不同设备上使用同一套代码来展示

1、设置@media      2、rem       3、vw/vh

一、@media 媒体查询 

    @media screen and(min-width: 500px){    // 大于500px执行下面代码
            ...
    }

二、rem

    rem会根据根元素&lt;html&gt;的fontSize的大小来变化，需要运用js来计算根据屏幕宽度或来计算html的赋值

    1、普通CSS写法

        html { font-size: 16px; }
        div { width: 2rem; }

    2、Sass的工程: 

        前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即: 
        @function px2rem($px){
            $rem : 37.5px;
            @return ($px/$rem) + rem;
        }

        调用
        height: px2rem(90px);
        width: px2rem(90px);

三、vw、vh

    上面两种不是特别完美，媒体查询不能做到等比例响应，rem需要js与css耦合在一起，而且vw/vh就不需要

    计算vm方法: 16 / 750 * 100 = 2.13vw;        // 16是px转rem的值，750

        html {
            font-size: 2.13vw;
        }

    vw: 视窗的宽度，视窗的宽度是100vw

    vh: 视窗的高度，视窗的高度是100vh

    vmin: 选取vw和vh中最小的那个

    vmax: 选取vw和vh中最大的那个

https://zhuanlan.zhihu.com/p/23968868
https://juejin.im/entry/59b00e46f265da2491513bcc
</code></pre><h4 id="移动端概念"><a href="#移动端概念" class="headerlink" title="移动端概念"></a>移动端概念</h4><pre><code>一、物理像素: 物理像素是屏幕的实际尺寸

二、设备独立像素: 设备像素与CSS像素之间的关系

三、设备像素比 dpr: 设备像素比 = 物理像素 / 设备独立像素;

    js获取设备像素比: window.devicePixelRatio        // devicePixelRatio = 物理像素 / 实际像素;

    iphoneX是3倍屏，其它都是2倍屏

    retina屏是超高像素密度屏，同样大小的屏幕上显示的像素点由1个变为多个，同样苹果设备的retina屏中，像素点1个变为4个

    1、根据不同的设备像素比来加载不同的图片

        // 例如图片宽高为: 200px*200px，那么写法如下
        .css{ width:100px;height:100px;background-size:100px 100px; }

        // 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px
        .css{ font-size:20px }

        // image-set设计Rentina背景图
        image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。
        .css {
            background: url(images/bg.jpg) no-repeat center;
            background: -webkit-image-set(
            url(images/bg.jpg) 1x,     //支持image-set普通屏
            url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan
        }

        // javscript的解决方案
        $(document).ready(function(){
            if (window.devicePixelRatio &gt; 1) {
                var lowresImages = $(&apos;img&apos;);

                images.each(function(i) {
                    var lowres = $(this).attr(&apos;src&apos;);
                    var highres = lowres.replace(&quot;.&quot;, &quot;@2x.&quot;);
                    $(this).attr(&apos;src&apos;, highres);
                });
            }
        });

    https://www.jianshu.com/p/c88e9489b583

四、设置不同像素比的响应样式

    /* 2倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 2.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
        }
    }

    /* 3倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 3.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
        }
    }
</code></pre><h4 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h4><pre><code>1、空白页基本meta标签

    &lt;!-- 设置缩放 --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;

    &lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注: IOS7.0版本以后，safari上已看不到效果） --&gt;
    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;

    &lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;
    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;

    &lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;
    &lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;


2、其他meta标签

    &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;
    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;

    &lt;!-- 避免IE使用兼容模式 --&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;

    &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;
    &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;

    &lt;!-- 微软的老式浏览器 --&gt;
    &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;

    &lt;!-- uc强制竖屏 --&gt;
    &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;

    &lt;!-- QQ强制竖屏 --&gt;
    &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;

    &lt;!-- UC强制全屏 --&gt;
    &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;

    &lt;!-- QQ强制全屏 --&gt;
    &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;

    &lt;!-- UC应用模式 --&gt;
    &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;

    &lt;!-- QQ应用模式 --&gt;
    &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;

    &lt;!-- windows phone 点击无高光 --&gt;
    &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre><h4 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h4><pre><code>一、dns-prefetch 预加载

    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://g.alicdn.com&quot;&gt;

    dns-prefetch, DNS解析往往导致了网站加载速度慢。现代浏览器针对这个问题开发了处理方式，它将域名缓存后，当用户点击其它页面地址后自动的获取


二、prefetch 连接网页预先加载

    当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用。prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。

    &lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;

三、preconnect 

    和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）

    &lt;link rel=&quot;preconnect&quot; href=&quot;http://css-tricks.com&quot;&gt;


http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/
</code></pre><h4 id="打电话发短信写邮件怎么实现"><a href="#打电话发短信写邮件怎么实现" class="headerlink" title="打电话发短信写邮件怎么实现"></a>打电话发短信写邮件怎么实现</h4><pre><code>一、打电话

    &lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;

二、发短信，winphone系统无效

    &lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;

三、写邮件

    // 注: 在添加这些功能时，第一个功能以&quot;?&quot;开头，后面的以&quot;&amp;&quot;开头

    1.普通邮件
    &lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）
    &lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;

    3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）
    &lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址
    &lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    5.包含主题，用?subject=
    &lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;

    6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 
    &lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;

    7.内容包含链接，含http(s)://等的文本自动转化为链接
    &lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;

    8.内容包含图片（PC不支持）
    &lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;

    9.完整示例
    &lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;
</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>一、美化表单元素

    // 使用appearance改变webkit浏览器的默认外观
    input,select { -webkit-appearance:none; appearance: none; }

    // winphone下，使用伪元素改变表单元素默认外观
    1、禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰
            select::-ms-expand { display:none; }

    2、禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰
            input[type=radio]::-ms-check,
            input[type=checkbox]::-ms-check { display:none; }

    3、禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰
            input[type=text]::-ms-clear,
            input[type=tel]::-ms-clear,
            input[type=number]::-ms-clear { display:none; }


二、其它实用的css

    1、去掉webkit的滚动条——display: none;
            // 其他参数
            ::-webkit-scrollba //滚动条整体部分
            ::-webkit-scrollbar-thumb   //滚动条内的小方块
            ::-webkit-scrollbar-track   //滚动条轨道
            ::-webkit-scrollbar-button  //滚动条轨道两端按钮
            ::-webkit-scrollbar-track-piece  //滚动条中间部分，内置轨道
            ::-webkit-scrollbar-corner       //边角，两个滚动条交汇处
            ::-webkit-resizer            //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件

    2、禁止长按链接与图片弹出菜单
            a,img { -webkit-touch-callout: none }    

    3、禁止文字复制
            html,body {-webkit-user-select:none; user-select: none; }

    4、改变输入框placeholder的颜色值
            ::-webkit-input-placeholder { /* WebKit browsers */color: #999; }
            :-moz-placeholder { /* Mozilla Firefox 4 to 18 */color: #999; }
            ::-moz-placeholder { /* Mozilla Firefox 19+ */color: #999; }
            :-ms-input-placeholder { /* Internet Explorer 10+ */color: #999; }
            input:focus::-webkit-input-placeholder{ color:#999; }

    5、android上去掉语音输入按钮
            input::-webkit-input-speech-button {display: none}

    6、阻止windows Phone的默认触摸事件
            /*说明: winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如: */
            html { -ms-touch-action:none; } //禁止winphone默认触摸事件

            取消input在ios下，输入的时候英文首字母的默认大写
            &lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;

    7、手机拍照和上传图片
            // IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持
            &lt;input type=&quot;file&quot; accept=&quot;images/*&quot; /&gt;
            &lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;
</code></pre><h4 id="播放视频不全屏"><a href="#播放视频不全屏" class="headerlink" title="播放视频不全屏"></a>播放视频不全屏</h4><pre><code>&lt;!--
        1.ios7+支持自动播放
        2.支持Airplay的设备（如: 音箱、Apple TV)播放
        x-webkit-airplay=&quot;true&quot; 
        3.播放视频不全屏
        webkit-playsinline=&quot;true&quot; 
--&gt;
&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt;
</code></pre><h4 id="bug修改"><a href="#bug修改" class="headerlink" title="bug修改"></a>bug修改</h4><pre><code>android 2.3 bug
// 1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉
// 2.after和before伪类无法使用动画animation
// 3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值
// 4.translate百分比的写法和scale在一起会导致失效，例如: 
-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)

android 4.x bug
// 1.三星 Galaxy S4中自带浏览器不支持border-radius缩写
// 2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分
// 3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色
// 4.android无法同时播放多音频audio

一、消除transition闪屏
    .css {
        -webkit-transform-style: preserve-3d;
        -webkit-backface-visibility: hidden;
        -webkit-perspective: 1000;
    }

二、开启硬件加速

    //目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。
    .css {
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
    }

三、渲染优化

    1、禁止使用iframe（阻塞父文档onload事件）

    2、禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）

    3、使用CSS3代码代替JS动画

    4、开启GPU加速

    5、使用base64位编码图片(不小图而言，大图不建议使用),以减少网络请求。比较耗费CPU。小图标优势在于: 减少HTTP请求、避免文件跨域、修改及时生效
</code></pre><p>—————————– 移动端的JS ——————————–</p>
<h4 id="移动端touch事件（区分webkit和winphone）"><a href="#移动端touch事件（区分webkit和winphone）" class="headerlink" title="移动端touch事件（区分webkit和winphone）"></a>移动端touch事件（区分webkit和winphone）</h4><pre><code>一、当用户手指放在移动设备在屏幕上滑动会触发的touch事件

    1、以下支持webkit

        touchstart: 当手指触碰屏幕时候发生。不管当前有多少只手指
        touchmove: 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生: 阻止页面滚动
        touchend: 当手指离开屏幕时触发
        touchcancel: 系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用

    2、TouchEvent对象 : 

        touches: 屏幕上所有手指的信息
        targetTouches: 手指在目标区域的手指信息
        changedTouches: 最近一次触发该事件的手指信息
        touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息

        event.changedTouches[0].clientX  获取移动端事件

    3、参数信息(changedTouches[0])

        clientX、clientY在显示区的坐标
        target: 当前元素

    4、事件响应顺序

        ontouchstart  &gt; ontouchmove  &gt; ontouchend &gt; onclick

    5、以下支持winphone 8

        MSPointerDown: 当手指触碰屏幕时候发生。不管当前有多少只手指
        MSPointerMove: 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生: 阻止页面滚动
        MSPointerUp: 当手指离开屏幕时触发


二、移动端的web页面click事件会产生200-300ms的延时响应

    移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。

    原因: 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。

            比如在点击一个&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;时，浏览器先捕获是单击还是双击缩放，所以捕获一次单击后，浏览器会hold一段时间来看是否有下一次点击，这个时间间隔就是300ms，这就是延时的由来，所以使用click来触发事件需要延时300ms后才生效

    解决方案: 
            fastclick可以解决在手机上点击事件的300ms延迟
            zepto的touch模块，tap事件也是为了解决在click的延迟问题
</code></pre><h4 id="屏幕旋转的事件orientationchange"><a href="#屏幕旋转的事件orientationchange" class="headerlink" title="屏幕旋转的事件orientationchange"></a>屏幕旋转的事件orientationchange</h4><pre><code>JS处理

    function orientInit(){
            var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight ? &apos;landscape&apos; : &apos;portrait&apos;;
            if(orientChk ==&apos;lapdscape&apos;){
                    //这里是横屏下需要执行的事件
            }
            else{
                    //这里是竖屏下需要执行的事件
            }
    }

    orientInit();
    window.addEventListener(&apos;onorientationchange&apos; in window?&apos;orientationchange&apos;:&apos;resize&apos;, function(){
            setTimeout(orientInit, 100);
    },false)    


CSS处理

    // 竖屏时样式
    @media all and (orientation:portrait){   }

    // 横屏时样式
    @media all and (orientation:landscape){   }
</code></pre><h4 id="audio元素和video元素在ios和andriod中无法自动播放"><a href="#audio元素和video元素在ios和andriod中无法自动播放" class="headerlink" title="audio元素和video元素在ios和andriod中无法自动播放"></a>audio元素和video元素在ios和andriod中无法自动播放</h4><pre><code>// 音频，写法一
&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;

// 音频，写法二
&lt;audio controls=&quot;controls&quot;&gt; 
        &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt;
        &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt;
        优先播放音乐bg.ogg，不支持在播放bg.mp3
&lt;/audio&gt;

// JS绑定自动播放（操作window时，播放音乐）
$(window).one(&apos;touchstart&apos;, function(){
        music.play();
})

// 微信下兼容处理
document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () {
        music.play();
}, false);

// 小结
// 1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常
// 2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间
</code></pre><h4 id="重力感应事件"><a href="#重力感应事件" class="headerlink" title="重力感应事件"></a>重力感应事件</h4><pre><code>// 运用HTML5的deviceMotion，调用重力感应事件
if(window.DeviceMotionEvent){
        document.addEventListener(&apos;devicemotion&apos;, deviceMotionHandler, false)
}   

var speed = 30;
var x = y = z = lastX = lastY = lastZ = 0;
function deviceMotionHandler(event){
    var acceleration = event.accelerationIncludingGravity;
    x = acceleration.x;
    y = acceleration.y; 
    z = acceleration.z;
    if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed ){
            //这里是摇动后要执行的方法 
            yaoAfter();
    }
    lastX = x;
    lastY = y;
    lastZ = z;
}

function yaoAfter(){
        //do something
}
</code></pre><h4 id="设备判断"><a href="#设备判断" class="headerlink" title="设备判断"></a>设备判断</h4><pre><code>一、JS判断设备

    function deviceType(){
        var ua = navigator.userAgent;
        var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];    
        for(var i=0; i&lt;len,len = agent.length; i++){
            if(ua.indexOf(agent[i])&gt;0){   
                return agent[i];     
                break;
            }
        }
    }
    deviceType();
    window.addEventListener(&apos;resize&apos;, function(){
        deviceType();
    })

二、JS判断微信浏览器

    function isWeixin(){
        var ua = navigator.userAgent.toLowerCase();
        if(ua.match(/MicroMessenger/i)==&apos;micromessenger&apos;){
            return true;
        }else{
            return false;
        }
    }
</code></pre><h4 id="前端动画的几种方式"><a href="#前端动画的几种方式" class="headerlink" title="前端动画的几种方式"></a>前端动画的几种方式</h4><pre><code>一、动画方式

    1、css3的transition 和 animattion

    2、定时器, 最原始的“window.setTimout()”或者“window.setInterval()” 不断更新元素的状态位置等来实现动画

    3、requestAnimationFrame方法

    4、canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现

    5、SVG、WebGL

二、requestAnimationFrame  注意 Android不支持此方法

    requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。

    设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。

    1、对requestAnimationFrame方法处理兼容:

        window.requestAnimFrame = (function(){
        return  window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element){
                                window.setTimeout(callback, 1000 / 60);
                        };
        })();

    2、Example

        &lt;div id=&quot;demo&quot; style=&quot;position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;&quot;&gt;&lt;/div&gt;
        &lt;script&gt;
                var demo = document.getElementById(&apos;demo&apos;);
                function render(){
                        demo.style.left = parseInt(demo.style.left) + 1 + &apos;px&apos;; //每一帧向右移动1px
                }
                var requestID = requestAnimationFrame(function(){
                        render();
                        //当超过300px后才停止
                        if(parseInt(demo.style.left) &lt;= 300) {
                                requestAnimationFrame(arguments.callee);        // arguments.callee调用函数本身，或者给函数一个名，参数传个名
                        }
                });

                // cancelAnimationFrame(requestID);      // 停止动画重绘
        &lt;/script&gt;

三、常用动画库

    Ani.js -- 基于CSS动画的生命处理库
    Dynamics.js -- 创建具有物理运动效果动画的js库
    Animate.css -- 齐全的CSS3动画库
    Three.js -- 让用户通过javascript入手进入搭建webgl项目的类库

    http://www.tuicool.com/articles/uUfYry
    http://www.jianshu.com/p/280e0ef90b96
</code></pre><h4 id="其它API"><a href="#其它API" class="headerlink" title="其它API"></a>其它API</h4><pre><code>一、querySelector()、querySelectorAll()

    获取元素 document.querySelector(&apos;#app&apos;);

二、window.devicePixelRatio 获取设备像素比，也叫做dpr

    这个属性是系统自动算出来的值返回给window.devicePixelRatio，公式就是

    // 比如ipone6 750px物理像素 / 375px设备像素，所以dpr为2，有这个属性不用我们就不用去算
    window.devicePixelRatio = 物理像素 / 设备独立像素;

三、getBoundingClientRect  js判断可视区域

    var htmlWidth = document.documentElement.getBoundingClientRect().width;     // html文档的宽度
    var top = document.documentElement.getBoundingClientRect().top;      // 元素顶端到可见区域顶端的距离
    var se = document.documentElement.clientHeight; // 浏览器可见区域高度。

四、document.documentElement、document.body

    document.body 获取body文档
    document.documentElement 获取HTML整个文档，从&lt;!DOCTYPE html&gt;开始

五、document.documentElement.getBoundingClientRect().width   获取html文档宽度

    获取文档可视区宽度

    问题
            document.body.clientWidth;   // 这里取的是body的宽度，如果body的宽度被改变
            window.innerWidth;      // 这里获取的是整个宽口的宽度，包括滚动条

    解决方法: document.documentElement.getBoundingClientRect().width
</code></pre><h4 id="fetch-新一代ajax"><a href="#fetch-新一代ajax" class="headerlink" title="fetch 新一代ajax"></a>fetch 新一代ajax</h4><pre><code>一、fetch的请求设置与响应

    fetch(&apos;/some/url&apos;, {
        method: &apos;get&apos;
    })
    .then(function(response) {
        // 成功
    })
    .catch(function(err) {
        // 出错了;等价于 then 的第二个参数,但这样更好用更直观 :(
    });


二、设置Header头

    fetch(&apos;https://www.baidu.com/search/error.html&apos;, {
        method: &apos;POST&apos;,
        headers: new Headers({
                &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;     // 指定提交方式为表单提交
        }),
        body: new URLSearchParams([[&quot;foo&quot;, 1],[&quot;bar&quot;, 2]]).toString()
    })
    .then((res)=&gt;{
        return res.text()
    })
    .then((res)=&gt;{
        console.log(res)
    })

fetch没有拦截请求和响应数据的功能，在单页面路由跳转时会需要提前去查看用户的一些登录信息，这时候需要使用Axios插件
</code></pre><h4 id="问题收集"><a href="#问题收集" class="headerlink" title="问题收集"></a>问题收集</h4><pre><code>一、keydown侦听输入个数时，中文输入法输入个数的问题 

        let username = document.querySelector(&apos;#username&apos;);

        // 如果输入中文，输入法比如输 &quot;物品&quot; 五笔需要输入 &quot;trkk&quot;，这样size为4，这样对中文判断长度会有问题
        $(&apos;#username&apos;).on(&apos;keydown&apos;, function(){
                let size = $(this).val().length;
                console.log(size);    
        })

        // 解决方法，侦听compositionend事件，返回的size正常
        $(&apos;#username&apos;).on(&apos;compositionend&apos;, function(){
                let size = $(this).val().length;
                console.log(size);  
        })

        http://www.alloyteam.com/2017/03/moves-the-input-box-fill-series-a/
        http://www.alloyteam.com/2016/12/alloytouch-full-screen-scroll-plugin-released-30-seconds-to-get-smooth-page-h5/


二、Retina屏1px边框处理

    高清屏，1px实际是2x2个像素来渲染，有的还是3x3，所以border: 1px 移动端会渲染为2px或3px

    &lt;div class=&quot;bor-box&quot;&gt;
            &lt;div class=&quot;bor-querymidea&quot;&gt;通过伪类创建边框，在通过媒体查询来适配&lt;/div&gt;
    &lt;/div&gt;

    解决方法

    1、通过-webkit-min-device-pixel-ratio 来确定两倍屏来修改边框大小

            .bor-querymidea{
                border: 1px #ccc solid;
            }

            /* 2倍屏 */
            @media only screen and (-webkit-min-device-pixel-ratio: 2.0){
                .bor-querymidea{
                    /* border: 0.5 #ccc solid;   retina屏是不识别0.5px，会解释为0 */
                    -webkit-transform: scaleY(0.5);
                    transform: scaleY(0.5);
                }
            }

            /* 3倍屏 */
            @media only screen and (-webkit-min-device-pixel-ratio: 3.0){
                .bor-querymidea{
                    -webkit-transform: scaleY(0.33);
                    transform: scaleY(0.33);
                }
            }

        2、js判断如果devicePixelRation的值

            devicePixelRation = 2; 输出viewport: &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;

            devicePixelRatio = 3; 输出 &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.333, maximum-scale=0.333, minimum-scale=0.333, user-scalable=no&quot;&gt;

        https://www.jianshu.com/p/7e63f5a32636          // 7咱方法


三、设置viewport 缩放比例

    (function(doc, win) {
        var scale = 1.0;
        if (win.devicePixelRatio === 2) {
            scale *= 0.5;
        }
        if (win.devicePixelRatio === 3) {
            scale *= 0.333333;
        }
        var text = &apos;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale +&apos;, minimum-scale=&apos; + scale + &apos;, width=device-width, user-scalable=no&quot; /&gt;&apos;;
        doc.write(text);       
    })(document, window);

    https://www.cnblogs.com/stella1024/p/7199832.html
</code></pre><h4 id="收集工具"><a href="#收集工具" class="headerlink" title="收集工具"></a>收集工具</h4><pre><code>1、browsersync 多端浏览器同步测试工具  http://www.browsersync.cn/

2、lib-flexible 处理根据屏幕的尺寸将Html中的font-size的值自动转换  https://github.com/amfe/lib-flexible

3、sublime的px转rem的插件   https://github.com/flashlizi/cssrem
</code></pre><p>| <a href="http://www.uigreat.com/page/guifan" target="_blank" rel="noopener">http://www.uigreat.com/page/guifan</a>            // 移动端屏幕尺寸集合<br>| <a href="http://cubic-bezier.com/#.55,.01,.38,.99" target="_blank" rel="noopener">http://cubic-bezier.com/#.55,.01,.38,.99</a>         // 调节css3动画效果并导出代码<br>| <a href="https://segmentfault.com/a/1190000007075834" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007075834</a>   // Retina屏<br>| <a href="http://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=404009356&amp;idx=1&amp;sn=e3218b95b78a5f043e7b0e3df49703d3&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=404009356&amp;idx=1&amp;sn=e3218b95b78a5f043e7b0e3df49703d3&amp;scene=4#wechat_redirect</a><br>| <a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html</a><br>| <a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/#prettyPhoto" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/#prettyPhoto</a>  rem<br>| <a href="https://github.com/amfe/article/issues/17" target="_blank" rel="noopener">https://github.com/amfe/article/issues/17</a>     // 淘宝H5终端适配</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Précédent</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Suivant &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
