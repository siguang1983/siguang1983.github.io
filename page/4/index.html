<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/ES6/">ES6</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/ES6/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| let块级作用域、 const常量<br>| 解构赋值<br>| 箭头函数、default、rest、spread<br>| 模板字符串<br>| class: extends、super、constructor、静态属性和方法、实例属性<br>| Proxy 对象的拦截器<br>| Promise、Generator、async<br>| 模块化: import、export、as、*、default export<br>| 数据结构: Set不重复值的集合、Map<br>| symbol 独一无二的值</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><pre><code>一、let 声明变量

    let完全可以取代var, 特性: 1、let不允许重复声明        2、没有预解析功能        3、块级作用域

    1、预解析功能

        console.log(a);        // 报错, 如果是原来的var声明这里会是undeined, 所以let没有预解析功能
        let a = 20;

    2、块级作用域 在{ }中声明的变量只能在括号里使用

        var name = &apos;lulu&apos;;
        function prsone(){
            let name = &apos;siguang&apos;;
        }

        prsone();
        console.log(name);            // &apos;lulu&apos;

        // 输出的都是10
        for(var i=0; i&lt;10; i++){
            setTimeout(function(){
                console.log(i);        // 使用var声明的i都会打印出9，如果使用let输出的就是0到10
            })
        }

二、const常量

    1、常量只允许赋一次值不能被修改        2、常量声明都为大写        3、与let相当只在块级作用域有效

    const NAME = &apos;siguang&apos;;        // 不能变化的值
    NAME = &apos;lulu&apos;;                // 报错
</code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><pre><code>允许从数组和对象中提取的值，对变量进行赋值，被称为解构赋值

一、数组解构使用[]

    let [a, b, c] = [1,2,3];    // a=1, b=2, c=3

    # 默认值
    let [x, y = &apos;b&apos;] = [&apos;a&apos;];     // x=&apos;a&apos;, y=&apos;b&apos;


二、对象解构使用{}

    // 对象是按名字来解析赋值
    let obj = {
        getName: function(){}, 
        foo: &apos;aaa&apos;, 
        bar: &apos;bbb&apos;
    };
    let {foo, bar} = obj        // foo=&apos;aaa&apos;, bar=&apos;bbb&apos;

    // 对象的解构赋值，先找到同名，在将值赋给对应的变量
    let { foo: val, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };  
    console.log(val, bar)        // foo=&apos;undefined&apos;, val=&apos;aaa&apos;, bar=&apos;bbb&apos;


三、字符串的解构赋值

    const [a, b, c, d, e] = &apos;hello&apos;;    // a=h, b=e, c=l, d=l, e=o
    const [...tail] = &apos;hello&apos;;            // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]

    # length属性
    let {length: len} = &apos;hello&apos;;        // length = 5


四、默认参数 default

    # 参数作为数组
    function add([x, y]){
        return x * y
    }
    add([3,2]);        // 6

    # 参数作为对象，对x、y的默认初始值
    function move({x = 0, y = 0}) {
        return [x, y];
    }
    move({x: 3, y: 8}); // [3, 8] 


五、不定参数 Rest

    function f(x, ...y) {
        // y是一个数组
        return x * y.length;
    }
    f(3, &quot;hello&quot;, true) == 6


六、扩展运算符 Spread

    function f(x, y, z) {
        return x + y + z;
    }
    // 将数组中的每个元素展开为函数参数
    f(...[1,2,3]) == 6
</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>一、写到`...`之间，值的输出使用 ${...} 

二、可以写多行字符串，只写到`...`之间就可以

二、${...}可以解析变量、对象的值、表达式、函数返回

    let name = &apos;siguang&apos;;
    let obj = {
        age: 33
    }
    console.log(`你的名字是: ${ name } 你的年龄是:  ${ obj.age }`)

三、标签模板

    let a=10, b=20;
    dialog`Hello ${a+b} world ${a*b}`;        // 等同于 dialog()
</code></pre><h4 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h4><pre><code>一、箭头函数

    1、箭头函数的注意问题: 

        * 箭头函数里的this不是指向调用者，而指向对象
        * 不能当构造函数来用
        * 函数内不存在arguments对象
        * 不可以使用yield命令，箭头函数不能用作Generator函数

        arr.sort(function(){  ...  }) 相当于 arr.sort((a, b) =&gt; a-b);

        // 箭头函数的this，不是指向调用者
        const Template = {
            test(){
                console.log(this);        // this指向Template

                document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                    /* 如果非箭头函数this应该指向 #showThis */
                    /* 这里箭头函数不是指向调用者，所以指向了 Template */
                    console.log(this);    
                }
            }
        }
        Template.test();


    2、var f = function(v){
            return v;
        }

        // ES6写法
        var f = v =&gt; v;


    3、var sum = function(num1, num2){
            return num1 + num2;
        }

        // ES6写法
        var sum = (num1, num2) =&gt; {
            return num1 + num2;
        }


    4、对象中方法的简写

        var obj = {
            name: &apos;haha&apos;,
            getName(){                // 是getName: function(){}的简写
                console.log(this.name);
            },
            setName(name){
                this.name = name;
                console.log(this.name);
            }
        }


    5、参数的解构赋值

        const full = ({ first, last }) =&gt; first + &apos; &apos; + last;    
        full({first: 20, last: 30})

        // 等同于
        // function full(person) {
        //      return person.first + &apos; &apos; + person.last;
        // }        


    6、[1,2,3].map(function (x) {
            return x * x;
        });

        // ES6写法
        [1,2,3].map( (x) =&gt; x * x);


二、函数参数默认值

    function fn(a, b=2){
        // b如果不传相当于2，等同于 var b = arguments.length &gt; 1 &amp;&amp; arguments[1] == undefined ? arguments[1] : 2;
        return {a, b}
    }
    console.log(fn(10));        // 返回{a: 10, b: 2}

    // 如果没有参数默认值时还需要在函数体内做兼容
    function fn(name){
        var getName = name || 20;
    }
    fn();


三、rest 参数  获取多余参数

    以&apos;...变量名&apos; 来获取多余的参数，返回一个数组，这样就不需要arguments对象了

    function person(...rest){
        console.log(rest);        // [1,2,3,4,5]
    }
    person(1,2,3,4,5);

    function person(a, ...rest){
        console.log(a);            // 1
        console.log(rest);        // [2,3,4,5]
    }
    person(1,2,3,4,5);


四、spread 扩展操作符 ...  与rest相反

    function add(x, y) {
        return x + y;        // 4+38
    }
    var numbers = [4, 38];
    add(...numbers)         // 42


    # 可以将字符串转成数组
    let arr = [...&apos;hello&apos;];        // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]


五、name属性

    funciton foo(){ ... }
    foo.name;        // &apos;foo&apos; 返回函数名


六、绑定this

    箭头函数可以绑定this对象，减少显式this对象的写法(call、apply、bind)

    ES7提出了函数绑定来取代&quot;call、apply、bind&quot;调用，使用两个&quot;::&quot;

    Example

        foo::bar        // 等同于 bar.bind(foo)
</code></pre><h4 id="对象扩展-Object"><a href="#对象扩展-Object" class="headerlink" title="对象扩展 Object"></a>对象扩展 Object</h4><pre><code>一、简写

    1、对象属性和值相同可以写成一个

        var foo = { name: &apos;siguang&apos;};
        var baz = {
            foo            // 与 foo: foo 相同
        };
        console.log(baz.foo.name);    // siguang


    2、对象中函数的简写

        var o = {
            name: &apos;momo&apos;,
            getName(){            // 等同于 getName: function(){}
                retrun this.name;
            }
        }


    3、示例1 参数作为对象返回

        function f(x, y) {
            return {x, y};
        }

        // 等同于
        function f(x, y) {
            return {x: x, y: y};
        }
        f(1, 2) // Object {x: 1, y: 2}

    // 示例2 CommonJS模块输出变量
        const getItem = function(){ ... }
        const setItem = function(){ ... }
        const clear = function(){ ... }
        module.exports = { getItem, setItem, clear };

        // 等同于
        // module.exports = {
        //   getItem: getItem,
        //   setItem: setItem,
        //   clear: clear
        // };


二、[] 属性名表达式

    // 对象的属性名可以用&apos;[]&apos;字符串拼接
    var sex = &apos;男&apos;;
    var obj = {
        name: &apos;momo&apos;,
        [sex]: false,
        [&apos;get&apos;+&apos;Name&apos;](){
            console.log(this.name, this[&apos;男&apos;]);        // 返回 momo false
        }
    }

    obj.getName();


三、getter 赋值器、setter 取值器

    let cat = { 
        name: &apos;喵喵&apos;, 
        get name(){ return this.name },   
        set name(value){
            if(Object.prototype.toString.call(&apos;xxx&apos;) == &apos;[object String]&apos;){
                this.name += value
            }
        }
    }


四、Object.is(): 用于对比是否相等，相当于 === ，可以正确比较 -0和0，NaN和

    &apos;==&apos;与&apos;===&apos;的缺点:

        相等运算符（==）缺点: 自动转换数据类型
        和严格相等运算符（===）缺点: NaN不等于自身，以及+0等于-0

    Objetc.is(0, -0);        // false
    Object.is(NaN, NaN);    // true


五、Object.assign(全并目标对象， 被合并对象B, 被合并对象C): 合并到第一个参数上，不是深度拷贝，所以还存在引用关系

    /* 注意: 如果后面的对象与前面对象的属性相同会赋盖掉前面的对象的值 */

    var objA = {a: 1, b:2}, objB = {b: 3, c: 4}; 
    let req = Object.assign(objA, objB);         // {a:1, b:3, c:4}

    添加对象的方法: 
        Object.assign(SomeClass.prototype, {
            someMethod(arg1, arg2){
                // ...
            },
            anotherMethod(){
                // ...
            }
        })

        相当于
        SomeClass.prototype.someMethod = function(arg1, arg2){ // ... }
        SomeClass.prototype.anotherMethod = function(){ // ... }

    克隆对象: 
        function clone(obj){
            return Object.assign({}, obj);
        }


六、getPrototypeOf(object)、setPrototype(object, 谁的prototype): 获取、设置对象的prototype

    var Cat = function(name){
        this.name = name;
    }

    Cat.prototype.showName = function(){
        return this.name;
    }

    var c1 = new Cat(&apos;momo&apos;);
    c1.showName();

    console.log(Object.getPrototypeOf(c1))

    // 设置prototype
    var Person = function(nationality){
        this.nationality = nationality;
    }
    Person.prototype = {
        showNationality: function(){
            return this.nationality;
        }
    }
    Object.setPrototypeOf(c1, Person.prototype);
    console.log(Object.getPrototypeOf(c1));


七、keys()、values()

    获取对象的所有keys或所有值, 并返回一个数组

    var obj = {name: &apos;siguang&apos;, age: 33};
    console.log(Object.keys(obj));        // [name, age]
    console.log(Object.values(obj));    // [&apos;siguang&apos;, 33]


八、__proto__属性

    用来读取或设置当前对象的prototype对象

    var Person = function(name){
        this.name = name;
    }
    Person.prototype = {
        constructor: Person,
        getName(){
            console.log(this.name);
        }
    }
    var op = new Person(&apos;lulu&apos;);

    // 继承
    var PersonChilder = function(){}; 
    PersonChilder.__proto__ = op;
    var opc = new PersonChilder(); 
    console.log(opc.getName())


    增强的对象字面量

    // 通过对象字面量创建对象
    var human = {
        breathe() {
            console.log(&apos;breathing...&apos;);
        }
    };

    var worker = {
        __proto__: human, //设置此对象的原型为human,相当于继承human
        company: &apos;freelancer&apos;,
        work() {
            console.log(&apos;working...&apos;);
        }
    };

    human.breathe();//输出 ‘breathing...’

    //调用继承来的breathe方法
    worker.breathe();//输出 ‘breathing...’


九、遍历属性的方法

    1) for...in 循环

    2）Object.keys(obj): 返回obj对象的所有key, 返回是一个数组
</code></pre><h4 id="类、继承"><a href="#类、继承" class="headerlink" title="类、继承"></a>类、继承</h4><pre><code>一、类的一些特性

    1、对象方法的简写方法
        class Cat{
            getName(){        // 老写法 getName: function(){}

            }
        }

    2、通过__proto__属性可以直接调用父类
        var parent = {
            getParentName(){
                console.log(&apos;parent&apos;)
            }
        }

        var childer = {
            __proto__: parent,            // 通过__proto__指向parent, 就可以直接调用parent类中的方法
            getChildeName(){
                console.log(&apos;childer&apos;);
            }
        }

        childer.getChildeName();    // childer
        childer.getParentName();    // parent


二、创建类

    class Cat {

        // ES6中新型构造器, 用来初始化时这里接收参数
        constructor(name){ 
            this.name = name;
        }

        getName(){        // 公有方法
            console.log(this.name);
        }

        _bar(baz){        // 私有方法
            return this.sfn = baz;
        }
    }

    Cat.userName = &apos;siguang&apos;;

    var oCat = new Cat(&apos;哈哈&apos;);
    oCat.getName();


三、继承 extends

    // 创建一个类
    class Person {
        constructor(name){
            this.name = name;
        }

        getName(){
            console.log(this.name);
        }
    }

    // 继承这个类
    class Children extends Person {
        constructor(name, color){
            super(name);                // super指向继承的构造函数Person的constructor
            this.color = color;
        }

        getColor(){
            console.log(this.name, this.color);
        }
    }

    // 实例化
    var op = new Person(&apos;siguang&apos;);
    op.getName();        // output &apos;siguang&apos;

    var oc = new Children(&apos;lulu&apos;, &apos;red&apos;);        
    oc.getColor();        // output &apos;red&apos;
    oc.getName();        // output &apos;lulu&apos;


四、static 静态属性和方法

    类似构造函数，直接挂载到函数下的叫对象的属性和方法，而写到构造函数内部的叫构造函数的属性和方法

    1、静态方法前面需要加上&apos;static&apos;关键字，相当于只是函数下的方法而不是prototype的方法，静态方法可以被子类继承，

        class Foo{
            static methodName(){
                return &apos;hello&apos;
            }
        }

        Foo.methodName();    // hello

        var foo = new Foo();
        foo.methodName();    // 报错

    2、静态属性

        ES6中没有静态属性，只能声明静态方法，ES7中可以直接写到类内在进行转码

        class Foo {
            constructor(...args) {
                this.args = args;
            } 
            outputUserName(){
                console.log(this.username);    // 这里username未定义，除非在constructor中定义 this.username
            }
        }
        Foo.username = &apos;siguang&apos;;       // 类的静态属性

        var foo = new Foo();
        console.log(foo.personName);    // undefined
        foo.outputUserName();   // undefined 


五、实例属性

    注意: 一定要将实例属性和静态属性区分，实例属性写到constructor中this.username, new后的实例时候可以被实例方法调用，而静态属性只挂到了类下直接通过类来调取，Foo.username

    class Foo{
        constructor(){
            this.username = &apos;siguang&apos;;
        }
        showName(){
            console.log(this.username);     // siguang
            console.log(Foo.username);      // lulu
        }
    }
    Foo.username = &apos;lulu&apos;;

    var foo = new Foo();
    foo.showName();

    ****** ES7 中静态属性和实例属性的定义 ******
    class MyClass{
        usernameA = &apos;siguang&apos;;        // 实例属性

        showName(){
            console.log(this.usernameA);
        }
    }


六、super()方法

    继承时必须调用super方法，否则constructor中的this为undefined，调用父类的构造器进行初始化, 子类调用父类的构造函数

    class BaseModel {
        constructor(options, data) { // class constructor，node.js 5.6暂时不支持options = {}, data = []这样传参
            this.name = &apos;Base&apos;;
            this.url = &apos;http://azat.co/api&apos;;
            this.data = data;
            this.options = options;
        }
        getName() { // class method
            console.log(`Class name: ${this.name}`);
        }
    }

    class AccountModel extends BaseModel {
        constructor(options, data) {
            super({private: true}, [&apos;3333&apos;, &apos;4444&apos;]); 
            this.name = &apos;Account Model&apos;;
            this.url +=&apos;/accounts/&apos;;
        }
        getAccountsData() {
            return this.data;
        }
    }

    let accounts = new AccountModel(5);
    accounts.getName();         // Account Model
    console.log(&apos;Data is %s&apos;, accounts.getAccountsData);        // {private: true}

    let base = new BaseModel({public: true}, [&apos;111&apos;, &apos;2222&apos;]);
    console.log(base.getName());        // Base


七、class中的Generator方法

    方法前面加&quot; * &quot; 号表示该方法是Generator函数

    class MyClass = {
        constructor(){
            ...
        }

        * getName(){
            ...
        }
    }
</code></pre><h4 id="Promise-异步编程"><a href="#Promise-异步编程" class="headerlink" title="Promise 异步编程"></a>Promise 异步编程</h4><pre><code>// resolve: 成功、reject: 失败

var pro = new Promise(function(resolve, reject){        // resolve成功, reject失败
    // 将一个耗时长的任务放到执行器里
    setTimeout(function(){
        resolve();            // 4毫秒后执行成功
    }, 400)
})

pro.then(
    function(){                        // 这里执行的就是reslove
        console.log(&apos;成功执行&apos;);
    },
    function(){                        // 这里执行的就是reject
        console.log(&apos;失败执行&apos;);
    }
)
.catch(function(e){                // 捕获异常，如果then中的两个方法成功失败有报错就会走catch
    console.log(e)
})


方法: 

一、Promise.all([实例1，实例2，实例3]): 用于多个promise实例，当三个实例都为真的时候all这个结果为真

    var p1 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p1完成&quot;);
        }, 400);
    })

    var p2 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p2完成&quot;);
        }, 1000);
    })

    var p3 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p3完成&quot;);
        }, 4000);
    })

    var p4 = Promise.all([p1, p2, p3]);
    p4.then(function(){
        console.log(&apos;三个全部执行成功&apos;)
    }, function(){
        console.log(&apos;失败&apos;)
    })

二、Promise.race([实例1，实例2，实例3]): 只要有一个为成功，p4为成功，与all()方法正反

https://www.jianshu.com/p/c98eb98bd00c
</code></pre><h4 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h4><pre><code>一、export: 模块输出

    1、使用对象简写方式

        var name1 = &apos;aaa&apos;;
        var name2 = &apos;bbb&apos;;
        var name3 = &apos;ccc&apos;;

        // 对象的简写 相当于{ name1: name1, name2: name2, name3: name3 }
        export {name1, name2, name3} 

        // 也可以写成    
        export var name1 = &apos;aaa&apos;;
        export var name2 = &apos;bbb&apos;;
        export var name3 = &apos;ccc&apos;;


    2、可以直接输出变量、函数或类

        export function person(){ ... }

        export {...}

        // 不能直接输出变量名
        var name = &apos;siguang&apos;;
        export name;            // 报错

        写成: export var name = &apos;siguang&apos;;        
        写成: var name = &apos;siguang&apos;;   export {name};    


    3、跨模块常量

        const常量只能在当前代码下使用，通过export可以进行跨模块常量，多个文件都可以使用

        export const name = &apos;siguang&apos;;
        export const age = 33;

        import * as info from &apos;userinfo&apos;;        // 或 import { name, age } from &apos;userinfo&apos;


二、as 关键字来修改名字

    meat.js

        export function beef(){
            return &apos;牛肉&apos;;
        }

        export function pork(){
            return &apos;猪肉&apos;;
        }

    main.js

        // * 代表meat.js下所有的对外接口，转换成meat对象下，这样就可以通过meat来调用meat下的
        import * as meat from &apos;./meat.js&apos;;        
        console.log(meat.beef());        // 牛肉
        console.log(meat.pork());        // 猪肉


三、* 将somModule内的所有导出接口

    import * as newSome from &apos;./someModule&apos;        // 将someModule类的所有接口更改到newSome下


四、export default 指定匿名

    import加载时将定义的名与导出的相同，否则无法加载，如果指定默认输出使用export default，在import导入的时候不用在关心命名的问题

    1、meat.js

            // 输出时是匿名
            export default function() {
                console.log(&apos;foo&apos;);
            }

            简写
            export default(){        // export default {}  写成默认对象

            }

        main.js

            // 导入时可以任意起名
            import beef from &apos;./meat.js&apos;


    2、default与不写default输出的区别

        // 使用default来输出，import不需要使用 {}
        export default function crc32() {
            // ...
        }
        import crc32 from &apos;crc32&apos;;

        // 不使用default来输出，import需要使用 {}
        export function crc32() { // 输出
            // ...
        };
        import {crc32} from &apos;crc32&apos;; // 输入


五、import: 模块加载

    // 取整个对象
    import $ from &apos;jquery&apos;;

    // 通过解构取对象
    import {name1, name2, nam3} from &apos;./user.js&apos;;

    // 通过逗号分两整体和解构分别来取
    import React, { Component, PropTypes } from &apos;react&apos;;

    // 重命名
    import * as React from &apos;react&apos;;        // * 对整体模块加载，并通过as转换一个名

    // 按需加载
    button.addEventListener(&apos;click&apos;, event =&gt; {
        imoprt(&apos;dialog.js&apos;)
            .then(dialog =&gt; {
                dialog.show();
            }).
            catch(err =&gt;{
                // error
            })
    }, false)


六、不同写法

    1、普通写法

        meat.js
            export function beef(){
                return &apos;牛肉&apos;;
            }
            export function pork(){
                return &apos;猪肉&apos;;
            }

        main.js

            import { beef, pork } from &apos;meat.js&apos;;
            console.log(beef());        // 牛肉
            console.log(pork());        // 猪肉


    2、key的简写

        var fn1 = funtion(){
            console.log(&apos;fn1&apos;);
        }

        var fn2 = function(){
            console.log(&apos;fn2&apos;);
        }

        export {fn1, fn2}         // 对象名与key相同可以写成一个
</code></pre><h4 id="数据结构-Set-、Map"><a href="#数据结构-Set-、Map" class="headerlink" title="数据结构 Set()、Map()"></a>数据结构 Set()、Map()</h4><pre><code>一、Set(): 类似数组的一种新结构，成员都是唯一的值没有重复值，相当于数组去重

    # 数组去重的新方法
    let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
    console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
    let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    特性: 
        1、不允许数组里有重复数据

    方法: 
        1、set.size(): 获取数据的长度

        2、set.add(value): 添加值

        3、set.delete(value): 删除set的实例值

        4、set.has(value): 传入的参数是否为set的成员

        5、set.clear(): 删除set的所有成员


二、Map(): 传统的对象key只能为字符串, Map可以是对象和其它类型

    var map = new Map([[&apos;name&apos;, &apos;age&apos;]]);
    console.log(map);        // {name: &apos;age&apos;}

    特性: 
        不允许有重复的key值

    方法: 
        1、map.size: 成员总数

        2、map.set(&apos;key&apos;, &apos;value&apos;): 添加成员

        3、map.get(): 获取

        4、map.clear(): 清除所有
</code></pre><h4 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h4><pre><code>一、repeat(): 复制字符串  &apos;哈哈哈！&apos;.repeat(5);    复制五个&apos;哈哈哈！&apos;

二、includes()、startsWith()、endsWith(): 查找三个方法

    var str = &apos;siguang 1983&apos;;
    str.includes(&apos;o&apos;);        // 查找字符串中是否包含值，包含返回true否则返回false
    str.startsWith(&apos;s&apos;);    // 第一个字符是不是s，如果是返回true
    str.endsWith(&apos;d&apos;);        // 最后一个字符是不是 d，返回布尔值
</code></pre><h4 id="数值-Math"><a href="#数值-Math" class="headerlink" title="数值 Math"></a>数值 Math</h4><pre><code>一、trunc(): 去除小数部分

    Math.trunc(123.123123);    // 123

二、sign(): 判断是正数还是负数，如果是正数返回1，负数返回-1，0返回0

    Math.sign(-234);    // -1

三、hypot(): 返回所有参数的平方和的平方根

    Math.hypot(3,4);    // 5 勾股定理
</code></pre><h4 id="数组扩展-Array"><a href="#数组扩展-Array" class="headerlink" title="数组扩展 Array"></a>数组扩展 Array</h4><pre><code>一、form(): 将对象转成数组

    var obj = {&apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;};
    var arr =  Array.form(obj); console.log(arr);        // [a, b, c]


二、of(): 将一组值转成数组

    var arrA = new Array(1, 2, 3);    // 生成一个[1,2,3]
    var arrB = new Array(3);        // arrB.length  等于3 如果传一个参数这样会生成一个3个空值

    var arrC = Array.of(3);            // [3] 解决了new Array的问题


三、find(): 找出第一个符合条件的数据元素

    // 找出数组中值大于3的第一个数
    var arr = [1,2,3,4,5,6];
    var n = arr.find(function(value, index){
        return value &gt; 3;
    })
    console.log(n);        // 4


四、findIndex(): 找出第一个符合条件的位置，也就是所引值

五、fill(填充内容, 填充开始的位置, 填充结束的位置): 填充数组

    var arr = [1,2,3,4,5,6];
    arr.fill(7);        // 数组里全部为7
    arr.fill(7, 1, 3);    // 数组下标从1-3的值为7
    console.log(arr);


六、for...of: 遍历数组、字符串的值，但不能遍历对象

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr){
        console.log(value);        // 1,2,3,4,5,6 只能将遍历出数组的值
    }


七、keys()和values(): 返回数组的Key或value

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr.key()){
        console.log(value);
    }


八、entries(): 将数组的key和value一块输出

    var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];
    for(var [key, value] of arr.entries()){
        console.log(key, value);
    }

    返回: 
        0 &quot;a&quot;
        1 &quot;b&quot;
        2 &quot;c&quot;
        3 &quot;d&quot;
        4 &quot;e&quot;
        5 &quot;f&quot;


九、includes(): 查看数组中是否包含指定的值

    var arr = [1, 2, 3, 4, 5];
    arr.includes(3);        // true
</code></pre><h4 id="二进制数组-ArrayBuffer对象"><a href="#二进制数组-ArrayBuffer对象" class="headerlink" title="二进制数组 ArrayBuffer对象"></a>二进制数组 ArrayBuffer对象</h4><pre><code>二进制数组由三类对象组成: 

    ArrayBuffer对象: 代表原始的二进制数据。

    TypedArray视图: 用来读写简单类型的二进制数据。

    DataView视图: 用来读写复杂类型的二进制数据。


一、ArrayBuffer 对象

    它不能直接读写，只能通过（TypedArray和DataView）来读写。

    ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。

    var buf = new ArrayBuffer(32);        // 生成一段32字节的内存区域，每个字节默认为0


    属性和方法: 

    1、byteLength: 返回分配内存的字节长度

        var buffer = new ArrayBuffer(32);

        buffer.byteLength;        // 32


    2、slice(): 拷贝字节

        var buffer = new ArrayBuffer(8);

        var newBuffer = buffer.slice(0, 3);     //拷贝`buffer`对象的前三个字节（从0到3前结束），生成一个新的ArrayBuffer对象: newBuffer


    3、isView(): 返回一个布尔值，表示参数是否为ArrayBuffer的视图实例

        var buffer = new ArrayBuffer(8);
        ArrayBuffer.isView(buffer) // false

        var v = new Int32Array(buffer);
        ArrayBuffer.isView(v) // true


二、TypedArray 视图

    TypedArray数组只提供9种固定的构造函数
</code></pre><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><pre><code>新的数据类型，独一无二的值，凡是属性名属于Symbol类型，就是独一无二的

# 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();

s1 === s2         // false

# 有参数的情况
var s1 = Symbol(&apos;foo&apos;);
var s2 = Symbol(&apos;foo&apos;);

s1 === s2         // false

一、不能与其它值进行运算

    var sym = Symbol(&apos;My symbol&apos;);
    console.log(&quot;your symbol is &quot; + sym);        // 报错


二、toString()转成字符串

    let sym = Symbol(&apos;my symbol&apos;);
    sym.toString()    // &quot;Symbol(my symbol)&quot;
</code></pre><h4 id="Proxy-拦截器"><a href="#Proxy-拦截器" class="headerlink" title="Proxy 拦截器"></a>Proxy 拦截器</h4><pre><code>可以监听对象身上发生变化，对操作对象属性读取时做一个拦截器

&lt;script&gt;
    let obj = {
        a: 1,
        b: 2
    }

    // 相当于操作对象属性时的一个拦截器
    let p1 = new Proxy(obj, {
        get(obj, key) { // 获取值操作
            return obj[key];
        },
        set(obj, attr, value) { // 赋值操作

            // 这里来做拦截，如果修改的key=a 并且 value值小于10不会就将值修改
            if (attr == &apos;a&apos; &amp;&amp; value &lt; 10) {
                obj[attr] = value;
            }
        }
    })

    // 设置属性
    p1.a = 9; // {a: 9, b: 2}
    p1.a = 20; // {a: 9, b: 2}
    p1.b = 10; // {a: 9, b: 20}

    // 获取属性值
    console.log(p1.a, p1.b);    
&lt;/script&gt;
</code></pre><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><pre><code>Generator是ES6提供的异步函数，Generator可以通过yield表达式来定义步骤，通过next()来获取结果 

Example: 

    function* ouputGenerator() {
        yield &apos;hello&apos;;            // 调用后不会马上执行，只有调用next()才会返回
        yield &apos;world&apos;;
        return &apos;ending&apos;;
    }

    let gen = ouputGenerator();

    console.log(gen.next());     // {value: &quot;hello&quot;, done: false}  value就是返回值
    console.log(gen.next());     // {value: &quot;world&quot;, done: false}
    console.log(gen.next());     // {value: &quot;ending&quot;, done: true}  done为true就是后面没有yeild的定义


一、Generator的特征:

    1、function 关键字与函数名之间有一个&quot;*&quot;号

    2、函数体内有 yield 语句

    3、可以执行暂停

    4、generator也可以不用yield, 但需要执行一次next()


二、属性和方法

    1、next() 可以带一个参数，参数可以是上一个yield的返回值

        done为true 表示结束  Object {value: &quot;ending&quot;, done: true}

    2、value: 就是next返回的值，done为false表示已经结束

    3、yield: 定义表达式


三、Generator与Promise的区别

    promise如果写多个嵌套会很麻烦:

        getArticleList()
            .then(articles =&gt; getArticle(articles[0].id))
            .then(article =&gt; getAuthor(article.authorId))
            .then(author =&gt; {
                alert(author.email);
            });

        function getAuthor(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/E105pDLh&quot;,{
                    author: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticle(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/EkI02vUn&quot;,{
                    id: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticleList(){
            return new Promise(function(resolve, reject){
            $.ajax(
                &quot;http://beta.json-generator.com/api/json/get/Ey8JqwIh&quot;)
                .done(function(result){
                    resolve(result);
                }); 
            });
        }


    Generator的写法:

        function* run(){
            var articles = yield getArticleList();
            var article = yield getArticle(articles[0].id);
            var author = yield getAuthor(article.authorId);
            console.log(author.email);  
        }

        var gen = run();
        gen.next().value
            .then(articles =&gt; {
                gen.next(articles).value.then(article =&gt; {
                    gen.next(article).value.then(author =&gt; {
                    gen.next(author)
                })
            })
        })


Example:

    function* ouputGenerator() {
        console.log(&apos;调用了&apos;)        // ** 如果没执行next不会执行 ** 
    }

    var gen = ouputGenerator();

    setTimeout(()=&gt;{
        gen.next()
    }, 3000)
</code></pre><h4 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h4><pre><code>async 是ES7引入的函数，使的异步变得更加方便

Generator函数执行必须靠执行器，也就是需要调next()，async函数有自带的执行器，async返回的是Promise对象

await: 命令后面是一个Promise对象

Example:

    async function getStockPriceByName(name) {
        var symbol = await getStockSymbol(name);
        var stockPrice = await getStockPrice(symbol);
        return stockPrice;
    }

    getStockPriceByName(&apos;goog&apos;).then(function (result) {
        console.log(result);
    });
</code></pre><p>| 参考资料<br>| <a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/babel.html</a><br>| <a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/style</a><br>| <a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/CSS3深入理解/">深入理解CSS3</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/CSS3深入理解/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/CSS3/">CSS3</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 选择器<br>| 文字样式: text-shadow、word-break、word-wrap、font-face、wrod-spacing、letter-spacing、text-overflow<br>| 盒模型: calc计算属性值、box-sizing元素的宽高是否包括padding、border的值、box-shadow、box-reflect、resize<br>| 布局: dispay:flex布局、dispay:box 弹性盒模型<br>| 分栏布局: column-width、column-count、column-gap、column-rule<br>| 背景: background-clip、background-size<br>| 变形: transform: scale、skew、translate、rotate、matrix，transform-origin<br>| 动画: transition: transition-property、transition-duration、transition-timing-function、transition-delay，animation</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><pre><code>一、基本选择器

    1、 * 通配符: 用于html的所有结点 -&gt; * { width:200px; }

    2、 元素选择器: 页面的元素 -&gt; li { border:1px #fff solid; }

    3、 类选择器: 所有指定的类别 -&gt; .cla { width:200px; height:30px; }

    4、 id选择器: #k0 { background-color:#000; }

    5、 m n{} 后代选择器: .nav li { width:200px; }    // .nav下的所有li元素

    6、 m &gt; n 子选择器: ie6不支持 -&gt; .nav &gt; li { width:200px; }    // 只匹配.nav下的子li元素，孙li不匹配

    7、 m + n 相邻选择器: ie6不支持 -&gt; .nav + div { background-color:#ccc; }    // 匹配.nav相邻的div元素

    8、 m ~ n 兄弟选择器: ie6不支持 -&gt; .nav ~ li { background-color:#ccc; }    // 与.nav所有的同辈元素

    9、 m, m, m 群组选择器: .nav1, .nav2, .nav3 { width: 2000px; }    // 群组选择器将每个选择器用&quot;，&quot;号分开


二、属性选择器

    1、[attr]: 指定属性名

    2、[attr==val]: 指定属性等于匹配

    3、[attr*=val]: 匹配属性具有attr并且包含val指定值

    4、[attr^=val]: 匹配指定属性的值，以val开头

    5、[attr$=val]: 匹配指定属性的值，以val结尾        如果id=&quot;abc-1&quot;，匹配[attr $= \-1]使用转义\


三、元素

    1、:first-line: 为某个元素第一行文字的使用样式

    2、:first-letter: 用于首字母

    3、:before: 用于在某个元素之前插入一些内容，如: 元素:before { content: &quot;插入的文字&quot; };

    4、:after: 用于在某个元素之后插入一些内容，如: 元素:after{ content: &quot;插入的文字&quot; };

    5、:root: 选择器将样式绑定到页面的根元素中，根元素是指位于文档树中最顶层结构的元素.

    6、:not: 对某个结构元素使用样式，但排除这个结构元素下面子结构元素，让它不使用这个样式可以使用not。

    7、:empty: 指定元素为空白时使用的样式

    8、:target: 

    9、:first-child: 指定元素中第一个子元素

    10、:last-child: 指定元素中的最后一个子元素

    11、:nth-child(3): 指定元素中的第3个元素.   li:nth-child(3) { background: yello; }   可以指定even奇数、odd偶数

    12、:nth-last-child(3): 指定元素中从后数第3个元素

    13、:nth-of-type: 找标签下指定的第几个子元素，例: .box p:nth-of-type(2): 找出个box下的第二个p元素

    14、:nth-last-of-type(): 从后找

    15、:only-child: 父元素中只有一个子元素.

        *** nth-child与nth-of-type的区别 *** 

        nth-child 从子元素的第一个开始无论不会指定元素
        nth-of-type 所有子元素的序列，而不是指定某一元素下查找

        &lt;style&gt;
            body { margin: 0; }
            .box li:nth-child(2) { background-color: #ccc; }         // 影响 &lt;li&gt;bbb&lt;/li&gt;
            .box li:nth-of-type(2) { background-color: #ccc; }         // 只对子元素li的第2个 影响 &lt;li&gt;ccc&lt;/li&gt;
        &lt;/style&gt;

        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;p&gt;aaa&lt;/p&gt;
                &lt;li&gt;bbb&lt;/li&gt;
                &lt;li&gt;ccc&lt;/li&gt;
                &lt;li&gt;ddd&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;


四、伪类选择器

    什么是伪类选择器: 使用类选择器把相同元素定义成不同样式，如

        p.right { text-align: right; }
        p.left {text-align: lef; }

    1、E:hover: 当鼠标指针移动到元素上所使用样式

    2、E:active: 用来指定元素被激活（鼠标在元素上按下还没有松开）时使用样式

    3、E:focus: 元素获得光标时使用

    4、E:enabled: 元素可用时状态使用

    5、E:disabled: 元素不可用状态时样式

    6、E:read-only: 元素只处于只读状态下时使用

    7、E:read-write: 元素处于非只读状态时使用

    8、E:checked: 指定单选或多选

    9、E:default: 用来指定当页面打开时默认处于选取状态的单选或多选框

    10、E:indeterminate: 用来指定页面打开时，一组单选中任何一个单选框都没有设定为选取状态.

    11、E::selection: 用来指定当元素处于选中状态时的样式

    12、E:target: 显示的两条

    13、~: 兄弟元素选择器
</code></pre><h4 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h4><pre><code>伪类 - 用于已有元素处于某个状态，为其添加对应的样式，比如用户悬停 通过 :hover

伪元素 - 用于创建一些不在文档树中的元素，并为其添加样式，如 :before来在一个元素前增加一些文本

一、伪类 用于向某些选择器添加特殊效果

    a:link: 未被访问过
    a:visited: 已经被访问的链接
    a:hover: 鼠标指针移动到的链接
    a:active: 被点击的链接
    :first-chidle: 向元素的第一个子元素添加样式


二、伪类元素 用于向某些选择器添加特殊效果

    ::first-letter: 设置第一个字符的样式属性

    ::first-line: 设置第一行的样式

    ::before 和 ::after: 用于在元素前和元素后配置content属性添加内容

        .box::before { content: &apos;这里是在box元素之前显示&apos;}
        .box::after { content: &apos;这里是在box元素之后显示&apos; }


三、css3规则伪类使用一个&quot;:&quot;, 伪元素使用两个&quot;::&quot;

    : 用于css2的伪类，:: 用于css3的伪类
</code></pre><p><img src="/images/伪类.png" alt="伪类"><br><img src="/images/伪元素.png" alt="伪元素"> </p>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><pre><code>一、text-shadow: 文字阴影  text-shadow: 横向 纵向 模糊半径 颜色

    多阴影: text-shadow: 10px 10px 2px #ccc, 20px 20px 3px #c3c3c3; 以逗号分割.


二、word-break: 文字自动换行

    normal: 使用浏览器的默认行为

    keep-all: 只能在半角空格或连接符处换行

    break-all: 允许在单词内换行


三、word-wrap: 长单词与URL地址自动换行

    normal: 浏览器默认，只有在半角空格或连接符处换行

    break-word: 长单词或URL地址内进行换行


四、@font-face: 服务器端字体

    @font-face {
        font-family: &apos;iconfont&apos;;
        src: url(&apos;iconfont.eot&apos;);                 /* IE9 */
        src: url(&apos;iconfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */
        url(&apos;iconfont.woff&apos;) format(&apos;woff&apos;),     /* chrome、firefox */
        url(&apos;iconfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
        url(&apos;iconfont.svg#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */
    }

    // 使用字体
    .iconfont{ font-family:&quot;iconfont&quot;; font-size:16px;font-style:nrmal; }


五、word-spacing: 设置单词字段间距, 修复 IE6、7 中始终存在的 1px 空隙，减少单词间的空白（即字间隔）

    .main{
        font-size:0;
        *word-spacing:-1px;
    }

六、letter-spacing: normal;  /* 设置字母、字间距为0 */ 

七、text-overflow: 溢出的文本末尾加省略标记

    clip: 不显示省略号

    ellipsis: 文字溢出时显示 ...

    ellipsis-word: 
</code></pre><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><pre><code>一、display: 定义盒类型

    block: 转成块元素

    inline: 转成内联元素

    inline-block: 属于block的一种，也具有inline的特点

    inline-table: 

    flex、inline-flex: flex弹性布局

    box、inline-box: box弹性盒模型，父元素上加此属性


二、box-sizing: 指定元素的宽与高度的计算方法

    1、content-box: border和padding不计算width之内（标准盒模型）

    2、border-box: border和padding计算入width之内，元素的宽高 = border + padding + content + width/height

    3、padding-box: padding计算入内（怪异盒模型）

    好处: 如果我设置两列都为50%，如果之前我加入了边距，加了内边距等，这个百分比计算就不好撑控了，

         所以有了box-sizing就可以不用管内边距的值是多少边框值是多少，最后都为50%

    -webkit-box-sizing、-moz-box-sizing、box-sizing


三、calc 给属性的值做计算

    Android不支持

    例: height: calc(100% - 80px);

    rule:

        使用“+”、“-”、“*” 和 “/”四则运算;
        可以使用百分比、px、em、rem等单位；
        可以混合使用各种单位进行计算；
        表达式中有“+”和“-”时，其前后必须要有空格，如&quot;width: calc(12%+5em)&quot;这种没有空格的写法是错误的；
        表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。


四、盒相关属性

    1、box-shadow: 盒阴影    box-shadow: 横向距离 纵向距离 模糊半径 颜色 inset（内阴影）

    2、box-reflect: 倒影 

        box-reflect: 方向 距离 渐变

            方向: above: 倒影在上边     below: 倒影在下边     left: 倒影在左边         right: 倒影在右边

        Example: -webkit-box-reflect: below   0   -webkit-linear-gradient(transparent,transparent 50%,rgba(255,255,255,.3));

    3、resize: 自由绽放, 可以使用当前元素用鼠标进行宽度的缩放

        both: 水平垂直都可以缩放

        horizontal: 水平方向可以缩放

        vertical: 垂直都可以缩放

        注意: 一定要加overflow: auto 才可以缩放
</code></pre><h4 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h4><pre><code>布局分类: 1、静态 px        2、流式 fluid        3、自适应（弹性布局）flex        4、响应式 responsive

    box-sizing是先出来的，flexbox是过渡版，flex最新语法，一个特性是flex没有的，文字可以垂直居中

    .box{
        display: -webkit-flex; /* Safari/Chrom */
        display: flex;
    }


任何一个容器都可以设置flex布局  # 父元素设置display: flex;  行内元素设置 display: inline-flex;    

display: flex 或 inline-flex;   // 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。

一、父容器上设置的属性: 

    1、flex-direction: 子元素的排列方向

        row 水平方向，起点在左端 | row-reverse 水平方向，起点在右端 | column 垂直方向，起点在上沿 | column-reverse 垂直方向，起点在下沿

    2、flex-wrap: 是否换行显示  nowrap 不换行 | wrap 换行第一行在上方 | wrap-reverse 换行，第一行在下方        

    3、flex-flow: flex-direction属性 和 flex-wrap

    4、justify-content: 子元素的对齐方式 

        flex-start 左对齐 | flex-end 右对齐 | center 居中 | space-between 两端对齐 | space-around 每个项目两侧间隔相等

    5、align-items: 主轴对齐方式，指定伸缩项目沿主轴对齐方式 （水平方向）

        flex-start 交叉轴的起点对齐。

        flex-end 交叉轴的终点对齐。

        center 交叉轴的中点对齐。

        baseline 项目的第一行文字的基线对齐。

        stretch（默认值）如果项目未设置高度或设为auto，将占满整个容器的高度。

    6、align-content: 侧轴对齐方式，指定伸缩项目沿着侧轴对齐方式 (垂直方向)


二、栏目的属性

    1、order: 栏目排列顺序。数值越小，排列越靠前，默认为0

    2、flex-grow: 放大比例，默认为0，即如果存在剩余空间，也不放大。

    3、flex-shrink: 项目的缩小比例

    4、flex-basis: 项目占据的主轴空间

    5、flex: 设置列所在容器的比例

            flex: 1，相当于flex: 1 1 auto, 如果想指定一个列的宽度，flex: 0 0 100px;

            .boxA { flex:1 } .boxB{ flex: 2 }

    6、align-flex: 允许单个项目有与其他项目不一样的对齐方式,可覆盖align-items属性。

    7、align-self: 指定多行伸缩容器的对齐，可以单独伸缩子元素，会覆盖align-items


Example:

    .row{width:200px;
        height: 50px;
        /*加上厂商前缀，目前使用方式都有三种写法: 1，旧的2，过度的3，新的*/
        display: -webkit-box;
        display: -webkit-flex;
        display: -ms-flexbox;
        display: flex;
        -webkit-flex-flow: row nowrap;
        -ms-flex-flow: row nowrap;
        flex-flow: row nowrap;}

    .row div{ 
        width:50px;height:50px;
        -webkit-box-flex: 1; 
        -webkit-flex: 1; 
        -ms-flex: 1;
        flex: 1; 
        text-align: center;
        line-height: 5rem;
        background-color: #f69f75;
    }

https://github.com/ccforward/cc/issues/60
http://www.alloyteam.com/2015/05/xi-shuo-flexbox-dan-xing-he-zi-bu-ju/
</code></pre><h4 id="box弹性盒模型"><a href="#box弹性盒模型" class="headerlink" title="box弹性盒模型"></a>box弹性盒模型</h4><pre><code>一、display: box 父元素加值

    display中加 box 或 inline-box: 使用弹性盒模型时使用

    box-orient: 定义盒模型的布局方向  horizontal 水平显示  vertical 垂直显示

    box-direction: 元素排列顺序  normal 正序   reverse 倒序

    box-ordinal-group: 设置元素的具体位置 

        .box div:nth-of-type(1){ --webkit-box-ordinal-group: 2 }    // 将第一个元素放到第二个位置显示 

二、box-flex: 定义盒子的弹性空间

    .boxB div { height: 100px; background-color: red; border: 1px #fff solid;}
    .boxB div:nth-of-type(1){ -webkit-box-flex: 1; }        // 这里可以写固定宽度
    .boxB div:nth-of-type(2){ -webkit-box-flex: 2; }
    .boxB div:nth-of-type(3){ -webkit-box-flex: 3; }
    .boxB div:nth-of-type(4){ -webkit-box-flex: 4; }
    .boxB div:nth-of-type(5){ -webkit-box-flex: 5; }

三、box-pack: 对盒子富裕空间管理，让盒子左侧、右侧还是居中显示，相当于float:left right

    star: 所有子元素在盒左侧显示，富余空间在右侧

    end: 所有子元素在盒右侧显示，富余空间在左侧

    center: 所有子元素居中

    justify: 富余空间在子元素之间平均分布

四、box-align: 垂直方向对元素的位置进行管理

    start: 所有元素居顶

    end: 所有元素居底

    center: 所有元素居中
</code></pre><h4 id="分栏布局"><a href="#分栏布局" class="headerlink" title="分栏布局"></a>分栏布局</h4><pre><code>给要分栏内容的父级上加入下面属性对文字进行分栏显示

1、column-width: 栏目宽度

2、column-count: 栏目列数

3、column-gap: 栏目距离

4、column-rule: 栏目间隔线
</code></pre><h4 id="mask蒙版"><a href="#mask蒙版" class="headerlink" title="mask蒙版"></a>mask蒙版</h4><pre><code>#box {
    width: 100%;
    height: 300px;
    background: url(../img/eric.jpg) no-repeat;
       -webkit-mask-repeat: no-repeat;
}

.mask_img_1 {
    -webkit-mask-box-image: url(../img/apple.png) 10 20 30 40 round round;
}

1、mask-box-image: 定义图片遮罩

2、mask-composite: 定义同一个元素上有多个图片遮罩的顺序

3、mask-clip: 定义图片遮罩延伸的位置

4、mask-repeat: 定义遮罩是否重复

5、mask-size: 定义遮罩的大小    
</code></pre><h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><pre><code>一、linear-gradient: 线性渐变

    background: -webkit-linear-gradient(top, #000 0%, #fff 100%);  // (起始位置, 开始颜色 占多少比例, 结束颜色  占多少比例) 

    1、起始位置可以写成 (top left) 从左上开始，也可以写成angle 角度值 45deg, background: -webkit-linear-gradient(45deg, #ccc 50%, #000 50%);

    2、(left top, #ccc 50%, #000 50%) - 写成50%百分比两个颜色没有过渡，如果成写100px两个颜色有过渡色

    简写: background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #000), color-stop(100%, #fff));

二、radial-gradient: 径向渐变

三、color-stop(透明度, reg): 从一个颜色到另一个颜色的渐变，需要color-stop

http://www.zhangxinxu.com/wordpress/2013/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css3-gradient%E6%96%9C%E5%90%91%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98/
</code></pre><h4 id="背景和边框"><a href="#背景和边框" class="headerlink" title="背景和边框"></a>背景和边框</h4><pre><code>背景: 
    1、background-clip: 指定背影的范围

        border-box 背景图以边框线为开始     padding-box 背景图已padding以开始    content-box 背景以内容为开始    text 文字中嵌背景图，文字外没有背景图

    2、background-origin: 绘制背影图像起点

        border-box 以边框线为起点    padding-box 以padding为起点     content-box  以内容区为起点

    3、background-size: 指定背影图像的尺寸

        auto: 背景图真实的大小

        cover:背景图像缩放,保留图像原有的比例/长宽比,不管背景图像大于还是小于背景区域，都会覆盖背景区域,图像的宽度或高度等于或超过背景区域,再次,根据背景图像的比例是否匹配的背景区域,背景图像的某些部分可能不在背景区域内。

        contain:背景图像缩放,同时保留图像原有的比例/长宽比,无论是图像的宽度或高度超过背景区域,以尽可能大的覆盖背景区域。因此,根据背景图像的比例是否匹配背景区域,可能会有一些背景图像覆盖不到背景地区。

        指定值: background-size: 100px 200px;  or    background-size: 50% 80%;

    4、background-break: 指定内联元素的背景平时循环方式

边框: 
    1、border-radius[ˈreɪdiəs]: 圆角的半径

    2、border-image: 图像边框
</code></pre><h4 id="transform-2D"><a href="#transform-2D" class="headerlink" title="transform 2D"></a>transform 2D</h4><pre><code>一、transform分类: 

    1、缩放: scale(0.5) 0-1之间  transform: scale(0.5)

    2、倾斜: skew实现文字或图像的倾斜  transform: skew(30deg, 30deg)

    3、移动: translate移动元素  transform: translate(50px, 50px;)

    4、旋转: rotate[ˈroʊteɪt]旋转元素  transform: rotate(45deg)

    5、矩阵: matrix


二、旋转基准点: 

    transform-origin: left top;     以左上为基础点
</code></pre><h4 id="transform-3D"><a href="#transform-3D" class="headerlink" title="transform 3D"></a>transform 3D</h4><pre><code>一、transform-style: 指定3D空间呈现，主要有两个属性值: flat 和 preserve-3d。

    1、flat: 值为默认值，表示所有子元素在2D平面呈现

    2、preserve-3d: 表示所有子元素在3D空间中呈现

        2）perspective: 景深

        3）perspective-origin: 景深基点

        4）backface-visibility: 隐藏背面

        5）Transform中的3D: 

二、perspective [pəˈspektɪv]: 200; 景深的远近，数越小景深越明显

三、perspective-origin: 50% 50%;   景深基点, 中间

四、backface-visibility: hidden 隐藏背面

五、3D元素

    1、translateX、translateY、translateZ

    2、rotateX、rotateY、rotateZ

    transform: translate3d(x, y, z)


Example:

    &lt;style&gt;
        .container {
            /* 告诉引擎使用的是3D */
            -webkit-transform-style: -webkit-preserve-3d;

            /* 设置景深和景深基点 */
            -webkit-perspective: 200;
            -webkit-erspective-origin: 50% 50%;
        }

        .boxA {
            width: 200px;
            height: 200px;
            margin: 100px auto;
            background-color: #7cb305;

            transform: rotateX(45deg);
        }
    &lt;/style&gt;

    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;boxA&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;


https://www.qianduan.net/high-performance-css3-animations/
https://segmentfault.com/a/1190000005071819
</code></pre><h4 id="css开启硬件加速"><a href="#css开启硬件加速" class="headerlink" title="css开启硬件加速"></a>css开启硬件加速</h4><pre><code>大多数电脑的显卡都支持硬件加速、可以发挥GPU的力量，CSS animations, transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行

一、开启硬件加速

    将元素转成3D变化就可以来欺骗浏览器开启硬件加速

    .cube {
        -webkit-transform: translate3d(0, 0, 0);
        -moz-transform: translate3d(0, 0, 0);
        -ms-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
    }

二、解决使用transform或animator时页面闪烁的问题

    .cube {
        -webkit-backface-visibility: hidden;
        -moz-backface-visibility: hidden;
        -ms-backface-visibility: hidden;
        backface-visibility: hidden;

        -webkit-perspective: 1000;
        -moz-perspective: 1000;
        -ms-perspective: 1000;
        perspective: 1000;
    }
</code></pre><h4 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h4><pre><code>一、transition 允许块级元素属性，在指定时间内平滑改变

    transition: 过渡属性名  过渡时间  过渡模式  延迟时间

    .box { transition: all 2s linear 3s; }

        transition-property: all;     // 设置过渡效果，all或指定一个css属性; 如果是all就是所有属性只要有变化的就执行过渡效果

        transition-duration: 2s;     // 动画完成的时间

        transition-timing-function: // 过渡模式

        transition-delay: 2s;         // 延迟时间

    # 多个过渡通过逗号分割 .box { transition: width 2s linear, height 3s linear 2s; }

    # transition事件: 

        obj.addEventListener(&apos;transitionend&apos;, function(){}, false);
        obj.addEventListener(&apos;WebkitTransitionend&apos;, function(){}, false);

    过渡模式: ease、linear、ease-in、ease-out、ease-in-out

二、animation: 能够在样式中创建多个关键帧来编写样式

    1、按百分比来做不同的样式处理

        @-webkit-keyframes myColor {
            0%{
                background-color: red;
            }
            50%{
                background-color: yellow;
            }
            100%{
                background-color: red;
            }
        }

        .box { animation: myColor 5s linear; }

三、from...to，从0%到100%

    animation: inpEffect .4s linear;

    @-webkit-keyframes inpEffect {
        from { top:0px; }
        to { top:200px; }
    }

四、将animation动画执行到100%后停住，animation-fill-mode: forwards;  

    animation: inpEffect .4s linear;        // 或者加到animation中 animation: inpEffect .4s linear forwards;
    animation-fill-mode: forwards;

    @-webkit-keyframes inpEffect {
        to {
            transform: scaleX(1); 
        }
    }

兼容前缀

    -webkit-: 指对chrome这种webkit内核的浏览器

    -moz-: 指对Firefox浏览器

    -o-: 指对Opera浏览器
</code></pre><h4 id="Media-Queries-查询媒体"><a href="#Media-Queries-查询媒体" class="headerlink" title="Media Queries  查询媒体"></a>Media Queries  查询媒体</h4><pre><code>一、&lt;meta&gt;标签

    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;

    1、width=device-width: 宽度等于设备宽度

    2、initial-scale: 初始缩放比例   initial[ɪˈnɪʃəl]

    3、minimum-scale、maximum-scale: 允许用户缩放最小、大比例

    4、user-scalable: 是否允许用户缩放


二、css定定义

    媒体查询: @media 设备类型 and (设备特性) { 样式代码 }

    1、设备类型: 

        1) all 所有媒体
        2) braille 盲文触觉设备
        3) embossed 盲文打印机
        4) print 手持设备
        5) projection 打印预览
        6) screen 彩屏设备
        7) speech &apos;听觉&apos;类似的媒体类型
        8) tty 不适用像素的设备
        9) tv 电视

    2、and | not | only

    3、min-width、max-width 最小、大宽度

    4、device-width、device-height: 设备屏幕的宽、高度。 device[dɪˈvaɪs]

    引用不同样式: 

        @media screen and (mim-width:480px){    // 窗口宽高大于480时调用下面样式
            .ads {
                display:none;
            }
        }

        @media screen and (min-width: 500px) and (max-width: 800px){    // 窗口宽度500-800之间执行下面样式
            .ads {
                display:none;
            }
        }

三、引用样式文件表

    引用不同样式表 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;a.css&quot; meida=&quot;screen and (min-width: 800px)&quot;&gt;
</code></pre><h4 id="css性能"><a href="#css性能" class="headerlink" title="css性能"></a>css性能</h4><pre><code>一、尽可能少使用box-shadows与gradients，投影和渐变都是性能杀手

二、将动画元素不在文档流中，以减少重排，使用

    position: fixed;  
    position: absolute;
</code></pre><p>| <a href="https://segmentfault.com/a/1190000006878700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006878700</a><br>| <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</a>    flex布局<br>| <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a><br>| <a href="http://www.cnblogs.com/module/p/5578533.html" target="_blank" rel="noopener">http://www.cnblogs.com/module/p/5578533.html</a><br>| <a href="https://isux.tencent.com/css3/tools.html" target="_blank" rel="noopener">https://isux.tencent.com/css3/tools.html</a>         // 动画工具生成代码<br>|<br>| <a href="https://github.com/zhiqiang21/blog/issues/2" target="_blank" rel="noopener">https://github.com/zhiqiang21/blog/issues/2</a><br>| <a href="http://div.io/topic/1348" target="_blank" rel="noopener">http://div.io/topic/1348</a><br>| <a href="https://github.com/tj?page=2&amp;tab=repositories" target="_blank" rel="noopener">https://github.com/tj?page=2&amp;tab=repositories</a><br>| <a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/</a>  伪类、伪元素<br>| <a href="https://zhuanlan.zhihu.com/p/33984503" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33984503</a>            // z-index<br>| <a href="https://cases.aotu.io/" target="_blank" rel="noopener">https://cases.aotu.io/</a>        h5活动案例<br>| <a href="https://zhuanlan.zhihu.com/p/25070186" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25070186</a>            // 布局<br>| <a href="https://zhuanlan.zhihu.com/p/25068655" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25068655</a>            // 居中布局</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/Babel/">Babel</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/Babel/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| babel安装<br>| ES6转ES5 babel-preset-es2015<br>| jsx文件的转换 npm i babel-preset-react<br>| .babelrc 文件配置 presets来解析<br>| 加UMD模块，可以自带模块代码</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><pre><code>$ npm install babel-cli         // babel的命令行cli

$ npm install --save-dev babel-preset-react        // 转换JSX语法并去掉注释

    .babelre配置  { &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;, &quot;stage-2&quot;] }


$ npm install --save-dev babel-preset-env        // 转义器将JS的 ES6、7转成ES5，官方废弃了ES2015/ES2016/ES2017使用babel-preset-env 来代替

    .babelre配置  { &quot;presets&quot;: [&quot;env&quot;] }

$ npm install --save-dev babel-loader            // webpack的使用babel的加载器

$ npm install -save-dev babel-polyfill        // babel默认只转新的javascript语法，不会转新的API, 如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，需要使用babel-polyfill
</code></pre><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><pre><code>babel支持的使用场景非常多，可以在浏览器中使用（browser）也可以在命令行（cli），还可以是我们常见的gulp和webpack中

一、安装：

    $ npm install babel-cli  babel-preset-env                    // 包括了: babel、babel-node、babel-core、babel-register

    // PolyFill 用于语法转换（如箭头函数）
    $ npm install --save-dev babel-polyfill                

    // babel-preset-react用于JSX语法转换Flow
    $ npm install --save-dev babel-preset-react                // .babelrc中需要加react

    $ touch .babelrc

        { &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;] }


        1、babel-register模块改写require命令，为它加上一个钩子。require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。

            npm install --save-dev babel-register

            // 先加载babel-register，这样就会不在对index.js进行转码了
            require(&quot;babel-register&quot;);
            require(&quot;./index.js&quot;);

        2、浏览器环境

            下载babel-core: npm install babel-core@5

            &lt;!-- 引用browser.js --&gt;
            &lt;script src=&quot;node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt;
            &lt;!-- type值为text/babel --&gt;
            &lt;script type=&quot;text/babel&quot;&gt;
                // 这里写es6的代码
            &lt;/script&gt;


二、babel用处

    1、将ES6转成ES5代码 babel-preset-es2015

        npm i babel-preset-es2015 --save-dev

        需要创建一个 .babelrc 文件
        {
              &quot;presets&quot;: [&quot;es2015&quot;]
        }

    2、babel-polyfill: 可以在在浏览器直接解析    npm i babel-polyfill --save-dev

    3、React的JSX代码: npm i babel-preset-react --save-dev

        对.babelrc文件配置
        {
              &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
        }


三、执行编译

    # babel main.js     // 将文件直接编译

    # babel main.js --out-file  main-component.js     // 编译文件 - 将main.js编译成一个main-component.js, 缩定--out-file 写成 -o

    # babel src --out-dir build   // 编译目录 - 将src目录下的所有文件编译到build目录下，--out-dir简写 -d

    # babel --watch main.js --out-file main-component.js  --source-maps  // --watch 侦听文件的变化，--source-maps 会在文件打出文件的目录, 简写 -w

    # babel src --out-dir lib  // 编译目录，src目录下的所有文件进行编辑并放到lib文件夹中


四、浏览器上直接编译 browser.js

    可以直接转换，不需要执行编译命令

    1、加载需要文件
        babel-core/browser.js 
        babel-core/browser-polyfill.js     // 修补浏览器工具的，浏览器不支持的时候需要它

    2、&lt;script&gt;调用
        type中必须写成 &apos;text/babel&apos;
        &lt;script src=&quot;main.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h4><pre><code>Babel 附带一个内置的 CLI，可用于从命令行编译文件, 用于执行命令

// 安装
$ npm install --save-dev babel-cli

// 执行
package.json中配置

    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;babel src -d build&quot;,        // 通过babel将src目录下的文件全部转译到build目录
    },
</code></pre><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><pre><code>将运行代码分三个阶段：解析、转换、生成

.babelrc文件

    {
        &quot;presets&quot;: [
            &quot;es2015&quot;,            // es2015、es2016、es2017
            &quot;react&quot;,
            &quot;stage-2&quot;            // stage-0...stage-4
        ]
    }
</code></pre><h4 id="Stage-X-阶段"><a href="#Stage-X-阶段" class="headerlink" title="Stage-X 阶段"></a>Stage-X 阶段</h4><pre><code>$ npm install --save-dev babel-preset-stage-0        // 安装

.babelrc
{
    &quot;presets&quot;: [&quot;stage-0&quot;] 
}

Stage 0 - 稻草人: 只是一个想法，可能是 babel 插件

Stage 1 - 提案: 初步尝试

Stage 2 - 初稿: 完成初步规范

Stage 3 - 候选: 完成规范和浏览器初步实现

Stage 4 - 完成: 将被添加到下一年度发布
</code></pre><h4 id="Balel-与-Gulp结合"><a href="#Balel-与-Gulp结合" class="headerlink" title="Balel 与 Gulp结合"></a>Balel 与 Gulp结合</h4><pre><code>// 安装gulp 和 gulp-bable包
$ npm i gulp gulp-babel --save

gulpFile:

    var gulp = require(&apos;gulp&apos;);
    var babel = require(&apos;gulp-babel&apos;);

    gulp.task(&apos;babelTask&apos;, function(){
        return gulp.src(&apos;./src/*.js&apos;)
            .pipe(babel())
            .pipe(gulp.dest(&apos;babelTask&apos;))
    })

    gulp.task(&apos;default&apos;,[&apos;babelTask&apos;]);
</code></pre><h4 id="Babel-与-Webpack结合"><a href="#Babel-与-Webpack结合" class="headerlink" title="Babel 与 Webpack结合"></a>Babel 与 Webpack结合</h4><pre><code>// 安装webpack和babel需要的包
$ npm install babel-loader babel-core babel-preset-es2015 webpack --save-dev

webpack.config.js:

    var webpack = require(&apos;webpack&apos;);
    var path = require(&apos;path&apos;);

    module.exports = {

        /* 页面入口 - 单入口文件 */
        entry: {
                index : &apos;./src/js/webpackPackMain.js&apos;          // 单入口文件
        },

        output: {
                path: &apos;./dist/js/&apos;,
                filename: &apos;[name].min.js?[hash]&apos;            // [hash] 将文件输出后加一个hash值
        },

        //加载器配置
        module: {
                loaders: [
                    &lt;!-- { test: /\.css$/, loader: &apos;style-loader!css-loader&apos;},
                    { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},
                    { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                    // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                    { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;}, --&gt;

                    // es6转es5
                    {
                        test: /\.js$/,
                        exclude: /(node_modules|bower_components)/,
                        loader: &apos;babel-loader&apos;,
                        query: {
                            presets: [&apos;es2015&apos;]
                        }
                    }
                ]
        }
    };
</code></pre><p>| <a href="https://babel.docschina.org/" target="_blank" rel="noopener">https://babel.docschina.org/</a>            // 官网</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/HTML、CSS深入理解/">HTML、CSS深入理解</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/HTML、CSS深入理解/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/HTML-CSS/">HTML/CSS</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>—————– CSS —————–</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><pre><code>内联元素与块元素的区别

    内联元素: 

        1、与其它内联元素都在并列同一行     

        2、不能设置宽、高

        3、不能设置上下外边距、内边距 margin-top、margin-bottom 和  padding-top、padding-bottom ，设置内边距也不会撑起父级高度

    块元素: 

        1、不指定宽度，会继承父元素的宽度，每个块元素都是独立一行

        2、元素的宽高都可以设置，如果不设置宽度就为100%;


一、display属性: 

    1、inline: 内联元素        2、block: 块元素

    3、inline-block: 具有block的宽高特性，又具有inline的同行元素特性

    4、table-cell: 文字的垂直居中，类似表格的单元格

    5、box: 弹性盒模型的过渡版本，现在用flex替换

    5、flex: flex是一个弹性布局的最新版本，老版本使用的box

        flex布局，子元素的float、clear、vertical-align属性将失效

        主要属性有两大类: 容器属性和项目属性


二、visibility 隐藏时可以保留元素的空间, display不会保留

    visible: 可视        hidden: 对象隐藏


三、overflow 

    overflow-x、overflow-y: 分别处理水平或垂直

    1、hidden: 隐藏溢出的内容

    2、scroll: 溢出的内容以滚动条显示
</code></pre><h4 id="BFC浮动"><a href="#BFC浮动" class="headerlink" title="BFC浮动"></a>BFC浮动</h4><pre><code>BFC概念: Block Formatting context(块级格式化上下文) 页面中一块渲染区域，并且有一套渲染规则，决定子元素如何定位，以及他们之间的关系和相互作用

触发BFC - 只要元素满足下面任一条件即可触发 BFC 特性：

    body 根元素

    浮动元素：float 除 none 以外的值

    绝对定位元素：position (absolute、fixed)

    display 为 inline-block、table-cells、flex

    overflow 除了 visible 以外的值 (hidden、auto、scroll)


如果子元素设置了浮动 float:left; 那么浮动的元素就会脱离普通文档流, 不会撑起父元素的高度, 容器只剩下2px的边距高度

    &lt;div style=&quot;border: 1px slid #000&quot;&gt;        // 添加overflow: hidden
        &lt;div style=&quot;width: 100px; height: 100px; background: #eee; float: left&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;


一、float 浮动

    left、right 左右浮动  浮动问题: 会使父级的高度失效，使用清除浮动来解决


二、clear 清除浮动

    both: 不允许有浮动对象     left: 不允许左边有浮动        right: 不允许有右边浮动

    /* 万能清除浮动 */
    .clear:after { content:&apos;&apos;; display:block; clear:both; height:0; overflow:hidden; visibility:hidden; }
    .clear { zoom:1; }

    after伪类： 元素内部末尾添加内容；
        :after{content&quot;添加的内容&quot;;} IE6，7下不兼容

    zoom 缩放 
        a、触发 IE下 haslayout，使元素根据自身内容计算宽高。
        b、FF 不支持；
</code></pre><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><pre><code>一、padding: 内边距 padding不支持负值

二、margin: 外边距 支持负值

    margin存在的问题: 

    1、适用于block元素，不起作用的absolute、fixed、inline、table-cell元素

    2、margin-top和margin-bottom 兄弟之间的会重叠

        解决方法:
            1、给当前元素加浮动 float: left
            2、给当前元素加 

    3、margin-top: 会影响到父元素（标准浏览器会影响，IE正常）

        解决方法: 给父元素加一个padding、border或overflow:hidden 即上面代码里的注释部分

三、border: 边框线
</code></pre><h4 id="position-定位"><a href="#position-定位" class="headerlink" title="position 定位"></a>position 定位</h4><pre><code>一、absolute: 绝对定位，查找父子以上的元素是否定义了position，如果没有就以window为定位基准

二、relative: 相对定位

三、fixed: 始终以window为定位，固定到屏幕的某个位置，浏览器滚动也跟随

四、static: 

五、z-index: 层级堆叠顺序，值越高越在最上面，最小值为0，最大值为2147483647
</code></pre><h4 id="background-背景"><a href="#background-背景" class="headerlink" title="background 背景"></a>background 背景</h4><pre><code>1、background-attachment: 背景图是随着滚动还是固定

    fixed: 相对窗体固定

    scroll: 背景图以元素固定，元素内容滚动时图像不会跟随滚动

2、transparent: 背景透明

background-color: 背景颜色 
background-image: 背景图片
background-repeat: 背景重复
background-position: 背景位置
</code></pre><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><pre><code>1、word-spacing: 单词与单词之间的间隔

2、letter-spacing: 字母与字母之间的间隔

3、word-wrap: 属性允许长单词或 URL 地址换行到下一行    @ break-word 在需要换行时才换

    如果不加些属于英文不会换行

4、word-break: 断字点进行换行

    break-all: 让英文象中文一样可以在行内做任意字间换行

    keep-all: 让中文向英文的换行方式接近，只在空格或英文标点符号才换行

5、white-space: 指定超出父级盒子宽度，文本进行换行(中、英文)，white-space: nowrap;

6、text-overflow: 文本的溢出时隐藏，test-overflow: ellipsis;  溢出用省略号来修剪

    p {width: 100px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;}

7、text-indent: 文本的首行缩进

8、vertical-align: 文本的对齐方式

    * 只应用于inline水平以及table-cell元素  别把他放到div或p的块元素内

    1、线类

        baseline: 默认，元素的基线与父元素的基线对齐

        top、bottom、middle: 居上、下、中

    2、文本

        text-top、text-bottom: 

    3、上标下标类

        super: 上标   sub: 下标   不过位置都不太兼容，需要重写

    4、数值百分比

        vertical-align: 20px;

9、color: 文本颜色

10、text-align: 文本对齐 left right center justify

11、text-decoration: 文本装饰 overline 上划线  underline 下划线  line-through 从中间穿过的线

12、direction: 文字方向 rtl 从右向左    ltr 从左向右

13、line-height: 行高
</code></pre><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><pre><code>table: margin可以使用，除非设置 display: inline-table

1、border-collape: 表格或单元格边框合并到一起

    separate: 边框独立        collapse: 相邻合并

2、border-spacing: 表格或单元格之间的距离

表格单线条:

    .tab { border-spacing: 0;  border-collapse: collapse;}
    .tab td, .tab th { border-collapse: collapse; border: 1px #ccc solid; border-spacing: 0; padding: 10px 20px; }
</code></pre><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><pre><code>rem: 是相对于根元素(html)的font-size值为基准，em是相对父级元素变化，px是物理像素

vw/vh: 根据屏幕不同变化的

em: 相对长度，相对于父元素
</code></pre><h4 id="语法与规则"><a href="#语法与规则" class="headerlink" title="语法与规则"></a>语法与规则</h4><pre><code>1、!important 提升优先级

2、@import url(&quot;global.css&quot;); 导入外部样式表

3、@charset &apos;uft-8&apos; 编码
</code></pre><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><pre><code>p{...} 元素选择器

.className{...} 类选择器

#idName{...} id选择器

.user[id=&apos;username&apos;]{...} 属性选择器

.claA .claB{...} 后代选择器

.clsA &gt; .clsB {...} 子选择器

.clsA + .clsB {...} 相邻选择器

.clsA, .clsB{...} 选择器分组
</code></pre><h4 id="伪类、伪元素"><a href="#伪类、伪元素" class="headerlink" title="伪类、伪元素"></a>伪类、伪元素</h4><pre><code>伪类 用于向某些选择器添加特殊效果

    a:link: 未被访问过
    a:visited: 已经被访问的链接
    a:hover: 鼠标指针移动到的链接
    a:active: 被点击的链接

    :first-childe: 向元素的第一个子元素添加样式


伪类元素 用于向某些选择器添加特殊效果

    :first-letter: 设置第一个字符的样式属性  ::first-letter

    :first-line: 设置第一行的样式    ::first-line

    :before 和 :after: 用于在元素前和元素后配置content属性添加内容    ::before   ::after

        .box::before { content: &apos;这里是在box元素之前显示&apos;}
        .box::after { content: &apos;这里是在box元素之后显示&apos; }


css3规则伪类使用一个&quot;:&quot;, 伪元素使用两个&quot;::&quot;

    : 用于css2的伪类，:: 用于css3的伪类
</code></pre><h4 id="css基础属性"><a href="#css基础属性" class="headerlink" title="css基础属性"></a>css基础属性</h4><pre><code>字体

    font-size: 字体大小

    font-family: 使用的字体

    font-style: 字体风格  @ italic 斜体

    font-weight: 字体重量

    font: 简写 

        按顺序 也可以设置第六个值为line-hgith
        font-style
        font-variant
        font-weight
        font-size/line-height
        font-family

链接

    a:link: 未被访问过

    a:visited: 已经被访问的链接

    a:hover: 鼠标指针移动到的链接

    a:active: 被点击的链接

列表

    list-style-image: 将图像设置为列表标志

    list-style-position: 标志的位置

    list-style-type: 标志类型  @circle 圆  @square 方块

    list-style: 简写属性

尺寸

    width、height: 宽高

    max-width、max-height: 最大宽高

    min-width、min-height: 最小宽高

透明度

    opacity: 0.4;

    filter: alpha(opacity=40); /* 针对 IE8 以及更早的版本 */
</code></pre><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><pre><code>1、body高度为100%，html继承了浏览器的高度，body继承了html的高度，这样body就为100%了

    html{ height: 100%; }
    body { height: 100%; margin: 0;}
    .box { width: 100%; height: 100%; background-color: #ccc; }

2、浏览器hack

    .box { width: 100px\9; }

    浏览器（加粗表示支持）    CSS hack
    IE6        _background-color:#38DB24;
    IE6、7    *background-color:#38DB24;
    IE6、7    +background-color:#38DB24;
    IE6、7    #background-color:#38DB24;
    IE6、7    background-color:#38DB24 !ie;
    IE6、7、8、9、10    background-color:#38DB24\9;
    IE7、8、9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari        html&gt;body .ie78910-all-hack { background-color: #38DB24 }
    IE8、9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari        html&gt;/**/body .ie8910-all-hack { background-color: #38DB24 }
    IE8、9、10&amp;Opera    background-color:#38DB24\0;
    IE9、10    :root .ie910-hack { background-color:#38DB24\9; }
    IE9、10    background-color:#38DB24\9\0;
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    body:nth-of-type(1) .ie910-all-hack {background-color:#38DB24 ;}
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    @media all and (min-width: 0px) { .ie910-all-2-hack{ background-color:#38DB24 ;} }
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    @media all and (min-width: 0px) { .ie910-all-3-hack{background-color:#38DB24 ;} }
    IE9、10&amp;Firefox&amp;Opera&amp;Chrome&amp;Safari    :root *&gt; .ie910-all-4-hack { background-color:#38DB24 }
    IE10    @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) { .ie10-hack{background-color:#38DB24 ;} }
    Firefox    @-moz-document url-prefix() { .firefox-hack{background-color:#38DB24 ;} }
    Chrome&amp;Safari    @media screen and (-webkit-min-device-pixel-ratio:0) {.chrome-safari-hack{background-color:#38DB24 ;} }

3、条件注释

    lt : 就是Less than的简写，也就是小于的意思。

    lte : 就是Less than or equal to的简写，也就是小于或等于的意思。

    gt : 就是Greater than的简写，也就是大于的意思。

    gte: 就是Greater than or equal to的简写，也就是大于或等于的意思。

    !: 就是不等于的意思，跟javascript里的不等于判断符相同。

    1、只有IE能识别
        &lt;!--[if IE]&gt;
            &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;
        &lt;![endif]--&gt;

    2、指定版本
        &lt;!--[if IE 8]&gt; 
            &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;   
        &lt;![endif]--&gt;

    3、低于指定版本才能识别
        &lt;!--[if lt IE 7]&gt; 
            &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;   
        &lt;![endif]--&gt;


4、layout: IE的私有概念

5、zoom: 用于处发layout

    zoom: 1;
</code></pre><h4 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h4><pre><code>http://alloyteam.github.io/gopng

http://fis.baidu.com

http://gruntjs.com
</code></pre><p>—————– HTML —————–</p>
<h4 id="HTML标记"><a href="#HTML标记" class="headerlink" title="HTML标记"></a>HTML标记</h4><pre><code>1、&lt;!DOCTYPE html&gt; 声明文档解析类型，指定浏览器用哪个版本来解析页面

    解析类型有两种模式:  

    1、怪异模式: 浏览器使用自己的怪异模式解析渲染页面（如果不声明doctype就是怪异模式）

    2、标准模式: 使用严格模式，以W3C的标准解析渲染页面

    HTML 4.01 规定了三种文档类型: Strict、Transitional 以及 Frameset。


2、&lt;html&gt; 定义文档  &lt;body&gt; &lt;head&gt; 定义文档信息

3、&lt;title&gt;、&lt;style&gt;

4、&lt;meta&gt;: 文档元信息

5、&lt;link&gt;: 文档与外部资源

6、&lt;script&gt;: 定义脚本

7、&lt;div&gt;

8、&lt;iframe&gt;: 内联框架

9、&lt;img&gt;: 定义图像

文本:

10、&lt;p&gt;: 段落

11、&lt;span&gt;: 文档中的节

12、&lt;a&gt;: 定义锚，属性 href、title

13、&lt;b&gt;: 定义粗体

14、&lt;i&gt;: 斜体

15、&lt;em&gt;&lt;strong&gt;: 强调内容 斜体、粗体

16、&lt;u&gt;: 下划线文字

17、&lt;big&gt;、&lt;small&gt; 大字体和小字体   

    &lt;h2&gt;标准属性&lt;small&gt;id, class, title, style, dir, lang&lt;/small&gt;&lt;/h2&gt;

18、&lt;bdo&gt; 定义字体显示的方法 

    文字翻转显示 &lt;bdo dir=&quot;rtl&quot;&gt;Here is some text&lt;/bdo&gt;  

19、&lt;br&gt;: 换行

20、&lt;del&gt;: 被删除的文本

21、&lt;hr&gt;: 定义水平线

22、&lt;ins&gt;: 定义被插入文本

23、&lt;sub&gt;: 下标文本

24、&lt;sup&gt;: 上标文本

25、&lt;var&gt;: 文本的变量部分

26、&lt;code&gt;&lt;pre&gt;

标题

27、&lt;h1&gt;...&lt;h6&gt;    

列表

28、&lt;ul&gt;: 无序列表

29、&lt;ol&gt;: 有序列表

30、&lt;li&gt;: 列表的项目

31、&lt;dl&gt;、&lt;dt&gt;、&lt;dd&gt;: 定义列表

表单

32、&lt;form&gt;

33、&lt;fieldset&gt;、&lt;legend&gt;: 定义围绕表单中元素的边框。

    &lt;fieldset&gt;
        &lt;legend&gt;健康信息&lt;/legend&gt;
        身高: &lt;input type=&quot;text&quot; /&gt;
    &lt;/fieldset&gt;

34、&lt;input&gt;

35、&lt;label&gt;: input元素的标注

36、&lt;select&gt;: 下拉菜单 &lt;option&gt;菜单内容

37、&lt;button&gt;: 按钮

38、&lt;textarea&gt;: 多行文本

表格

39、&lt;table&gt;

40、&lt;tr&gt;、&lt;td&gt;: 行、列

41、&lt;caption&gt;: 定义表格标题

42、&lt;th&gt;: 表格头单元

43、&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;: 表格头和主体

窗口框架

44、&lt;frame&gt;: 定义框架集窗口或框架

45、&lt;frameset&gt;: 定义框架集

46、&lt;object&gt;、&lt;param&gt;
</code></pre><p>| <a href="http://www.css88.com/book/css/" target="_blank" rel="noopener">http://www.css88.com/book/css/</a><br>| <a href="http://www.w3cplus.com/" target="_blank" rel="noopener">http://www.w3cplus.com/</a><br>| <a href="https://www.nihaoshijie.com.cn/index.php/page/3" target="_blank" rel="noopener">https://www.nihaoshijie.com.cn/index.php/page/3</a><br>| <a href="http://jixianqianduan.com/page6/" target="_blank" rel="noopener">http://jixianqianduan.com/page6/</a><br>| <a href="http://www.css88.com/archives/category/js-and-ria" target="_blank" rel="noopener">http://www.css88.com/archives/category/js-and-ria</a><br>| <a href="http://www.w3cplus.com/solution/index/index.html" target="_blank" rel="noopener">http://www.w3cplus.com/solution/index/index.html</a><br>| <a href="https://github.com/csswizardry/inuit.css/tree/master/base" target="_blank" rel="noopener">https://github.com/csswizardry/inuit.css/tree/master/base</a><br>| <a href="https://github.com/GumbyFramework/Gumby" target="_blank" rel="noopener">https://github.com/GumbyFramework/Gumby</a><br>| <a href="http://www.shejidaren.com/css-written-specifications.html" target="_blank" rel="noopener">http://www.shejidaren.com/css-written-specifications.html</a><br>| <a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25321647</a>        BFC</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/HTML5深入理解/">HTML5深入理解</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/HTML5深入理解/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/HTML5/">HTML5</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 文件API FileList对象上传文件信息、FileReader()文件读取对象、FormData()异步上传文件<br>| 拖放API<br>| 离线应用 manifest<br>| postMessage 跨文档消息传送<br>| webScoket<br>| 本地存储localStorage、sessionStorage<br>| 多线程 web workers<br>| 获取地理位置 geolocation<br>| video、audio<br>| canvas绘图<br>| History 历史管理</p>
<h4 id="新增语义化标签"><a href="#新增语义化标签" class="headerlink" title="新增语义化标签"></a>新增语义化标签</h4><pre><code>1、header: 用于头部

2、footer: 用于页尾

3、nav: 用于导航

4、aside: 定义页面区域

5、article: 用来显示一块独立的文章内容

6、section: 文档的节

7、hgroup: 标题元素进行组合
</code></pre><h4 id="表单类"><a href="#表单类" class="headerlink" title="表单类"></a>表单类</h4><pre><code>一、表单属性

    1、placeholder: 内容为空时的提示 &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt;

    2、autofocus: 指定控件自动获取焦点 &lt;input type=&quot;text&quot; autofocus &gt;

    3、autocomplate: 自动完成功能，on和off两个值 &lt;input type=&quot;text&quot; autocomplate=&quot;on&quot;&gt; 只有Opera支持

    4、require: 如果该元素为空，则无法提交表单 &lt;input type=&quot;text&quot; required /&gt;


二、表单类型

    1、search: 用于搜索关键词 &lt;input type=&quot;search&quot; vlaue=&quot;&quot; &gt; 

    2、email: 需要输入正确的电子邮件地址

    3、number: 只能输入数字，配合min、max属性

    4、range: 数值范围

        &lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;-360&quot; max=&quot;360&quot; class=&quot;rang&quot; id=&quot;lateZ&quot; /&gt;

        事件: onchange: 触发后执行,只触发一次        oninput: 最真实触发，拖动就触发

    5、tel: 点击只提供数字键盘

    6、url: 输入url

    7、pattern: 正则表达式     &lt;input type=&quot;email&quot; pattern=&quot;[^ @]*@[^ @]*&quot; value=&quot;&quot;&gt;


邮件链接: &lt;a href=&quot;mailto:cxz@126.com&quot;&gt;发送邮件&lt;/a&gt;
电话链接: &lt;a href=&quot;tel:15012345678&quot;&gt;打电话&lt;/a&gt;
</code></pre><h4 id="dataList数据列表"><a href="#dataList数据列表" class="headerlink" title="dataList数据列表"></a>dataList数据列表</h4><pre><code>通过数据列表来实现自动补全的功能

&lt;form action=&quot;/server&quot; method=&quot;post&quot;&gt;
    &lt;input list=&quot;jslib&quot; name=&quot;jslib&quot;&gt;
    &lt;datalist id=&quot;jslib&quot;&gt;
        &lt;option value=&quot;jQuery&quot;&gt;
        &lt;option value=&quot;Dojo&quot;&gt;
        &lt;option value=&quot;Prototype&quot;&gt;
        &lt;option value=&quot;Augular&quot;&gt;
    &lt;/datalist&gt;
    &lt;input type=&quot;submit&quot; value=&quot;完成&quot; /&gt;
&lt;/form&gt;
</code></pre><h4 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h4><pre><code>FileList、FileReader()、FormData() 三个API对象

一、FileList对象、File对象: 读取本地文件

    HTML4: &lt;file&gt;控件内只允许放置一个文件，HTML5: 加入multipe属性，允许file添加多个文件

    Example:
        &lt;input type=&quot;file&quot; id=&quot;fileLoad&quot; /&gt; 
        &lt;input type=&quot;file&quot; id=&quot;fileLoad&quot; multiple /&gt;          // mutiple 可以进行多个文件的选取
        &lt;script&gt;
            oUpFile.onclick = function(){
                var oFileLoad = document.querySelector(&apos;#fileLoad&apos;).files[0];        // 返回的是FileList对象列表
                for(var k in oFileLoad){
                    console.log(k, oFileLoad[k]);
                }
            }
        &lt;/script&gt;

        FileList返回: 
        {
            name: f82f4a858d04d0a68f528e4602120c05.jpg,        // 文件名
            lastModified: 1462944176000,                    // 最后修改日期
            lastModifiedDate: Wed May 11 2016 13:22:56 GMT+0800 (CST),// 最后修改日期
            webkitRelativePath,
            size: 554902,                        // 文件大小 
            type: image/jpeg                    // 文件名型
        }

    https://segmentfault.com/a/1190000004084956


二、FileReader() 文件读取对象

    FileReader() 将文件读入内存，并且转成不同类型（二进制、DataURL、文本）

    方法: 
        1、readAsBinaryString: 将文件读取为二进制码

        2、readAsDataURL: 将文件读取为DataURL，一段是以data:开头的 Base64位图片编码

        3、readAsText: 将文件读取为文本，第2个参数为编码类型，默认为UTF-8

        4、abort: 中断读取

    Example:
        var oFile = document.querySelector(&quot;oFile&quot;).files[0];        // 返回FileList对象

        reader = new FileReader();        // 创建FileReader()对象读取文件
        reader.readAsDataURL(oFile);    // 将文件以什么格式读入页面
        reader.onload = function(e){
            $(&quot;#oimg&quot;).attr(&apos;src&apos;, e.target.result);    // e.target.result 来获取文件的格式
            $(&quot;#fileText&quot;).text(e.target.result);
        }


三、FormData() 对象

    FormData()可以异步上传二进制文件, 只能传文件、图片的二进制等

    &lt;form&gt;表单的enctype属性有三个值:

        1、application/x-www-form-urlencoded: 用来设置表单传输，默认也是这个值，所以form中不写enctype属性也是按这个默认去传的

        2、multipart/form-data: 用来传输图片或MP3等文件, 会以request payload提交数据

        3、text/plain: 用于传输文本，邮件用此编码        

    API:
        1、创建FormData , var formData = new FormData(&apos;表单名&apos;)

        2、get(key): 获取存储的字段的值

        3、append(key, value): 存储字段

        4、set(key, value): 修改值

        5、has(key): 判断是否存已经有了key

        6、delete(key): 删除数据

        7、formData.entries(): 遍历FormData

        8、next(): 遍历时所用下一个节点数据，如果没有返回undefined

        9、发送数据: 通过XHR

            var xhr = new XMLHttpRequest();
            xhr.open(&apos;post&apos;, &apos;login&apos;);
            xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);
            xhr.send(formData);

    Example:

        &lt;form id=&quot;upFileForm&quot; method=&quot;post&quot; enctype=”multipart/form-data”&gt;
            &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;upFile&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;upFile&quot; value=&quot;上传&quot;&gt;
        &lt;/form&gt;

        &lt;script&gt;                
            let from = document.querySelector(&apos;#upFileForm&apos;)[0];
            let uploadFile = document.querySelector(&quot;#upFile&quot;);
            let formData = new FormData(from);

            formData.append(&apos;file&apos;, uploadFile.files[0]);
            console.log(formData)

            $.ajax({
                url: &apos;/remittanceDetail/import&apos;,
                type: &quot;post&quot;,
                data: formData,
                processData: false,     // 告诉jQuery不要去处理发送的数据
                  contentType: false,     // 告诉jQuery不要去设置Content-Type请求头
                success: function(res) {
                    console.log(&apos;err&apos;, res)
                },
                error: function(res){
                    if(res == 0){
                        console.log(&apos;err&apos;, res) 
                    }
                    console.log(&apos;err&apos;, res)                      
                }
            });
        &lt;/script&gt;

    https://segmentfault.com/a/1190000002680797
    https://segmentfault.com/a/1190000006716454
    http://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html
</code></pre><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><pre><code>ArrayBuffer是一段连续的长度固定的字节序列，如：通过实例化ArrayBuffer对象在内存中创建一段二进制存储空间（或叫二进制缓冲区），

// 创建一段字节长度为8的内存空间
var buffer = new ArrayBuffer(8);
// 获取字节长度
console.log(buffer.byteLength); // 8
</code></pre><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><pre><code>处理对二进制的方法，通过Blob来操作二进制数据

var abc = new ArrayBuffer(80);        // ArrayBuffer ES6用来在内存中存一段二进制数据
var blob = new Blob([abc], {type: &apos;text/plain});

方法:

1、slice(): 将大文件分片，用于分片上传

https://www.cnblogs.com/hhhyaaon/p/5928152.html
https://github.com/eligrey/FileSaver.js
</code></pre><h4 id="拖放API"><a href="#拖放API" class="headerlink" title="拖放API"></a>拖放API</h4><pre><code>拖放过程由两个部分构成:

    被拖拽的元素，之后简称为子项（item）
    放置被拖拽元素的元素，之后简称为容器（container）

1、draggable属性: 将想要拖放对象元素加入引属性设置为true

2、拖放事件: 

    子项事件: 
        1）dragstart - 拖拽开始

        2）drag - 拖拽过程中不断触发

        3）dragend - 拖拽结束，无论有没有拖进容器（ 鼠标松开就触发 ）

    容器事件:
        1）dragenter - 子项进入容器范围

        2）dragover - 子项在容器范围内不断触发

        3）dragleave - 子项离开容器范围

        4）drop - 拖拽结束，且子项成功拖进容器


    Example:
        &lt;script&gt;
            var oBox = document.querySelector(&apos;#box&apos;);            // 容器
            var oDragBlcok = document.querySelector(&apos;#dragBlcok&apos;);    // 拖拽块

            oDragBlcok.addEventListener(&apos;dragstart&apos;, function(e){
                e.dataTransfer.setData(&apos;name&apos;, &apos;siguang&apos;);
            })

            oDragBlcok.addEventListener(&apos;dragend&apos;, function(e){
                var name = e.dataTransfer.getData(&apos;name&apos;);
                console.log(name);
            })    
        &lt;/script&gt;


3、拖拽事件对象

    e.dataTransfer: 拖拽文件的信息

        files: FileList对象，相当于input的type=&quot;file&quot;的内容

            astModified:1494234931000
            lastModifiedDate:
            Mon May 08 2017 17:15:31 GMT+0800 (CST)
            name:&quot;chongwutupianxiaotuxiaom.jpg&quot;
            size:20926type:&quot;image/jpeg&quot;
            webkitRelativePath:&quot;&quot;


4、DataTransfer对象: 拖拽时需要传递一些数据，DataTransfer就可以来对数据进行传输，绑定在拖放事件的Event中

    1）dataTransfer.items: 一个数据集合

    2）dataTransfer.setDragImage(element, x, y): 拖拽过程中定义一个元素替换原有的，可以看到拖拽元素跟随的效果。

    3）dataTransfer.setData(key, val): 添加自定义数据

    4）dataTransfer.getData(key): 获取自定义数据

    5）dataTransfer.clearData(): 清除自定义数据

    6）dataTransfer.getData(format): 播放文件列表
</code></pre><h4 id="离线应用"><a href="#离线应用" class="headerlink" title="离线应用"></a>离线应用</h4><pre><code>在没有网络的情况下，可以使用本地缓存的离线数据也可以使web应用运行进来

1、离线与缓存的区别

    两都都是为了更好的缓存各种文件以提高读取速度，两者对网络环境有要求: 

    1、网页缓存依赖有网络的情况，离线应用在离线下仍然可用

    2、网页缓存主要缓存当前页面的内容，离线应用是缓存的指定文件，在离线状态下仍可以访问


2、manifest（[ˈmænəˌfɛst]显示）文件

    通过manifest文件来管理哪些文件需要缓存

    设置完后所有本地缓存的文件存储到Application Cache中，如果段网时在Network中查看缓存的文件为（from cache）

    offline.manifest:
        CACHE MANIFEST // 必要，把文件的作用告诉给浏览器，让文件支持text/cache-manifest
        #Version 1.0
        CACHE:  // chche，指定需要被缓存的资源，浏览器会对这些设置的资源
            index.html  
            style.css
            images/2.jpg
            default.js

        NETWORK:    // 指定不进行缓存的资源，如果为“*”通配符，表示所有资源都不被缓存
            # 1.jpg
            images/1.jpg            

        FALLBACK:             // 每行指定两个资源，如果
            /js/test/index.html   /js/test/404.html


3、需要在html页面中的&lt;html&gt;标签加入manifest=&quot;offline.manifest&quot;

    &lt;html lang=&quot;en&quot; manifest=&quot;offline.manifest&quot;&gt;


4、applicationCache对象

    1）检测是否支持离线应用

        if(window.applicationCache){
            // 支持
        }

    2）属性: 

        applicationCache.status返回: 离线缓存状态
            0: 无缓存
            1: 闲置
            2: 检查中
            3: 下载中
            4: 更新完成
            5: 废弃

    3）事件: 
        checking: 检查缓存更新时；
        error: 检查更新或下载资源时发声错误
        noupdate: 描述文件无变化
        downloading: 开始下载应用缓存资源
        progress: 下载缓存资源过程中
        updateready: 下载完毕
        cached: 应用缓存完整可用时

        applicationCache.addEventListener(&apos;updateready&apos;, function(){  // 资源下载中  }, false)

    4）applicationCache.update(): 让离线缓存检查更新上面的事件


5、检测是否有网络 online 和 offline

    // navigator.onLine如果设置为true表示能上网
    if (navigator.onLine) {
        // statement if online
    } else {
        // statement if offline
    }

    // 侦听当网络变化的时候触发
    window.addEventListener(&apos;online&apos;, function(){
        console.log(&apos;在线&apos;);
    }, false);

    window.addEventListener(&apos;offline&apos;, function(){
        console.log(&apos;离线&apos;);
    }, false);
</code></pre><h4 id="postMessage-跨文档消息传输"><a href="#postMessage-跨文档消息传输" class="headerlink" title="postMessage() 跨文档消息传输"></a>postMessage() 跨文档消息传输</h4><pre><code>HTML5来进行两个不同跨域的页面来消息传递（iframe不同域）

1、postMessage(&apos;发送数据&apos;, 要发送到的URL): 发送消息

2、message: 事件来接收消息，其中event对象

    evt.origin: 发送消息所在的域

    evt.data: 接收到的数据

    evt.source: 向来源可以在回执信息


Example:

    &lt;iframe id=&quot;myframe&quot; src=&quot;originPage.html&quot;&gt;&lt;/iframe&gt;
    &lt;button id=&quot;sendBtn&quot;&gt;发送消息&lt;/button&gt;

    &lt;script&gt;

        // 接收originPage.html页面消息
        window.addEventListener(&apos;message&apos;, function(evt){

            // ev.origin 获取消息的URL，如果不是taobao就不执行
            if(ev.origin != &quot;http://www.taobao.com&quot;){
                return false;
            }

            // ev.data 传输的数据
            alert(&quot;那里传来的消息: &quot; + ev.data)

        }, false);

        // 向originPage.html页面 发送消息
        var oSendBtn = document.querySelector(&apos;#sendBtn&apos;);
        oSendBtn.onclick = function(){
            var iframWindow = document.querySelector(&apos;#myframe&apos;);

            // postMessage()
            iframWindow.postMessage(&quot;A secret&quot;, &quot;http://www.w3cmm.com&quot;);        // window.parent.postMessage(data,&apos;*&apos;);
        }    

    &lt;/script&gt;


iframe的父子窗口操作:

    iframe获取父窗体的元素: window.parent.xxxx

        如果iframe嵌套多层，直接获取最顶层的窗体 window.top.xxxx

    父窗体获取iframe内的元素: oIfr.contentWindow.document.body.offsetHeight
</code></pre><h4 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h4><pre><code>webScoket提供了浏览器和服务器之间的长链接通信，只有一方提出断开socket才会断开，否则使终链接状态

传统使用Ajax轮询来定时获取服务器的数据，缺点是每隔一断时间就需要请求一次服务器，都需要创建一次TCP和断开一次TCP连接，HTTP请求，会对服务器有压力，
使用webScoket就可以省去连接的步聚，客户端可以一直侦听服务器端推送的数据来进行处理就可以了.

创建WebSocket对象 var oWebSocket = new WebSocket(&apos;ws://192.168.1.1:8005/socket&apos;);

属性: 
    1、readyState: 获取socket的状态 [&quot;正在连接&quot;, &quot;已建立连接&quot;, &quot;正在关闭连接&quot;, &quot;已关闭连接&quot;]

方法: 
    1、send(data): 向服务器发送数据

    2、close(): 关闭socket连接


事件: 
    1、onmessage(): 接收服务器发送的消息

    2、onopen(): 侦听打开socket

    3、onclose(): 侦听关闭socket时

示例: 
    &lt;script&gt;
         var statusArr = [&quot;正在连接&quot;, &quot;已建立连接&quot;, &quot;正在关闭连接&quot;, &quot;已关闭连接&quot;];

        var oSocket = new WebSocket(&quot;ws//www.baidu.com:8089&quot;);            // 必须使用ws或wss开头

        // 侦听socket打开事件
        oSocket.onopen = function(evt){
            console.log(statusArr[oSocket.readyState]);
        }

        // 侦听socket关闭
        oSocket.onclose = function(evt){
            console.log(statusArr[oSocket.readyState]);
        }

        // 侦听接收服务器端传来的数据
        oSocket.onmessage = function(evt){
            var data = evt.data;
            console.log(data);
        }

        // 向服务器发送数据
        $(&quot;#box&quot;).click(function(){
            oSocket.send(&quot;向服务器发送数据&quot;)
        })

        // 断开与服务器的socket连接
        $(&quot;#close&quot;).click(function(){
            oSocket.close();
        })
    &lt;/script&gt;
</code></pre><h4 id="本地存储-localStorage、sessionStorage"><a href="#本地存储-localStorage、sessionStorage" class="headerlink" title="本地存储 localStorage、sessionStorage"></a>本地存储 localStorage、sessionStorage</h4><pre><code>本地存储与cookie的区别

    cookie: 存储量比较少（浏览器不同，大致4k），有个数限制，会随请求发送到服务器

    localStorage: 永久存储，每个域存储（5MB，浏览器不同），总体数量无限制

    sessionStorage: 只在session内有限，存储没有限制

方法: 
    1、setItem(key, value): 保存数据

    2、getItem(key): 获取数据

    3、clear(): 清空存储中的所有数据

    4、removeItem(key): 删除存储中的一项

    5、key(n): 返回存储中的第n个键名

    length: 返回存储数量

监听: 
    window.addEventListener(&apos;storage&apos;, showStorageEvent, false);
</code></pre><h4 id="web-Workers-多线程"><a href="#web-Workers-多线程" class="headerlink" title="web Workers 多线程"></a>web Workers 多线程</h4><pre><code>js是单线程，页面有大量计算就很容易阻塞页面的执行，H5可以使用web workers来处理.

创建web workers对象:  new Worker(&apos;work.js&apos;);

方法: 
    1、postMessage(data): 向web workers传送数据

事件: 
    1、onmessage(): 监听处理完发送的数据

    2、onerror(): 错误时处理的事件

Example: 

    main.js: 
        var oWorker = new Worker(&apos;js/worker.js&apos;);
        oWorker.postMessage(1000000);    // 发送要处理的数据
        oWorker.onmessage = function(ev){
            var od = ev.data;            // 接收处理完的值
        }

    worker.js
        onmessage = function(ev){    // 侦听传来的数据
            var od = ev.data;
            var num = 20;
            for(var i=0; i&lt;od; i++){
                num *= i;
            }
            postMessage(num);        // 多处理处理完返回的数据
        }


注意: 
    1、多线程必须要在服务环境下进行开发，否则会报错   
    2、处理线程的JS文件，没有window，document，DOM等对象。但是可以使用navigator，location，XMLHttpRequest等对象。
        这些限制导致了Web Worker一般用于有耗时较长的业务中，比如有大量计算的页面
</code></pre><h4 id="Geoloation-地理位置"><a href="#Geoloation-地理位置" class="headerlink" title="Geoloation 地理位置"></a>Geoloation 地理位置</h4><pre><code>处于安全考虑，地理位置信息属于用户隐私，当浏览器获取设备信息需要得到用户的确认

检测是否可以使用:

    if(navigator.geoloation){
        // 支持地址位置信息
    }

一、Geoloation方法: 

    1、getCurrentPosition(      // 首次取得当前地理位置
            function(position){
                // 返回坐标回调 position对象
                pos.latitude
            },
            function(error){
                // 错误显示
            },
            {对象用来处理如何获取位置}
        }

    2、watchPosition(): 监听不断变化的移动设备，原理与steInterval差不多，用法与getCurrentPosition一样也是三个参数

    3、clearWatch(): 删除监听watchPosition()

    Example:
        navigator.geoloation.getCurrentPosition(function(pos){
            // pos.coords.latitude;        // 当前纬度
        })


二、position对象: 获取地理位置成功后返回position对象

    属性: 
        1、latitude: 纬度

        2、longitude: 经度

        3、altitude: 海拔

        4、accuracy: 纬度或纬度的精度（以米为单位）

        5、altitudeAccurancy: 获取到海拔高度的精度（以米为单位）

        6、heading: 设备前进方向，以旋转角度来表示

        7、speed: 设备前进的速度（以米/秒为单位）

        8、timestamp: 获取地理位置信息的时间

    错误返回三种值: 1 = 用户拒绝了位置服务、 2 = 获取不到位置信息、3 = 获取信息超时错误

    timeout: 几秒后获取不到返回失败

    maxmumAge: 对地理位置 进行缓存的有效时间（毫秒）

    Example:
        &lt;script&gt;
            var oBox = getId(&quot;box&quot;);
            var sHtml = [];

            function getId(id){
                return document.getElementById(id);
            }

            function successFun(position){
                console.log(&quot;地理位置是: &quot; +position.coords.latitude+&quot;，&quot;+position.coords.longitude);
            }

            function errorFun(err){
                // console.log(err.message); // 错误信息
                // console.log(err.code);    // 错误码

                switch(err.code){
                    case 1:
                        alert(&quot;用户拒绝了位置服务&quot;);
                        break;
                    case 2:
                        alert(&quot;获取不到位置信息&quot;);
                        break;
                    case 3:
                        alert(&quot;获取信息超时错误&quot;);
                        break;
                }
            }

            // 创建geolocation对象
            function createGeolocation(){
                if(navigator.geolocation){  // 标准浏览器支持

                    // 获取坐标
                    navigator.geolocation.getCurrentPosition(successFun, errorFun, {
                        // 设置缓存有效时间为2分钟
                        maximumAge : 60*1000*2,

                        // 5秒内未获取到地理位置则返回错误
                        timeout : 10000
                    })
                }
                else{
                    alert(&quot;你使用的是非标准浏览器&quot;);
                }
            }

            createGeolocation();
        &lt;/script&gt;

http://www.alloyteam.com/2015/08/mobile-phone-location-on-the-sensor/
</code></pre><h4 id="Video-和-audio-多媒体"><a href="#Video-和-audio-多媒体" class="headerlink" title="Video 和 audio 多媒体"></a>Video 和 audio 多媒体</h4><h4 id="canvas绘图"><a href="#canvas绘图" class="headerlink" title="canvas绘图"></a>canvas绘图</h4><h4 id="History-历史管理"><a href="#History-历史管理" class="headerlink" title="History 历史管理"></a>History 历史管理</h4><pre><code>可以在添加一条记录到历史记录的列表中，或者在没有刷新时，可以更新地址栏的URL。单页面的的跳转就用到了这里

例Vue的路由有两种模式: hash和history, history就用到了历史管理，使url改变不会去请求http

一、JS对象

    1、length: 浏览器历史列表url的数量

    2、back(): 向后一个url

    3、forward(): 向前一个url

    4、go(-1): 指定跳转到哪个历史


二、HTML5提供两个新方法: 

    可以通过新增的方法做到页面跳转不重新请求页面

    1、history.state: 当前url下对应状态信息，如果当前url不是通过pushState或replaceState添加的, state 

    2、history.pushState(state, title, url): 在不刷新页面的情况下，添加历史记录，可以前进和后退

        state: 存储JSON字符串

        title: 浏览器不支持设置null

        url: 更新浏览器的地址

    3、history.replaceState(): 与pushState基本上同，不同的是不可以前进和后退

    4、popstate 事件: 侦听前进和后退

    Example:

        window.addEventListener(&apos;popstate&apos;, function(e){
            getContent(location.pathname, false);
        })

        var getContent=(url, addEnter) =&gt; {
            $.get(url, function(dat){
                history.pushState(null, null, url)
            })
        }

https://segmentfault.com/a/1190000002468274
http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/
http://www.cnblogs.com/flash3d/archive/2013/10/23/3384823.html
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/移动端的那些积累/">移动端的那些积累</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/移动端的那些积累/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/移动端积累/">移动端积累</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="移动端特性"><a href="#移动端特性" class="headerlink" title="移动端特性"></a>移动端特性</h4><pre><code>手机端的web页(H5)

跨平台（手机端、PC端）

基于webview
</code></pre><h4 id="webkit-常用属性"><a href="#webkit-常用属性" class="headerlink" title="-webkit- 常用属性"></a>-webkit- 常用属性</h4><pre><code>http://ued.ctrip.com/webkitcss/   整理的webkit属性集合

&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalabel=no&quot;&gt;

1、-webkit-appearance: none;     // 用于移IOS下移除原生样式

2、text-size-adjust: 100%;       // webkit内核浏览器可以让终端字体小于12px

    iPhone 和 Android 的浏览器纵向和橫向时自动调整字体大小的功能。通过 text-size-adjust 设为 none 或者 100% 关闭字体大小自动调整功能.
    html {
        font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, Arial, sans-serif;
        -ms-text-size-adjust: 100%;
        -webkit-text-size-adjust: 100%; 
    }

3、overflow-scrolling  硬件加速, 在body中设置

    body {
        /*height: 100%;*/
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch; 
    }

4、tap-highlight-color  用户点击iOS的Safari浏览器中的链接或JavaScript的可点击的元素时，覆盖显示的高亮颜色

    a {
        -webkit-tap-highlight-color: transparent;
    }

5、touch-callout  当触摸并长按住的时候，禁止或显示系统默认菜单

    a {
        -webkit-touch-callout: none
    }

    window.ontouchstart = function(e) {
        if (e.target.tagName === &apos;img&apos;)
             e.preventDefault();
    }

6、pointer-events:none;
</code></pre><h4 id="viewport-视图"><a href="#viewport-视图" class="headerlink" title="viewport 视图"></a>viewport 视图</h4><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;

    width - 设置viewport宽度，为一个正整数，或字符串‘device-width’

    height - 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置

    initial-scale - 默认缩放比例，为一个数字，可以带小数

    minimum-scale - 允许用户最小缩放比例，为一个数字，可以带小数

    maximum-scale - 允许用户最大缩放比例，为一个数字，可以带小数

    user-scalable - 是否允许手动缩放
</code></pre><h4 id="不同屏幕的适配方案"><a href="#不同屏幕的适配方案" class="headerlink" title="不同屏幕的适配方案"></a>不同屏幕的适配方案</h4><pre><code>通过响应式技术，在不同设备上使用同一套代码来展示

1、设置@media      2、rem       3、vw/vh

一、@media 媒体查询 

    @media screen and(min-width: 500px){    // 大于500px执行下面代码
        ...
    }

二、rem

    rem会根据根元素&lt;html&gt;的fontSize的大小来变化，需要运用js来计算根据屏幕宽度或来计算html的赋值

    1、普通CSS写法

        html { font-size: 16px; }
        div { width: 2rem; }

    2、Sass的工程: 

        前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即: 
        @function px2rem($px){
            $rem : 37.5px;
            @return ($px/$rem) + rem;
        }

        调用
        height: px2rem(90px);
        width: px2rem(90px);

三、vw、vh

    上面两种不是特别完美，媒体查询不能做到等比例响应，rem需要js与css耦合在一起，而且vw/vh就不需要

    计算vm方法: 16 / 750 * 100 = 2.13vw;        // 16是px转rem的值，750

        html {
            font-size: 2.13vw;
        }

    vw: 视窗的宽度，视窗的宽度是100vw

    vh: 视窗的高度，视窗的高度是100vh

    vmin: 选取vw和vh中最小的那个

    vmax: 选取vw和vh中最大的那个

https://zhuanlan.zhihu.com/p/23968868
https://juejin.im/entry/59b00e46f265da2491513bcc
</code></pre><h4 id="移动端概念"><a href="#移动端概念" class="headerlink" title="移动端概念"></a>移动端概念</h4><pre><code>一、物理像素: 物理像素是屏幕的实际尺寸

二、设备独立像素: 设备像素与CSS像素之间的关系

三、设备像素比 dpr: 设备像素比 = 物理像素 / 设备独立像素;

    js获取设备像素比: window.devicePixelRatio        // devicePixelRatio = 物理像素 / 实际像素;

    iphoneX是3倍屏，其它都是2倍屏

    retina屏是超高像素密度屏，同样大小的屏幕上显示的像素点由1个变为多个，同样苹果设备的retina屏中，像素点1个变为4个

    1、根据不同的设备像素比来加载不同的图片

        // 例如图片宽高为: 200px*200px，那么写法如下
        .css{ width:100px;height:100px;background-size:100px 100px; }

        // 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px
        .css{ font-size:20px }

        // image-set设计Rentina背景图
        image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。
        .css {
            background: url(images/bg.jpg) no-repeat center;
            background: -webkit-image-set(
            url(images/bg.jpg) 1x,     //支持image-set普通屏
            url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan
        }

        // javscript的解决方案
        $(document).ready(function(){
            if (window.devicePixelRatio &gt; 1) {
                var lowresImages = $(&apos;img&apos;);

                images.each(function(i) {
                    var lowres = $(this).attr(&apos;src&apos;);
                    var highres = lowres.replace(&quot;.&quot;, &quot;@2x.&quot;);
                    $(this).attr(&apos;src&apos;, highres);
                });
            }
        });

    https://www.jianshu.com/p/c88e9489b583

四、设置不同像素比的响应样式

    /* 2倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 2.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
        }
    }

    /* 3倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 3.0){
        .bor-querymidea::after{
            -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
        }
    }
</code></pre><h4 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h4><pre><code>1、空白页基本meta标签

    &lt;!-- 设置缩放 --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;

    &lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注: IOS7.0版本以后，safari上已看不到效果） --&gt;
    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;

    &lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;
    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;

    &lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;
    &lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;


2、其他meta标签

    &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;
    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;

    &lt;!-- 避免IE使用兼容模式 --&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;

    &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;
    &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;

    &lt;!-- 微软的老式浏览器 --&gt;
    &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;

    &lt;!-- uc强制竖屏 --&gt;
    &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;

    &lt;!-- QQ强制竖屏 --&gt;
    &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;

    &lt;!-- UC强制全屏 --&gt;
    &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;

    &lt;!-- QQ强制全屏 --&gt;
    &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;

    &lt;!-- UC应用模式 --&gt;
    &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;

    &lt;!-- QQ应用模式 --&gt;
    &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;

    &lt;!-- windows phone 点击无高光 --&gt;
    &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre><h4 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h4><pre><code>一、dns-prefetch 预加载

    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://g.alicdn.com&quot;&gt;

    dns-prefetch, DNS解析往往导致了网站加载速度慢。现代浏览器针对这个问题开发了处理方式，它将域名缓存后，当用户点击其它页面地址后自动的获取


二、prefetch 连接网页预先加载

    当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用。prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。

    &lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;

三、preconnect 

    和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）

    &lt;link rel=&quot;preconnect&quot; href=&quot;http://css-tricks.com&quot;&gt;


http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/
</code></pre><h4 id="打电话发短信写邮件怎么实现"><a href="#打电话发短信写邮件怎么实现" class="headerlink" title="打电话发短信写邮件怎么实现"></a>打电话发短信写邮件怎么实现</h4><pre><code>一、打电话
    &lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;

二、发短信，winphone系统无效
    &lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;

三、写邮件

    // 注: 在添加这些功能时，第一个功能以&quot;?&quot;开头，后面的以&quot;&amp;&quot;开头

    1.普通邮件
    &lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）
    &lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;

    3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）
    &lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址
    &lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;

    5.包含主题，用?subject=
    &lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;

    6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 
    &lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;

    7.内容包含链接，含http(s)://等的文本自动转化为链接
    &lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;

    8.内容包含图片（PC不支持）
    &lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;

    9.完整示例
    &lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;
</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>一、美化表单元素

    // 使用appearance改变webkit浏览器的默认外观
    input,select { -webkit-appearance:none; appearance: none; }

    // winphone下，使用伪元素改变表单元素默认外观
    1、禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰
        select::-ms-expand { display:none; }

    2、禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰
        input[type=radio]::-ms-check,
        input[type=checkbox]::-ms-check { display:none; }

    3、禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰
        input[type=text]::-ms-clear,
        input[type=tel]::-ms-clear,
        input[type=number]::-ms-clear { display:none; }


二、其它实用的css

    1、去掉webkit的滚动条——display: none;
        // 其他参数
        ::-webkit-scrollba //滚动条整体部分
        ::-webkit-scrollbar-thumb   //滚动条内的小方块
        ::-webkit-scrollbar-track   //滚动条轨道
        ::-webkit-scrollbar-button  //滚动条轨道两端按钮
        ::-webkit-scrollbar-track-piece  //滚动条中间部分，内置轨道
        ::-webkit-scrollbar-corner       //边角，两个滚动条交汇处
        ::-webkit-resizer            //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件

    2、禁止长按链接与图片弹出菜单
        a,img { -webkit-touch-callout: none }    

    3、禁止ios和android用户选中文字
        html,body {-webkit-user-select:none; user-select: none; }

    4、改变输入框placeholder的颜色值
        ::-webkit-input-placeholder { /* WebKit browsers */color: #999; }
        :-moz-placeholder { /* Mozilla Firefox 4 to 18 */color: #999; }
        ::-moz-placeholder { /* Mozilla Firefox 19+ */color: #999; }
        :-ms-input-placeholder { /* Internet Explorer 10+ */color: #999; }
        input:focus::-webkit-input-placeholder{ color:#999; }

    5、android上去掉语音输入按钮
        input::-webkit-input-speech-button {display: none}

    6、阻止windows Phone的默认触摸事件
        /*说明: winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如: */
        html { -ms-touch-action:none; } //禁止winphone默认触摸事件

        取消input在ios下，输入的时候英文首字母的默认大写
        &lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;

    7、手机拍照和上传图片
        // IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持
        &lt;input type=&quot;file&quot; accept=&quot;images/*&quot; /&gt;
        &lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;
</code></pre><h4 id="播放视频不全屏"><a href="#播放视频不全屏" class="headerlink" title="播放视频不全屏"></a>播放视频不全屏</h4><pre><code>&lt;!--
    1.ios7+支持自动播放
    2.支持Airplay的设备（如: 音箱、Apple TV)播放
    x-webkit-airplay=&quot;true&quot; 
    3.播放视频不全屏
    webkit-playsinline=&quot;true&quot; 
--&gt;
&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt;
</code></pre><h4 id="bug修改"><a href="#bug修改" class="headerlink" title="bug修改"></a>bug修改</h4><pre><code>android 2.3 bug
// 1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉
// 2.after和before伪类无法使用动画animation
// 3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值
// 4.translate百分比的写法和scale在一起会导致失效，例如: 
-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)

android 4.x bug
// 1.三星 Galaxy S4中自带浏览器不支持border-radius缩写
// 2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分
// 3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色
// 4.android无法同时播放多音频audio

一、消除transition闪屏
    .css {
        -webkit-transform-style: preserve-3d;
        -webkit-backface-visibility: hidden;
        -webkit-perspective: 1000;
    }

二、开启硬件加速

    //目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。
    .css {
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
    }

三、渲染优化

    1、禁止使用iframe（阻塞父文档onload事件）

    2、禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）

    3、使用CSS3代码代替JS动画

    4、开启GPU加速

    5、使用base64位编码图片(不小图而言，大图不建议使用),以减少网络请求。比较耗费CPU。小图标优势在于: 减少HTTP请求、避免文件跨域、修改及时生效
</code></pre><p>—————————– 移动端的JS ——————————–</p>
<h4 id="移动端touch事件（区分webkit和winphone）"><a href="#移动端touch事件（区分webkit和winphone）" class="headerlink" title="移动端touch事件（区分webkit和winphone）"></a>移动端touch事件（区分webkit和winphone）</h4><pre><code>一、当用户手指放在移动设备在屏幕上滑动会触发的touch事件

    1、以下支持webkit

        touchstart: 当手指触碰屏幕时候发生。不管当前有多少只手指
        touchmove: 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生: 阻止页面滚动
        touchend: 当手指离开屏幕时触发
        touchcancel: 系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用

    2、TouchEvent对象 : 

        touches: 屏幕上所有手指的信息
        targetTouches: 手指在目标区域的手指信息
        changedTouches: 最近一次触发该事件的手指信息
        touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息

        event.changedTouches[0].clientX  获取移动端事件

    3、参数信息(changedTouches[0])

        clientX、clientY在显示区的坐标
        target: 当前元素

    4、事件响应顺序

        ontouchstart  &gt; ontouchmove  &gt; ontouchend &gt; onclick

    5、以下支持winphone 8

        MSPointerDown: 当手指触碰屏幕时候发生。不管当前有多少只手指
        MSPointerMove: 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生: 阻止页面滚动
        MSPointerUp: 当手指离开屏幕时触发


二、移动端的web页面click事件会产生200-300ms的延时响应

    移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。

    原因: 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。

        比如在点击一个&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;时，浏览器先捕获是单击还是双击缩放，所以捕获一次单击后，浏览器会hold一段时间来看是否有下一次点击，这个时间间隔就是300ms，这就是延时的由来，所以使用click来触发事件需要延时300ms后才生效

    解决方案: 
        fastclick可以解决在手机上点击事件的300ms延迟
        zepto的touch模块，tap事件也是为了解决在click的延迟问题
</code></pre><h4 id="屏幕旋转的事件orientationchange"><a href="#屏幕旋转的事件orientationchange" class="headerlink" title="屏幕旋转的事件orientationchange"></a>屏幕旋转的事件orientationchange</h4><pre><code>JS处理

    function orientInit(){
        var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight ? &apos;landscape&apos; : &apos;portrait&apos;;
        if(orientChk ==&apos;lapdscape&apos;){
            //这里是横屏下需要执行的事件
        }
        else{
            //这里是竖屏下需要执行的事件
        }
    }

    orientInit();
    window.addEventListener(&apos;onorientationchange&apos; in window?&apos;orientationchange&apos;:&apos;resize&apos;, function(){
        setTimeout(orientInit, 100);
    },false)    


CSS处理

    // 竖屏时样式
    @media all and (orientation:portrait){   }

    // 横屏时样式
    @media all and (orientation:landscape){   }
</code></pre><h4 id="audio元素和video元素在ios和andriod中无法自动播放"><a href="#audio元素和video元素在ios和andriod中无法自动播放" class="headerlink" title="audio元素和video元素在ios和andriod中无法自动播放"></a>audio元素和video元素在ios和andriod中无法自动播放</h4><pre><code>// 音频，写法一
&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;

// 音频，写法二
&lt;audio controls=&quot;controls&quot;&gt; 
    &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt;
    &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt;
    优先播放音乐bg.ogg，不支持在播放bg.mp3
&lt;/audio&gt;

// JS绑定自动播放（操作window时，播放音乐）
$(window).one(&apos;touchstart&apos;, function(){
    music.play();
})

// 微信下兼容处理
document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () {
    music.play();
}, false);

// 小结
// 1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常
// 2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间
</code></pre><h4 id="重力感应事件"><a href="#重力感应事件" class="headerlink" title="重力感应事件"></a>重力感应事件</h4><pre><code>// 运用HTML5的deviceMotion，调用重力感应事件
if(window.DeviceMotionEvent){
    document.addEventListener(&apos;devicemotion&apos;, deviceMotionHandler, false)
}   

var speed = 30;
var x = y = z = lastX = lastY = lastZ = 0;
function deviceMotionHandler(event){
    var acceleration = event.accelerationIncludingGravity;
    x = acceleration.x;
    y = acceleration.y; 
    z = acceleration.z;
    if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed ){
        //这里是摇动后要执行的方法 
        yaoAfter();
    }
    lastX = x;
    lastY = y;
    lastZ = z;
}

function yaoAfter(){
    //do something
}
</code></pre><h4 id="设备判断"><a href="#设备判断" class="headerlink" title="设备判断"></a>设备判断</h4><pre><code>一、JS判断设备

    function deviceType(){
        var ua = navigator.userAgent;
        var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];    
        for(var i=0; i&lt;len,len = agent.length; i++){
            if(ua.indexOf(agent[i])&gt;0){   
                return agent[i];     
                break;
            }
        }
    }
    deviceType();
    window.addEventListener(&apos;resize&apos;, function(){
        deviceType();
    })

二、JS判断微信浏览器

    function isWeixin(){
        var ua = navigator.userAgent.toLowerCase();
        if(ua.match(/MicroMessenger/i)==&apos;micromessenger&apos;){
            return true;
        }else{
            return false;
        }
    }
</code></pre><h4 id="前端动画的几种方式"><a href="#前端动画的几种方式" class="headerlink" title="前端动画的几种方式"></a>前端动画的几种方式</h4><pre><code>一、动画方式

    1、css3的transition 和 animattion

    2、定时器, 最原始的“window.setTimout()”或者“window.setInterval()” 不断更新元素的状态位置等来实现动画

    3、requestAnimationFrame方法

    4、canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现

    5、SVG、WebGL

二、requestAnimationFrame  注意 Android不支持此方法

    requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。

    设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。

    1、对requestAnimationFrame方法处理兼容:

        window.requestAnimFrame = (function(){
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element){
                    window.setTimeout(callback, 1000 / 60);
                };
        })();

    2、Example

        &lt;div id=&quot;demo&quot; style=&quot;position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;&quot;&gt;&lt;/div&gt;
        &lt;script&gt;
            var demo = document.getElementById(&apos;demo&apos;);
            function render(){
                demo.style.left = parseInt(demo.style.left) + 1 + &apos;px&apos;; //每一帧向右移动1px
            }
            var requestID = requestAnimationFrame(function(){
                render();
                //当超过300px后才停止
                if(parseInt(demo.style.left) &lt;= 300) {
                    requestAnimationFrame(arguments.callee);        // arguments.callee调用函数本身，或者给函数一个名，参数传个名
                }
            });

            // cancelAnimationFrame(requestID);      // 停止动画重绘
        &lt;/script&gt;

三、常用动画库

    Ani.js -- 基于CSS动画的生命处理库
    Dynamics.js -- 创建具有物理运动效果动画的js库
    Animate.css -- 齐全的CSS3动画库
    Three.js -- 让用户通过javascript入手进入搭建webgl项目的类库

    http://www.tuicool.com/articles/uUfYry
    http://www.jianshu.com/p/280e0ef90b96
</code></pre><h4 id="其它API"><a href="#其它API" class="headerlink" title="其它API"></a>其它API</h4><pre><code>一、querySelector()、querySelectorAll()

    获取元素 document.querySelector(&apos;#app&apos;);

二、window.devicePixelRatio 获取设备像素比，也叫做dpr

    这个属性是系统自动算出来的值返回给window.devicePixelRatio，公式就是

    // 比如ipone6 750px物理像素 / 375px设备像素，所以dpr为2，有这个属性不用我们就不用去算
    window.devicePixelRatio = 物理像素 / 设备独立像素;

三、getBoundingClientRect  js判断可视区域

    var htmlWidth = document.documentElement.getBoundingClientRect().width;     // html文档的宽度
    var top = document.documentElement.getBoundingClientRect().top;      // 元素顶端到可见区域顶端的距离
    var se = document.documentElement.clientHeight; // 浏览器可见区域高度。

四、document.documentElement、document.body

    document.body 获取body文档
    document.documentElement 获取HTML整个文档，从&lt;!DOCTYPE html&gt;开始

五、document.documentElement.getBoundingClientRect().width   获取html文档宽度

    获取文档可视区宽度

    问题
        document.body.clientWidth;   // 这里取的是body的宽度，如果body的宽度被改变
        window.innerWidth;      // 这里获取的是整个宽口的宽度，包括滚动条

    解决方法: document.documentElement.getBoundingClientRect().width
</code></pre><h4 id="fetch-新一代ajax"><a href="#fetch-新一代ajax" class="headerlink" title="fetch 新一代ajax"></a>fetch 新一代ajax</h4><pre><code>一、fetch的请求设置与响应

    fetch(&apos;/some/url&apos;, {
        method: &apos;get&apos;
    })
    .then(function(response) {
        // 成功
    })
    .catch(function(err) {
        // 出错了;等价于 then 的第二个参数,但这样更好用更直观 :(
    });


二、设置Header头

    fetch(&apos;https://www.baidu.com/search/error.html&apos;, {
        method: &apos;POST&apos;,
        headers: new Headers({
            &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;     // 指定提交方式为表单提交
        }),
        body: new URLSearchParams([[&quot;foo&quot;, 1],[&quot;bar&quot;, 2]]).toString()
    })
    .then((res)=&gt;{
        return res.text()
    })
    .then((res)=&gt;{
        console.log(res)
    })

fetch没有拦截请求和响应数据的功能，在单页面路由跳转时会需要提前去查看用户的一些登录信息，这时候需要使用Axios插件
</code></pre><h4 id="问题收集"><a href="#问题收集" class="headerlink" title="问题收集"></a>问题收集</h4><pre><code>一、keydown侦听输入个数时，中文输入法输入个数的问题 

    let username = document.querySelector(&apos;#username&apos;);

    // 如果输入中文，输入法比如输 &quot;物品&quot; 五笔需要输入 &quot;trkk&quot;，这样size为4，这样对中文判断长度会有问题
    $(&apos;#username&apos;).on(&apos;keydown&apos;, function(){
        let size = $(this).val().length;
        console.log(size);    
    })

    // 解决方法，侦听compositionend事件，返回的size正常
    $(&apos;#username&apos;).on(&apos;compositionend&apos;, function(){
        let size = $(this).val().length;
        console.log(size);  
    })

    http://www.alloyteam.com/2017/03/moves-the-input-box-fill-series-a/
    http://www.alloyteam.com/2016/12/alloytouch-full-screen-scroll-plugin-released-30-seconds-to-get-smooth-page-h5/


二、Retina屏1px边框处理

    高清屏，1px实际是2x2个像素来渲染，有的还是3x3，所以border: 1px 移动端会渲染为2px或3px

    &lt;div class=&quot;bor-box&quot;&gt;
        &lt;div class=&quot;bor-querymidea&quot;&gt;通过伪类创建边框，在通过媒体查询来适配&lt;/div&gt;
    &lt;/div&gt;

    解决方法

    1、通过-webkit-min-device-pixel-ratio 来确定两倍屏来修改边框大小

        .bor-querymidea{
            border: 1px #ccc solid;
        }

        /* 2倍屏 */
        @media only screen and (-webkit-min-device-pixel-ratio: 2.0){
            .bor-querymidea{
                /* border: 0.5 #ccc solid;   retina屏是不识别0.5px，会解释为0 */
                -webkit-transform: scaleY(0.5);
                transform: scaleY(0.5);
            }
        }

        /* 3倍屏 */
        @media only screen and (-webkit-min-device-pixel-ratio: 3.0){
            .bor-querymidea{
                -webkit-transform: scaleY(0.33);
                transform: scaleY(0.33);
            }
        }

    2、js判断如果devicePixelRation的值

        devicePixelRation = 2; 输出viewport: &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;

        devicePixelRatio = 3; 输出 &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.333, maximum-scale=0.333, minimum-scale=0.333, user-scalable=no&quot;&gt;

    https://www.jianshu.com/p/7e63f5a32636          // 7咱方法


三、设置viewport 缩放比例

    (function(doc, win) {
        var scale = 1.0;
        if (win.devicePixelRatio === 2) {
            scale *= 0.5;
        }
        if (win.devicePixelRatio === 3) {
            scale *= 0.333333;
        }
        var text = &apos;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale +&apos;, minimum-scale=&apos; + scale + &apos;, width=device-width, user-scalable=no&quot; /&gt;&apos;;
        doc.write(text);       
    })(document, window);

    https://www.cnblogs.com/stella1024/p/7199832.html
</code></pre><h4 id="收集工具"><a href="#收集工具" class="headerlink" title="收集工具"></a>收集工具</h4><pre><code>1、browsersync 多端浏览器同步测试工具  http://www.browsersync.cn/

2、lib-flexible 处理根据屏幕的尺寸将Html中的font-size的值自动转换  https://github.com/amfe/lib-flexible

3、sublime的px转rem的插件   https://github.com/flashlizi/cssrem
</code></pre><p>| <a href="http://www.uigreat.com/page/guifan" target="_blank" rel="noopener">http://www.uigreat.com/page/guifan</a>            // 移动端屏幕尺寸集合<br>| <a href="http://cubic-bezier.com/#.55,.01,.38,.99" target="_blank" rel="noopener">http://cubic-bezier.com/#.55,.01,.38,.99</a>         // 调节css3动画效果并导出代码<br>| <a href="https://segmentfault.com/a/1190000007075834" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007075834</a>   // Retina屏<br>| <a href="http://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=404009356&amp;idx=1&amp;sn=e3218b95b78a5f043e7b0e3df49703d3&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=404009356&amp;idx=1&amp;sn=e3218b95b78a5f043e7b0e3df49703d3&amp;scene=4#wechat_redirect</a><br>| <a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html</a><br>| <a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/#prettyPhoto" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/#prettyPhoto</a>  rem<br>| <a href="https://github.com/amfe/article/issues/17" target="_blank" rel="noopener">https://github.com/amfe/article/issues/17</a>     // 淘宝H5终端适配</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/ES5/">ES5</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/ES5/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h4><pre><code>1、async: 异步下载当前脚本，不阻塞后续代码的执行

2、charset: 字符集

3、defer: 表示当前脚本延迟到文档完全被解析和显示后在执行 defer=&quot;defer&quot;

4、src: 文件路径

5、language: 语言

6、type: 脚本类型

&apos;use strict&apos; 严格模式
</code></pre><h4 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h4><pre><code>作用域: 变量和函数可访问的范围，作用域分为局部和全局，函数中声明的变量叫局部变量，在window对象下定义的变量为全局变量

作用域链: 决定哪些变量能够被当前函数访问及访问顺序

    函数对象有一个[[Scope]]属性，包含了函数被创建作用域中对象的集合，集合被称为函数的作用域链scope chain，它决定了哪些数据能被函数访问

    function doSomething(){
        var blogName=&quot;Jessica&quot;;
        function innerSay(){
            alert(blogName);
        }
        innerSay();
    }
    alert(blogName);        //脚本错误
    innerSay();             //脚本错误
</code></pre><h4 id="js预解析"><a href="#js预解析" class="headerlink" title="js预解析"></a>js预解析</h4><pre><code>JS执行时先将代码中所有 var定义变量和function(){} 进行提取，函数内部变量除外。

将var的变量赋为undefined

将函数都为函数本身function getName(){}，所以在调用函数时无论在前还是在后都会被调用。

Example:
    var add = &apos;bbb&apos;; 
    function add(){console.log(&apos;aaa&apos;)} 

    add();      报错
</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code>闭包: 函数嵌套，内部函数调用外部函数的局部变量，内部函数执行完后自动消毁，外部函数的变量不会被回收一直保存在内存中.

&lt;script&gt;
    var fun = function(){
        var a = 1;
        return function(){
            a++;
            alert(a);
        }
    }

    var f = fun();        // 这里返回了匿名函数的引用，里面的局部变量就不会被消毁
    f();    // 2
    f();    // 3
    f();    // 4
&lt;/script&gt;
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>一、函数没有重载: 当两个函数名相同，后面的函数会覆盖掉之前的函数

    function getUserName(){
        console.log(&apos;a&apos;);
    }

    function getUserName(){
        console.log(&apos;b&apos;);
    }

    getUserName();      // &apos;b&apos;


二、声明函数和匿名函数: 

    function person() {  ...  };          // 声明
    var person = function() {  ...  }     // 匿名

    Example:

        getName();          // b
        var getName = function(){       // 优先级要高于声明函数，但要必须执行到这里才有效
            console.log(&apos;a&apos;);
        };

        getName();          // a

        function getName(){
            console.log(&apos;b&apos;);
        }
        getName();          // a


三、函数参数

    1、形参、实参

        function add(a, b){ return a+b }    // 形参

        add(1,2)    // 实参


    2、arguments数组: 函数参数的数组

    3、callee 函数的调用当前函数的本身，可以使用arguments.caller(), 可以用于递归

        function factorial(num){
            if(num &lt; 1){
                return 1;
            }
            else{
                return num * arguments.callee(num-1);
            }
        }

    4、caller 返回被调用函数的本身

        function outer() {
            inner();
        }

        function inner() {
            alert(arguments.callee);        // function inner(){ ... }
            alert(arguments.callee.caller); // function outer(){ ... }
        }

        outer();

四、如果函数没有return返回undefined

    var fn = function(){ }; 
    fn();       // undefined
</code></pre><h4 id="call-、apply"><a href="#call-、apply" class="headerlink" title="call()、apply()"></a>call()、apply()</h4><pre><code>Function.prototype.call() 和 Function.prototype.apply() 用于改变函数的this指向

一、无参

    var obj1 = {
        name: &apos;siguang&apos;,
        getName: function(){
            return this.name;
        }
    }

    var obj2 = {
        name: &apos;lulu&apos;
    }

    console.log(obj1.getName());  // siguang

    // 注意这里是将getName中的this指定指向了obj2，并且执行了getName()函数
    var n1 = obj1.getName.call(obj2);
    console.log(n1);        // lulu

二、有参

    var objA = {
        num: 10,
        add: function(a, b){
            return a + b + this.num;
        }
    }
    var objB = {
        num: 20
    } 

    var n1 = objA.add(1, 2);
    console.log(n1);    // 13

    var n2 = objA.add.call(objB, 1, 2);     // 如果objA.add.apply(objB, [1,2]);
    console.log(n2)     // 23
</code></pre><h4 id="void-0"><a href="#void-0" class="headerlink" title="void(0)"></a>void(0)</h4><pre><code>这个操作符允许插入一个计算结果等效于undefined的表达式。

void操作符经常仅仅是用来获得undefined值，比如经常使用到的“void(0)”(这等效于“void 0”)

当浏览器遇到一个javascript:URI，它会运算带有URI的代码，然后将计算结果替换当前页面的内容，除非它的返回值是undefined。void操作符可以被用于返回undefined

&lt;a href=&quot;javascript:void(0);&quot;&gt;
    Click here to do nothing
&lt;/a&gt;
</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>一、 数据类型包括

    Number、String、Boolean、null、undefined

    获取数据的类型: 返回的值（number、string、boolean、array、object、function、undefined、null）

    Object.prototype.toString.call(val)

    // 判断类型
    function returnType(val) {
        let typeName;
        if (typeof val === &apos;object&apos;) {
            let typeName = Object.prototype.toString.call(val);

            if (typeName == &apos;[object Array]&apos;) {
                return &apos;array&apos;
            } else if (typeName == &apos;[object Object]&apos;) {
                return &apos;object&apos;
            }
            else if(typeName == &apos;[object Null]&apos;){
                return &apos;null&apos;
            }
        } else {
            return typeof val;
        }
    }


二、NaN 非数值

    isNaN() 是否是一个NaN非数值， 如果是数字返回false, 否则返回true

        isNaN(NaN);     // true
        isNaN(10);      // false
        isNaN(&apos;10&apos;);    // false 转换后是一个数字
        isNaN(&apos;blue&apos;);  // true 转换后不会是一个数字
        isNaN(true);    // false true转换后为1是一个数字


    数值转换:
        Number() 布尔转换成1或0，null返回0，undefined返回NaN，
        parseiInt()
        parseFloat()


toString(): 将该对象的原型始以字符串形式返回   xx.toString();       // &apos;xx&apos;

valueOf(): 返回最适合该对象的类型的原始值
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>var testA = 3 &amp;&amp; 2;             // 返回 2，如果左侧为真返回右侧，否则返回左侧

var testB = 0 || 3;             // 返回3，如果左侧为假返回右侧

var a = 1; console.log(!!a);    // 返回true，!!强制转换成布尔值

var a = &apos;123.563&apos;; console.log( +a );  // 123.563，+转换成数值类型
</code></pre><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><pre><code>for(var i=0; i&lt;10; i++){}

do{....} while(express)

while(){ ... }

for( in ){}

break 退出整个循环        continue 跳出当前循环，继续执行下一个循环

switch case default
</code></pre><h4 id="定时器的运行机制"><a href="#定时器的运行机制" class="headerlink" title="定时器的运行机制"></a>定时器的运行机制</h4><pre><code>JS的执行机制: 

    JS引擎执行JS的机制是基于事件循环，JS是单线程，同一时间只能执行一个任务，其它任务就得排队，后续任务需要前一个任务结束才能执行

    为了避免一些长时间任务造成的无意义等待，JS引入了异步，用另一个线程来管理异步任务

    同步任务在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程，等主线程队列执行完后，在去异步队列查询是否有可执行的异步任务

异步 - ajax、定时器、Promise

Example:

    // HTML5规范规定最小时间不能小于4ms(毫秒)，如果小于4会被当4来处理，Chrome可以设置1ms
    setTimeout(function(){
        console.log(1);
    }, 0);
    console.log(2);         // 先log出2，在log出1
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>一、事件机制: 事件捕获 和 事件冒泡, IE11之前没有捕获

二、事件委托

    事件委托（也称事件代理）: 将事件绑定到父元素上，利用冒泡机制来对点击的元素进行处理

    &lt;div id=&quot;boxList&quot;&gt;
        &lt;ul&gt;
            &lt;li data-attr=&quot;a1&quot;&gt;aaa&lt;/li&gt;
            &lt;li data-attr=&quot;a2&quot;&gt;bbb&lt;/li&gt;
            &lt;li data-attr=&quot;a3&quot;&gt;ccc&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var oList = document.querySelector(&apos;#boxList&apos;);
        oList.onclick = function(e){
            var arrtName = e.target.getAttribute(&apos;data-attr&apos;);
            console.log(arrtName);
        }
    &lt;/script&gt;


三、自定义事件

四、onLoad与DOMContentLoaded事件的区别

    onLoad: 是当所有资源都加载完成后在执行onLoad函数内的程序

    DOMContentLoaded: 是当DOM树加载完成后就执行此函数内的程序


五、onmouseover、onmouseout与onmouseEnter、onmouseLeave

    onmouseover、onmouseout 会冒泡

    onmouseEnter、onmouseLeave 不会冒泡


六、addEventListener(事件类型, 执行函数, boolear): 第三个参数，如果是true表示在捕获取中调用事件，false冒泡时调用

    这里执行的函数不会被重载

    var oSendBtn = document.querySelector(&apos;#sendBtn&apos;);      // 点击会输出&apos;aa&apos;, &apos;bb&apos;

    oSendBtn.addEventListener(&apos;click&apos;, function(){
        console.log(&apos;aa&apos;);
    }, false);

    oSendBtn.addEventListener(&apos;click&apos;, function(){
        console.log(&apos;bb&apos;);
    }, false);
</code></pre><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>一、加载非阻塞脚本:  

    浏览器遇到 &lt;script&gt; 标签时，页面加载都会停下来，先执行js代码，然后在继续加载（因为不知道脚本里有没有document.wirte()
    来向页面写内容，所以会需要先执行完js文件在继续）

    使用动态创建DOM元素，将脚本加载放到&lt;/body&gt;之前来加载，这样不会影响页面的内容展示


二、按需加载: 可以分图片按需加载，js文件按需加载、数据接需加载

    图片按需加载使用的lazyload

    JS按需加载类似模块化开发，只对依赖的文件进行加载


三、图片预加载: 通过new Images()来创建图像对象提前将图片进行加载

    function preloadImg(url) {
        var img = new Image();
        img.src = url;
        if(img.complete) {
            //接下来可以使用图片了
            //do something here
        }
        else {
            img.onload = function() {
                //接下来可以使用图片了
                //do something here
            };
        }
    }
</code></pre><h4 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h4><pre><code>由于同源策略，安全性，ajax不同域下的数据不可以调用

跨域的产生: 1、同域名不同端口        2、同域名不同协议        3、主域和子域之间        4、子域和子域之间

解决跨域的方法: 

一、JSONP

    JSONP利用script标签中的src属性，src属性没有跨域限制，通过url的参数将回调函数的名称和数据请求给服务器，服务器接收到url参数进行处理，并将数据挂载到回调函数的参数并执行回调函数，客户端有与回调函数名相同，来处理这些数据

    // 处理回调函数数据的函数
    function doSomething(data) {
        // 对data处理
    }
    var script = document.createElement(&quot;script&quot;);
    script.src = &quot;http://www.b.com/b.html?callback=doSomething&quot;;
    document.body.appendChild(script);


二、document.domain: 

    适用于主域相同子域不同，比如 www.renrendai.com 和 action.renrendai.com

    例如: 两个域下各有a.html和b.html, a通过iframe嵌到另一个子域b.html是无权访问b.html文档内的元素, 所以通过document.domain来设置

    a.html: 
        document.domain = &quot;www.we.com&quot;;
        var iframe = document.createElement(&quot;iframe&quot;);
            iframe.src = &quot;http://a.we.com/b.html&quot;;
            document.body.appendChild(iframe);
            iframe.onload = function() {
                console.log(iframe.contentWindow....); // 在这里操作b.html里的元素数据
        }

    b.html:
       document.domain = &quot;www.we.com&quot;;       // b页面必须要设置a.html


三、HTML5 postMessage() 处理iframe跨域问题

    如果在一个主域中的a.html嵌套个 &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

    postMessage有两个接口: postMessage(send) 发送数据和 onmessage接收数据事件通过e.data来获取到

    Example: 
        // a.html
        &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot; id=&quot;messageId&quot;&gt;&lt;/iframe&gt;

        var oMessage = document.getElementById(&apos;messageId&apos;);
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收b的数据
            }, false);
            oMessage.postMessage(&apos;发送给b的数据&apos;, &apos;http://www.b.com/b.html&apos;);
        }

        // b.html
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收a的数据
            })
            window.parent.postMessage(&apos;发送给a的数据&apos;, &apos;http://www.a.html/a.html&apos;);
        }

    传统的iframe跨域使用方法: http://www.cnblogs.com/snandy/p/3900016.html


四、window.name + iframe

    window.name原理是利用同一个窗口在不同页面共用一个window.name，这个需要在a.com下建立一个代理文件c.html，使同源后a.html能获取c.html的window.name.

        // a.html
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.b.com/b.html&quot;;
        document.body.appendChild(iframe); // 现在a.html里建一个引用b.html的iframe，获得b的数据

        var flag = true;
        iframe.onload = function() {
            if (flag) {
                iframe.src = &quot;c.html&quot;;          // 这里在去加载c.html

                  // 判断是第一次载入的话，设置代理c.html使和a.html在同目录同源，这样才能在下面的else取到data
                flag = false;
            } 
            else { 
                // 第二次载入由于a和c同源，a可以直接获取c的window.name
                alert(iframe.contentWindow.name);

                iframe.contentWindow.close();
                document.body.removeChild(iframe);
                iframe.src = &apos;&apos;;
                iframe = null;
            }
        }

        // b.html
        window.name = &quot;这是 b 页面的数据&quot;;


五、window.location.hash + iframe

    b.html将数据以hash值的方式附加到c.html的url上，在c.html页面通过loaction.hash获取数据后传到a.html

    // a.html
    var iframe = document.createElement(&quot;iframe&quot;);
    iframe.src = &quot;http://www.b.com/b.html&quot;;
    document.body.appendChild(iframe); // 在a页面引用b
    function check() { 
        // 设置个定时器不断监控hash的变化，hash一变说明数据传过来了
        var hashs = window.location.hash;
        if (hashs) {
            clearInterval(time);
            alert(hashs.substring(1));
        }
    }
    var time = setInterval(check, 30);

    //b.html
    window.onload = function() {
        var data = &quot;this is b&apos;s data&quot;; 
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.a.com/c.html#&quot; + data;         
        document.body.appendChild(iframe); // 将数据附加在c.html的hash上
    }

    //c.html
    // 获取自身的hash再传到a.html的hash里，数据传输完毕
    parent.parent.location.hash = self.location.hash.substring(1);
</code></pre><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><pre><code>一、CORS概念: 是指跨域资源共享, 用于解决前端跨域问题, 使用自定义头部让浏览器与服务器进行沟通, 来进行请求成功或失败

    原理: 服务器对header设置一个Access-Control-Allow-Origin: *, 开启跨域请求。

    *表示接受所有域名的请求。也可以指定特定的域名 Access-Control-Allow-Origin: http://www.client.com。


二、CORS优点: 跨域最常用的是JSONP但这种方式是通过Get的方式请求src完成的，很多跨域问题JSONP无法解决，比如: 

    1、post请求跨域

    2、&quot;script error&quot; 的脚本错误提示

    3、canvas中无法获取跨域图片的信息，如果使用CORS上面几个问题就可以解决
</code></pre><p>   三、CORS缺点: </p>
<pre><code>1、cookie不会随请求发送，也不会响应

2、不能设置请求头的Content-Type字段

3、不能访问响应头信息
</code></pre><h4 id="Promise异步编程"><a href="#Promise异步编程" class="headerlink" title="Promise异步编程"></a>Promise异步编程</h4><h4 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h4><pre><code>同步: 就是代码逐行执行

异步: Promins、Ajax、setTimeout 来实现，执行到异步的代码时不会等待返回结果后在执行之后的代码，会直接往下执行。

同步和异步是针对单线程来讲的象JS，象Java一般不会说同步和异步，而是阻塞和非阻塞。
</code></pre><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><pre><code>面向对象的特点: 封装、继承、多态

对象组件: 私有、公有属性、方法和特权方法

一、constructor属性: 指向这个原型的构造函数，如果是类式继承需要修改子类的constructor的指向，如果不改子类会指向父类.

二、原型和原型链: 

    prototype原型: 在创建函数的时候JS会为这个函数自动加上prototype属性

    原型链: 每一个构造函数都有一个prototype, prototype包含一个指向构造函数的指针, 而实例包含指向原型的对象的指针, 都是通过 __proto__ 属性来指向

    1）构造函数实例化后，prototype下的所有属性和方法都为公用的一套, 这样为了节省资源提高性能

    2）优先级: 如果同时在构造函数内或prototype中定义相同的属性或方法名, 会先找到执行构造函数内的属性或方法, 如果没有在到prototype中查找。

        __proto__属性: __proto__是实例与prototype之间的链接，实例的__proto__指向构造函数的prototype.function F(){}; 

        var f = new F(); 
        console.log(f.__proto__ === F.prototype);           // true
        Object.prototype是顶级对象，所有对象都继承它

三、继承

    每个对象都是由Object.prototype对象继承的

    继承分为: 类式继承、原型链继承、拷贝继承。

    1、类式继承: 

        function Parent(){}
        Parent.prototype.say = function(){ 
            console.log(&apos;haha&apos;)
        }

        function Childer(){}

        /* 将第一个类的实例赋给第二个类的原形，类式继承的原因
        *  类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问
        */
        Childer.prototype = new Parent();   

        // 上一步执行后prototype的constructor会指向Parent，所以需要修正回来
        Childer.prototype.constructor = Childer;    
        Childer.prototype.getAuthor = function(){ console.log(&apos;siguang&apos;) }


    2、原型链继承: 

        // 原型链式继承
        /*
        * 流程:
        * 1、clonePlan调用blood属性会在clonePlan查找所有属性，
        * 2、如果没有找到在看clonePlan的__proto__指象哪里，这里指向了F，到F对象下的prototype下查找
        * 3、plane将prototype赋给了F的prototype所以最终找到了blood属性
        */

        function extend(obj){
            var F = function(){};
            F.prototype = obj;
            return new F();
        }

        // 定义一个类
        var Plane = function(){
            this.blood = 100;
            this.attackLevel = 1;
            this.defenseLevel = 1;
        }
        Plane.prototype = {
            getBlood: function(){
                console.log(this.blood);
            },
            getAttackLevel: function(){
                console.log(this.attackLevel)
            }
        }
        var plane = new Plane();

        // 将类通过extend函数继承过来
        var clonePlan = extend(plane);
        clonePlan.blood = 1234;
        clonePlan.attackLevel = 4567;

        clonePlan.getBlood();               // 1234
        clonePlan.getAttackLevel();         // 4567


    3、拷贝继承

        function extend(parent, childer){
            for(var key in parent){
                childer[key] = parent[key];
            }
        }

        extend(a.prototype, b.prototype);


    4、Object.create()继承

        function Car(desc){
            this.desc = desc;
            this.color = &apos;red&apos;
        }

        Car.prototype = {
            getInfo: function(){
                return `color: ${this.color}, desc: ${this.desc}`
            }
        }

        // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
        var child = Object.create(Car.prototype);
        child.desc = &apos;aaa&apos;;
        child.color = &apos;bbb&apos;;

        // 改变子类不会影响到父类
        console.log(child);
        var childCar = child.getInfo();
        console.log(childCar)       // color: bbb, desc: aaa


        var oCar = new Car(&apos;ccc&apos;);
        console.log(oCar.getInfo());    /// color: red, desc: ccc


四、SuperClass.prototype = {} 与 SuperClass.prototype.getName = function(){} 区别

    一个是将对象覆盖prototype, 一个是将方法添加到prototype中

    存在的问题，SuperClass.prototype = {}这种方式，实例的对象没有constructor,
</code></pre><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><pre><code>一、XMLHttpRequrest 缓存

    缓存只有在get请求中存在，如果服务端设置了缓存，如果在缓存失效前请求就会取到缓存的数据，解决有两种方法:

    1、加If-Modified-Since头

        xhr.setRequestHeader(&apos;If-Modified-Since&apos;, &apos;0&apos;);

        jquery中设置  $.ajax({ cache: false })

    2、给请求的URL后加参数 

        let sendUrl = &quot;http://host/getUser&quot;+&quot;?&quot;+Math.random();


// 创建一个XMLHttpRequest对象
var xhr = window.XMLHttpRequrest ? new XMLHttpRequrest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);   

属性: 服务器响应

    1、reponseText: 字符串响应数据

    2、responseXML: 获取XML响应数据

    3、timout: 设置超时请求时间

    4、responseType: 设置返回数据类型

        1、text: 字符串      2、document: Document对象       3、json: json数据       4、blob: 二进制对象       5、arrayBuffer: 二进制

方法: 

    1、open(请求类型，请求地址，同步/异步): 请求类型

    2、send(): 请求发送到服务器

    3、setRequestHeader(key，value): 设置请求头

    4、getResponseHeader(header)、getAllResponseHeaders(): 获取响应头

事件: 

    1、onabort: 停止传输

    2、onerror: 错误

    3、onload: 

    4、ontimout: 超时执行的事件

    5、onreadystatechange: 请求发送到服务器时，接收一些响应

        readyState: XMLHttpRequest的状态，

            0: 请求未初始化    1、服务器连接已建立      2、请求已接收     3、请求处理中     4、请求已完成，已响应

        status:  200: 成功  404:  未找到资源

        xhr.onreadystatechange = function(e){
            if(this.readyState == 4 &amp;&amp; this.state == 200){
                console.log(this.reponseText)
            }
        }

    6、upload: 上传 XMLHttpRequestUpload

        function uploadFile() {  
            // 创建FormData对象
            var fd = new FormData();
            // 添加值
            fd.append(&quot;fileToUpload&quot;, document.getElementById(&apos;fileToUpload&apos;).files[0]); 

            // 创建XMLHttpRequest()请求
            var xhr = new XMLHttpRequest();  
            // 文件上传时侦听progress事件
            xhr.upload.addEventListener(&quot;progress&quot;, uploadProgress, false);  

            xhr.addEventListener(&quot;load&quot;, uploadComplete, false);    // 载入 
            xhr.addEventListener(&quot;error&quot;, uploadFailed, false);     // 错误
            xhr.addEventListener(&quot;abort&quot;, uploadCanceled, false);   // 终止

            // 请求方式和地址
            xhr.open(&quot;POST&quot;, &quot;test2.php&quot;);  
            // 发送请求到服务器
            xhr.send(fd);  
        }

        function uploadProgress(evt) { 
            // evt.loaded 当前上传的大小， evt.total 文件总大小
            if (evt.lengthComputable) {  
                var percentComplete = Math.round(evt.loaded * 100 / evt.total);  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = percentComplete.toString() + &apos;%&apos;;  
            }  
            else {  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = &apos;unable to compute&apos;;  
            }
        }

        function uploadComplete(evt) {  
            /* This event is raised when the server send back a response */  
            alert(evt.target.responseText);  
        }

        function uploadFailed(evt) {  
            alert(&quot;There was an error attempting to upload the file.&quot;);  
        }

        function uploadCanceled(evt) {  
            alert(&quot;The upload has been canceled by the user or the browser dropped the connection.&quot;);  
        }
</code></pre><h4 id="content-type四种类型"><a href="#content-type四种类型" class="headerlink" title="content-type四种类型"></a>content-type四种类型</h4><pre><code>get请求包括请求头、状态行

post请求包括请求头、状态行、请求主体（主体类型设置就是content-type来处理）

Content-Type:

一、application/x-www-form-urlencoded: 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据

    jquery和ajax的默认的方式 content-type:「application/x-www-form-urlencoded;charset=utf-8」

    header:
    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/x-www-form-urlencoded;charset=utf-8 

    ** Form Data

        incomeTime: &quot;16:25:13&quot;
        serialNumber: &quot;223&quot;
        incomeBank: &quot;中央银行&quot;
        incomeAccount: &quot;穷逼&quot;


二、multipart/form-data: 一般用来上传文件，必须让 form 的 enctyped 等于这个值

    content-type: multipart/form-data

    POST http://wwwexamplecom HTTP/11 
    Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA 

    ** Request Payload

        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
        Content-Disposition: form-data; name=&quot;text&quot; 

        title 
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
        Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chromepng&quot; 
        Content-Type: image/png 

        PNG  content of chromepng  
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 


三、application/json: 告诉服务端消息主体是序列化后的 JSON 字符串

    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/json;charset=utf-8 

    // ajax请求
    var data = {&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]};
    $ajaxpost(url, data)success(function(result){

    });

    // 发送
    POST http://wwwexamplecom HTTP/11
    Content-Type: application/json;charset=utf-8

    ** Request Payload

        {&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]}


四、text/xml: XML文件作为编码方式的需要用到的类型

    POST http://wwwexamplecom HTTP/11
    Content-Type: text/xml

    ** Request Payload


五、HTML5中的fromData异步上传表单

    这里注意需设置 content-type:false 和 processData: false

    function upThumbSubmit() {
        if(!windowFormData) {　
            alert(&apos;your brower is too old&apos;);
            return false;
        }
        var formData = new FormData($( &quot;#upForm&quot; )[0]);
        var upLoadFile = documentquerySelector(&apos;upfile&apos;)files[0];
        formDataappend(&apos;file&apos;: upLoadFile);

        $ajax({
            url:&apos;?c=api&amp;a=upload&apos;,
            type:&apos;post&apos;,
            data:formData,
            processData: false,        // 不会被序列化
            contentType: false,        
            dataType:&apos;json&apos;,
            success:function(data){
                alert(data);
                return false;

            }
        });
    }
</code></pre><h4 id="iframe父子页面的通信"><a href="#iframe父子页面的通信" class="headerlink" title="iframe父子页面的通信"></a>iframe父子页面的通信</h4><pre><code>Example:

    parent.html:
        &lt;body&gt;
            &lt;iframe src=&quot;child.html&quot; frameborder=&quot;0&quot; id=&quot;child&quot;&gt;&lt;/iframe&gt;
        &lt;/body&gt;

    childe.html:
        &lt;body&gt;
            &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
        &lt;/body&gt;

一、父页面获取子页面

    &lt;script&gt;
        var myIframe = document.querySelector(&apos;#child&apos;), 
            childDocument;

        if(myIframe.document){
            childDocument = myIframe.docuemnt;
        }
        else{
            childDocument = myIframe.contentWindow.docuemnt;
        }

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;
    &lt;/script&gt;

    1、先获取iframe节点

        var myIframe = document.querySelector(&apos;#child&apos;);        // 或 myIframe = window.frames[&apos;child&apos;];

    2、获取iframe页面的document对象

        // ie浏览器
        var childDocument = myIframe.docuemnt;

        // 其它浏览器
        var childWindow = myIframe.contentWindow;     // 获取iframe的window对象
        var childDocument = myIframe.contentWindow.docuemnt;    // 获取iframe的document对象
        var childDocuemnt = myIframe.contentDocument;   // 也是获取document对象  与 myIframe.contentWindow.docuemnt 相同

    3、向id=&apos;box&apos;设置内容

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;


二、子页面获取父页面

    1、获取父页面的document对象

        var parentDocument = window.parent.document;

    2、如果iframe嵌套多个iframe，想直接取到最顶层的iframe

        var selfDocument = window.self.document;
</code></pre><p>——————— ES5 API ————————</p>
<h4 id="提供全局的JSON对象"><a href="#提供全局的JSON对象" class="headerlink" title="提供全局的JSON对象"></a>提供全局的JSON对象</h4><pre><code>1、JSON.parse(): 将字符串转成对象

2、JSON.stringify(): 将对象转成字符串
</code></pre><h4 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h4><pre><code>1、push(): 向数组最后插入内容   unshift():向数据最前面插入一项

2、pop(): 删除数组最后一项内容  shift(): 删除数组第一项内容

    var arr = [1, 2, 3];   
    console.log(arr.pop());     // 3
    console.log(arr)    // [1, 2]

3、reverse(): 数组顺序颠倒

4、sort(): 排序

    let arr = [1, 123, 23, 4, 125, 6, 2, 31];
    arr.sort(function(v1, v2) {
        return v1 &lt; v2 // 从大到小排列
    })

5、concat(): 两个数组进行合并, 也可以拷贝成为一个新数组，而不是带指向

        var arrA = [1,2,3];
        var arrB = arrA.concat();
        arrB.push(5,6,7);
        console.log(arrA);  // [1,2,3]
        console.log(arrB);  // [1,2,3,5,6,7]

6、slice(开始，结束): 返回一个子数组,  如果结束参数不传为从开始取到最后的值

    let arr = [125, 123, 31, 23, 6, 4, 2, 1];
    let newArr = arr.slice(2, 5);  
    console.log(newArr, arr);        // [31, 23, 6]    [125, 123, 31, 23, 6, 4, 2, 1]

7、splice(): 用于替换、插入、删除

    splice(1,3): 删除 下标1-3的数据
    splice(3,0, &apos;insert&apos;): 插入 在位置3一个&apos;insert&apos;字符串
    splice(2,4, &apos;replce&apos;): 替换 将2-4的数组用 &apos;replce&apos;符

8、indexOf(): 查找数组中指定的字位的位置，未找到返回-1

    var arr = [1,2,3,4,5,6];  arr.indexOf(3);         // 返回2

9、lastIndexOf(): 查找数组中指定的字位的位置，从后向前查找，未找到返回-1


* 迭代方法

10、every(): 每一项为true，结果返回true

    // 数组中是否包含大于2的数
    var num = [1,2,3,2,1];
    var result = num.every(function(item,index,array) {    // item: 1, index: 0, array: [1,2,3,2,1]
        return (item &gt; 2);
    })
    console.log(result);        // true


11、some(): 有一项为true就不会往下执行，并返回true

    var dwarfPlanets = [&quot;ceres&quot;, &quot;pluto&quot;, &quot;haumea&quot;, &quot;makemake&quot;, &quot;eris&quot;];
    var result = dwarfPlanets.some(function(element) {
        return (element === &quot;pluto&quot;);
    });   
    console.log(result)     // true


5、filter(): 条件中返回true结果，重新返回一个新数组

    var arr = [1, 2, 3, 2, 5, 7];
    var result = arr.filter(function(item,index,array){
        return (item &gt; 2);
    })
    console.log(result);        // [3, 5, 7];


6、forEach(): 遍历数组, forEach无法跳出循环, 只能通过try...catch

    var arr = [&apos;lulu&apos;, &apos;siguang&apos;, &apos;mama&apos;, &apos;baba&apos;];
    arr.forEach(function(item, index, arr){  // lulu  0  [&quot;lulu&quot;, &quot;siguang&quot;, &quot;mama&quot;, &quot;baba&quot;]
        console.log(&apos;name:&apos;+item, index, arr);
    })


7、map(): 将每次return的数据，最终组成一个数组返回

    var srcColors = [
        {r: 255, g: 255, b: 255 },
        {r: 128, g: 128, b: 128 },
        {r: 0,   g: 0,   b: 0   }
    ];

    var newColor = srcColors.map(function(item, index, arr){         
        return item.r;
    })
    console.log(newColor);        // 返回 [255, 128, 0]


8、reduce(上次执行的结果，当前值，当前索引，数组对象)、reduceRight(): 归并数组，每次循环都会返回上一次值和当前值

    var val = [1,2,3,4,5];
    var sum = val.reduce(function(prev, cur, index, arr){   // prev 第一次执行的是1, 第二次执行的就是上次1+2返回的结果
        return prev + cur;   
    })
    console.log(sum);   // 15
</code></pre><h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><pre><code>1、__proto__: 对象实例与prototype之间的连接，原型链

2、prototype: 原型，公用的，节省内存开支，查找先去对象本身找属性和方法，如果没有到prototype下查找

3、constructor: 保存用于创建当前对象的构造函数名

4、toString()、valueOf()

5、delete: 删除对象属性

6、hasOwnProperty(propertyName): 用来判断属性是否在对象中（而不是原型中） var obj = {name: &apos;aaa&apos;}; obj.hasOwnProperty(&apos;name&apos;)

    var o = { name: &apos;siguang&apos;, getName: function(){ console.log(this.name) } };
    o.hasOwnProperty(&apos;name&apos;);       // true

    判断对象的属性或方法是否存在
    var obj = {};

    判断属性
        obj.name    // 如果属性不存在返回 undefined，也就是false

    判断方法
        typeof obj.getName == &apos;function&apos;      // 如果存在返回true


7、isPrototypeOf(object): 判断一个对象的原型是否是在指定对象的原型链中

    var o = new Object();
    Object.prototype.isPrototypeOf(o)


8、instanceof: 用来判断一个构造函数的prototype属性是否在另一个检测对象的原型链上

    A instanceof B   // 检测B的prototype是否存在于A的原型链上

9、in: 属性是否在对象中能访问，返回true或false

    function Persion(){
        var sex = &apos;男&apos;;
        this.name = &apos;siguang&apos;;
    }
    Persion.prototype.age = &apos;haha&apos;;

    var p1 = new Persion();
    console.log(&apos;name&apos; in p1);      // true
    console.log(&apos;age&apos; in p1);       // true
    console.log(&apos;sex&apos; in p1);       // false;


10、Object.create(o, p): 可以创建一个干净的对象，给o对象创建一个prototype，如果p对象存在

    var oA = Object.create(null);    // 创建一个干净的对象，没有__proto__属性
    var oB = {};        // 存储__proto__

    function Car(desc){
        this.desc = desc;
        this.color = &apos;red&apos;
    }

    Car.prototype = {
        getInfo: function(){
            return `color: ${this.color}, desc: ${this.desc}`
        }
    }

    // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
    var child = Object.create(Car.prototype);
    child.desc = &apos;aaa&apos;;
    child.color = &apos;bbb&apos;;

    // 改变子类不会影响到父类
    console.log(child);
    var childCar = child.getInfo();
    console.log(childCar)       // color: bbb, desc: aaa

    var oCar = new Car(&apos;ccc&apos;);
    console.log(oCar.getInfo());    /// color: red, desc: ccc

    1) Object.create()与new Object()的区别

        var Base = function () {}
        var o1 = new Base();
        var o2 = Object.create(Base);

        Object.create(null) 是创建一个空对象，这个对象不继承Object.prototype原型链上的属性或方法


11、Object.defineProperty(obj, prop, descriptor): 对象新增或修改一个属性会执行set()、get()方法来通知

    参数: obj 目标对象     prop需要定义的属性      descriptor该属性拥有的特性，可设置的值有

    descriptor的值: 

        value 属性的值，默认为 undefined。

        writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。

        get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。

        set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。

        configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。

        enumerable 是否能在for...in循环中遍历出来或在Object.keys中列举出来。默认为 false。

    Example:
        var obj = {};
        Object.defineProperty(obj, &apos;name&apos;, {
            get: function(){
                debugger;
                // this.name;  
                return 23;
            },
            set: function(newValue){
                debugger
            }
        })

        Object.defineProperty(obj, &apos;sex&apos;, {
            get: function(){
                debugger;
                return &apos;女&apos;;
            },
            set: function(newValue){
                debugger
            }
        })

        obj.name = &apos;sss&apos;;           // 调用set()
        console.log(obj.name);      // 调用get()   23

        obj.sex = &apos;男&apos;;
        console.log(obj.sex);       // 女


    MVVM的核心: 

        &lt;div&gt;
            &lt;p&gt;你好，&lt;span id=&apos;nickName&apos;&gt;&lt;/span&gt;&lt;/p&gt;
            &lt;div id=&quot;introduce&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;

            // 视图控制器
            var userInfo = {};
            Object.defineProperty(userInfo, &quot;nickName&quot;, {
                get: function(){
                    return document.getElementById(&apos;nickName&apos;).innerHTML;
                },
                set: function(nick){
                    document.getElementById(&apos;nickName&apos;).innerHTML = nick;
                }
            });

            Object.defineProperty(userInfo, &quot;introduce&quot;, {
                get: function(){
                    return document.getElementById(&apos;introduce&apos;).innerHTML;
                },
                set: function(introduce){
                    document.getElementById(&apos;introduce&apos;).innerHTML = introduce;
                }
            })

            userInfo.nickName = &quot;siguang&quot;;
            userInfo.introduce = &quot;我是&quot;+ userInfo.nickName +&quot;，我来自黑龙江，...&quot;

        &lt;/script&gt;

    https://segmentfault.com/a/1190000004346467


12、Object.defineProperties: 与defineProperty相同就是可以设置多个属性

    let book = { year: 2004, edit: 1}
    Object.defainProperyies(book, {
        year:{
            get: function(){},
            set: function(){}
        },
        edit: {
            get: function(){},
            set: function(){}
        }
    })


13、Object.getPrototypeOf(object): 调用父类原型上的方法

    // 定义一个父类
    function PersonA(){
        this.methodA = function(){ 
            alert(&quot;a&quot;);
        }
    }
    PersonA.prototype.methodB = function(){
        alert(&apos;b&apos;);
    }

    // 定义一个子类
    function Man(){
        this.m1 = function(){
            //getPrototypeOf只有继承父类的时候才可以调用其方法
            Object.getPrototypeOf(this).methodA();        
        }
    }

    Man.prototype = new PersonA();
    Man.prototype.m2 = function(){
        Object.getPrototypeOf(this).methodB();
    }

    var man = new Man();
    man.m1();        // a
    man.m2();        // b


14、Object.keys(obj): 将对象obj下所有的属性的key，返回一个数组，用可以用它来判断是数组是否为空

    Object.keys(obj).length 是否等于0

15、Object.getOwnPropertyDescriptor(): 
</code></pre><h4 id="Function扩展"><a href="#Function扩展" class="headerlink" title="Function扩展"></a>Function扩展</h4><pre><code>1、bind(): 一个函数绑定之后，可以保持传递this的上下文

    var obj = {
        nameStr: 20,
        getName: function(){
            setTimeout(function(){
                console.log(this.nameStr);
            }.bind(obj), 10)
        }
    }

    // 输出20，如果不加bind()，this指向window所以输出的是undeined
    obj.getName();
</code></pre><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><pre><code>var od = new Date();    // 创建当前中国标准时间 Thu Apr 27 2017 18:39:17 GMT+0800 (CST)
var od = new Date(&apos;2017-04-27 18:40:00&apos;);   // 指定时间 返回当前标准时间 Thu Apr 27 2017 18:40:00 GMT+0800 (CST)

1、getTime(): 返回当前毫秒数

2、setTime(): 以毫秒设置时期

    var od = new Date(); 
    od.setTime(12312312312332); 
    console.log(od);        // Mon Feb 29 2360 22:45:12 GMT+0800 (CST)

3、getFullYear()、setFullYear(): 获取或设置年份

4、getMonth()、setMonth(): 获取或设置月份，值需要+1

5、getDate()、setDate(): 获取或设置日

6、getDay(): 返回星期几，值是0-6

7、getHours(): 小时

8、getMinutes(): 分钟

9、getSeconds(): 秒
</code></pre><h4 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h4><pre><code>1、toFixed(): 将值格式化小数点后几位
</code></pre><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><pre><code>1、length: 字符串长度

2、charAt(): 返回指定位置的字符  &apos;abcde&apos;.charAt(3)  &apos;d&apos;

3、chartCodeAt(): 返回指定位置的字符编码

4、concat(): 两个字符串拼接

5、split(): 将字符串以什么为分割，并返回为一个数组

截取

6、slice(begin,end): 截取字符串指定开始和结束位置的字符并返回， 可以接受负数

7、substring(begin,end): 截取字符串从开始到结束，

8、substr(begin, length): 返回一个指定开始到一个结束长度的字符

位置

9、indexOf(): 查找指定字符所在的位置

10、lastIndexOf(): 从后向前查找指定字符的位置

11、trim(): 删除前后空格  str.replace(/^\s*|$\s*/g, &apos;&apos;);

12、toLocaleUpperCase(): 转成小写字母

13、toUpperCase(): 转成大写字母

正则

14、search(reg): 搜索正则中匹配字符的位置，没有返回-1

15、match(reg): 将匹配的正则返回一个数组

    let text = &quot;cat, bat, sat, fat&quot;;
    let om = text.match(/.at/g);        // [&quot;cat&quot;, &quot;bat&quot;, &quot;sat&quot;, &quot;fat&quot;]

16、exec():

17、replace(reg, 替换字符): 替换指定字符
</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><pre><code>1、min()、max(): 返回最小、最大值

舍入

2、ceil(): 向上舍入

3、floor(): 向下舍入

4、round(): 四舍五入

5、random(): 随机数 0-1之间

6、abs(): 绝对值

7、sin()、cos()
</code></pre><h4 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h4><pre><code>encodeURI()、encodeURIComponent()
</code></pre><h4 id="前端动画实现种类"><a href="#前端动画实现种类" class="headerlink" title="前端动画实现种类"></a>前端动画实现种类</h4><pre><code>1、纯粹的CSS3: transition/animation+transform（大名鼎鼎的animate.css）

2、JS+CSS3 transition或者animation: 这里第一种一样，只是通过js里add class和remove class去增加或者移除对应的动画

3、纯粹JS控制时间轴: 第一和第二种都是自带时间轴，使用 setInterval / setTimeout / requestAnimationFrame 不断地修改 DOM 的 style 属性产生动画
</code></pre><p>| <a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es5/</a>    ES5兼容表<br>| <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/className" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/className</a>        API<br>| <a href="https://segmentfault.com/a/1190000000515151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000515151</a><br>| <a href="https://segmentfault.com/a/1190000005653355" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005653355</a><br>| <a href="https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx</a><br>| <a href="http://www.alloyteam.com/2016/05/javascript-timer/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/05/javascript-timer/</a>        js运行机制</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/DOM/">DOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/DOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h4><pre><code>DOM 文档对象模型     D - Document      O - Object      M - Model
</code></pre><h4 id="Node-对象属性"><a href="#Node-对象属性" class="headerlink" title="Node 对象属性"></a>Node 对象属性</h4><pre><code>1、nodeType: 节点类型

    e.target.nodeType 来获取节点的类别

    1、Element 1

    2、Attr  2

    3、Text  3

    4、注释  8

    5、Document 9


2、nodeName: 节点名称   返回的是大写 &apos;DIV&apos;

3、nodeValue: 节点的类型

    元素节点的 nodeValue 是 undefined 或 null
    文本节点的 nodeValue 是文本本身
    属性节点的 nodeValue 是属性值

    &lt;p&gt;dfsdfsdf&lt;/p&gt;

    let oP = document.querySelector(&apos;p&apos;);   
    // 这里注意oP是元素如果直接写成oP.nodeValue返回是null，写成oP下的第一个节点才找到文本元素
    oP.firstChild.nodeValue;            

4、parentNode: 返回当前节点的父节点   e.target.parentNode.nodeName

    document.querySelector(&apos;ul&apos;).parentNode     // &lt;div class=&quot;box&quot;&gt;...&lt;/box&gt;

5、childNodes、children: 返回所有子节点元素，不包括孙节点

    &lt;ul id=&quot;list&quot;&gt;
        &lt;li&gt;111&lt;/li&gt;
        &lt;li&gt;222&lt;/li&gt;
        &lt;li&gt;
            &lt;ul&gt;
                &lt;li&gt;333&lt;/li&gt;
                &lt;li&gt;444&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;

    let oList = document.querySelector(&quot;#list&quot;);
    let lis = oList.children;
    for(let i=0; i&lt;lis.length; i++){
        console.log(lis[i].nodeName);   // output LI LI LI
    }

    ** childeNodes与children区别 ** 

        childeNodes: 包括空行的文本节点, 如果是空行的节点返回是一个text节点
        children: 不包括空行之类的节点

6、hasChildNodes(): 判断是否有子节点，返回Booleanw值

7、firstChild、lastChild: 返回子节点的第一个节点、最后一个节点

    firstChild 相当于 children[0]

    lastChilde 相当于 children[node.children.length-1]

    &lt;div id=&quot;car&quot;&gt;&lt;p&gt;aaa&lt;/p&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;/div&gt;

    let oCars = document.querySelector(&quot;#car&quot;);
    console.log(oCars.firstNode, oCars.lastNode);   //&lt;p&gt;aaa&lt;/p&gt; 、 &lt;span&gt;ccc&lt;/span&gt;

8、previousSibling、nextSibling: 当前节点的前一个节点、后一个节点

    注意: 如果是空行返回的是 text

9、innerHTML: 获取或修改HTML元素内容

    Element.innerHTML = &apos;&lt;div&gt;xxxxx&lt;div&gt;&apos;;

10、innerText: 获取或修改的是除去html的文本

11、outerHTML、outerText: 与innerHTML、innerText相当，不同的是它包含当前节点元素，inner只包含子节点元素

12、offsetParent: 获取当前元素定位的父元素  找到基于设置position的父元素

     document.querySelector(&apos;ul&apos;).offsetParent
</code></pre><h4 id="Node-对象的方法"><a href="#Node-对象的方法" class="headerlink" title="Node 对象的方法"></a>Node 对象的方法</h4><pre><code>一、节点操作方法

    1、getElementById(): 获取指定ID的元素

    2、getElementsByTagName(): 获取指定标签名称的所有元素

    3、getElementsByClassName(): 获取指定类名的元素

    4、appendChild(): 追加子节点  注意这里插入的是一个节点，而不是HTML的字符串 parent.appendChild(children);

    5、removeChild(): 删除子节点，不能删除孙子节点    (removeNode 只支持IE)

        删除节点 并返回删除的节点
        let oSubCar = document.querSelector(&apos;#subCar&apos;);
        document.querySelector(&apos;body&apos;).removeChild(oSubCar);        // &lt;div id=&quot;subCar&quot;&gt;...&lt;/div&gt;

    6、cloneNode(Boolean): 复制节点  如果参数为true复制指定节点下包括所有子节点，如果不写只复制当前节点不手包子节点

        &lt;div class=&quot;car&quot;&gt;
            &lt;ul id=&quot;box&quot;&gt;
                &lt;li&gt;aaa&lt;/li&gt;
                &lt;li&gt;bbb&lt;/li&gt;
                &lt;li&gt;ccc&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div id=&quot;subCar&quot;&gt;&lt;/div&gt;

        &lt;script&gt;
            // 将id=box所有的节点插入到id=subCar中
            let boxList = document.querySelector(&apos;#box&apos;).cloneNode(true);
            var oSubCar = document.querySelector(&apos;#subCar&apos;);
            oSubCar.appendChild(boxList);
        &lt;/script&gt;

    7、hasAttributes(): 判断当前节点是否拥有属性

        &lt;div id=&quot;miniCar&quot;&gt;&lt;/div&gt;
        &lt;div&gt;swsss&lt;/div&gt;

        let isAttribute = document.getElementsByTagName(&apos;div&apos;)[1].hasAttributes();
        console.log(isAttribute);   // false

    8、hasChildNodes(): 判断当前节点是否拥有子节点

    9、insertBefore(newitem, ex): 在指定节点之前插入

        insertAfter(): 这个需要自己来写没有这个方法

        let oMain = document.querySelector(&apos;#main&apos;);
        let oP = document.querySelector(&apos;p&apos;);
        let oUl = document.querySelector(&apos;.uls&apos;).cloneNode(true);
        oMain.insertBefore(oUl, oP);    将ul元素内所有节点复制并插入到oP元素之前

    10、replaceChild(newNode, oldNode): 替换节点

        document.querySelector(&apos;body&apos;).replaceChild(oMiniCar, oSubCar)


二、创建元素方法

    1、createAttribute(): 创建属性节点

    2、createElement(): 创建元素节点

    3、createTextNode(): 创建文本节点


三、操作属性方法

    1、getAttribute(): 获取属性值

    2、setAttribute(): 设置属性值
</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>1、style：获取或设置style值   Element.style.color = &apos;blue&apos; 

2、currentStyle、getCurrentStyle()获取样式中每个属性的值

    var oBox = document.querySelector(&apos;#box&apos;);
    var getStyle = function(obj, attr){
        return window.getComputedStyle ? window.getComputedStyle(obj, null)[attr] : obj.currentStyle[attr];
    }

    var attrTxt = getStyle(oBox, &apos;width&apos;);          // &apos;100px&apos;;

    注意: (1)中style只能获取元素中的内联样式，而currentStyle、getCurrentStyle()无论是内联样式还是在class中都可以找到

3、getComputedStyle(元素， 伪类): 获取指定元素值，currentStyle（ie独有） 

    &lt;script&gt;
        function getStyle(element, attr) {
            if(window.getComputedStyle) {
                return window.getComputedStyle(element, null)[attr];
            } else {
                return element.currentStyle[attr];
            }
        }

        // 获取class=position-node元素上的position值
        var dom = document.querySelector(&quot;.position-node&quot;);
        var style = getStyle(dom);
        console.log(style.position);    // 返回relative
    &lt;/script&gt;


    *** element.getComputedStyle与element.style的区别

    element.getComputedStyle: 只读
    element.style: 可读写

4、className: 获取或设置元素的类名  Element.addClass = &apos;classname&apos;
</code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><pre><code>1、write(): 向输出流写文本或html

2、document.title: 返回标题

4、&quot;javascript:&quot; : 伪协议 来调用javascript http协议(http://)，FTP协议(ftp://)

5、对象检测: 可以测试浏览器是否支持当前对象

    if(document.getElementById){ ...}
</code></pre><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><pre><code>1、createDocumentFragment: 创建文档碎片

    Example: 创建节点并插入到body中，如果不使用文档碎片，每次都需要重新插入一次

    var oFragment = document.createDocumentFragment();
    for(var i = 0 ; i &lt; 10; i ++) {
        var p = document.createElement(&quot;p&quot;);
        var oTxt = document.createTextNode(&quot;段落&quot; + i);
        p.appendChild(oTxt);
        oFragment.appendChild(p);
    }
    document.body.appendChild(oFragment);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、表单事件：

    submit事件

    reset事件

    click事件

    change事件

    focus事件（不冒泡） （IE和ES5支持冒泡的focusin）

    blur事件（不冒泡） （IE和ES5支持冒泡的focusout）

    input事件（ES5 textinput提供更方便的获取输入文字的方案）


2、Window事件

    load: 资源全部加载完成后触发事件（图片、css、js）

    DOMContentLoaded事件: Document对象构建完后就开始调用此事件

    readyStatechage事件:

    unload事件: 关闭borwser的时候触发

    beforeunload事件

    resize: 浏览器窗口发生改变触发

    scroll: 滚动条有变化时触发


3、鼠标事件

    click: 点击事件

    dbclick：双击事件

    mouseover: 鼠标移入事件（冒泡）

    mouseout: 鼠标移出事件（冒泡）

    mousedown: 鼠标按下事件

    mouseup: 鼠标放开事件

    contextmenu: 上下文本菜单事件

    mouseenter: 事件（不冒泡）

    mouseleave: 事件（不冒泡）

    mousewheel: 事件（FF DOMMouseScroll事件、DOM3 wheel事件）


4、键盘事件

    keydown事件

    keyup事件

    keypress事件
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/javascript设计模式/">设计模式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/javascript设计模式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/设计模式/">设计模式</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 面向对象(类型判断、封装、多态、闭包、高阶函数)<br>| 单例模式 - 命名空间、只被实例化一次<br>| 工厂模式 - 加工在输厂的过程<br>| 外观模式 - 将复杂的接口统一，用于低层兼容<br>| 适配器模式 - 将一个接口转化为另一个接口<br>| 代理模式 - 一个对象不能直接访问另一个对象时，使用代理对象<br>| 装饰者模式 - 不改变原有对象的，并对其进行拓展<br>| 桥接模式 - 提取公用的方法，并通过桥接来进行连接<br>| 享元模式 -<br>| 观察者模式 -<br>| 状态模式 -<br>| 访问者模式 -<br>|<br>| 组合模式<br>| 策略模式 - 将一组算法封装起来，使其可以相互之间替换<br>| 中介者模式</p>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><pre><code>只能将带有duckSinging()方法的对象加入到 choir 数组中

&lt;script&gt;

    // 方法一
    var duck = {
        duckSinging: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 方法二
    var chicken = {
        chicken: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 存储带有duckSinging()方法的对象
    var choir = [];

    var joinChoir = function(animal){
        if(animal &amp;&amp; typeof animal.duckSinging == &apos;function&apos;){        // 只能加入带有duckSinging()方法的对象
            choir.push(animal);
            console.log(&apos;恭喜入合唱团&apos;);
            console.log(&apos;合唱团已有成员数量&apos;, choir.length);
        }
    }

    joinChoir(duck);
    joinChoir(chicken);

&lt;/script&gt;
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>封装: 目的是将信息隐藏, 其它语言通过private、public、protected来处理访问权限

js没有这些关键字通过变量的作用域来实现封装

&lt;script&gt;
    var Book = funtcion(id, bookname, price){
        // 私有属性
        var name = 1;

        // 私有方法
        function checkId(){ }

        // 公有属性
        this.id = id;
        this.bookname = bookname;

        // 公有方法
        this.copy = function(){}

        // 特权方法
        this.getName() = function{ return name }
    }

    // 在原型 (prototype) 来添加属性和方法，有两种方式
    // 1、为原型一一添加属性和方法
    // 2、将一个对象赋给原型

    Book.prototype.display = function(){
        // 展示这本书
    }

    Book.prototype = {            // 这种方法会将prototype下的constructor被覆盖掉
        display: function(){
            // 展示这本书
        }
    }
&lt;/script&gt;

&lt;script&gt;
    // 闭包实现 1
    var Book = (function(){
        // 静态私有变量
        var bookNum = 0;

        // 静态私有方法
        function checkBook(name){}

        // 返回构造函数
        return function(newId, newName, newPrice){
            var name, price;
            function checkId(name){}
        }
    });

    Book.prototype = {
        isJSBook: false,
        display: function(){}
    }


    // 闭包实现 2
    var Book = (function(){

        // 私有变量
        var bookNum = 0;

        // 私有方法
        function checkBook(name){ }

        // 创建类
        function _book(newId, newName, newPrice){}
        _book.prototype = {}

        return _book
    })();
&lt;/script&gt;
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code>一、类式继承

    将父类的实例赋给子类的原形，类式继承的原因: 类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问

    &lt;script&gt;

        // 父类
        function Parent(){
            this.name = &apos;siguang&apos;
        }

        Parent.prototype.say = function(){ 
            console.log(this.name);
        }

        // 子类                
        function Childer(){}

        Childer.prototype = new Parent();   // 类式继承

        // 上一步执行后prototype的constructor会指向Parent，因为constructor指向还是在Paremt类上
        Childer.prototype.constructor = Childer;

        Childer.prototype.getSubValue = function(){
            console.log(&apos;getSubValue&apos;)
        }

        // 实例
        var oParent = new Parent();
        var oChilder = new Childer();

        oParent.say();                // siguang
        oChilder.say();                // siguang
        console.log(oChilder.name); // siguang
        oChilder.name = &apos;haha&apos;;
        oChilder.say();                // haha
        oChilder.getSubValue();        // getSubValue
    &lt;/script&gt;


二、构造函数式继承

    /*
    * 构造函数继承
    * 继承非prototype下的属性和方法
    */
    &lt;script&gt;
        // 父类继承
        function SuperClass(id){
            this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;];
            this.id = id;
            this.showId = function(){
                console.log(this.id);
            }
        }
        SuperClass.prototype.showBooks = function(){
            console.log(this.books);
        }

        // 声明子类
        function SubClass(id){
            // 继承父类所有公用属性和方法（this下的内容），但不继承prototype下的属性和方法
            SuperClass.call(this, id);
        }

        // SubClass.prototype.constructor = SubClass;

        var sub1 = new SubClass(10);
        var sub2 = new SubClass(20);

        sub1.books.push(&apos;设计模式&apos;);    
        console.log(sub1.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;设计模式&apos;]
        console.log(sub1.id);            // 10
        // sub1.showBooks();            // 报错，不
        sub1.showId();                    // 10

        console.log(sub2.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]
        console.log(sub2.id);            // 20
    &lt;/script&gt;


总结: 类似继承与构造函数式继承的区别

    1、类似继承: ChildreClass.prototype = new ParentClass();

        继承父类的公用属性和方法（this.的内容）和 prototype下的属性和方法, 需要改变constructor的名字

    2、构造函数式继承: ParentClass.call(this);

        只能继承公用属性和就去，不能继承父类prototype下的属性和方法, 不需要改变constructor的名字


三、原型继承

    通过一个继承方法，创建一个过渡对象，将继承的父对象赋给过渡对象的原型，在返回过渡对象的实例

    &lt;script&gt;
        var Parent = function(){
            this.blod = 20;
            this.level = 1;
        }
        Parent.prototype.getBlod = function(){
            console.log(this.blod, this.level);
        }

        Object.create = Object.create || function(obj){
            var F = function(){};        // 声明一个过渡对象
            F.prototype = obj;            // 过渡对象的原型继承父对象
            return new F();                // 返回过渡对象的一个实例，该实例的原型继承了父对象
        }

        var oParent = new Parent();
        var oChilde = Object.create(oParent);

        oChilde.blod = 30;    // 如果clone不设置blod属性，会到prototype的指向中找，最终会在oParent中找到属性
        oChilde.getBlod();    // 30 1

        oParent.getBlod();    // 20 1
    &lt;/script&gt;


四、寄生式继承

    就是将原型继承在二次封装，并返回一个对象

    &lt;script&gt;

        // 寄生式继承
        // 声明基对象
        var book = {
            name: &apos;js book&apos;,
            alikeBook: [&apos;css book&apos;, &apos;html book&apos;]
        }

        function createBook(obj){
            // 通过原型继承方式创建新对象
            var o = new inhreitObject(obj);
            // 拓展新对象
            o.getName = function(){
                console.log(this.name);
            }

            // 返回拓展新对象
            return o;
        }

        function inhreitObject(obj){
            var F = function(){};
            F.prototype = obj;
            return new F();
        }


        var oCreateBook = createBook(book);
        oCreateBook.getName();            // &apos;js book&apos;

    &lt;/script&gt;


五、多继承

    只适用于对象，不适用构造函数，继承某一个类，和继承多个类

    &lt;script&gt;

        // 单继承 属性复制
        // 这种是浅复制，象jquery等框架实现了深度复制
        var extend = function(target, source){
            // 遍历源对象中的属性
            for(var property in source){
                // 将源对象中的属性复制到目标对象中
                target[property] = source[property];
            }

            // 返回目标对象
            return target;
        }


        var book = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }
        var anotherBook = {
            color: &apos;blue&apos;
        }

        extend(anotherBook, book);
        console.log(anotherBook.name);
        console.log(anotherBook.alike);
        console.log(book, anotherBook);



        // 多继承 多个对象继承 属性复制
        var mix = function(){
            var i = 1,                    // 从第二个参数起为被继承的对象
                len = arguments.length,    // 获取参数长度
                target = arguments[0],    // 第一个对象为目标对象
                arg;                    // 缓存参数对象

            // 遍历被继承的对象
            for(; i&lt;len; i++){
                // 缓存当前对象
                arg = arguments[i];
                // 遍历被继承对象中的属性
                for(var property in arg){
                    // 将被继承对象中的属性复制到目标对象中
                    target[property] = arg[property];
                }
            }
            return target;
        }


        var book1 = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }

        var book2 = {
            tag: &apos;书&apos;
        }

        var book3 = {
            detail: &apos;产品优势&apos;
        }

        var newBook = mix(book1, book2, book3);

    &lt;/script&gt;
</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><pre><code>多态: 就是调用同一对象，通过参数发出不同指令，执行不同的结果

&lt;script&gt;

    var googleMap = {
        show: function(){
            console.log(&apos;开始渲染谷歌地图&apos;);
        }
    }

    var baiduMap = {
        show: function(){
            console.log(&apos;开始渲染百度地图&apos;);
        }
    }

    // 渲染地图
    var renderMap =  function(map){

        // 如果对象下有show方法就执行
        if(map.show instanceof Function){        
            map.show();
        }

        // 另一个判断类型模式
        // if(map &amp;&amp; typeof map.show == &apos;function&apos;){
        //     map.show();
        // }
    }

    renderMap(googleMap);
    renderMap(baiduMap);

&lt;/script&gt;
</code></pre><h4 id="闭包、高阶函数"><a href="#闭包、高阶函数" class="headerlink" title="闭包、高阶函数"></a>闭包、高阶函数</h4><pre><code>高阶函数至少满足以下条件之一

一、函数可以作为参数被传递

    &lt;script&gt;
        var getUserInfo = function(userId, callback){
            $.ajax(&apos;http://xx.com/user?uid=&apos;+userId, function(data){
                if(typeof callback == &apos;function&apos;){
                    callback();
                }
            })
        }
    &lt;/script&gt;

二、函数可以作为返回值输出

    &lt;script&gt;

        // 函数作为返回值输出
        var isType = function(type){
            return function(obj){
                return Object.prototype.toString.call(obj) === &apos;[object &apos;+ type +&apos;]&apos;
            }
        } 

        var str = &quot;sdfsdf&quot;
        var isString = isType(&apos;String&apos;);
        console.log(isString(str));        // true
    &lt;/script&gt;
</code></pre><h4 id="全局变量的解决方法"><a href="#全局变量的解决方法" class="headerlink" title="全局变量的解决方法"></a>全局变量的解决方法</h4><pre><code>避免全局函数: 1、对象方法   2、函数对象    3、构造函数

&lt;script&gt;

    // 都是全局变量
    function checkName(){
        // 验证姓名
    }

    function checkEmail(){
        // 验证邮箱
    }

    function checkPassword(){
        // 验证密码
    }

    /*
    * 方法一 对象收编全局变量
    */
    var ChceckObject = {
        checkName: function(){
            // 验证姓名
        },
        checkEmail: function(){
            // 验证邮箱
        },
        checkPassword: function(){
            // 验证密码
        }
    }


    /*
    * 方法二 函数对象
    */
    var CheckObject = function(){
        return {
            checkName: function(){
                // 验证姓名
            },
            checkEmail: function(){
                // 验证邮箱
            },
            checkPassword: function(){
                // 验证密码
            }
        }
    }

    // 调用
    var oCheck = CheckObject();
    oCheck.checkName();


    /*
    * 方法三 构造函数写法
    */
    var CheckObject = function(){
        this.checkName = function(){
            // 验证姓名
        }
        this.checkEmail = function(){
            // 验证邮箱
        }
        this.checkPassword = function(){
            // 验证密码
        }
    }

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 创建型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><pre><code>单例模式: 又被称为单体模式，只允许实例化一次的对象类

全局变量 var a = {};    属于单例对象, 不属于单例模式

jquery就是一个很大的单例,js载入时被初始化一次

    (function(){
        var jquery = (function(){})();
        window.jQuery = window.$ = jQuery;
    })(window);


一、最简单的单例就是一个对象

    var app = {
        util: {},
        tool: {},
        ajax: {}
    }


二、私有变量的单例模式，减少全局变量方法

    1、使用命名空间

        var MyApp = {};

        MyApp.namespace = function(name){
            var parts = name.split(&apos;.&apos;);
            var current = MyApp;
            for(var i in parts){
                if(!current[parts[i]]){
                    current[parts[i]] = {}
                }
                current = current[parts[i]];
            }
        }

        MyApp.namespace(&apos;event&apos;);
        MyApp.namespace(&apos;dom.style&apos;);


    2、使用闭包封装私有变量

        var user = (function(){
            var _name = &apos;sven&apos;,
                _age = 30;

            return {
                getUserInfo: function(){
                    return _name +&apos;-&apos;+ _age;
                }
            }
        })();


三、惰性单例模式

    &lt;script&gt;

        // 惰性单例模式  只有在需要的时候才会创建
        var createLoginLayer = (function() {
            var div;
            return function() {
                if (!div) {
                    div = document.createElement(&apos;div&apos;);
                    div.className = &apos;dialog&apos;;
                    div.innerHTML = &apos;我是登录窗口&apos;;
                    div.style.display = &apos;none&apos;;
                    document.body.appendChild(div);
                }

                return div
            }
        })();

        var oLoginBtn = document.querySelector(&apos;#loginBtn&apos;);
        oLoginBtn.onclick = function(){
            var oLayer = createLoginLayer();
            oLayer.style.display = &apos;block&apos;;
        }

    &lt;/script&gt;
</code></pre><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><pre><code>工厂模式: 将不同的参数传入到工厂方法中，进行加工后，然后在返回新的产品

// 创建一个工厂函数，并将结果返回
function createPerson(name, age, sex){
    var createObject = {};

    // 加工
    createObject = {    
        name: name,
        age: age,
        sex: sex,
        showInfo: function(){
            console.log(&apos;姓名:&apos;+ this.name +&quot;  年龄:&quot; + this.age);
        }
    }

    // 返回成品
    return createObject;
}

var person = createPerson(&apos;siguang&apos;, 30, &apos;男&apos;);
person.showInfo();
</code></pre><h4 id="建造者模式-builder"><a href="#建造者模式-builder" class="headerlink" title="建造者模式 builder"></a>建造者模式 builder</h4><pre><code>将一个复杂对象的构建层与表示层相互分离
</code></pre><h4 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h4><pre><code>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性及方法

&lt;script&gt;

    // 定义一个基本的图片轮播对象
    var LoopImages = function(imgArr, container){
        this.imgArr = imgArr;
        this.container = container;
    }
    LoopImages.prototype = {
        // 创建
        createImage: function(){
            console.log(&apos;loopImage createImage function&apos;);
        },
        // 切换方法
        changeImage: function(){
            console.log(&apos;LoopImage changeImage function&apos;);
        }
    }

    // 定义一个上下滑动的效果
    var SliderLoopImage = function(imgArr, container){
        LoopImages.call(this, imgArr, container);
    }
    SliderLoopImage.prototype = new LoopImages();            // 就是类似继承，并将要改变的方法重写

    // 重写切换方法
    SliderLoopImage.prototype.changeImage = function(){
        console.log(&apos;SlideLoopImg changeImage function&apos;);
    }

    var oSlider = new SliderLoopImage([&apos;1.jpg&apos;, &apos;2.jpg&apos;], &apos;#box&apos;);
    oSlider.createImage();
    oSlider.changeImage();

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 结构型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><pre><code>外观模式: 为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易

// 外观模式实现
function addEvent(dom, type, fn){
    if(dom.addEventListener){
        dom.addEventListener(type, fn, false);
    }
    else if(dom.attachEvent){
        dom.attachEvent(&apos;on&apos;+type, fn);
    }
    else{
        dom[&apos;on&apos;+type] = fn;
    }
}

var myInpurt = document.querySelector(&apos;#myinput&apos;);

addEvent(myInpurt, &apos;click&apos;, function(){
    console.log(&apos;绑定第一个事件&apos;)
})
</code></pre><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><pre><code>适配器模式: 将一个类的接口转化成另外一个接口，使类之间的接口不兼容问题通过适配器得以解决

一、如果有jQuery框架，现在A框架与jQuery框架基本相同可以将两种框架适配

    // 定义A框架
    var A = jQuery || {};

    A.g = function(id){
        return document.getElementById(id);
    }

    A.on = function(id, type, fn){
        var dom = typeofi id === &apos;String&apos; ? A.g(id) : id;
        if(dom.addEventListener){
            dom.addEventListener(type, fn, false);
        }
        else if(dom.attachEvent){
            dom.attachEvent(&apos;on&apos;+type, fn);
        }
        else{
            dom[&apos;on&apos;+type] = fn;
        }
    }

二、jquery适配器

    window.A = A = jQuery;

三、参数适配

    function doSomeThing(obj){
        var adapter = {
            name: &apos;雨夜&apos;,
            titel: &apos;设计&apos;,
            age: 30,
            color: &apos;pink&apos;,
            size: 100,
            prize: 50
        }

        for(var key in adapter){
            adapter[key] = obj[key] || adapter[key];        // 处理如果obj没有的参数
        }
        return adapter;            // 也可以使用extend();
    }
</code></pre><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><pre><code>代理模式: 由于一个对象不能直引用另一个对象，所以需要一个代理对象来为两个对象之间起到中介作用

&lt;script&gt;
    var Flower = function(){};

    var xiaoming = {
        sendFlower: function(target){
            var flower = new Flower();
            target.receiveFlower(flower);
        }
    }

    // B代理小明去给A送花
    var B = {
        receiveFlower: function(flower){
            A.listenGoodModd(function(){        // 侦听A的心情
                A.receiveFlower(flower);
            })
        }
    }

    // A接收小明的花
    var A = {
        receiveFlower: function(flower){
            console.log(&apos;收到花&apos;+ flower);
        },
        listenGoodModd: function(fn){
            setTimeout(function(){
                fn()
            }, 10000);
        }
    }

    xiaoming.sendFlower(B);
&lt;/script&gt;
</code></pre><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><pre><code>装饿者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求

&lt;p&gt;姓名: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;username&quot; /&gt;&lt;span id=&quot;usernameError&quot;&gt;Error username xxxx&lt;/span&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;密码: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;password&quot; /&gt;&lt;span id=&quot;passwordError&quot;&gt;Error password xxxx&lt;/span&gt;&lt;/p&gt;

&lt;script&gt;

    /*
    * 装饰者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求
    */

    // 点击文本框，显示提示信息，并保留原input上的事件
    var username = document.querySelector(&apos;#username&apos;);
    var password = document.querySelector(&apos;#password&apos;);

    // 基础需求，点击文本框后会加入文本内容
    username.onclick = function(){
        this.value = &apos;初始化username&apos;;
    }.bind(username);

    password.onclick = function(){
        this.value = &apos;初始化password&apos;;
    }.bind(password);


    // 新增的需求，点击后需要有提示消息，这里不破坏原有的功能
    // 装饰者方法
    var decorator = function(input, fn){
        var input = document.querySelector(input);

        // 判断事件是否已经绑定事件
        if(typeof input.onclick == &apos;function&apos;){
            // 缓存input本身的处理的事件
            var oldClickFn = input.onclick;

            // 为事件定义新的事件, 执行将新好的方法全执行
            input.onclick = function(){
                oldClickFn();
                fn();
            }
        }
        else{
            input.onclick = fn;
        }
    }

    // 调用
    decorator(&apos;#username&apos;, function(){
        document.querySelector(&quot;#usernameError&quot;).style.display = &apos;block&apos;;
    })
    decorator(&apos;#password&apos;, function(){
        document.querySelector(&quot;#passwordError&quot;).style.display = &apos;block&apos;;
    })

&lt;/script&gt;
</code></pre><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><pre><code>桥接模式: 将一个功能有共用的部分抽取出来，将实现与抽出来共用方法，通过桥接方法链接在一起，这就是桥接模式

&lt;div class=&quot;box&quot;&gt;
    &lt;span&gt;最新回答&lt;/span&gt;
    &lt;span&gt;热门回答&lt;/span&gt;
    &lt;span&gt;等待回答&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
    var box = document.querySelector(&apos;.box&apos;);
    var spans = box.getElementsByTagName(&apos;span&apos;);

    // 抽出的公用
    function changeColor(dom, color, bg){
        dom.style.color = color;
        dom.style.backgroundColor = bg;
    }

    // 桥接模式
    function bindSpan(){
        var i = 0;
        var len = spans.length;

        for(i; i&lt;len; i++){
            spans[i].onmouseover = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#ffbb96&apos;);
            }
            spans[i].onmouseout = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#fff2e8&apos;);
            }                
        }
    }

    bindSpan();
&lt;/script&gt;
</code></pre><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><pre><code>享元模式: 运用共享技术有效地支持大量细粒的对象，避免对象间有相同内容造成多余的开销
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 行为型设计模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>观察者模式 - 又称发布订阅模式或消息机制
</code></pre><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><pre><code>状态模式 - 当一个对象内部状态发生改变时，会导致行为改变

状态模式是解决程序中臃肿的分支判断语句问题，将每个分支转化一种状态独立出来

&lt;script&gt;

    // 创建一个玛丽类
    var MarryState = function(){

        // 存储内部状态
        var _currentState = {};

        // 动作与状态方法映射
        var states = {
            jump: function(){
                console.log(&apos;jump&apos;);
            },
            move: function(){
                console.log(&apos;move&apos;);
            },
            shoot: function(){
                console.log(&apos;shoot&apos;);
            },
            squat: function(){
                console.log(&apos;squat&apos;);
            }
        };

        // 动作控制类
        var Action = {

            // 改变状态方法
            changeState: function(){
                var arg = arguments;
                _currentState = {};
                if(arg.length){
                    for(var i=0, len=arg.length; i&lt;len; i++){
                        _currentState[arg[i]] = true;
                    }
                }
                return this;
            },

            // 执行动作
            goes: function(){
                console.log(&apos;触发一次动作&apos;);
                for(var i in _currentState){
                    states[i] &amp;&amp; states[i]();       // 如果动作存在并执行
                }
                return this;
            }
        }

        return {
            change: Action.changeState,
            goes: Action.goes
        }
    }


    MarryState()
        .change(&apos;jump&apos;, &apos;shoot&apos;)
        .goes()

&lt;/script&gt;
</code></pre><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><pre><code>策略模式: 定义一系列算法，把他们封装起来，并使它们可以相互替换

策略模式由两部分组成:

    1、策略类，策略类封装了具体的算法，并负责具体的计算过程

    2、环境类，接受客户的请求，把请求委托给一个策略类

Example:

    &lt;script&gt;
        // 需求根据KPI等级返回奖金金额

        // 定义策略类
        var strategies = {
            &apos;S&apos;: function(salary){
                return salary * 4;
            },
            &apos;A&apos;: function(salary){
                return salary * 3;
            },
            &apos;B&apos;: function(salary){
                return salary * 2;
            }
        }

        // 环境类
        var calculateBonus = function(level, salary){
            return strategies[level] &amp;&amp; strategies[level](salary);
        }

        console.log(calculateBonus(&apos;B&apos;, 2000));        // 4000
        console.log(calculateBonus(&apos;S&apos;, 5000));        // 20000

    &lt;/script&gt;
</code></pre><h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><pre><code>职责链模式 - 解决请求的发送者与请求的接受者之间的耦合
</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><pre><code>命令模式 - 将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数
</code></pre><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><pre><code>迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部

&lt;script&gt;
    var isType = function(type){
        var callType =  Object.prototype.toString.call(type);

        switch(callType){
            case &apos;[object Object]&apos;:
                return &apos;object&apos;;
                break;

            case &apos;[object Array]&apos;:
                return &apos;array&apos;;
                break;

            default: 
                return false;
                break;
        }
    }

    var each = function(arr, callback){
        if(isType(arr) == &apos;object&apos;){
            for(var key in arr){
                callback.call(arr[key], key, arr[key]);
            }
        }
        else if (isType(arr) == &apos;array&apos;){
            for(var i=0; i&lt;arr.length; i++){
                callback.call(arr[i], i, arr[i]);
            }
        }
    }

    each([1, 2, 3], function(index, val){
        console.log(index, val);
    })

    each({name: &apos;siguang&apos;, age: 32, sex: &apos;男&apos;}, function(key, val){
        console.log(key, val);
    })
&lt;/script&gt;
</code></pre><h4 id="发布订阅模式模式"><a href="#发布订阅模式模式" class="headerlink" title="发布订阅模式模式"></a>发布订阅模式模式</h4><pre><code>发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变，所有依赖于它的对象都将得到通知.

js中事件模型来替代传统的发布订阅模式
</code></pre><p>| <a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/正则表达式/">正则表达式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/正则表达式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="特殊字符和转义序列"><a href="#特殊字符和转义序列" class="headerlink" title="特殊字符和转义序列"></a>特殊字符和转义序列</h4><pre><code>1、[...] 位于括号内的任意字符            

    /[abcde]/.test(&apos;aboot&apos;);     // 只要含有任意一个字符返回 true

    /a[bo]t/.test(&apos;abot&apos;);        // false 中间只能含有其中一个字符，匹配&apos;abt&apos;或&apos;aot&apos;

2、[^...] 不在括号中之中的任意字符

    /a[^bo]t/.test(&apos;ast&apos;);        // true a|t之间不含有b、o期中一个字符

*3、. 除了换行和Unicode行止符之外的任意字符

    /a.t/.test(&apos;a*t&apos;);        // true , &apos;a\nt&apos;换行false，使用 \.来进行转义

4、\w 任何ASCII字符,等于[a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // true, 不含有其它字符

5、\W 任何非ASCII字符单字字符，等于[^a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // false, 至少需要有一个特殊字符

6、\s 任何空格

    /\s/.test(&apos;I think&apos;);    // true

7、\S 不包含空格

    /\s/.test(&apos;I think&apos;);    // false, 非空格为true

8、\d 任何数字，等于[0-9]

9、\D 除了数字之外的任意字符

10、\b 单词边界

    例: 匹配 hi 这个词，如果写成 /hi/ 这样 &apos;wordhibiry are you&apos; 也会匹配，如果加\b会单词的分界空格处来匹配， /hi\b/.test(&apos;word hi biry are you&apos;);  true

11、\B 非单词边界 
</code></pre><h4 id="指定匹配的位置"><a href="#指定匹配的位置" class="headerlink" title="指定匹配的位置"></a>指定匹配的位置</h4><pre><code>1、^ 匹配字符串的开头

    /^ab/.test(&apos;absolute&apos;);        // true 以ab开头

2、$ 匹配字符串的结尾

    /te$/.test(&apos;absolute&apos;);        // true 以te结尾

* 3、? ! 一个反前向声明者，含义与反前向声明相反
</code></pre><h4 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h4><pre><code>1、| 用于分隔选择的字符，相当于或

    /oa|on|op/.test(&apos;option&apos;);    // true，只要带有oa、on、op都匹配

2、(...) 分组，相当于并且

    /(\d+&amp;)([a-zA-Z]+%)/.test(&apos;1234&amp;abcde%&apos;);        // true, 必须包含数据+&amp;，并且还包含英文字母+%

* 3、(?...) 只组合，把项组合到一个单元，但不记忆与该组匹配的字符

    (?:):

    (?!):

    (?&lt;=):

    (?&lt;!):
</code></pre><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><pre><code>1、{ } 匹配一个字符的重复  **** 注意{3,10} 逗号后不能有空格, 如{3, 10}        

    /^\d{1,3}$/: 最少2个数字，最多4个数字

    /^\d{4,}$/: 最少有4个数字

    /^\d{4}$/: 只能有4个数字

2、* 表示0次或多次重复,等价于{0, }    /^\d*$/

3、？最少0次, 最多1次重复，等价于{0,1}   

4、+ 表示最少出现1次，等价于{1,}

5、\1、\2 重复的子项

    var reg = /(a)(b)(c)\1/;
    var str = &quot;abca&quot;;

    // 返回 true： \1是重复第一个子项(a)，相当于/(a)(b)(c)(a)/.     \2就是第二项(b)
    console.log(reg.test(str));
</code></pre><h4 id="修饰符，高级匹配"><a href="#修饰符，高级匹配" class="headerlink" title="修饰符，高级匹配"></a>修饰符，高级匹配</h4><pre><code>1、g 匹配的是全局，检索字符串的所有匹配

    如果不加g只匹配第一个后就退出

    let reg = /你妈的|去你妈|傻逼/g;
    let content = &apos;你妈的房子傻逼是用来住的你妈的不是用来炒的去你妈的吧&apos;;
    content = content.replace(reg, &apos;***&apos;);
    console.log(content)            // ***房子***是用来住的***不是用来炒的***的吧

2、i 匹配忽略大小写

    /java/i.test(&apos;JavdaScript&apos;);        // true

3、m 进行多行匹配
</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>1、match(reg) 将匹配结果返回一个数组

    var arr = &apos;123kasdo34kk234k234234k&apos;.match(/\d+/g);        // 如果不加g，只返回第一个
    console.log(arr);        // [&quot;123&quot;, &quot;34&quot;, &quot;234&quot;, &quot;234234&quot;]

2、test() 如果没有匹配返回false否则返回true

3、search(reg) 查找并返回所在的位置，如果没有匹配的返回-1

    var result = &apos;房地产行业究竟是白银时代还是钻石时代&apos;.search(/钻石/); 
    console.log(result);        // 返回 8

4、content.replace(reg, str) 用于执行检索和替换操作

5、exec() [ɪɡ&apos;zek] 如果找到返回一个数组并存放匹配的结果，如果没有找到返回null

    var result = /白银|钻石/g.exec(&apos;房地产行业究竟是白银时代还是钻石时代&apos;); 
    console.log(result);        // [&apos;&apos;]
</code></pre><h4 id="整理经验"><a href="#整理经验" class="headerlink" title="整理经验"></a>整理经验</h4><pre><code>1、如果检查全部需要前后加匹配

    /\d+/  只对字符中存在数字就匹配

    /^\d+$/  对字符中全部为数字的进行匹配


2、test()、exec()是对每一个字符串进行匹配，如果为true就不会往下执行，并返回true

    例如: 匹配字符中不能带有.字符
    /[^\.]/.test(&apos;123123.&apos;);    // 返回true，因为第一个字符就不是.返回true不在往下执行

    /[\.]/.test(&apos;23412.34&apos;);    // 如果存在就返回true
    或者
    /^[^\.]$/g.test(&apos;asdfa.sdf&apos;) // 返回true

3、| 或符号只能用到()中，不能在[]中使用
</code></pre><h4 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h4><pre><code>1、密码强度

    // 弱密码 - 纯数字、纯字母或纯特殊字符
    /^(?:\d+|[a-zA-Z]+|[!@#$%^&amp;*]+)$/

    // 中密码 - 字母+数字，字母+特殊字符，数字+特殊字符
    /^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$/

    // 强密码 - 必须有数字、小写字母、大写字母和特殊字符
    /^(?=.*((?=[!@#$%^&amp;*_]+)[^A-Za-z0-9]))(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[^\u4e00-\u9fa5]{8,16}$/


2、手机号码验证

    /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139|186|185|170|156|155|130|131|132|189|180|170|153|133)(\d){8}$/.test(&apos;13012345678&apos;)

    移动号段: /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139)(\d){8}$/;     

    联通号段: /^(186|185|170|156|155|130|131|132)(\d){8}$/

    电信号段: /^(189|180|170|153|133)(\d){8}$/


3、验证Email - /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/

4、验证中文 - /^[\u4e00-\u9fa5]+$/

5、域名验证 - /^(http(s)?:\/\/)(www)?\.\w+\.(com|cn|net|org)$/

6、手机号前带86或是+86 - /^((\+86)|(86))?(13)\d{9}$/

7、电话号码与手机号码同时验证 - /(^(\d{3,4}-)?\d{7,8})$|(13[0-9]{9})/

8、验证IP地址 - /^((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)$/;    //  匹配0-255, 匹配&apos;255.255.255.255&apos;

9、邮政编码 - /[1-9]{1}(\d+){5}/

10、身份证号码 - /\d{18}|\d{15}/

11、双字节字符串(汉字) - /[^\x00-\xff]*/

12、去除两端空格 - /^\s*|\s*$/

数字正则

    /^\d+$/ - 非负整数（正整数 + 0)

    /^[1-9](\d)+$/ - 正整数(不可以以0开头)  

    /^-(\d)+$/ - 非正整数（负整数 + 0） 

    /^-[1-9]?(\d){0,}$/ - 负整数(-12345), 不可以-012312

    /^[1-9]?(\d)+\.(\d)+$/ - 浮点数   

    /^[+-]?\d+(\.\d{1,2})?$/ - 可以是整数 或 浮点数，并且小数点只能后两位

    ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$    //正浮点数   
    ^((-\\d+(　　//非正浮点数（负浮点数 + 0）   
    ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$  //负浮点数  

    /^[A-Za-z]+$/ - 由26个英文字母组成的字符串   

    /^[A-Z]+$/ - 由26个英文字母的大写组成的字符串   

    /^[a-z]+$/ - 由26个英文字母的小写组成的字符串  

    /^[A-Za-z0-9]+$/ - 由数字和26个英文字母组成的字符串   

    /^\w+$/ - 由数字、26个英文字母或者下划线组成的字符串
</code></pre>
        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
