<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Labels</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/06/14/TypeScript/">TypeScript</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2019/06/14/TypeScript/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-06-14T02:44:28.000Z" itemprop="datePublished">2019-06-14</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/TypeScript/">TypeScript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="typeScript"><a href="#typeScript" class="headerlink" title="typeScript"></a>typeScript</h4><p>  typeScript由微软研发的编程语言，是 JavaScript 语言的超集，代码又最终会编译成 JavaScript 来执行</p>
<p>  一、安装</p>
<pre><code>$ npm install -g typescript
</code></pre><p>  二、编译</p>
<pre><code>$ tsc greeter.ts
</code></pre><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>  1、布尔</p>
<pre><code>let createDone: boolean = false;    
</code></pre><p>  2、数字</p>
<pre><code>let createNumber: number = 10;
</code></pre><p>  3、字符串</p>
<pre><code>let createString: string = &apos;aaa&apos;;
let showString: stinrg = `hello ${createNumber}`
</code></pre><p>  4、数组</p>
<pre><code>let list: number[] = [1,2,3]
let listString: string[] = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]
let numandString: (number | string)[] = [&apos;1&apos;,2,3]
</code></pre><p>  5、元组 Tuple</p>
<pre><code>允许一个已知的元素数量和类型的数据
let x: [string, number];
x = [&apos;hello&apos;, 10]
</code></pre><p>  6、枚举</p>
<pre><code>enum Color { Red, Green, Blue }; 
let c: Color = Color.Green
</code></pre><p>  7、任意类型 any</p>
<pre><code>let notSure: any = 4;   // any 可以对不同类型的值
notSure = &apos;a string instead&apos;;

let list: any[] = [1, true, &apos;free&apos;];
list[1] = 100
</code></pre><p>  8、空值 void</p>
<pre><code>void 表示没有任何类型，一个函数无返回值时返回类型是void;
function warnUser(): void(){
  console.log(&apos;...&apos;);
}

let unusable: void = undefined;
</code></pre><p>  9、Object</p>
<pre><code>function create(o: object | null):void;
create({ prop: 0});
</code></pre><p>  10、Null 和 Undefined</p>
<pre><code>let u: undefined = undefined;
let n: null = null;
</code></pre><p>  11、Never 永不存在值的类型</p>
<pre><code>function infiniteLoop(): never {
  while (true) {
  }
}
</code></pre><p>  12、类型断言 &lt;&gt;、as</p>
<pre><code>断言有两种写法&lt;&gt;和as，用来指定一个值的类型

let someValue: any = &quot;this is a string&quot;;
let strLength: number = (&lt;string&gt;someValue).length;
let strLength: number = (someValue as string).length;
</code></pre><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><p>  1、解构数组</p>
<pre><code>let input = [1, 2];
function f([first, second]: [number, number]){
  console.log(first);
  console.log(second);
}
f(input);
</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>  1、interface来做成定义的接口</p>
<pre><code>interface SuperConfug { 
  color: string;  
  width: number;
}

function printLabel(super: SuperConfug) {
  console.log(super.color);
}
let myObj = {color: &apos;blud&apos;, width: 100};
printLabel(myObj);
</code></pre><p>  2、readonly 表示只读，不能对其属性进行重新赋值</p>
<pre><code>interface Point {  
  readonly x: number;  
  readonly y: number;
}
</code></pre><p>  3、?表示属性是可选的</p>
<pre><code>// [propName: string]: any 表示允许 obj[xxx] 这样的动态属性
interface SquareConfig {  
  color?: string;  
  width?: number;  
  [propName: string]: any;
}
</code></pre><p>  4、函数接口</p>
<pre><code>interface SearchFunc {  
  (source: string, subString: string): boolean;
}
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>  1、参数</p>
<pre><code>function fn(source: string, subString: string){
  let result = source.search(subString);
  return result &gt; -1;
}
fn(&apos;aaa&apos;, &apos;bbbbb&apos;);
</code></pre><p>  2、为函数定义类型</p>
<pre><code>function add(x: nubmer, y: number): number {
  return x + y;
}
</code></pre><p>  2、索引类型</p>
<pre><code>interface StringArray {
  [index: number]: string;
}
let myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];

let myStr: string = myArray[0];
</code></pre><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>  泛型允许延迟编写类或方法中元素的数据类型</p>
<pre><code>function identity&lt;T&gt;(arg: T): T{
  return arg;
}

function main() {
  const result = identity&lt;number&gt;(1);
}
</code></pre><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>  1、创建类</p>
<pre><code>class Greeter {
  greeting: string;
  constructor(message: string){     // 定义message为字符串类型
    this.greeting = message;
  }
  greet(){
    return `Hello, ${this.greeting}`;
  }
}

let oGreeter = new Greeter(&apos;111&apos;);
</code></pre><p>  2、继承</p>
<pre><code>class Animal {
  move(distance: number = 0) {
    console.log(`Animal moved ${distance}.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(&apos;Woof! Woof!&apos;);
  }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre><p>  3、增加了public, private(不能被外部访问), protected（不能被外部访问，只能被内部和继承访问）, readonly 等访问控制修饰符</p>
<pre><code>class Person {  
  protected name: string;  
  constructor(name: string) {    
    this.name = name;  
  }
}
class Employee extends Person {  
  private department: string;  
  constructor(name: string, department: string) {    
    super(name);    
    this.department = department;  
  }  
  public getElevatorPitch() {    
    return `Hello, my name is ${this.name} and I work in ${this.department}.`;  
  }
}

readonly属性：
class Person {
  readonly name: string = &apos;john&apos;; // 我只读
  constructor(theName: string) {
    this.name = theName; // 可以
  }

  setName() {
    this.name = &apos;lili&apos;; // 报错
  }
}
</code></pre><p>  4、静态属性static</p>
<pre><code>static成了所有实例共有的成员

class Person {
  static globalPeopleCount: number = &apos;7000000000&apos;;
}
const john = new Person();
john.globalPeopleCount += 1;

const lili = new Person();
lili.globalPeopleCount // 7000000001
</code></pre><p>  5、抽象类</p>
<pre><code>不能被实例化的类型，目的就是用来继承

abstract class Animal {
  abstract makeSound(): void;
  move(): void {
    console.log(&apos;roaming the earch...&apos;);
  }
}
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>  1、node</p>
<pre><code>$ npm install -g ts-node  // 安装ts-node来执行ts文件

$ ts-node server.ts       // 执行
</code></pre><p>  2、react配置</p>
<pre><code>$ npm install @types/react
</code></pre><p>  2、tsconfig.json</p>
<pre><code>{  
  &quot;compilerOptions&quot;: {   
    &quot;module&quot;: &quot;commonjs&quot;,          // 表示这是一个 Node.js 项目，使用 CommonJS 模块机制。
    &quot;moduleResolution&quot;: &quot;node&quot;, 
    &quot;target&quot;: &quot;es6&quot;,             // 指定将代码编译到 ES6
    &quot;rootDir&quot;: &quot;src&quot;,            // 指定源码输入目录和编译后的代码输出目录
    &quot;outDir&quot;: &quot;dist&quot;, 
    &quot;sourceMap&quot;: true, 
    &quot;noImplicitAny&quot;: true,       // 开头的几个选项指定一些更严格的检查
    &quot;noImplicitReturns&quot;: true, 
    &quot;noImplicitThis&quot;: true 
  }
}
</code></pre><p>  3、TSlint</p>
<pre><code>$ npm install tslint -g

根目录创建tslint.json:
{  
  &quot;extends&quot;: [ &quot;tslint:recommended&quot; ],  
  &quot;rules&quot;: {    
    &quot;no-console&quot;: [ false],    
    &quot;only-arrow-functions&quot;: [ false ] 
  }
}

$ tslint --fix src/**/*.ts      // 执行
</code></pre><p>  4、webpack中使用</p>
<pre><code>$ npm install ts-loader typescript --save-dev

webpack.config.js

module.exports = {
  entry: &apos;./app.ts&apos;,
    output: {
    filename: &apos;bundle.js&apos;
    },
    resolve: {
      extensions: [ &apos;.ts&apos;, &apos;.tsx&apos;, &apos;.js&apos; ]
    },
    module: {
      loaders: [     
        {
          test: /.tsx?$/
          loader: &apos;ts-loader&apos;
        }    
      ]
    },
  };

tsconfig.json中配置

{  
  &quot;compilerOptions&quot;: {    
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;target&quot;: &quot;es6&quot;,
    &quot;noImplicitAny&quot;: true,
    &quot;noImplicitReturns&quot;: true,
    &quot;noImplicitThis&quot;: true  
  }
}
</code></pre><p>  5、小程序</p>
<pre><code>https://segmentfault.com/a/1190000008175944
</code></pre><p>| <a href="https://github.com/semlinker/awesome-typescript" target="_blank" rel="noopener">https://github.com/semlinker/awesome-typescript</a>       // 合集<br>| <a href="https://zhongsp.gitbooks.io/typescript-handbook/doc/handbook/Basic%20Types.html" target="_blank" rel="noopener">https://zhongsp.gitbooks.io/typescript-handbook/doc/handbook/Basic%20Types.html</a><br>| <a href="https://mp.weixin.qq.com/s/Oyawvb5BD-OKvMuF2tQ0pw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Oyawvb5BD-OKvMuF2tQ0pw</a>?<br>| <a href="https://www.jianshu.com/p/f317a3c01b58" target="_blank" rel="noopener">https://www.jianshu.com/p/f317a3c01b58</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/14/React(之四)其它状态管理及框架/">React（之四）其它框架状态管理及框架</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/12/14/React(之四)其它状态管理及框架/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-14T03:06:16.000Z" itemprop="datePublished">2018-12-14</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| dva<br>| redux<br>| redux-saga<br>| redux-thunk<br>| Ant Design Pro</p>
<h4 id="状态管理框架"><a href="#状态管理框架" class="headerlink" title="状态管理框架"></a>状态管理框架</h4><pre><code>https://cn.mobx.js.org/

// redux-saga 中间件
https://redux-saga-in-chinese.js.org/    

// dva
https://dvajs.com/guide/#%E7%89%B9%E6%80%A7        dva
</code></pre><h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><pre><code>redux-saga 是一个用于管理 Redux 应用异步操作的中间件（又称异步 action），Sagas是通过Generator函数来创建

Reducers 负责处理 action 的 state 更新
Sagas 负责协调那些复杂或异步的操作

一、安装

    $ npm install --save redux-saga


二、使用

    sagas.js   // 创建一saga.js文件

    main.js

        import { createStore, applyMiddleware } from &apos;redux&apos;
        import createSagaMiddleware from &apos;redux-saga&apos;

        import reducer from &apos;./reducers&apos;
        import mySaga from &apos;./sagas&apos;

        // 创建saga中间件
        const sagaMiddleware = createSagaMiddleware()

        // 加到createStore中
        const store = createStore(
            reducer,
            applyMiddleware(sagaMiddleware)
        )

        // 运行 saga
        sagaMiddleware.run(mySaga)


三、核心函数

    1、takeEveny(&apos;actionName&apos;, 执行的saga函数) - type的action触发，就执行goAge()函数

    2、takeLatest()

    3、createSagaMiddleware()：创建一个Reudx中间件，将Sagas与Redux Store链接起来

    4、middleware.run()：运行sagas，


四、Effect 

    import { call, put, takeEveny } from &apos;redux-saga/effects&apos;

    1、take()：监听未来的action

        function* watchFetchData() {
            while(true) {
                // 监听一个type为 &apos;FETCH_REQUESTED&apos; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData)  语句
                yield take(&apos;FETCH_REQUESTED&apos;);
                yield fork(fetchData);
            }
        }

    2、takeEveny(): 

        function* rootSaga() {     // 在store.js中，执行了 sagaMiddleware.run(rootSaga)
            yield takeEvery(&quot;ADD_SAGA&quot;, addSagas)   // 如果有对应type的action触发，就执行goAge()函数
        }

    3、put()：发送action的effect，简单把它理解为dispatch

        export function* toggleItemFlow() {
            let list = []
            // 发送一个type为 &apos;UPDATE_DATA&apos; 的Action，用来更新数据，参数为 `data：list`
            yield put({
                type: actionTypes.UPDATE_DATA,
                data: list
            })
        }

    4、call()：简单的理解为就是可以调用其他函数的函数

        export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

        export function* removeItem() {
            try {
                // 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数
                return yield call(delay, 500)
            } catch (err) {
                yield put({type: actionTypes.ERROR})
            }
        }

    5、fork()：用来调用其它函数，是一个非阻塞函数，

        export default function* rootSaga() {
            // 下面的四个 Generator 函数会一次执行，不会阻塞执行
            yield fork(addItemFlow)
            yield fork(removeItemFlow)
            yield fork(toggleItemFlow)
            yield fork(modifyItem)
        }

    6、select()：获取Store中的state值

        let tempList = yield select(state =&gt; {
            debugger;
        })


https://www.jianshu.com/p/7cac18e8d870
https://github.com/redux-saga/redux-saga/ 官网
https://redux-saga-in-chinese.js.org/ 中文在线文档
https://segmentfault.com/a/1190000007248878 Redux异步方案选型
https://www.jianshu.com/p/f3c7594c4fb4 redux-saga 初级学习教程
https://github.com/Pines-Cheng/blog/issues/9 从redux-thunk到redux-saga实践
http://yanqiw.github.io/react/2017/03/05/redux-saga.html Redux Saga实践
</code></pre><h4 id="dva-js"><a href="#dva-js" class="headerlink" title="dva.js"></a>dva.js</h4><pre><code>dva是redux和redux-saga的数据流文案，还内置了react-router和fetch的一个应用框架

一、安装

    $ sudo npm i dva-cli -g

    $ sudo dva new dva-quickstart


二、定义Model

    把一个领域的模型管理起来，包含同步更新state的reducers，处理异步逻辑

    export default {
        namespace: &apos;products&apos;,  // 表示在全局 state 上的 key，最好与组件名相同保持统一
        state: {},                            // 初始值
        reducers: {                            // 等同于 redux 里的 reducer，接收 action，同步更新 state
            save(state, action) {
                return {
                    ...state,
                    data: action.payload,
                };
            },
        }
    }


三、connect 起来

    通过connect将model和component联接起来

    class products extends Componet {
        ... 

        render {
            const { dispatch, products } = this.props

            return (
                &lt;div&gt;&lt;/div&gt;
            )
        }
    }

    export default connect(({ products }) =&gt; ({
        products,
    }))(Products);


四、models

    dispatch

    Reducer(state, action): 

    effects: 异步操作，底层引入redux-sagas，采用了generator

    Subscription: 

    Router: 


五、整理

    1、调用同步和异步

        调用reducers内的方法是同步，直接改变指定state的值

        调用effects内的方法是异步的调用，调取成功后在调用reducers中的方法来改变state


安装后目录结构:
|- mock                        // mock
|- node_modules        // 包
|- package.json        
|- public
|- src
        |- asserts            // 静态资源，打包会经过webpack处理
        |- components        // 存放React组件，公用的无状态组件
        |- models                // 模型文件
        |- routes                // 存放需要connect model的路由组件
        |- services            // 存放服务文件，一般是网络请求
        |- utils                // 工具库
        |- router.js        // 路由文件
        |- index.js            // 项目入口
        |- index.css
|- .editorconfig        // 编辑器配置文件
|- .eslintrc
|- .gitignore
|- .roadhogrc.mock.js    // Mock配置文件
|- .webpackrc                //  自定义的webpack配置文件


https://dvajs.com/        // dva
</code></pre><h4 id="Ant-Design-Pro"><a href="#Ant-Design-Pro" class="headerlink" title="Ant Design Pro"></a>Ant Design Pro</h4><pre><code>安装:
$ git clone --depth=1 https://github.com/ant-design/ant-design-pro.git my-project
$ cd my-project
$ npm install

启动服务:
$ npm start                            // mock数据
$ npm start:no-mock         // 不走mock数据
$ npm run prettier            // 格式化代码
$ npm run lint-staged        // 检测

构建:
$ npm run build


一、路由

    脚手架默认提供了两种布局模板：基础布局 - BasicLayout 以及 账户相关布局 - UserLayout

    router.config.js

    1、name、icon - 菜单项和图标

    2、hideChildrenInMenu - 菜单子路由是否展示

    3、hideInMenu - 菜单中不展示这个路由

    4、authority - 指写可以看当前菜单的用户 Array

    // app
    {
        path: &apos;/&apos;,
        component: &apos;../layouts/BasicLayout&apos;,
        Routes: [&apos;src/pages/Authorized&apos;],
        authority: [&apos;admin&apos;, &apos;user&apos;],
        routes: [
            {
                path: &apos;/dashboard&apos;,
                name: &apos;dashboard&apos;,
                icon: &apos;dashboard&apos;,
                hideChildrenInMenu: true,                    // 隐藏所有子菜单，但这块需要加一个对应dashboard路由的component: &apos;./Dashboard/Analysis&apos;
                routes: [
                    {
                        path: &apos;/dashboard/analysis&apos;,
                        name: &apos;analysis&apos;,
                        component: &apos;./Dashboard/Analysis&apos;,
                    },
                    ...
                ],
            }
        ]
    }
    // new 这里是新增布局
    {
        path: &apos;/new&apos;,
        component: &apos;../layouts/new_page&apos;,
        routes:[...]
    },


二、config.js 配置代理到后端服务器

    {
        proxy:{
            &apos;/server/api/&apos;: {
                target: &apos;https://preview.pro.ant.design/&apos;,
                changeOrigin: true,
                pathRewrite: { &apos;^/server&apos;: &apos;&apos; }, // /server/api/currentUser -&gt; /api/currentUser
            },
        }
    }

三、支持SASS

    $ npm i node-sass sass-loader --save            // 安装依赖


四、页面添加 dva

    modle - 分两种: 1、全局models（存在/src/models/）   2、页面models （存在于每个业务下/models 不能被其他页面所引用）

    service - 请求数据


五、请求的过程

    1、UI 组件交互操作

    2、调用 model 的 effect

    3、调用统一管理的 service 请求函数

    4、使用封装的 request.js 发送请求

    5、获取服务端返回

    6、然后调用 reducer 改变 state

    7、更新 model


六、Mock

    export default {
        // 支持值为 Object 和 Array
        &apos;GET /api/users&apos;: { users: [1, 2] },

        // GET POST 可省略
        &apos;/api/users/1&apos;: { id: 1 },

        // 支持自定义函数，API 参考 express@4
        &apos;POST /api/users/create&apos;: (req, res) =&gt; { res.end(&apos;OK&apos;); },
    };

    1、可以引用Mock.js第三方库

        import mockjs from &apos;mockjs&apos;;

        export default {
            // 使用 mockjs 等三方库
            &apos;GET /api/tags&apos;: mockjs.mock({
                &apos;list|100&apos;: [{ name: &apos;@city&apos;, &apos;value|1-100&apos;: 50, &apos;type|0-2&apos;: 1 }],
            }),
        };

七、自定义主题

    config/config.js文件

    theme: {
        &apos;font-size-base&apos;: &apos;14px&apos;,
        &apos;badge-font-size&apos;: &apos;12px&apos;,
        &apos;btn-font-size-lg&apos;: &apos;@font-size-base&apos;,
        &apos;menu-dark-bg&apos;: &apos;#00182E&apos;,
        &apos;menu-dark-submenu-bg&apos;: &apos;#000B14&apos;,
        &apos;layout-sider-background&apos;: &apos;#00182E&apos;,
        &apos;layout-body-background&apos;: &apos;#f0f2f5&apos;,
    };


八、项目总结

    1、Mock数据不能在生产环境使用，只能在开发环境

    2、使用动态路由时切换时取不到参数，见下面UMI动态路由解决方法
</code></pre><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><pre><code>├── config              # umi 配置，包含路由，构建等配置
│   ├── config.js                        #    构建
│   ├── plugin.config.js
│   ├── router.config.js      # 路由配置文件
├── mock                # 本地模拟数据
├── public
│   └── favicon.png         # Favicon
├── layouts                            # 框架页面
├──     ├── BasicLayout                # Basic框架页
├──     ├── Header                        # 头  
├──   ├── Footer                        # 尾
├── locales
|          ├── zh-CN
|            |            ├── menu.js            # 配置显示在菜单对应路由的中文名
├── src                                    # 重要
│   ├── assets              # 本地静态资源
│   ├── components          # 业务通用组件
│   │       ├── GlobalHeader        # 顶部右侧部分内容
│   ├── e2e                 # 集成测试用例
│   ├── layouts             # 通用布局
│   │            ├── BasicLayouts      # 基础布局
│   ├── models              # 全局 dva model
│   |            ├── menu.js                    # 菜单处理过滤
│   |            ├── login.js                # 登录请求
│   ├── pages               # 业务页面入口和常用模板
│   │            ├── document.ejs        # 首页模板
│   │            ├── User                        # Login/Register  登录和注册组件
│   ├── services            # 后台接口服务
│   ├── utils               # 工具库
│   ├── locales             # 国际化资源
│   ├── global.less         # 全局样式
│   ├── defaultSettings.js    # 配置菜单样式等
│   └── global.js           # 全局 JS
├── utils                                # 工具
├──     ├── request.js                # 封装Ajax请求
├──     ├── Authorized                # 授权
├── models                            # 全局
├──     ├── menu                            # 菜单的配置和过滤
├──   ├── 
├── tests               # 测试工具
├── README.md
└── package.json
</code></pre><h4 id="Umi-js"><a href="#Umi-js" class="headerlink" title="Umi.js"></a>Umi.js</h4><pre><code>umi，中文可发音为乌米, 内置了react、react-router，以路由为基础，支持next.js的约定式路由

一、安装

    $ yarn global add umi     // 安装 umi -v 来查看版本

    $ mkdir myumi &amp;&amp; cd myumi

    1、脚手架创建

        $ yarn creat umi                 // 通过creat-umi脚手架创建，其实就安装了 Ant Design Pro 的简版没有components


    2、普通创建

        $ umi g page index            // 简单创建页面

            umi g page users

        $ umi dev            // 启动服务

        $ umi build        // 构建


二、路由

    约定式路由 - 启动服务后在pages下产生一个.umi临时目录里面有router.js，umi 会根据 pages 目录自动生成路由配置

    配置式路由 - 如果使用配置可以在，config/router.config.js

    1、路由跳转: 

        import Link from &apos;umi/link&apos;            // 加载link

        export default function(){
            return (
                &lt;div&gt;
                    &lt;Link to=&quot;/user&quot;&gt;跳转到用户&lt;/Link&gt;
                &lt;/div&gt;
            )
        }

        命令式:
            function goToListPage() {
                router.push(&apos;/list&apos;);
            }

    2、动态路由

        umi约定 带 $ 前缀的目录或文件为动态路由

        + pages/
            + $post/
                - index.js
                - comments.js
            + users/
                $id.js
            - index.js

        [
            { path: &apos;/&apos;, component: &apos;./pages/index.js&apos; },
            { path: &apos;/users/:id&apos;, component: &apos;./pages/users/$id.js&apos; },
            { path: &apos;/:post/&apos;, component: &apos;./pages/$post/index.js&apos; },
            { path: &apos;/:post/comments&apos;, component: &apos;./pages/$post/comments.js&apos; },
        ]

        注意: 动态路由切换时不会在调用componentWillMount，需要在componentDidUpdate来侦听

             state = {
                chartId: &apos;&apos;
            };

            componentDidUpdate(){
                const { computedMatch } = this.props;
                const { chartId } = this.state;

                if(chartId !== computedMatch.params.id){
                    this.initChartList();
                }
            }

            initChartList(){
                const { dispatch, computedMatch } = this.props;
                console.log(computedMatch.params.id)

                this.setState({
                    chartId: computedMatch.params.id
                })

                dispatch({
                    type: &apos;chartData/getChartsData&apos;,
                    payload: {
                        pageId: computedMatch.params.id
                    }
                });
            }


    3、路由嵌套

        配置routers

        export default {
            routes: [
                { path: &apos;/users&apos;, component: &apos;./users/_layout&apos;,
                    routes: [
                        { path: &apos;/users/detail&apos;, component: &apos;./users/detail&apos; },
                        { path: &apos;/users/:id&apos;, component: &apos;./users/id&apos; }
                    ]
                },
            ],
        };

    4、权限

        PrivateRoute.js来渲染/list

    https://umijs.org/zh/guide/router.html#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1


三、Mock 数据

    let agentDataList = [...]
    function getAgents(req, res) {
        const dataSource = agentDataList;
        const result = {
            list: dataSource,
            total: dataSource.length,
        };
        return res.json(result);
    }

    export default {
        &apos;POST /api/arbitration/agent/query&apos;: getAgents,
    }

    --- 可以引入mock.js ---
    import mockjs from &apos;mockjs&apos;;
    export default {
        // 使用 mockjs 等三方库
        &apos;GET /api/tags&apos;: mockjs.mock({
            &apos;list|100&apos;: [{ name: &apos;@city&apos;, &apos;value|1-100&apos;: 50, &apos;type|0-2&apos;: 1 }],
        }),
    };
</code></pre><h2 id="antdPro-流程"><a href="#antdPro-流程" class="headerlink" title="antdPro 流程"></a>antdPro 流程</h2><pre><code>一、app.js入口

    // 获取权限路由，也可以在这添加路由
    fetch(&apos;/api/auth_routes&apos;)
  .then(res =&gt; res.json())
  .then(ret =&gt; {
    authRoutes = ret;
    oldRender();
  });


二、login 登录接口

    request: /api/login/account
    response: {status: &quot;ok&quot;, type: &quot;account&quot;, currentAuthority: &quot;admin&quot;}


三、设置和获取权限 

    router.config.js 配置Routes每个页面都调用Authorized.js来判断权限
    {
        path: &apos;/&apos;,
        component: &apos;../layouts/BasicLayout&apos;,
        Routes: [&apos;src/pages/Authorized&apos;],                // 设置
        authority: [&apos;admin&apos;, &apos;user&apos;, &apos;ROLE_RDDPL4WSV0&apos;],
        routes: [
            { path: &apos;/&apos;, redirect: &apos;/dashboard/workplace&apos;, authority: [&apos;admin&apos;, &apos;user&apos;, &apos;ROLE_RDDPL4WSV0&apos;] },
        ]
    }


    utils/authority   getAuthority、setAuthority

    存储到localStrage中的antd-pro-authority


四、菜单

    modules/menu        getMenuData()获取菜单的方法

    layouts/BasicLayouts        页面布局，SiderMenu组件menuData菜单数据

    menuData格式
    [{
        &quot;path&quot;: &quot;/dictionary&quot;,
        &quot;icon&quot;: &quot;book&quot;,
        &quot;name&quot;: &quot;数据字典&quot;,
        &quot;locale&quot;: &quot;menu.dictionary&quot;,
        &quot;authority&quot;: [&quot;admin&quot;, &quot;user&quot;],
        &quot;children&quot;: [{
            &quot;path&quot;: &quot;/dictionary/list&quot;,
            &quot;name&quot;: &quot;字典列表&quot;,
            &quot;exact&quot;: true,
            &quot;locale&quot;: &quot;menu.dictionary.list&quot;
        }, {
            &quot;path&quot;: &quot;/dictionary/create&quot;,
            &quot;name&quot;: &quot;新建字典&quot;,
            &quot;exact&quot;: true,
            &quot;locale&quot;: &quot;menu.dictionary.create&quot;
        }]
    }]
</code></pre><h4 id="react使用typescript"><a href="#react使用typescript" class="headerlink" title="react使用typescript"></a>react使用typescript</h4><pre><code>1、state和props定义

    interface IProps {
        aProps: string;
        bProps: string;
    }
    interface IState {
        aState: string;
        bState: string;
    }

    class App extends React.PureComponent&lt;IProps, IState&gt; {
        state = {
            aState: &apos;&apos;,
            bState: &apos;&apos;,
        };

        render(){
            this.props.aProps;
            this.state.aState;
            return null;
        }
    }

    const mapStateToProps = () =&gt; {
        return {
            aProps: &apos;a&apos;,
            bProps: &apos;b&apos;
        }
    }
    const mapDispatchToProps = {};
    export default connect(mapStateToProps, mapStateToProps)(App)
</code></pre><p>| <a href="https://www.jianshu.com/p/c7b3b9c98d04" target="_blank" rel="noopener">https://www.jianshu.com/p/c7b3b9c98d04</a><br>| <a href="https://umijs.org/zh/plugin/umi-plugin-react.html#%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">https://umijs.org/zh/plugin/umi-plugin-react.html#%E5%AE%89%E8%A3%85</a>            // umiJS</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/07/20/axios-ajax请求封装/">axios</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/07/20/axios-ajax请求封装/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-07-20T06:08:21.000Z" itemprop="datePublished">2018-07-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端插件/">前端插件</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>$ npm i axios            // 阿西奥斯

引用 const axios = require(&apos;axios&apos;);

$ bower install axios

cdn &lt;script src=&quot;http://unpkg.com/axios/dist/axios.min.js&quot;&gt;
</code></pre><h4 id="Request参数"><a href="#Request参数" class="headerlink" title="Request参数"></a>Request参数</h4><pre><code>{
    baseUrl: &apos;/api&apos;                    // 基础url
    url: &apos;/databaseList&apos;,        // 请求的接口，与基础合起来为&apos;/api/databaseList&apos;
    method: &apos;get&apos;,        // 请求方式，default=get

    // 设置头部信息
    headers: {
        &apos;Content-Type&apos;: &apos;Application-json&apos;,
        &apos;X-token&apos;: &apos;1k12hkj34j2kbjhs9df74b&apos;},
    },

    // URL的参数，get或Content-Type=&apos;application/x-www-form-urlencoded&apos;使用的参数，不能用data
    params: {
        ID: 12345
    },

    // data发送的主休，用于post、stream、buffer
    data: {
        username: &apos;sigunag&apos;,
        password: &apos;*******&apos;
    },

    // 超时时间
    timeout: 1000,

    // 响应类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos;
    responseType: &apos;json&apos;,

    // 响应的编码
    responseEncoding: &apos;utf8&apos;,

    // socket代理路径
    socketPath: null, // default

    // keepAlive 保持连接，默认不启动
    httpAgent: new http.Agent({ keepAlive: true }),
    httpsAgent: new https.Agent({ keepAlive: true }),

    // 代理主机
    proxy: {
        host: &apos;127.0.0.1&apos;,
        port: 9000,
        auth: {
            username: &apos;mikeymike&apos;,
            password: &apos;rapunz3l&apos;
        }
    },

    // 取消请求
    cancelToken: new CancelToken(function (cancel) {

    })

    // 一个可选的函数负责序列化“参数”
    paramsSerializer: function(params) {
        return Qs.stringify(params, {arrayFormat: &apos;brackets&apos;})
    },

    transformRequest: [function (data, headers) {        // 在请求服务器之前的回调，适用于post
        return data;
    }],
    transformResponse: [function (data) {        // 在响应的回调，适用于post
        return data;
    }],
}
</code></pre><h4 id="Response参数"><a href="#Response参数" class="headerlink" title="Response参数"></a>Response参数</h4><pre><code>{
    // 响应数据
    data: {},

    // 状态码
    status: 200,

    // http响应状态消息
    statusText: &apos;OK&apos;,

    // 响应头
    headers: {},

    // `config` is the config that was provided to `axios` for the request
    config: {},

    // `request` is the request that generated this response
    // It is the last ClientRequest instance in node.js (in redirects)
    // and an XMLHttpRequest instance the browser
    request: {}
}
</code></pre><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><pre><code>const axios = require(&apos;axios&apos;);


const request = axios.create({
      baseURL: &apos;/api&apos;,     // api的base_url
        timeout: 10000,     // 请求超时时间 ms
})

/* 创建拦截器 */
// 请求拦截器
request.interceptors.request.use(
    (config) =&gt; {
        // Do something before request is sent
        return config;
    }, 
  (error) =&gt; {
        // Do something with request error
        return Promise.reject(error);
    }
);

// 响应拦截器
request.interceptors.response.use(
    (response) =&gt; {
        // Do something with response data
        return response;
    }, 
    (error) =&gt; {
        // Do something with response error
        return Promise.reject(error);
    }
);

axios.get(&apos;/user&apos;, {        
    params: {
        ID: 12345
    }
})
.then((d) =&gt; {
    // success
})
.catch((error) =&gt; {
    // error
})
.then(() =&gt; {
    //
})


一、请求参数 

    1、get或content-type=&quot;application/x-www-form-urlencoded&quot; 使用 params来加参数

    2、post、content-type=&quot;application/json&quot; 使用 data来传参数
</code></pre><h4 id="axios-all-处理多个请求"><a href="#axios-all-处理多个请求" class="headerlink" title="axios.all 处理多个请求"></a>axios.all 处理多个请求</h4><pre><code>就是promis.all()，多个请求全部执行成功后在执行

function getUserAccount() { return axios.get(&apos;/user/12345&apos;);     }
function getUserPermissions() { return axios.get(&apos;/user/12345/permissions&apos;); }

axios.all([getUserAccount(), getUserPermissions()])
    .then(axios.spread(function (acct, perms) {
        // Both requests are now complete
    }));
</code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code>一、axios(config)

    1、post请求

        axios.request(&apos;/user/12345&apos;,{
            method: &apos;post&apos;,
            data: {
                firstName: &apos;Fred&apos;,
                lastName: &apos;Flintstone&apos;
            }
        });

    2、get请求

        axios.request(&apos;http://bit.ly/2mTM3nY&apos;, {
            method:&apos;get&apos;,
            responseType:&apos;stream&apos;
        })
        .then(function(response) {
            response.data.pipe(fs.createWriteStream(&apos;ada_lovelace.jpg&apos;))
        });

二、创建实例

    const request = axios.create({
        baseURL: &apos;/api&apos;,            // 基础
        timeout: 1000,                // 请求超时时间
        headers: {&apos;X-Custom-Header&apos;: &apos;foobar&apos;}
    });


{


}
</code></pre><h4 id="axios-mock-adapter-axios使用mock"><a href="#axios-mock-adapter-axios使用mock" class="headerlink" title="axios-mock-adapter axios使用mock"></a>axios-mock-adapter axios使用mock</h4><pre><code>https://github.com/ctimmerm/axios-mock-adapter
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/10/23/微信小程序、公众号开发/">微信小程序、公众号开发</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/10/23/微信小程序、公众号开发/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-10-23T08:02:17.000Z" itemprop="datePublished">2017-10-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/微信小程序/">微信小程序</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h4><pre><code>一、appleID的获取

    https://mp.weixin.qq.com/wxopen/basicprofile?action=index&amp;token=767275273&amp;lang=zh_CN

    在开发设置选项 =&gt; AppID(小程序ID)

二、文件类型

    1、app.js 脚本文件        2、app.json 配置文件        3、app.wxml 页面结构        4、app.wxss样式文件
</code></pre><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><pre><code>一、app.json配置

    {
        // 页面路径
        &quot;pages&quot;: [
            &quot;pages/index/index&quot;,            // 初始显示的组件用
            &quot;pages/logs/index&quot;
        ],
        // 默认页面窗口表现
        &quot;window&quot;: {
            &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
        },
        // 底部tab的表现
        &quot;tabBar&quot;: {
            &quot;list&quot;: [
                {
                    &quot;pagePath&quot;: &quot;pages/index/index&quot;,
                    &quot;text&quot;: &quot;首页&quot;
                }, 
                {
                    &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
                    &quot;text&quot;: &quot;日志&quot;
                }
            ] 
        },
        // 设置网络超时时间
        &quot;networkTimeout&quot;: {
            &quot;request&quot;: 10000,
            &quot;downloadFile&quot;: 10000
        },
        // 是否开启debug模式
        &quot;debug&quot;: true
    }

    https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html         // 各类别配置
</code></pre><h4 id="App-js-主函数"><a href="#App-js-主函数" class="headerlink" title="App.js 主函数"></a>App.js 主函数</h4><pre><code>一、事件

    1、onLaunch - 监听小程序初始化，初始化完成会触发onLaunch

    2、onShow - 监听小程序显示，小程序启动、从后台进入前台显示，触发onShow

    3、onHide - 监听小程序隐藏，从前台进入后台，会触发onHide

    4、onError - 错误监听，脚本错误或api调用失败触发


二、onLaunch和onShow的参数 

    App({
        onLaunch: function (path) {
            console.log(path);
        }
    })

    1、path - String    打开小程序的路径

    2、query - Object 打开小程序的query

    3、scene - Number 打开小程序的场景值

    4、shareTicket - String    shareTicket，详见 获取更多转发信息

    5、referrerInfo - Object    当场景为由从另一个小程序或公众号或App打开时，返回此字段

        返回值:
            1020    公众号 profile 页相关小程序列表    返回来源公众号 appId
            1035    公众号自定义菜单    返回来源公众号 appId
            1036    App 分享消息卡片    返回来源应用 appId
            1037    小程序打开小程序    返回来源小程序 appId
            1038    从另一个小程序返回    返回来源小程序 appId
            1043    公众号模板消息    返回来源公众号 appId

    6、referrerInfo.appId - String 来源小程序或公众号或App的 appId，详见下方说明

    7、referrerInfo.extraData - Object 来源小程序传过来的数据，scene=1037或1038时支持


三、getApp() 全局函数用来获取小程序实例

    var appInstance = getApp();

    app.globalData.userInfo;        // 获取当前用户信息
</code></pre><h4 id="Page-用来注册一个页面"><a href="#Page-用来注册一个页面" class="headerlink" title="Page() 用来注册一个页面"></a>Page() 用来注册一个页面</h4><pre><code>指定页面的初始数据、生命周期、事件处理

一、生命周期

    onLoad: 页面加载，一个页面只会调用一次

    onShow: 页面显示 

    onReady: 页面初次渲染完成

    onHide: 页面隐藏

    onUnload: 页面卸载

    /** 生命周期函数--监听页面加载 **/
    onLoad: function (options) {
        console.log(options);
    },

    /** 生命周期函数--监听页面初次渲染完成 **/
    onReady: function () {

    },

    /** 生命周期函数--监听页面显示 **/
    onShow: function () {

    },

    /** 生命周期函数--监听页面隐藏 **/
    onHide: function () {

    },

    /** 生命周期函数--监听页面卸载 **/
    onUnload: function () {

    },

    /** 页面相关事件处理函数--监听用户下拉动作 **/
    onPullDownRefresh: function (e) {
        this.setData({
            updata: JSON.stringify(e)
        })
        console.log(e)
    },

    /** 页面上拉触底事件的处理函数 **/
    onReachBottom: function (e) {
        this.setData({
            updata: JSON.stringify(e)
        })
        console.log(e)
    },

    /** 用户点击右上角分享 **/
    onShareAppMessage: function () {

    }


二、事件方法

    data - 页面初始数据, WXML中调用 {{test}}

    onload - 监听页面加载

    onReady - 监听页面初次渲染完成

    onShow - 监听页面显示

    onHide - 监听页面隐藏

    onUnload - 监听页面卸载

    onPullDowRefesh - 监听用户下拉动作

    onReachBottom - 上拉触底事件

    onShareAppMessage - 用户点击右上角转发

        onShareAppMessage: function () {
            return {
            title: &apos;自定义转发标题&apos;,
            path: &apos;/page/user?id=123&apos;
            }
        }

    onPageScroll - 页面滚动触发


三、绑定事件

    &lt;view bindTap=&quot;viewTap&quot;&gt;click me&lt;/view&gt;

    Page({
        data:{
            message: &apos;view tap&apos;
        },
        viewTap: () =&gt; {
            console.log(this.message)
        }
    })


四、Page.prototype.route - 获取当前页面的路径

五、Page.prototype.setData() - 用于将数据从逻辑层发送到视图层，同时改变对应的this.data的值

    Page({
        data:{
            username: &apos;siguang&apos;
        }
        login: ()=&gt;{
            this.setData({
                username: &apos;lulu&apos;
            })
        }
    })
</code></pre><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><pre><code>所有页面的路由全部由框架管理

一、页面栈

    1、初始化 - 新页面入栈

    2、打开新页面 - 新页面入栈。  调用 API wx.navigateTo 或使用组件 &lt;navigator open-type=&quot;navigateTo&quot;/&gt;

    3、页面重定向 - 当前页面出栈，新页面入栈。  调用 API wx.redirectTo 或使用组件 &lt;navigator open-type=&quot;redirectTo&quot;/&gt;

    4、页面返回 - 页面不断出栈，直到目标返回页，新页面入栈。 调用 API wx.navigateBack 或使用组件&lt;navigator open-type=&quot;navigateBack&quot;&gt;或用户按左上角返回按钮

    5、Tab - 切换    页面全部出栈，只留下新的 Tab 页面。 调用 API wx.switchTab 或使用组件 &lt;navigator open-type=&quot;switchTab&quot;/&gt; 或用户切换 Tab

    6、重加载 - 页面全部出栈，只留下新的页面。 调用 API wx.reLaunch 或使用组件 &lt;navigator open-type=&quot;reLaunch&quot;/&gt;

    Example:
        bindViewTap: function() {
            wx.navigateTo({
                url: &apos;../logs/logs&apos;
            })
        }

二、getCurrentPages() 获取当前页面的栈的实例

三、Tips

    navigateTo, redirectTo 只能打开非 tabBar 页面。
    switchTab 只能打开 tabBar 页面。
    reLaunch 可以打开任意页面。
</code></pre><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><pre><code>一、全局变量和方法

    全局方法通过 getApp()获取全局的应用实例

    全局数据设置:

        App({
            globalData: 1
        })


二、模块化

    1、导出

        module.exports 或 exports对外暴露接口, exports是module.exports的一个引用

        小程序不支持直接引入node_modules, 如果需要就将代码拷到目录中

        // common.js
        function sayHello(name){
            console.log(`Hello ${name}`);
        }

        module.exports.sayHello = sayHello;


    2、引用

        conmmon = require(&apos;common.js&apos;);
        Page({
            helloMina: () =&gt;{
                common.sayHello(&apos;mina&apos;);
            }
        })
</code></pre><h4 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h4><pre><code>视图层WXMWXSS编写, 由组件进行展示

一、WXML

    1、数据绑定

        普通绑定: &lt;view&gt;{{message}}&lt;/view&gt;

        属性绑定: &lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;

        控制属性: &lt;view wx:if=&quot;{{condition}}&quot;&gt; &lt;/view&gt;


    2、循环渲染

        // 注意这里取到当前数据要用item
        &lt;view wx:for=&quot;{{arr}}&quot;&gt;{{item}}&lt;/view&gt;

        数组下标:
            &lt;view wx:for=&quot;{{arr}}&quot;&gt;
                姓名:{{item.name}} 年龄:{{item.age}} 序号:{{index}}
            &lt;/view&gt;

            两者相同
            &lt;view wx:for=&quot;{{arr}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
                姓名:{{itemName.name}} 年龄:{{itemName.age}} 序号:{{idx}}
            &lt;/view&gt;


    3、条件渲染

        &lt;view wx:if=&quot;{{view == 'webView'}}&quot;&gt;web view&lt;/view&gt;
        &lt;view wx:elif=&quot;{{view == 'app'}}&quot;&gt;app&lt;/view&gt;
        &lt;view wx:else=&quot;{{view == 'mina'}}&quot;&gt;mina&lt;/view&gt;

        Page({
            data: {
                view: &apos;app&apos;
            }
        })


    4、模板

        name: 模板名    is: 所要调用的模板名    data: 传入的数据

        &lt;template name=&quot;staffName&quot;&gt;
            &lt;view&gt;
                FirstName: {{firstName}}, lastName: {{lastName}}
            &lt;/view&gt;
        &lt;/template&gt;

        &lt;template is=&quot;staffName&quot; data=&quot;{{...staffA}}&quot;&gt;&lt;/template&gt;
        &lt;template is=&quot;staffName&quot; data=&quot;{{...staffB}}&quot;&gt;&lt;/template&gt;

        Page({
            data: {
                staffName: {fristName: &apos;sigunag&apos;, lastName: &apos;haha&apos;},
                staffName: {fristName: &apos;yuwan&apos;, lastName: &apos;lulu&apos;},
            }
        })
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>&lt;view bindtap=&quot;add&quot;&gt;{{count}}&lt;/view&gt;

Page({
    data: {
        count: 1
    },
    add: (event)=&gt;{
        this.setData({
            count: this.data.count++
        })
    }
})

一、事件分类

    分为冒泡事件和非冒泡事件

    冒泡事件:  bindtouchstart 前面加bind

        touchstart    手指触摸动作开始    
        touchmove    手指触摸后移动    
        touchcancel    手指触摸动作被打断，如来电提醒，弹窗    
        touchend    手指触摸动作结束    
        tap    手指触摸后马上离开    
        longpress    手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发    1.5.0
        longtap    手指触摸后，超过350ms再离开（推荐使用longpress事件代替）    
        transitionend    会在 WXSS transition 或 wx.createAnimation 动画结束后触发    
        animationstart    会在一个 WXSS animation 动画开始时触发    
        animationiteration    会在一个 WXSS animation 一次迭代结束时触发    
        animationend    会在一个 WXSS animation 动画完成时触发

    事件绑定和冒泡:

        bind 不会阻止冒泡事件向上冒泡，bindtap
        catch 可以阻止冒泡事件向上冒泡。catchtap

    事件捕获:

        捕获阶段监听事件时，采用capture-bind、capture-catch关键字, 后者将中断捕获阶段和取消冒泡

    事件对象:

        baseEvent对象


二、view、block标签

    view 渲染单独一行类似块元素

    block 渲染成内联元素
</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>提供两种引用方法import 和 include

一、import 引用外部的&lt;template&gt;模板

    &lt;!-- item.wxml --&gt;
    &lt;template name=&quot;item&quot;&gt;
        &lt;text&gt;{{text}}&lt;/text&gt;
    &lt;/template&gt;

    &lt;!--  index.wxml  --&gt;
    &lt;import src=&quot;item.wxml&quot;/&gt;
    &lt;template is=&quot;item&quot; data=&quot;{{text: 'forbar'}}&quot;/&gt;


二、include 引用非&lt;template&gt;模板的文件，公用的头尾等

    &lt;!-- index.wxml --&gt;
    &lt;include src=&quot;header.wxml&quot;/&gt;
    &lt;view&gt; body &lt;/view&gt;
    &lt;include src=&quot;footer.wxml&quot;/&gt;

    &lt;!-- header.wxml --&gt;
    &lt;view&gt; header &lt;/view&gt;

    &lt;!-- footer.wxml --&gt;
    &lt;view&gt; footer &lt;/view&gt;
</code></pre><h4 id="WXSS-样式语言"><a href="#WXSS-样式语言" class="headerlink" title="WXSS 样式语言"></a>WXSS 样式语言</h4><pre><code>尺寸单位: rex, 可以根据屏幕宽度自行自适应

一、样式导入

    @import &apos;common.wxss&apos;
    .middle-p {
        padding: 15px;
    }

二、内联样式
    data: {
        color: &apos;#ddd&apos;
    }
    &lt;view style=&quot;color: {{color}}&quot;&gt;

    &lt;view class=&quot;middle-p&quot;&gt;        // 多个class使用空格分隔

三、全局、局部样式

    定义在app.wxss中的样式为全局

    每个页的wxss为局部
</code></pre><h4 id="WXS-脚本"><a href="#WXS-脚本" class="headerlink" title="WXS 脚本"></a>WXS 脚本</h4><pre><code>小程序自己的一套脚本语言, 可以直接编写到WXML中, 也可以单独写成一个.wxs文件

一、写到wxml中

    &lt;!-- index.wxml&gt;
    &lt;wxs module=&quot;m1&quot;&gt;
        var msg = &apos;hello world&apos;;
        module.exports.message = msg
    &lt;/wxs&gt;

    &lt;view&gt;
        {{m1.message}}
    &lt;/view&gt;

二、写成一个.wxs文件

    // pages/comm.wxs
    // 如果comm.wxs文件中要引用其它的wxs文件使用require,  var tool = require(&apos;./tools.wxs&apos;);

    var foo = &quot;&apos;hello world&apos; from comm.wxs&quot;;
    var bar = function(d) {
        return d;
    }
    module.exports = {
        foo: foo,
        bar: bar
    };

    // 页面引用
    &lt;wxs src=&quot;./../tools.wxs&quot; module=&quot;tools&quot; /&gt;
    &lt;view&gt; {{tools.msg}} &lt;/view&gt;
</code></pre><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><pre><code>小程序两种启动方式:

    冷启动: 用户首次打开或小程序被微信主动销毁后在次打开的情况，

    热启动: 用户已经打开某个小程序，在一定时间内在次打开，此时无需重新启动，只需将后台切换到前台
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>网络请求request、文件上传下载uploadFile、webSocket都需要设置指定的服务器
</code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code>wx.getSystemInfo 或者 wx.getSystemInfoSync 获取小程序的基本库版本

wx.canIUse 判断是否可以在该基础库版本下直接使用对应的API或者组件
</code></pre><h4 id="开发总结"><a href="#开发总结" class="headerlink" title="开发总结"></a>开发总结</h4><pre><code>1、小程序初始指定页面

    app.json中, 调整pages数组的顺序, 第一个就是最先被载入

    &quot;pages&quot;:[
        &quot;pages/my/my&quot;,
        &quot;pages/index/index&quot;,
        &quot;pages/logs/logs&quot;    
    ]

2、当前页面使用修改标题

    在当前页面下的.json文件中加入

    goods-details.json
    {
        &quot;navigationBarTitleText&quot;: &quot;商品详情&quot;
    }

3、获取元素上的自定义属性值

    1) evt.currentTarget.dataset.propertyindex;        

    2) evt.detail

    &lt;view bindtap=&quot;labelItemTap&quot; data-propertyindex=&quot;{{idx}}&quot;&gt;&lt;/view&gt;        // 注意这里自定义属性需要以&quot;data-&quot;开头，并且不能为大写，如果有大写取值时全部为小写

    js:

    labelItemTap: function(evt){
        let val = evt.currentTarget.dataset.propertyindex;
    }

4、在app.json中配置pages的路径会自动创建目录和基本文件这里

    这里注意创建js时候会将生命周期方法和上拉下拉刷新方法全部都创建好，不必重写 onPullDownRefresh()、onReachBottom();
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>如果修改 checkbox 的样式

时间选择器只有时、分，没有秒

slider滑动组件拖动块不能改颜色

小程序下拉刷新不触发 onPullDownRefresh
</code></pre><h4 id="小程序与RN相比"><a href="#小程序与RN相比" class="headerlink" title="小程序与RN相比"></a>小程序与RN相比</h4><pre><code>小程序布局写法简单，RN的布局比较麻烦

小程序的组件简单，RN组件麻烦，并且IOS和Android兼容

RN可以随意发起网络请求访问数据，小程序需要指定服务器并且需要https协议

RN需要与通过Xcode来进去打包、并且需要在appStor进行发布审核

RN做的app需要到商店下载使用，小程序发布后在微信就可以找到
</code></pre><p>| <a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="noopener">http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html</a>        // 公众服务平台所有的sdk<br>| <a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=20171013" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=20171013</a>  // 小程序<br>| <a href="https://www.w3cschool.cn/weixinapp/9wou1q8j.html" target="_blank" rel="noopener">https://www.w3cschool.cn/weixinapp/9wou1q8j.html</a><br>| <a href="http://203.195.235.76/jssdk/" target="_blank" rel="noopener">http://203.195.235.76/jssdk/</a>   小程序demo<br>| <a href="https://github.com/gooking/awesome-wechat-weapp" target="_blank" rel="noopener">https://github.com/gooking/awesome-wechat-weapp</a>    微信小程序开发资源汇总</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/20/Jade模板/">Jade 模板</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/20/Jade模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-09-20T03:41:55.000Z" itemprop="datePublished">2017-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="jade介绍、安装"><a href="#jade介绍、安装" class="headerlink" title="jade介绍、安装"></a>jade介绍、安装</h4><pre><code>jade是前后端都可以使用的模板引擎7

1、安装:

    sudo npm i -g jade


2、介绍

    元素标签不需要写&lt;&gt;

    子元素与父元素需要换行并tab缩进

    标签与文本需要使用空格来隔开


3、jade的缺点

    1）可移植性差

    2）调试困难

    3）性能一般

4、初始阶段开发效率，稳定性成和协作的成本
</code></pre><h4 id="jade-头尾标签"><a href="#jade-头尾标签" class="headerlink" title="jade 头尾标签"></a>jade 头尾标签</h4><pre><code>&lt;!DOCTYPE&gt;
html
    head
        title ${title}

    body
        h1 标题内容
</code></pre><h4 id="命令行编译jade文件"><a href="#命令行编译jade文件" class="headerlink" title="命令行编译jade文件"></a>命令行编译jade文件</h4><pre><code># jade index.jade         // 会将jade文件编译成同级目录的index.html文件，并且是没有代码格式的只有一行

# jade -P index.jade     // 有缩进，可读的格式

# jade -P -w index.jade // 侦听jade文件有变化执行转换的命令

小技巧: 在sublime中打开 index.jade 和 index.html文件, 选择view菜单 -&gt; layout/ columns2 变成两列，将index.html放到另一列中，这样每次保存就可以看到html代码
</code></pre><h4 id="属性文本和值"><a href="#属性文本和值" class="headerlink" title="属性文本和值"></a>属性文本和值</h4><pre><code>1、class和id

    div.row

    div#row

    div#row.column-samil    // id=&quot;row&quot; class=&quot;column-samil&quot;

    div.rowA.main        // class=&quot;rowA main&quot;


2、属性

    a标签的href属性值，和自定义属性和值
    a(href=&quot;http://haha.com&quot;,
        title=&quot;jade&quot;,
            data-uid=&quot;siguang&quot;)

    input(name=&quot;course&quot; type=&quot;check&quot; checked)
</code></pre><h4 id="混合的文本和标签"><a href="#混合的文本和标签" class="headerlink" title="混合的文本和标签"></a>混合的文本和标签</h4><pre><code>1、如果字符里有点进行处理

    // 不会把.aa解析成 class=&quot;aa&quot; 并且换行,也能写html标签
    div.row
        p.
            1.aa &lt;strong&gt;这里字体加粗&lt;/string&gt;
            2.bb
            3.cc 
            4.dd

    或者
    div.row
        p
            | 1.aa 
            | 2.bb
            | 3.cc 
            | 4.dd
</code></pre><h4 id="注释和条件注释"><a href="#注释和条件注释" class="headerlink" title="注释和条件注释"></a>注释和条件注释</h4><pre><code>1、单行注释 //

2、不可见的注释 //-

3、块注释        //- 在当前节点的开头

4、条件注释

    &lt;!--[if IE 8]&gt;
        &lt;html class=&apos;ie8&apos;&gt;
    &lt;![endif]&gt;


    &lt;/html&gt;        // 需要html



div.row
    // a(href=&quot;http://haha.com&quot;, title=&quot;siguang&quot;, data-index=&quot;1&quot;) 去主站

    //- input(name=&quot;course&quot; type=&quot;check&quot; checked)

div.row
//-
    p.
        1.aa &lt;strong&gt;这里字体加粗&lt;/string&gt;
        2.bb
        3.cc 
        4.dd
</code></pre><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><pre><code>声明: - var course = &apos;jade&apos;

获取: #{jade}

1、命令行下传值
    jade index.jade -P -w --obj &apos;{&quot;name&quot;:&quot;siguang&quot;, age: 30}&apos;

    div.row
        div.column-12
            姓名: #{name}

        div.column-12
            年龄: #{age}

2、通过json传值

    jade index.jade -P -O test.json

    test.json
    {
        &apos;name&apos;: &apos;siguang&apos;,
        &apos;age&apos;: 30
    }
</code></pre><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><pre><code>1、将html转成字符串输出

    - var data = &apos;&lt;script&gt;alert(123)&lt;/script&gt;&apos;

    p #{data}


2、非转义

    - var data = &apos;&lt;script&gt;alert(123)&lt;/script&gt;&apos;

    p !{data}
</code></pre><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><pre><code>1、if...else...

    - var isData = true
    if isData
        div 对象存在
    else
        对象不存在


2、case

    - var name = &apos;jade&apos;
    case name
        when &apos;java&apos;
            div java

        when &apos;jade&apos;
            p hello jad



3、for 或 each 循环

    - var data = {&apos;name&apos;: &apos;siguang&apos;, &apos;nage&apos;: 30}
    div.row
        - for(var key in data)
            div= key +&apos;=&apos;+data[key]

    each()
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>相同结构的内容可以放到mixin中，相同一个函数

1、无参
    mixin 函数名        // 声明 
        p 这里是函数的块内容
        p 这里是函数的块内容
        p 这里是函数的块内容

    +函数名            // 调用

2、有参

    mixin 函数名(参数)
        each key in data
            li= data[key]

    +函数名({username: &apos;siguang&apos;, age: 30});
</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><pre><code>代码复用

定义一个html的基本结构，内容只写到body中

public.jade

    DOCTYPE html
    html
        head

        body
            block desc
                p 内容继承
            block content    // 这里接收内容


main.jade

    // 通过extends继承到哪个 jade文件
    extends public

    block content        // 这里写到哪里
        div.row
            p aaaa
            p aaaa
            p aaaa

        div.row-b
            p bbb
            p bbb
            p bbb
</code></pre><h4 id="include-引用"><a href="#include-引用" class="headerlink" title="include 引用"></a>include 引用</h4><pre><code>引用一个jade文件

DOCTYPE html
html
    head
        include head

    body
        include login
</code></pre><h4 id="jade-api"><a href="#jade-api" class="headerlink" title="jade api"></a>jade api</h4><pre><code>http的原声写法

1、jade.compile(source, 传值): 返回一个函数来生成html

2、jade.compileFile(path, 传值)

3、jade.compileClient(source, 传值)

4、jade.render(source, 传值):

5、jade.renderFile(jade文件, 传值):


compile()示例
    var http = require(&apos;http&apos;);
    var jade = require(&apos;jade&apos;);

    var server = http.createServer(function(req, res){
        res.writeHead(200, {&apos;ContentType&apos;: &apos;text/html&apos;});

        var fn = jade.compile(&apos;div #{course}&apos;, {});
        var html = fn({course: &apos;jade&apos;});

        res.end(html);
    })

    server.listen(&apos;8081&apos;, &apos;localhost&apos;)


render()示例

    var http = require(&apos;http&apos;);
    var jade = require(&apos;jade&apos;);

    var server = http.createServer(function(req, res){
        res.writeHead(200, {&apos;ContentType&apos;: &apos;text/html&apos;});
        var html = jade.render(&apos;div #{course} #{name}&apos;, {course: &apos;jade&apos;, name: &apos;siguang&apos;});
        res.end(html);
    })

    server.listen(&apos;8081&apos;, &apos;localhost&apos;)


{pretty:true} 如果不加此属性html会是压缩模式，加上格式化的代码
</code></pre><h4 id="将html编译成jade文件"><a href="#将html编译成jade文件" class="headerlink" title="将html编译成jade文件"></a>将html编译成jade文件</h4><pre><code>安装: sudo npm install html2jade -g

生成命令: html2jade ./public/index.html &gt; index.jade

在node中转换

var html2jade = require(&apos;html2jade&apos;);

html2jade.convertDocument(document, {}, function(err, jade){
    console.log(&apos;反编译后的jade文件&apos;)
})


在线转换: http://html2jade.vida.io/
</code></pre><p>| 参考资料<br>| <a href="http://www.cnblogs.com/fullhouse/archive/2011/07/18/2109945.html" target="_blank" rel="noopener">http://www.cnblogs.com/fullhouse/archive/2011/07/18/2109945.html</a><br>|<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/20/numjucks模板/">numjucks模板</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/20/numjucks模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-09-20T03:41:55.000Z" itemprop="datePublished">2017-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="numjucks"><a href="#numjucks" class="headerlink" title="numjucks"></a>numjucks</h4><pre><code>numjucks可以用任意扩展名来命名模板名文件，推荐使用&apos;.njk&apos;

$ npm install nunjucks

require(&apos;nunjucks&apos;);
</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>{{ usernmae }}    {{ foo.bar }}
</code></pre><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><pre><code>{{ foo | title }}    {{ foo | join(',') }}
</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><pre><code>定义一个&quot;block&quot;，子模板可以覆盖它

一、Example

    A.html

        {% block header %}{% endblock %}

			<div>
				aaaa
			</div>

		B.html

			{% extends 'A.html' %}

			{% block header %}
				<div>
					<ul>
						<li>aaaa</li>
						<li>bbbb</li>
						<li>cccc</li>
					</ul>
				</div>
			{% endblock %}

二、super()
</code></pre><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><pre><code>{% if num > 20 %}
		<div>
			大于20显示些内容
		</div>
	{% endif %}


{% if num > 20 %}
		<span>大于20</span>
	{% elif num < 6 %}
		<span>小于6</span>
	{% else %}
		<span>其它</span>
	{% endif %}
</code></pre><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre><code>一、遍历数组

    var items = [{ title: &quot;foo&quot;, id: 1 }, { title: &quot;bar&quot;, id: 2}];

    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;ul&gt;
        {% for item in items %}
				<li> {{item.title}} </li>
			{% endfor %}
    &lt;/ul&gt;

二、遍历对象

    var food = {
        &apos;ketchup&apos;: &apos;5 tbsp&apos;,
        &apos;mustard&apos;: &apos;1 tbsp&apos;,
        &apos;pickle&apos;: &apos;0 tbsp&apos;
    };

    &lt;div&gt;
        {% for key, value in food %}
				<p>{{key}} - {{value}}</p>
			{% endfor %}
    &lt;/div&gt;
</code></pre><h4 id="set-设置和修改变量"><a href="#set-设置和修改变量" class="headerlink" title="set 设置和修改变量"></a>set 设置和修改变量</h4><pre><code>let username = &apos;siguang&apos;;

{{ username }}            // siguang
{% set username = 'lulu' %}
{{ username }}            // lulu
</code></pre><h4 id="extends-指定模板继承"><a href="#extends-指定模板继承" class="headerlink" title="extends 指定模板继承"></a>extends 指定模板继承</h4><pre><code>{% extends 'A.html' %}

{% block header %}
		<div>
			<ul>
				<li>aaaa</li>
				<li>bbbb</li>
				<li>cccc</li>
			</ul>
		</div>
	{% endblock %}
</code></pre><h4 id="block-区块"><a href="#block-区块" class="headerlink" title="block 区块"></a>block 区块</h4><pre><code>{% block css %}
		<link rel="stylesheet" href="app.css">
	{% endblock %}
</code></pre><h4 id="include-可以引用的模板"><a href="#include-可以引用的模板" class="headerlink" title="include 可以引用的模板"></a>include 可以引用的模板</h4><pre><code>{% include "item.html" %}
</code></pre><h4 id="import-加载不同的模板"><a href="#import-加载不同的模板" class="headerlink" title="import 加载不同的模板"></a>import 加载不同的模板</h4><h4 id="filter-区块中内容调用过滤器"><a href="#filter-区块中内容调用过滤器" class="headerlink" title="filter 区块中内容调用过滤器"></a>filter 区块中内容调用过滤器</h4><pre><code>{% filter replace("force", "forth") %}
		may the force be with you
	{% endfilter %}
</code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><h4 id="去除前后空格"><a href="#去除前后空格" class="headerlink" title="去除前后空格"></a>去除前后空格</h4><pre><code>var str = &apos; sssfsdfs &apos;;

{% -%}
</code></pre><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><pre><code>表达式 String、Number、Array、Dicts、Boolean

运算符 +、-、/、//、%、*、**

比较 ==、===、!=、!==、&gt;、&gt;=、&lt;、&lt;=

逻辑 and、or、not   {% if users and showUsers %} ... {% endif %}
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>传入一个函数，在这里可以执行 {{ foo(1,2,3) }}
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>{{ /bar$/g }}

g: 应用到全局
i: 不区分大小写
m: 多行模式
y: 粘性支持（sticky
</code></pre><blockquote>
<p>参考资料<br><a href="http://mozilla.github.io/nunjucks/cn/templating.html" target="_blank" rel="noopener">http://mozilla.github.io/nunjucks/cn/templating.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/hexo安装使用/">Hexo安装使用</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/hexo安装使用/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/hexo/">hexo</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>一、hexo安装

    $ npm install -g hexo-cli

    $ hexo init

    $ npm install

    $ hexo generate            生成静态文件

    $ hexo server            启动服务器


二、github创建项目

    github创建项目并取到ssh路径

三、配置_config.yml

    根目录打开_config.yml，修改下面内容

    theme: concise            // 接下来安装主题的名称

    deploy:
        type: git
        repo: https://github.com/siguang1983/siguang1983.github.io.git
        branch: master

四、安装主题

    https://hexo.io/themes/            选择一个主题

    安装主题每个主题都会有安装的介绍 

    主题安装会在themes目录下，删除其它主题如果不删除还上传后还会显示之前的主题

    设置主题的样式也在这里
</code></pre><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre><code>$ hexo clean

$ hexo d -g         根据设置的deploy中repo的地址发布到github上

文档放到source/_posts目录下
</code></pre><p>| <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/Rap的使用和mock数据/">Rap的使用和mock数据</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/Rap的使用和mock数据/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/mock数据/">mock数据</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>/<strong><strong>**</strong></strong> Rap <strong><strong>*</strong></strong>/</p>
<h4 id="Rap"><a href="#Rap" class="headerlink" title="Rap"></a>Rap</h4><pre><code>阿里的产品和mockjs，来模拟真实数据

https://github.com/thx/RAP/wiki/user_manual_cn#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE
</code></pre><h4 id="Rap使用"><a href="#Rap使用" class="headerlink" title="Rap使用"></a>Rap使用</h4><pre><code>一、注册和登录Rap

    http://rapapi.org/

二、分为团队、业务线、项目

    1、查找你所在的团队
</code></pre><p><img src="images/rap1.png" alt="查找你所在的团队"></p>
<pre><code>2、进入你所在的团
</code></pre><p><img src="images/rap2.jpeg" alt="查找你所在的团队"></p>
<pre><code>3、创建业务
</code></pre><p><img src="images/rap3.jpeg" alt="查找你所在的团队"></p>
<pre><code>4、创建模块和使用
</code></pre><p><img src="images/rap4.jpeg" alt="查找你所在的团队"></p>
<pre><code>三、其它技巧

    1、将一个接口的字段下所有字段copy到另一个接口

        选择要copy的字段名，到另一个接口粘贴后在control+Enter，就将所有的内容全部copy过来
</code></pre><p><img src="images/rap5.jpeg" alt="查找你所在的团队"></p>
<pre><code>四、MOCK工具

    1、使用参数的变量
        请求字段
            page   

        响应字段
            pageResponse 字段  @mock=${page}        // 这里最终pageResponse的显示就是Request中page的输入

            或者写默认值   @mock=${page=100}    // 如果请求不写page值默认为100

    2、id自动加1

        变量名     备注
        id|+1     @mock=100        // 表示id从100开始，每次加1

    3、其它写法

        @mock=@DATE

        @mock=true

        @mock=function(){return 100 + Math.random()*100}
</code></pre><p><img src="images/rap6.png" alt="查找你所在的团队"></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/Jenkins/">Jenkins</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/Jenkins/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Jenkins/">Jenkins</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Jankins"><a href="#Jankins" class="headerlink" title="Jankins"></a>Jankins</h4><pre><code>Jankins是自动化测试的一键部署工具

服务器: Linux、CentOS

数据库 - MySQL Server      github 账户    java开发工具 Intellij Idea
</code></pre><h4 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h4><pre><code>jenkins.io 官网

1、download Generic Java package (.war)

2、命令行中找到 下载的文件Jenkins.war

3、$ java -jar jenkins.war        // 安装

4、http://localhost:8080        // 解锁通过给出的服务器文件路径 

    1）$ vim /Users/apple/.jenkins/secrets/initialAdminPassword        // 路径不同注意取到密码 添加到管理员密码中

    2）创建admin账户

    3）配置Jenkins URL http://localhost:7890/

5、安装完成

6、插件安装
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/前端算法/">前端算法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/前端算法/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/算法/">算法</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><pre><code>一、冒泡法

    前后两个值相比

    function bubble(){
        var arr = [34,5,7,2,4,6,8];
        var len = arr.length;

        for(var i=0; i&lt;len; i++){
            // 这里 j&lt;len-1 也可以，但j&lt;len-1-i的目换是不用在去比较之前的结果 
            for(var j=0; j&lt;len-1-i; j++){   
                if(arr[j] &gt; arr[j+1]){        // 从小向大, 如果从大到小改成 &lt;
                    var temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        return arr;
    }
    console.log(bubble());
</code></pre><p><img src="images/冒泡.gif" alt="冒泡"> </p>
<pre><code>二、选择排序

    用当前的所在的数来与之后所有的数来判断找出最小数插入

    function selectionSort(){
        var arr = [34,5,7,26,8,13];
        var len = arr.length;
        var minIndex, temp;

        for(var i=0; i&lt;len; i++){
            minIndex = i;               // 循环进来后先指向当前第一个要比较的数，下面循环会将比较小最值的下标赋给它

            // 找出之后的最小数
            for(var j=i+1; j&lt;len; j++){
                if(arr[j] &lt; arr[minIndex]){     // 这里控制排序
                    minIndex = j;
                }
            }

            // 将最小数排到当前i的位置
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }

        return arr;
    }
    console.log(selectionSort());
</code></pre><p><img src="images/选择排序.gif" alt="选择排序"> </p>
<pre><code>三、插入排序

    将一个值与之前的值进行比较如果大于当前值就插入在当前位置

    function insertionSort(){
        var arr = [34,5,7,26,8,13];
        var len = arr.length;
        var preIndex, current;

        for(var i=1; i&lt;len; i++){
            preIndex = i-1;
            current = arr[i];   // 存储当前值

            while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current){
                console.log(arr[preIndex], current);
                arr[preIndex+1] = arr[preIndex];        // 将
                preIndex--;
            }

            arr[preIndex+1] = current;
        }

        return arr
    }

    console.log(insertionSort());
</code></pre><p><img src="images/插入排序.gif" alt="插入排序"> </p>
<pre><code>快速排序 
</code></pre><p><img src="images/选择排序.gif" alt="选择排序"><br><img src="images/选择排序.gif" alt="选择排序"> </p>
<p>| <a href="https://wowphp.com/post/komxdx8qe862.html" target="_blank" rel="noopener">https://wowphp.com/post/komxdx8qe862.html</a>      // 排序</p>

        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Volgende &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
