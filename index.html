<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大前端/">大前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/10/23/微信小程序、公众号开发/">微信小程序、公众号开发</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/10/23/微信小程序、公众号开发/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-10-23T08:02:17.000Z" itemprop="datePublished">2017-10-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/微信小程序/">微信小程序</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h4><pre><code>一、appleID的获取

    https://mp.weixin.qq.com/wxopen/basicprofile?action=index&amp;token=767275273&amp;lang=zh_CN

    在开发设置选项 =&gt; AppID(小程序ID)

二、文件类型

    1、app.js 脚本文件        2、app.json 配置文件        3、app.wxml 页面结构        4、app.wxss样式文件
</code></pre><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><pre><code>一、app.json配置

    {
        // 页面路径
        &quot;pages&quot;: [
            &quot;pages/index/index&quot;,            // 初始显示的组件用
            &quot;pages/logs/index&quot;
        ],
        // 默认页面窗口表现
        &quot;window&quot;: {
            &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
        },
        // 底部tab的表现
        &quot;tabBar&quot;: {
            &quot;list&quot;: [
                {
                    &quot;pagePath&quot;: &quot;pages/index/index&quot;,
                    &quot;text&quot;: &quot;首页&quot;
                }, 
                {
                    &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
                    &quot;text&quot;: &quot;日志&quot;
                }
            ] 
        },
        // 设置网络超时时间
        &quot;networkTimeout&quot;: {
            &quot;request&quot;: 10000,
            &quot;downloadFile&quot;: 10000
        },
        // 是否开启debug模式
        &quot;debug&quot;: true
    }

    https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html         // 各类别配置
</code></pre><h4 id="App-js-主函数"><a href="#App-js-主函数" class="headerlink" title="App.js 主函数"></a>App.js 主函数</h4><pre><code>一、事件

    1、onLaunch - 监听小程序初始化，初始化完成会触发onLaunch

    2、onShow - 监听小程序显示，小程序启动、从后台进入前台显示，触发onShow

    3、onHide - 监听小程序隐藏，从前台进入后台，会触发onHide

    4、onError - 错误监听，脚本错误或api调用失败触发


二、onLaunch和onShow的参数 

    App({
        onLaunch: function (path) {
            console.log(path);
        }
    })

    1、path - String    打开小程序的路径

    2、query - Object 打开小程序的query

    3、scene - Number 打开小程序的场景值

    4、shareTicket - String    shareTicket，详见 获取更多转发信息

    5、referrerInfo - Object    当场景为由从另一个小程序或公众号或App打开时，返回此字段

        返回值:
            1020    公众号 profile 页相关小程序列表    返回来源公众号 appId
            1035    公众号自定义菜单    返回来源公众号 appId
            1036    App 分享消息卡片    返回来源应用 appId
            1037    小程序打开小程序    返回来源小程序 appId
            1038    从另一个小程序返回    返回来源小程序 appId
            1043    公众号模板消息    返回来源公众号 appId

    6、referrerInfo.appId - String 来源小程序或公众号或App的 appId，详见下方说明

    7、referrerInfo.extraData - Object 来源小程序传过来的数据，scene=1037或1038时支持


三、getApp() 全局函数用来获取小程序实例

    var appInstance = getApp();

    app.globalData.userInfo;        // 获取当前用户信息
</code></pre><h4 id="Page-用来注册一个页面"><a href="#Page-用来注册一个页面" class="headerlink" title="Page() 用来注册一个页面"></a>Page() 用来注册一个页面</h4><pre><code>指定页面的初始数据、生命周期、事件处理

一、生命周期

    onLoad: 页面加载，一个页面只会调用一次

    onShow: 页面显示 

    onReady: 页面初次渲染完成

    onHide: 页面隐藏

    onUnload: 页面卸载

    /** 生命周期函数--监听页面加载 **/
    onLoad: function (options) {
        console.log(options);
    },

    /** 生命周期函数--监听页面初次渲染完成 **/
    onReady: function () {

    },

    /** 生命周期函数--监听页面显示 **/
    onShow: function () {

    },

    /** 生命周期函数--监听页面隐藏 **/
    onHide: function () {

    },

    /** 生命周期函数--监听页面卸载 **/
    onUnload: function () {

    },

    /** 页面相关事件处理函数--监听用户下拉动作 **/
    onPullDownRefresh: function (e) {
        this.setData({
            updata: JSON.stringify(e)
        })
        console.log(e)
    },

    /** 页面上拉触底事件的处理函数 **/
    onReachBottom: function (e) {
        this.setData({
            updata: JSON.stringify(e)
        })
        console.log(e)
    },

    /** 用户点击右上角分享 **/
    onShareAppMessage: function () {

    }


二、事件方法

    data - 页面初始数据, WXML中调用 {{test}}

    onload - 监听页面加载

    onReady - 监听页面初次渲染完成

    onShow - 监听页面显示

    onHide - 监听页面隐藏

    onUnload - 监听页面卸载

    onPullDowRefesh - 监听用户下拉动作

    onReachBottom - 上拉触底事件

    onShareAppMessage - 用户点击右上角转发

        onShareAppMessage: function () {
            return {
            title: &apos;自定义转发标题&apos;,
            path: &apos;/page/user?id=123&apos;
            }
        }

    onPageScroll - 页面滚动触发


三、绑定事件

    &lt;view bindTap=&quot;viewTap&quot;&gt;click me&lt;/view&gt;

    Page({
        data:{
            message: &apos;view tap&apos;
        },
        viewTap: () =&gt; {
            console.log(this.message)
        }
    })


四、Page.prototype.route - 获取当前页面的路径

五、Page.prototype.setData() - 用于将数据从逻辑层发送到视图层，同时改变对应的this.data的值

    Page({
        data:{
            username: &apos;siguang&apos;
        }
        login: ()=&gt;{
            this.setData({
                username: &apos;lulu&apos;
            })
        }
    })
</code></pre><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><pre><code>所有页面的路由全部由框架管理

一、页面栈

    1、初始化 - 新页面入栈

    2、打开新页面 - 新页面入栈。  调用 API wx.navigateTo 或使用组件 &lt;navigator open-type=&quot;navigateTo&quot;/&gt;

    3、页面重定向 - 当前页面出栈，新页面入栈。  调用 API wx.redirectTo 或使用组件 &lt;navigator open-type=&quot;redirectTo&quot;/&gt;

    4、页面返回 - 页面不断出栈，直到目标返回页，新页面入栈。 调用 API wx.navigateBack 或使用组件&lt;navigator open-type=&quot;navigateBack&quot;&gt;或用户按左上角返回按钮

    5、Tab - 切换    页面全部出栈，只留下新的 Tab 页面。 调用 API wx.switchTab 或使用组件 &lt;navigator open-type=&quot;switchTab&quot;/&gt; 或用户切换 Tab

    6、重加载 - 页面全部出栈，只留下新的页面。 调用 API wx.reLaunch 或使用组件 &lt;navigator open-type=&quot;reLaunch&quot;/&gt;

    Example:
        bindViewTap: function() {
            wx.navigateTo({
                url: &apos;../logs/logs&apos;
            })
        }

二、getCurrentPages() 获取当前页面的栈的实例

三、Tips

    navigateTo, redirectTo 只能打开非 tabBar 页面。
    switchTab 只能打开 tabBar 页面。
    reLaunch 可以打开任意页面。
</code></pre><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><pre><code>一、全局变量和方法

    全局方法通过 getApp()获取全局的应用实例

    全局数据设置:

        App({
            globalData: 1
        })


二、模块化

    1、导出

        module.exports 或 exports对外暴露接口, exports是module.exports的一个引用

        小程序不支持直接引入node_modules, 如果需要就将代码拷到目录中

        // common.js
        function sayHello(name){
            console.log(`Hello ${name}`);
        }

        module.exports.sayHello = sayHello;


    2、引用

        conmmon = require(&apos;common.js&apos;);
        Page({
            helloMina: () =&gt;{
                common.sayHello(&apos;mina&apos;);
            }
        })
</code></pre><h4 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h4><pre><code>视图层WXMWXSS编写, 由组件进行展示

一、WXML

    1、数据绑定

        普通绑定: &lt;view&gt;{{message}}&lt;/view&gt;

        属性绑定: &lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;

        控制属性: &lt;view wx:if=&quot;{{condition}}&quot;&gt; &lt;/view&gt;


    2、循环渲染

        // 注意这里取到当前数据要用item
        &lt;view wx:for=&quot;{{arr}}&quot;&gt;{{item}}&lt;/view&gt;

        数组下标:
            &lt;view wx:for=&quot;{{arr}}&quot;&gt;
                姓名:{{item.name}} 年龄:{{item.age}} 序号:{{index}}
            &lt;/view&gt;

            两者相同
            &lt;view wx:for=&quot;{{arr}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
                姓名:{{itemName.name}} 年龄:{{itemName.age}} 序号:{{idx}}
            &lt;/view&gt;


    3、条件渲染

        &lt;view wx:if=&quot;{{view == 'webView'}}&quot;&gt;web view&lt;/view&gt;
        &lt;view wx:elif=&quot;{{view == 'app'}}&quot;&gt;app&lt;/view&gt;
        &lt;view wx:else=&quot;{{view == 'mina'}}&quot;&gt;mina&lt;/view&gt;

        Page({
            data: {
                view: &apos;app&apos;
            }
        })


    4、模板

        name: 模板名    is: 所要调用的模板名    data: 传入的数据

        &lt;template name=&quot;staffName&quot;&gt;
            &lt;view&gt;
                FirstName: {{firstName}}, lastName: {{lastName}}
            &lt;/view&gt;
        &lt;/template&gt;

        &lt;template is=&quot;staffName&quot; data=&quot;{{...staffA}}&quot;&gt;&lt;/template&gt;
        &lt;template is=&quot;staffName&quot; data=&quot;{{...staffB}}&quot;&gt;&lt;/template&gt;

        Page({
            data: {
                staffName: {fristName: &apos;sigunag&apos;, lastName: &apos;haha&apos;},
                staffName: {fristName: &apos;yuwan&apos;, lastName: &apos;lulu&apos;},
            }
        })
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>&lt;view bindtap=&quot;add&quot;&gt;{{count}}&lt;/view&gt;

Page({
    data: {
        count: 1
    },
    add: (event)=&gt;{
        this.setData({
            count: this.data.count++
        })
    }
})

一、事件分类

    分为冒泡事件和非冒泡事件

    冒泡事件:  bindtouchstart 前面加bind

        touchstart    手指触摸动作开始    
        touchmove    手指触摸后移动    
        touchcancel    手指触摸动作被打断，如来电提醒，弹窗    
        touchend    手指触摸动作结束    
        tap    手指触摸后马上离开    
        longpress    手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发    1.5.0
        longtap    手指触摸后，超过350ms再离开（推荐使用longpress事件代替）    
        transitionend    会在 WXSS transition 或 wx.createAnimation 动画结束后触发    
        animationstart    会在一个 WXSS animation 动画开始时触发    
        animationiteration    会在一个 WXSS animation 一次迭代结束时触发    
        animationend    会在一个 WXSS animation 动画完成时触发

    事件绑定和冒泡:

        bind 不会阻止冒泡事件向上冒泡，bindtap
        catch 可以阻止冒泡事件向上冒泡。catchtap

    事件捕获:

        捕获阶段监听事件时，采用capture-bind、capture-catch关键字, 后者将中断捕获阶段和取消冒泡

    事件对象:

        baseEvent对象


二、view、block标签

    view 渲染单独一行类似块元素

    block 渲染成内联元素
</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>提供两种引用方法import 和 include

一、import 引用外部的&lt;template&gt;模板

    &lt;!-- item.wxml --&gt;
    &lt;template name=&quot;item&quot;&gt;
        &lt;text&gt;{{text}}&lt;/text&gt;
    &lt;/template&gt;

    &lt;!--  index.wxml  --&gt;
    &lt;import src=&quot;item.wxml&quot;/&gt;
    &lt;template is=&quot;item&quot; data=&quot;{{text: 'forbar'}}&quot;/&gt;


二、include 引用非&lt;template&gt;模板的文件，公用的头尾等

    &lt;!-- index.wxml --&gt;
    &lt;include src=&quot;header.wxml&quot;/&gt;
    &lt;view&gt; body &lt;/view&gt;
    &lt;include src=&quot;footer.wxml&quot;/&gt;

    &lt;!-- header.wxml --&gt;
    &lt;view&gt; header &lt;/view&gt;

    &lt;!-- footer.wxml --&gt;
    &lt;view&gt; footer &lt;/view&gt;
</code></pre><h4 id="WXSS-样式语言"><a href="#WXSS-样式语言" class="headerlink" title="WXSS 样式语言"></a>WXSS 样式语言</h4><pre><code>尺寸单位: rex, 可以根据屏幕宽度自行自适应

一、样式导入

    @import &apos;common.wxss&apos;
    .middle-p {
        padding: 15px;
    }

二、内联样式
    data: {
        color: &apos;#ddd&apos;
    }
    &lt;view style=&quot;color: {{color}}&quot;&gt;

    &lt;view class=&quot;middle-p&quot;&gt;        // 多个class使用空格分隔

三、全局、局部样式

    定义在app.wxss中的样式为全局

    每个页的wxss为局部
</code></pre><h4 id="WXS-脚本"><a href="#WXS-脚本" class="headerlink" title="WXS 脚本"></a>WXS 脚本</h4><pre><code>小程序自己的一套脚本语言, 可以直接编写到WXML中, 也可以单独写成一个.wxs文件

一、写到wxml中

    &lt;!-- index.wxml&gt;
    &lt;wxs module=&quot;m1&quot;&gt;
        var msg = &apos;hello world&apos;;
        module.exports.message = msg
    &lt;/wxs&gt;

    &lt;view&gt;
        {{m1.message}}
    &lt;/view&gt;

二、写成一个.wxs文件

    // pages/comm.wxs
    // 如果comm.wxs文件中要引用其它的wxs文件使用require,  var tool = require(&apos;./tools.wxs&apos;);

    var foo = &quot;&apos;hello world&apos; from comm.wxs&quot;;
    var bar = function(d) {
        return d;
    }
    module.exports = {
        foo: foo,
        bar: bar
    };

    // 页面引用
    &lt;wxs src=&quot;./../tools.wxs&quot; module=&quot;tools&quot; /&gt;
    &lt;view&gt; {{tools.msg}} &lt;/view&gt;
</code></pre><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><pre><code>小程序两种启动方式:

    冷启动: 用户首次打开或小程序被微信主动销毁后在次打开的情况，

    热启动: 用户已经打开某个小程序，在一定时间内在次打开，此时无需重新启动，只需将后台切换到前台
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>网络请求request、文件上传下载uploadFile、webSocket都需要设置指定的服务器
</code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code>wx.getSystemInfo 或者 wx.getSystemInfoSync 获取小程序的基本库版本

wx.canIUse 判断是否可以在该基础库版本下直接使用对应的API或者组件
</code></pre><h4 id="开发总结"><a href="#开发总结" class="headerlink" title="开发总结"></a>开发总结</h4><pre><code>1、小程序初始指定页面

    app.json中, 调整pages数组的顺序, 第一个就是最先被载入

    &quot;pages&quot;:[
        &quot;pages/my/my&quot;,
        &quot;pages/index/index&quot;,
        &quot;pages/logs/logs&quot;    
    ]

2、当前页面使用修改标题

    在当前页面下的.json文件中加入

    goods-details.json
    {
        &quot;navigationBarTitleText&quot;: &quot;商品详情&quot;
    }

3、获取元素上的自定义属性值

    1) evt.currentTarget.dataset.propertyindex;        

    2) evt.detail

    &lt;view bindtap=&quot;labelItemTap&quot; data-propertyindex=&quot;{{idx}}&quot;&gt;&lt;/view&gt;        // 注意这里自定义属性需要以&quot;data-&quot;开头，并且不能为大写，如果有大写取值时全部为小写

    js:

    labelItemTap: function(evt){
        let val = evt.currentTarget.dataset.propertyindex;
    }

4、在app.json中配置pages的路径会自动创建目录和基本文件这里

    这里注意创建js时候会将生命周期方法和上拉下拉刷新方法全部都创建好，不必重写 onPullDownRefresh()、onReachBottom();
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>如果修改 checkbox 的样式

时间选择器只有时、分，没有秒

slider滑动组件拖动块不能改颜色

小程序下拉刷新不触发 onPullDownRefresh
</code></pre><h4 id="小程序与RN相比"><a href="#小程序与RN相比" class="headerlink" title="小程序与RN相比"></a>小程序与RN相比</h4><pre><code>小程序布局写法简单，RN的布局比较麻烦

小程序的组件简单，RN组件麻烦，并且IOS和Android兼容

RN可以随意发起网络请求访问数据，小程序需要指定服务器并且需要https协议

RN需要与通过Xcode来进去打包、并且需要在appStor进行发布审核

RN做的app需要到商店下载使用，小程序发布后在微信就可以找到
</code></pre><p>| <a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="noopener">http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html</a>        // 公众服务平台所有的sdk<br>| <a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=20171013" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=20171013</a>  // 小程序<br>| <a href="https://www.w3cschool.cn/weixinapp/9wou1q8j.html" target="_blank" rel="noopener">https://www.w3cschool.cn/weixinapp/9wou1q8j.html</a><br>| <a href="http://203.195.235.76/jssdk/" target="_blank" rel="noopener">http://203.195.235.76/jssdk/</a>   小程序demo<br>| <a href="https://github.com/gooking/awesome-wechat-weapp" target="_blank" rel="noopener">https://github.com/gooking/awesome-wechat-weapp</a>    微信小程序开发资源汇总</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/20/Jade模板/">Jade 模板</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/20/Jade模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-09-20T03:41:55.000Z" itemprop="datePublished">2017-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="jade介绍、安装"><a href="#jade介绍、安装" class="headerlink" title="jade介绍、安装"></a>jade介绍、安装</h4><pre><code>jade是前后端都可以使用的模板引擎7

1、安装:

    sudo npm i -g jade


2、介绍

    元素标签不需要写&lt;&gt;

    子元素与父元素需要换行并tab缩进

    标签与文本需要使用空格来隔开


3、jade的缺点

    1）可移植性差

    2）调试困难

    3）性能一般

4、初始阶段开发效率，稳定性成和协作的成本
</code></pre><h4 id="jade-头尾标签"><a href="#jade-头尾标签" class="headerlink" title="jade 头尾标签"></a>jade 头尾标签</h4><pre><code>&lt;!DOCTYPE&gt;
html
    head
        title ${title}

    body
        h1 标题内容
</code></pre><h4 id="命令行编译jade文件"><a href="#命令行编译jade文件" class="headerlink" title="命令行编译jade文件"></a>命令行编译jade文件</h4><pre><code># jade index.jade         // 会将jade文件编译成同级目录的index.html文件，并且是没有代码格式的只有一行

# jade -P index.jade     // 有缩进，可读的格式

# jade -P -w index.jade // 侦听jade文件有变化执行转换的命令

小技巧: 在sublime中打开 index.jade 和 index.html文件, 选择view菜单 -&gt; layout/ columns2 变成两列，将index.html放到另一列中，这样每次保存就可以看到html代码
</code></pre><h4 id="属性文本和值"><a href="#属性文本和值" class="headerlink" title="属性文本和值"></a>属性文本和值</h4><pre><code>1、class和id

    div.row

    div#row

    div#row.column-samil    // id=&quot;row&quot; class=&quot;column-samil&quot;

    div.rowA.main        // class=&quot;rowA main&quot;


2、属性

    a标签的href属性值，和自定义属性和值
    a(href=&quot;http://haha.com&quot;,
        title=&quot;jade&quot;,
            data-uid=&quot;siguang&quot;)

    input(name=&quot;course&quot; type=&quot;check&quot; checked)
</code></pre><h4 id="混合的文本和标签"><a href="#混合的文本和标签" class="headerlink" title="混合的文本和标签"></a>混合的文本和标签</h4><pre><code>1、如果字符里有点进行处理

    // 不会把.aa解析成 class=&quot;aa&quot; 并且换行,也能写html标签
    div.row
        p.
            1.aa &lt;strong&gt;这里字体加粗&lt;/string&gt;
            2.bb
            3.cc 
            4.dd

    或者
    div.row
        p
            | 1.aa 
            | 2.bb
            | 3.cc 
            | 4.dd
</code></pre><h4 id="注释和条件注释"><a href="#注释和条件注释" class="headerlink" title="注释和条件注释"></a>注释和条件注释</h4><pre><code>1、单行注释 //

2、不可见的注释 //-

3、块注释        //- 在当前节点的开头

4、条件注释

    &lt;!--[if IE 8]&gt;
        &lt;html class=&apos;ie8&apos;&gt;
    &lt;![endif]&gt;


    &lt;/html&gt;        // 需要html



div.row
    // a(href=&quot;http://haha.com&quot;, title=&quot;siguang&quot;, data-index=&quot;1&quot;) 去主站

    //- input(name=&quot;course&quot; type=&quot;check&quot; checked)

div.row
//-
    p.
        1.aa &lt;strong&gt;这里字体加粗&lt;/string&gt;
        2.bb
        3.cc 
        4.dd
</code></pre><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><pre><code>声明: - var course = &apos;jade&apos;

获取: #{jade}

1、命令行下传值
    jade index.jade -P -w --obj &apos;{&quot;name&quot;:&quot;siguang&quot;, age: 30}&apos;

    div.row
        div.column-12
            姓名: #{name}

        div.column-12
            年龄: #{age}

2、通过json传值

    jade index.jade -P -O test.json

    test.json
    {
        &apos;name&apos;: &apos;siguang&apos;,
        &apos;age&apos;: 30
    }
</code></pre><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><pre><code>1、将html转成字符串输出

    - var data = &apos;&lt;script&gt;alert(123)&lt;/script&gt;&apos;

    p #{data}


2、非转义

    - var data = &apos;&lt;script&gt;alert(123)&lt;/script&gt;&apos;

    p !{data}
</code></pre><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><pre><code>1、if...else...

    - var isData = true
    if isData
        div 对象存在
    else
        对象不存在


2、case

    - var name = &apos;jade&apos;
    case name
        when &apos;java&apos;
            div java

        when &apos;jade&apos;
            p hello jad



3、for 或 each 循环

    - var data = {&apos;name&apos;: &apos;siguang&apos;, &apos;nage&apos;: 30}
    div.row
        - for(var key in data)
            div= key +&apos;=&apos;+data[key]

    each()
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>相同结构的内容可以放到mixin中，相同一个函数

1、无参
    mixin 函数名        // 声明 
        p 这里是函数的块内容
        p 这里是函数的块内容
        p 这里是函数的块内容

    +函数名            // 调用

2、有参

    mixin 函数名(参数)
        each key in data
            li= data[key]

    +函数名({username: &apos;siguang&apos;, age: 30});
</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><pre><code>代码复用

定义一个html的基本结构，内容只写到body中

public.jade

    DOCTYPE html
    html
        head

        body
            block desc
                p 内容继承
            block content    // 这里接收内容


main.jade

    // 通过extends继承到哪个 jade文件
    extends public

    block content        // 这里写到哪里
        div.row
            p aaaa
            p aaaa
            p aaaa

        div.row-b
            p bbb
            p bbb
            p bbb
</code></pre><h4 id="include-引用"><a href="#include-引用" class="headerlink" title="include 引用"></a>include 引用</h4><pre><code>引用一个jade文件

DOCTYPE html
html
    head
        include head

    body
        include login
</code></pre><h4 id="jade-api"><a href="#jade-api" class="headerlink" title="jade api"></a>jade api</h4><pre><code>http的原声写法

1、jade.compile(source, 传值): 返回一个函数来生成html

2、jade.compileFile(path, 传值)

3、jade.compileClient(source, 传值)

4、jade.render(source, 传值):

5、jade.renderFile(jade文件, 传值):


compile()示例
    var http = require(&apos;http&apos;);
    var jade = require(&apos;jade&apos;);

    var server = http.createServer(function(req, res){
        res.writeHead(200, {&apos;ContentType&apos;: &apos;text/html&apos;});

        var fn = jade.compile(&apos;div #{course}&apos;, {});
        var html = fn({course: &apos;jade&apos;});

        res.end(html);
    })

    server.listen(&apos;8081&apos;, &apos;localhost&apos;)


render()示例

    var http = require(&apos;http&apos;);
    var jade = require(&apos;jade&apos;);

    var server = http.createServer(function(req, res){
        res.writeHead(200, {&apos;ContentType&apos;: &apos;text/html&apos;});
        var html = jade.render(&apos;div #{course} #{name}&apos;, {course: &apos;jade&apos;, name: &apos;siguang&apos;});
        res.end(html);
    })

    server.listen(&apos;8081&apos;, &apos;localhost&apos;)


{pretty:true} 如果不加此属性html会是压缩模式，加上格式化的代码
</code></pre><h4 id="将html编译成jade文件"><a href="#将html编译成jade文件" class="headerlink" title="将html编译成jade文件"></a>将html编译成jade文件</h4><pre><code>安装: sudo npm install html2jade -g

生成命令: html2jade ./public/index.html &gt; index.jade

在node中转换

var html2jade = require(&apos;html2jade&apos;);

html2jade.convertDocument(document, {}, function(err, jade){
    console.log(&apos;反编译后的jade文件&apos;)
})


在线转换: http://html2jade.vida.io/
</code></pre><p>| 参考资料<br>| <a href="http://www.cnblogs.com/fullhouse/archive/2011/07/18/2109945.html" target="_blank" rel="noopener">http://www.cnblogs.com/fullhouse/archive/2011/07/18/2109945.html</a><br>|<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/20/numjucks模板/">numjucks模板</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/20/numjucks模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-09-20T03:41:55.000Z" itemprop="datePublished">2017-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="numjucks"><a href="#numjucks" class="headerlink" title="numjucks"></a>numjucks</h4><pre><code>numjucks可以用任意扩展名来命名模板名文件，推荐使用&apos;.njk&apos;

$ npm install nunjucks

require(&apos;nunjucks&apos;);
</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>{{ usernmae }}    {{ foo.bar }}
</code></pre><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><pre><code>{{ foo | title }}    {{ foo | join(',') }}
</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><pre><code>定义一个&quot;block&quot;，子模板可以覆盖它

一、Example

    A.html

        {% block header %}{% endblock %}

			<div>
				aaaa
			</div>

		B.html

			{% extends 'A.html' %}

			{% block header %}
				<div>
					<ul>
						<li>aaaa</li>
						<li>bbbb</li>
						<li>cccc</li>
					</ul>
				</div>
			{% endblock %}

二、super()
</code></pre><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><pre><code>{% if num > 20 %}
		<div>
			大于20显示些内容
		</div>
	{% endif %}


{% if num > 20 %}
		<span>大于20</span>
	{% elif num < 6 %}
		<span>小于6</span>
	{% else %}
		<span>其它</span>
	{% endif %}
</code></pre><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre><code>一、遍历数组

    var items = [{ title: &quot;foo&quot;, id: 1 }, { title: &quot;bar&quot;, id: 2}];

    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;ul&gt;
        {% for item in items %}
				<li> {{item.title}} </li>
			{% endfor %}
    &lt;/ul&gt;

二、遍历对象

    var food = {
        &apos;ketchup&apos;: &apos;5 tbsp&apos;,
        &apos;mustard&apos;: &apos;1 tbsp&apos;,
        &apos;pickle&apos;: &apos;0 tbsp&apos;
    };

    &lt;div&gt;
        {% for key, value in food %}
				<p>{{key}} - {{value}}</p>
			{% endfor %}
    &lt;/div&gt;
</code></pre><h4 id="set-设置和修改变量"><a href="#set-设置和修改变量" class="headerlink" title="set 设置和修改变量"></a>set 设置和修改变量</h4><pre><code>let username = &apos;siguang&apos;;

{{ username }}            // siguang
{% set username = 'lulu' %}
{{ username }}            // lulu
</code></pre><h4 id="extends-指定模板继承"><a href="#extends-指定模板继承" class="headerlink" title="extends 指定模板继承"></a>extends 指定模板继承</h4><pre><code>{% extends 'A.html' %}

{% block header %}
		<div>
			<ul>
				<li>aaaa</li>
				<li>bbbb</li>
				<li>cccc</li>
			</ul>
		</div>
	{% endblock %}
</code></pre><h4 id="block-区块"><a href="#block-区块" class="headerlink" title="block 区块"></a>block 区块</h4><pre><code>{% block css %}
		<link rel="stylesheet" href="app.css">
	{% endblock %}
</code></pre><h4 id="include-可以引用的模板"><a href="#include-可以引用的模板" class="headerlink" title="include 可以引用的模板"></a>include 可以引用的模板</h4><pre><code>{% include "item.html" %}
</code></pre><h4 id="import-加载不同的模板"><a href="#import-加载不同的模板" class="headerlink" title="import 加载不同的模板"></a>import 加载不同的模板</h4><h4 id="filter-区块中内容调用过滤器"><a href="#filter-区块中内容调用过滤器" class="headerlink" title="filter 区块中内容调用过滤器"></a>filter 区块中内容调用过滤器</h4><pre><code>{% filter replace("force", "forth") %}
		may the force be with you
	{% endfilter %}
</code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><h4 id="去除前后空格"><a href="#去除前后空格" class="headerlink" title="去除前后空格"></a>去除前后空格</h4><pre><code>var str = &apos; sssfsdfs &apos;;

{% -%}
</code></pre><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><pre><code>表达式 String、Number、Array、Dicts、Boolean

运算符 +、-、/、//、%、*、**

比较 ==、===、!=、!==、&gt;、&gt;=、&lt;、&lt;=

逻辑 and、or、not   {% if users and showUsers %} ... {% endif %}
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>传入一个函数，在这里可以执行 {{ foo(1,2,3) }}
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>{{ /bar$/g }}

g: 应用到全局
i: 不区分大小写
m: 多行模式
y: 粘性支持（sticky
</code></pre><blockquote>
<p>参考资料<br><a href="http://mozilla.github.io/nunjucks/cn/templating.html" target="_blank" rel="noopener">http://mozilla.github.io/nunjucks/cn/templating.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/Jenkins/">Jenkins</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/Jenkins/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Jenkins/">Jenkins</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Jankins"><a href="#Jankins" class="headerlink" title="Jankins"></a>Jankins</h4><pre><code>Jankins是自动化测试的一键部署工具

服务器: Linux、CentOS

数据库 - MySQL Server      github 账户    java开发工具 Intellij Idea
</code></pre><h4 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h4><pre><code>jenkins.io 官网

1、download Generic Java package (.war)

2、命令行中找到 下载的文件Jenkins.war

3、$ java -jar jenkins.war        // 安装

4、http://localhost:8080        // 解锁通过给出的服务器文件路径 

    1）$ vim /Users/apple/.jenkins/secrets/initialAdminPassword        // 路径不同注意取到密码 添加到管理员密码中

    2）创建admin账户

    3）配置Jenkins URL http://localhost:7890/

5、安装完成

6、插件安装
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/前端算法/">前端算法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/前端算法/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/算法/">算法</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><pre><code>一、冒泡法

    前后两个值相比

    function bubble(){
        var arr = [34,5,7,2,4,6,8];
        var len = arr.length;

        for(var i=0; i&lt;len; i++){
            // 这里 j&lt;len-1 也可以，但j&lt;len-1-i的目换是不用在去比较之前的结果 
            for(var j=0; j&lt;len-1-i; j++){   
                if(arr[j] &gt; arr[j+1]){        // 从小向大, 如果从大到小改成 &lt;
                    var temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        return arr;
    }
    console.log(bubble());
</code></pre><p><img src="images/冒泡.gif" alt="冒泡"> </p>
<pre><code>二、选择排序

    用当前的所在的数来与之后所有的数来判断找出最小数插入

    function selectionSort(){
        var arr = [34,5,7,26,8,13];
        var len = arr.length;
        var minIndex, temp;

        for(var i=0; i&lt;len; i++){
            minIndex = i;               // 循环进来后先指向当前第一个要比较的数，下面循环会将比较小最值的下标赋给它

            // 找出之后的最小数
            for(var j=i+1; j&lt;len; j++){
                if(arr[j] &lt; arr[minIndex]){     // 这里控制排序
                    minIndex = j;
                }
            }

            // 将最小数排到当前i的位置
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }

        return arr;
    }
    console.log(selectionSort());
</code></pre><p><img src="images/选择排序.gif" alt="选择排序"> </p>
<pre><code>三、插入排序

    将一个值与之前的值进行比较如果大于当前值就插入在当前位置

    function insertionSort(){
        var arr = [34,5,7,26,8,13];
        var len = arr.length;
        var preIndex, current;

        for(var i=1; i&lt;len; i++){
            preIndex = i-1;
            current = arr[i];   // 存储当前值

            while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current){
                console.log(arr[preIndex], current);
                arr[preIndex+1] = arr[preIndex];        // 将
                preIndex--;
            }

            arr[preIndex+1] = current;
        }

        return arr
    }

    console.log(insertionSort());
</code></pre><p><img src="images/插入排序.gif" alt="插入排序"> </p>
<pre><code>快速排序 
</code></pre><p><img src="images/选择排序.gif" alt="选择排序"><br><img src="images/选择排序.gif" alt="选择排序"> </p>
<p>| <a href="https://wowphp.com/post/komxdx8qe862.html" target="_blank" rel="noopener">https://wowphp.com/post/komxdx8qe862.html</a>      // 排序</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/hexo安装使用/">Hexo安装使用</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/hexo安装使用/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/hexo/">hexo</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>一、hexo安装

    $ npm install -g hexo-cli

    $ hexo init

    $ npm install

    $ hexo generate            生成静态文件

    $ hexo server            启动服务器


二、github创建项目

    github创建项目并取到ssh路径

三、配置_config.yml

    根目录打开_config.yml，修改下面内容

    theme: concise            // 接下来安装主题的名称

    deploy:
        type: git
        repo: https://github.com/siguang1983/siguang1983.github.io.git
        branch: master

四、安装主题

    https://hexo.io/themes/            选择一个主题

    安装主题每个主题都会有安装的介绍 

    主题安装会在themes目录下，删除其它主题如果不删除还上传后还会显示之前的主题

    设置主题的样式也在这里
</code></pre><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre><code>$ hexo clean

$ hexo d -g         根据设置的deploy中repo的地址发布到github上

文档放到source/_posts目录下
</code></pre><p>| <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/Rap的使用和mock数据/">Rap的使用和mock数据</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/Rap的使用和mock数据/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/mock数据/">mock数据</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>/<strong><strong>**</strong></strong> Rap <strong><strong>*</strong></strong>/</p>
<h4 id="Rap"><a href="#Rap" class="headerlink" title="Rap"></a>Rap</h4><pre><code>阿里的产品和mockjs，来模拟真实数据

https://github.com/thx/RAP/wiki/user_manual_cn#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE
</code></pre><h4 id="Rap使用"><a href="#Rap使用" class="headerlink" title="Rap使用"></a>Rap使用</h4><pre><code>一、注册和登录Rap

    http://rapapi.org/

二、分为团队、业务线、项目

    1、查找你所在的团队
</code></pre><p><img src="images/rap1.png" alt="查找你所在的团队"></p>
<pre><code>2、进入你所在的团
</code></pre><p><img src="images/rap2.jpeg" alt="查找你所在的团队"></p>
<pre><code>3、创建业务
</code></pre><p><img src="images/rap3.jpeg" alt="查找你所在的团队"></p>
<pre><code>4、创建模块和使用
</code></pre><p><img src="images/rap4.jpeg" alt="查找你所在的团队"></p>
<pre><code>三、其它技巧

    1、将一个接口的字段下所有字段copy到另一个接口

        选择要copy的字段名，到另一个接口粘贴后在control+Enter，就将所有的内容全部copy过来
</code></pre><p><img src="images/rap5.jpeg" alt="查找你所在的团队"></p>
<pre><code>四、MOCK工具

    1、使用参数的变量
        请求字段
            page   

        响应字段
            pageResponse 字段  @mock=${page}        // 这里最终pageResponse的显示就是Request中page的输入

            或者写默认值   @mock=${page=100}    // 如果请求不写page值默认为100

    2、id自动加1

        变量名     备注
        id|+1     @mock=100        // 表示id从100开始，每次加1

    3、其它写法

        @mock=@DATE

        @mock=true

        @mock=function(){return 100 + Math.random()*100}
</code></pre><p><img src="images/rap6.png" alt="查找你所在的团队"></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/05/08/前端插件收集/">前端插件收集</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/05/08/前端插件收集/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-05-08T06:08:21.000Z" itemprop="datePublished">2017-05-08</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/大前端/">大前端</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="前端开发桌面程序"><a href="#前端开发桌面程序" class="headerlink" title="前端开发桌面程序"></a>前端开发桌面程序</h4><pre><code>1、Electron - https://electronjs.org/docs                可以开发.exe的桌面程序

    https://www.jianshu.com/p/57d910008612
</code></pre><h4 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h4><pre><code>1、Bootstrap中文网：http://www.bootcss.com/       

2、Bootstrap Table API:  http://bootstrap-table.wenzhixin.net.cn/zh-cn/getting-started/

        http://www.cnblogs.com/gamehiboy/p/5176618.html

3、layUI框架: http://www.layui.com/

    页面中加载layui
    &lt;script src=&quot;lib/layui.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;mian.js&quot;&gt;&lt;/script&gt;

    main.js
    layui.use([&apos;laydate&apos;], function(){         // laydate 调用日期插件
          var laydate = layui.laydate;
          var oD = document.getElementById(&quot;dateInput&quot;);

          var start = {
            elem: oD,
            min: laydate.now(),
            max: &apos;2099-06-16 23:59:59&apos;,
            istoday: false,
            choose: function(datas){
                end.min = datas;     // 开始日选好后，重置结束日的最小日期
                end.start = datas     // 将结束日的初始值设定为开始日
            }
        };

        laydate(start);          
    });

阿里移动端框架 mui: http://m.sui.taobao.org/

饿了么vue ui移动框架: http://mint-ui.github.io/#!/zh-cn

饿了么vue PC端框架 : http://element.eleme.io/#/zh-CN/resource

蚂蚁金服React ui框架https://ant.design/

react native https://github.com/ant-design/ant-design-mobile/blob/master/README.zh-CN.md

                https://mobile.ant.design/docs/react/introduce

React UI: http://rsuite.github.io/#/?_k=1me3ji

移动端UI框架

mock：http://mockjs.com/       // 生成随机数据，拦截 Ajax 请求
</code></pre><h4 id="JS库"><a href="#JS库" class="headerlink" title="JS库"></a>JS库</h4><pre><code>1、jQeruy

2、underscore: http://www.css88.com/doc/underscore/

3、zepto: http://www.bootcss.com/p/zeptojs/


日期类

1、jquery DateTimePicker:  http://www.jq22.com/jquery-info332

2、Bootstrap DataPicker:   http://www.bootcss.com/p/bootstrap-datetimepicker/

3、laydate:  http://laydate.layui.com/
</code></pre><h4 id="JS框架"><a href="#JS框架" class="headerlink" title="JS框架"></a>JS框架</h4><pre><code>1、VueJS

2、AngularJS    

vue-strap：http://yuche.github.io/vue-strap/

3、React

4、ReactNative
</code></pre><h4 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h4><pre><code>Exporess:  http://www.expressjs.com.cn/

egg阿里nodejs框架:https://eggjs.org/zh-cn/basics/middleware.html
</code></pre><h4 id="移动端的Sass框架"><a href="#移动端的Sass框架" class="headerlink" title="移动端的Sass框架"></a>移动端的Sass框架</h4><pre><code>yo: https://github.com/doyoe/Yo#bugs-and-feature-requests
</code></pre><h4 id="icons"><a href="#icons" class="headerlink" title="icons"></a>icons</h4><pre><code>http://www.fontawesome.com.cn/

https://icons8.com/icon/new-icons/all

http://emojipedia.org/    小图片
</code></pre><h4 id="其它插件"><a href="#其它插件" class="headerlink" title="其它插件"></a>其它插件</h4><pre><code>1、socket: https://github.com/sockjs/sockjs-client    

2、二进制转换库: protobuf.js  bytebuffer.js  long.js

3、纯前端将table导出Excel文件  http://www.jianshu.com/p/74d405940305

    js-xlsx: https://github.com/SheetJS/js-xlsx      用来读取和写文件，

        暴露一个XLSX全局对象
            读取数据XLSX.reder()，读取文件XLSX.readerFile()
            写数据 XLSX.write()，写文件XLSX.writeFile()、写流文件XLSX.stream
            utils对象

    fileSaver: https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js

4、axios - ajax封装  https://github.com/axios/axios#cancellation

5、iScroll: http://cubiq.org/iscroll-5   http://www.360doc.com/content/14/0724/11/16276861_396699901.shtml

6、Swipper: http://www.swiper.com.cn/

http://www.jq22.com/      jquery插件网
</code></pre><h4 id="前端打包工具"><a href="#前端打包工具" class="headerlink" title="前端打包工具"></a>前端打包工具</h4><pre><code>1、gulp

2、webpack

3、grunt
</code></pre><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><pre><code>1、browsersync:   http://www.browsersync.cn/            // 浏览器同步测试工具

    http://www.browsersync.cn/docs/command-line/
</code></pre><h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><pre><code>http://www.sketchcn.com/

omniGraffle
</code></pre><h4 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h4><pre><code>Confluence 用于团的wiki，和日常工作流程

JIRA   产品版本  产品需求 - 技术开发 - 测试

Stash  git 仓库

https://jsfiddle.net/


mockJS: http://mockjs.com/

RAP: http://rap.taobao.org/org/index.do

    复制一个字段名，然后新建一个字段粘贴，在按ctrl+回车，就会将他下面所有的数据都复制过来，对于层级很复杂的比较好用

chrome 插件

    EditThisCookie   设置cookie

    PostMan        post请求
</code></pre><p>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong> 工具类 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong>/</p>
<h4 id="查看chrome的DNS缓存对应表-chrome-net-internals-dns"><a href="#查看chrome的DNS缓存对应表-chrome-net-internals-dns" class="headerlink" title="查看chrome的DNS缓存对应表: chrome://net-internals#dns"></a>查看chrome的DNS缓存对应表: chrome://net-internals#dns</h4><h4 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h4><pre><code>http://blog.csdn.net/u013861109/article/details/53106074

1、安装package control

    https://packagecontrol.io/

    Control + `（mac） 或 Ctrl+～ （win） 调出console  输入下面命令，查看是否安装成功 Perferences-&gt;package settings中看到package control这一项，则安装成功

    import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())

2、安装编辑器主题

   按下Ctrl+Shift+P，输入install，选择Package Control: Install Package，然后输入Spacegray，选择Theme: Spacegray.

   在菜单栏中选择Preferences-&gt;Settings-User，复制以下代码，覆盖打开的文件内容，保存即可应用主题：    
    {
        &quot;theme&quot;: &quot;Spacegray.sublime-theme&quot;,
        &quot;color_scheme&quot;: &quot;Packages/Theme - Spacegray/base16-ocean.dark.tmTheme&quot;
    }

3、设置代码行间距、字号

    需要个性哪个就直接在preferences -&gt; settings user 中的配置添加
    {
        &quot;color_scheme&quot;: &quot;Packages/Theme - Spacegray/base16-ocean.dark.tmTheme&quot;,
        &quot;theme&quot;: &quot;Spacegray.sublime-theme&quot;,
        &quot;font_size&quot;: &quot;16&quot;,
        &quot;line_padding_top&quot;: 2,
           &quot;line_padding_bottom&quot;: 2
    }


4、安装常用插件

    安装：command + shift + p 输入 ip 回车

    卸载：command + shift + p 输入remove 回车

    1) px转rem插件  https://github.com/flashlizi/cssrem

    1）emmet：html、css快速编写

            如果emmet插件失效：http://www.jianshu.com/p/0862e754cf15

    2）syncedSideBar：侧栏与主界面的颜色相同

    3）babel：ES6、JSX、React

    4）AngularJS

    5）jQuery：jQuery提示

    6）Html5：html5捆

    7）Less：一个Less语法高亮插件

    8）Sass

    9）JsFormat：js 格式化插件

    10）SublimeLinter：行内高亮语法

    11）SideBarEnhancements：一个左边栏增强

    12）SublimeCodeintel：一个代码智能提示引擎

    13）Alignment：Js代码对其插件

    14）BracketHighlighter：代码对其线高亮

    15）Git：git的支持插件

    16）Prefixr：Prefixr Api支持，Prefixr是一个生成css3兼容性的api

    17）LiveReload：网页浏览器页面重新加载插件

    18）Tag：格式化代码排版

            Mac OS X: Command-Option-Shift-F
            Windows: Control-Alt-Shift-F



    19) HTML-CSS-JS Prettify 代码格式化插件 cmd+shift+h

    20）cssrem：sublime的px转rem的插件   https://github.com/flashlizi/cssrem      需要手动下载放到packages中，配置cssrem.sublime文件指定px_to_rem的值 

    21）MarioRicalde-SCSS       SCSS的代码提式和高亮

react插件   http://www.jianshu.com/p/ecf6c802fdc5?open_source=weibo_search
</code></pre><h4 id="emmet快捷方法"><a href="#emmet快捷方法" class="headerlink" title="emmet快捷方法"></a>emmet快捷方法</h4><pre><code>http://www.w3cplus.com/tools/emmet-cheat-sheet.html

http://www.iteye.com/news/27580
</code></pre><h4 id="webStorm"><a href="#webStorm" class="headerlink" title="webStorm"></a>webStorm</h4><pre><code>1、格式化代码: format   command + option + L

2、install plugins  安装插件

    webstorm/plugins =&gt; 插入插件名，然后添加
</code></pre><h4 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h4><pre><code>用于开发react

atom-react-autocomplete 组件名及状态的自动补全 

http://blog.csdn.net/crper/article/details/52196675
</code></pre><h4 id="vs-Code"><a href="#vs-Code" class="headerlink" title="vs-Code"></a>vs-Code</h4><pre><code>插件：

安装插件： ext install 插件名

https://marketplace.visualstudio.com/VSCode

1、vue-beautify: vue格式化

2、vue: 语法高亮

3、html-snippets：H5 提示

4、vscode-html-css: 写class可以搜索到所有引用class的值

5、jquerysnippets: jquery提示

6、vscode-JS-CSS-HTML-formatter: html/css/js文件格式化 使用方法: ⌘ + P 输入formatter

7、path-intellisense: 路径自动提示

8、npm-intellisense: 使用require提示

9、vscode-eslint: 语法验证

10、Bootstrap: 

11、vscode-icons: 编辑器菜单中对应文件前加图标   输入icon 选择 File icon Theme

    vscode-icon-theme: 

12、ReactSnippets: ReactJS  jsx文件内 输入 rcc 就可以创建一个react组件的初始代码  
        https://marketplace.visualstudio.com/items?itemName=xabikos.ReactSnippets

13、vscode-node-readme: 可以查看node reuqire中引用的node-module的包内容

14、auto-close-tag: 可以将文档未闭合标签自动加关闭   输入close tag

15、px转rem插件   https://github.com/Maroon1/px2rem 

16、主题类

    Atom One Dark Theme

    vsc-material-theme

    Material Theme

    切换主题  ⌘ + shift + p   =&gt;  输入 them 选择颜色主题在列表中在选择

17、guides: 高亮缩进基准线   ext install guides

18、常见问题

    1) HTML GB2312的乱码问题：code - 首选项 - 设置  在右侧来设置此属性 files.autoGuessEncoding&quot;: true

-------------------

1、⌘ + p 搜索插件

2、⌘ + shift + p  命令

3、⌘ + , 打开settings.json配置

4、^(control) + ` 打开vscode自带的终端

5、miniMap的配置  在settings.json中加入 &quot;editor.minimap.enabled&quot;: true  配置

6、|http://www.jianshu.com/p/819fc0f7f3b2  配置

7、http://www.cnblogs.com/huaxingtianxia/p/5481493.html   快捷键

8、整行粘贴 sb是⌘+D,   vscode是光标在当前行 ⌘+C, 然后在⌘+V

9、多行光标

    ALT+鼠标

    ALT+上下方向键

    关键词被选中/高亮后，CTRL+D


{
    &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,
    &quot;workbench.colorTheme&quot;: &quot;Atom One Dark&quot;,
    &quot;files.autoGuessEncoding&quot;: false,
    &quot;window.zoomLevel&quot;: -1,
    &quot;editor.fontSize&quot;: 13,                    // 文字大小，也可以command +
    &quot;editor.tabSize&quot;: 2,                    // tab空格数
    &quot;editor.formatOnType&quot;: false,
    &quot;editor.formatOnSave&quot;: false,
    &quot;editor.wordWrap&quot;: &quot;on&quot;                    // 代码自动换行
}
</code></pre><h4 id="gitBook"><a href="#gitBook" class="headerlink" title="gitBook"></a>gitBook</h4><pre><code>https://segmentfault.com/a/1190000005859901
http://www.chengweiyang.cn/gitbook/introduction/README.html
</code></pre><h4 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h4><pre><code>https://sspai.com/post/25137
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/24/eCharts图表插件/">EChart</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/24/eCharts图表插件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-24T03:43:51.000Z" itemprop="datePublished">2017-04-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端插件类/">前端插件类</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>1、npm install echarts --save

2、引入echarts的两种方式

    页面直接引入文件: &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;

    webpack: import echarts from &apos;echarts&apos;

3、页面创建DOM的容器

    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;        必须要一个高度值
</code></pre><h4 id="异步数据加载和更新"><a href="#异步数据加载和更新" class="headerlink" title="异步数据加载和更新"></a>异步数据加载和更新</h4><pre><code>1、数据异步

    将数据通过ajax异步取到后，在通过setOption()方式直接加到载插件中


2、loading动画

    showLoading()来显示、hideLoading()隐藏

    Exampole
    var myChart = echarts.init(document.getElementById(&apos;main&apos;));

    myChart.showLoading();
    $.ajax({
        success:function(data){
            myChart.hideLoading();
        }
    })


3、数据的动态更新

    只需要加单个数据，先data.push(vlaue), 在通过setOption()将数据渲染出来

    var data = [];        // 存储数据 

    // 创建图表将data数据加入
    ....

    // 添加数据 
    function addData(){
        data.push(Math.random()*100);
    }

    setInterval(function(){
        addData();
        myChart.setOption({
            数据
        })
    },1000)
</code></pre><h4 id="数据区缩放组件-dataZoom"><a href="#数据区缩放组件-dataZoom" class="headerlink" title="数据区缩放组件 dataZoom"></a>数据区缩放组件 dataZoom</h4><pre><code>option = {
    xAxis: {
        type: &apos;value&apos;
    },
    yAxis: {
        type: &apos;value&apos;
    },

    dataZoom: [
        {   // 这个dataZoom组件，默认控制x轴。
            type: &apos;slider&apos;, // 这个 dataZoom 组件是 slider 型 dataZoom 组件
            start: 10,      // 左边在 10% 的位置。
            end: 60         // 右边在 60% 的位置。
        }
    ],

    series: [
        {
            type: &apos;scatter&apos;, // 这是个『散点图』
            itemStyle: {
                normal: {
                    opacity: 0.8
                }
            },
            symbolSize: function (val) {
                return val[2] * 40;
            },
            data: [[&quot;14.616&quot;,&quot;7.241&quot;,&quot;0.896&quot;],[&quot;3.958&quot;,&quot;5.701&quot;,&quot;0.955&quot;],[&quot;2.768&quot;,&quot;8.971&quot;,&quot;0.669&quot;],[&quot;9.051&quot;,&quot;9.710&quot;,&quot;0.171&quot;],[&quot;14.046&quot;,&quot;4.182&quot;,&quot;0.536&quot;],[&quot;12.295&quot;,&quot;1.429&quot;,&quot;0.962&quot;],[&quot;4.417&quot;,&quot;8.167&quot;,&quot;0.113&quot;],[&quot;0.492&quot;,&quot;4.771&quot;,&quot;0.785&quot;],[&quot;7.632&quot;,&quot;2.605&quot;,&quot;0.645&quot;],[&quot;14.242&quot;,&quot;5.042&quot;,&quot;0.368&quot;]]
        }
    ]
}
</code></pre><h4 id="事件和行为"><a href="#事件和行为" class="headerlink" title="事件和行为"></a>事件和行为</h4><pre><code>Echarts中有两种事件，1、用户的鼠标事件   2、交互组件后触发的行为事件

一、鼠标事件

    鼠标事件: &apos;click&apos;、&apos;dblclick&apos;、&apos;mousedown&apos;、&apos;mousemove&apos;、&apos;mouseup&apos;、&apos;mouseover&apos;、&apos;mouseout&apos;

    myChart.on(&apos;click&apos;, function(params){
        console.log(params.name)
    })


二、交互组件

    myChart.dispatchAction({ type: &apos;&apos; })        // 通过dispatchAction触发

    1、legendselectchanged: 切换图例开关时触发

    2、datazoom: 数据区域缩放触发


二、params 对象

    {
        // 当前点击的图形元素所属的组件名称，
        // 其值如 &apos;series&apos;、&apos;markLine&apos;、&apos;markPoint&apos;、&apos;timeLine&apos; 等。
        componentType: string,

        // 系列类型。值可能为：&apos;line&apos;、&apos;bar&apos;、&apos;pie&apos; 等。当 componentType 为 &apos;series&apos; 时有意义。
        seriesType: string,

        // 系列在传入的 option.series 中的 index。当 componentType 为 &apos;series&apos; 时有意义。
        seriesIndex: number,

        // 系列名称。当 componentType 为 &apos;series&apos; 时有意义。
        seriesName: string,

        // 数据名，类目名
        name: string,

        // 数据在传入的 data 数组中的 index
        dataIndex: number,

        // 传入的原始数据项
        data: Object,

        // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data，
        // dataType 的值会是 &apos;node&apos; 或者 &apos;edge&apos;，表示当前点击在 node 还是 edge 上。
        // 其他大部分图表中只有一种 data，dataType 无意义。
        dataType: string,

        // 传入的数据值
        value: number|Array

        // 数据图形的颜色。当 componentType 为 &apos;series&apos; 时有意义。
        color: string
    }
</code></pre><h4 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h4><pre><code>1、title: 标题（包括主副标题、链接、样式）

2、legend: 标记的区域 （对legend的显隐、宽高、位置、横纵向排列）

3、grid: 图表的网格区域 （是否显示网格、位标、宽高、背景色、边线色）

4、xAxis、yAxis: x、y坐标轴
    {
        splitLine:{
            show: false,                // 去掉网格线
            lineStyle: {
                color: &apos;#48484a&apos;    // 设置网络线颜色 
            }
        },                
        splitArea : {show : true}                //保留网格区域
    }

5、dataZoom: 数据缩放 （）

6、toolTip: 提示信息，鼠标移到数据点浮现的提示信息（）

7、axisPointer:

8、toolBox: 工具栏 （导出图表、数据视图、动态类型切换、缩放、重置）

9、series: 系列列表（来决定图表的类型、图表的数据）

10、color: 图表每一项的颜色

11、background: 图表背景色

12、textStyle: 文本样式

13、animate: 是否开启动画

----- 组件 -------

14、timeline: 时间轴组件

15、graphic: 原生图形元素组件

16、calendar: 日历坐标组件

17、brush: 区域选择组件

18、geo: 地理坐标系组件

19、parallel: 平行坐标系

20、parallelAxis: 这个组件是平行坐标系中的坐标轴

21、singleAxis: 单轴。可以被应用到散点图中展现一维数据
</code></pre><h4 id="series对象"><a href="#series对象" class="headerlink" title="series对象"></a>series对象</h4><pre><code>type: 展示图表的类型

name: 名称

label: 图形上文本标签的控制（show、position、offset、formatter、）

    formatter可以是字符串也可以是函数 

        字符串模板，模板变量有 {a}、{b}、{c}，分别表示系列名，数据名，数据值。

        formatter: &apos;{b}: {c}&apos;

        label:{
            normal:{
                formatter: function(data){            // callback
                    return data.percent + &apos;%&apos;;
                }
            }
        }, 

        params:
        {
            componentType: &apos;series&apos;,
            // 系列类型
            seriesType: string,
            // 系列在传入的 option.series 中的 index
            seriesIndex: number,
            // 系列名称
            seriesName: string,
            // 数据名，类目名
            name: string,
            // 数据在传入的 data 数组中的 index
            dataIndex: number,
            // 传入的原始数据项
            data: Object,
            // 传入的数据值
            value: number|Array,
            // 数据图形的颜色
            color: string,

            // 百分比
            percent: number,

        }

labelLine: 图形上图形与文本之间连接线的控制

data: 数据

center: 饼图中心坐标

radius: 半径
</code></pre><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><pre><code>1、x、y轴文字的颜色和角度

    xAxis: {
        type: &apos;category&apos;,
        boundaryGap: false,
        data: [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;, &apos;Sat&apos;, &apos;Sun&apos;],
        axisLabel: {            // 这里控制颜色
            show: true,
            textStyle: {
                color: &apos;#fff&apos;
            },
            rotate: 45
        }
    },
</code></pre><blockquote>
<p>参考资料<br><a href="http://echarts.baidu.com/echarts2/doc/doc.html#Title" target="_blank" rel="noopener">http://echarts.baidu.com/echarts2/doc/doc.html#Title</a><br><a href="http://echarts.baidu.com/gallery/editor.html" target="_blank" rel="noopener">http://echarts.baidu.com/gallery/editor.html</a>   在线编辑</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/06/Nginx服务器/">Nginx</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/06/Nginx服务器/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-06T10:18:51.000Z" itemprop="datePublished">2017-04-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/服务器/">服务器</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h4><pre><code>服务器分类: Nginx、Apache、tomcat、Micorsoft Server

ng是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器，超越Apache的高性能和稳定性.
</code></pre><h4 id="四层和七层负载均衡"><a href="#四层和七层负载均衡" class="headerlink" title="四层和七层负载均衡"></a>四层和七层负载均衡</h4><pre><code>负载均衡设备也被称为&quot;四到七层交换机&quot;，四层就是基于IP+端口的负载均衡，七层就是基于URL等应用信息的负载均衡.

如果只做HTTP的负载均衡，用haproxy好了。性能很强。

七层负载均衡优点:

    1、高并发连接: 支撑5万并发连接

    2、内存消耗少: 在3万并发连接，开启10个Nginx进程消耗150M内存

    3、配置文件简单

    4、节省带宽: 支持GZIP压缩，可以添加浏览器本地缓存的Header头，

    5、稳定性高: 用于反向代理, 宕机概率小

    9、支持热部署: 不间断服务进行更新
</code></pre><h4 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h4><pre><code>一、七层负载均衡优势:

    1、对HTTP报头检查，可以检出状态码为400、500、600的错误信息，如果有错误将连接请求重新定向到另一台服务器

    2、可以根据数据类型（判断数据包是图像、压缩文件、或多媒体文件等），将数据引向内容服务器

    3、根据请求类型，将普通文本、图象等静态文档，或是动态文档请求，引向相应的服务器来处理


二、Nginx负载均衡是基于内容和应用的七层资的，Nginx抗并发强，是因为Nginx使用了非阻塞、异步传输

三、模块

    1、nginx负载均衡模块

        配置负载均衡是ngx_http_upstream_module，这模块是默认安装

    2、代理模块

        Proxy为nginx的代理模块, 允许将用户的HTTP请求转发到后端服务器

四、反向代理 

    反向代理是指以代理服务器接受internet上的连接请求，将请求转发给内部服务器，并将从服务器得到结果返回给internet的客户端
</code></pre><h4 id="Nginx负载均衡调试策略"><a href="#Nginx负载均衡调试策略" class="headerlink" title="Nginx负载均衡调试策略"></a>Nginx负载均衡调试策略</h4><pre><code>ng的upstream目前支付几种分配:

1、轮询: 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务down掉，能自动剔除

2、weight: 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况

    upstream bakend { 
        server 192.168.0.14 weight=10; 
        server 192.168.0.15 weight=10; 
    }

3、ip_hash: 每个请求按访问ip的hash结果分配，每个访客访问一个固定的后端服务器

    upstream bakend { 
        ip_hash; 
            server 192.168.0.14:88; 
            server 192.168.0.15:80; 
        }
    }

4、fair（第三方）

5、url_hash（第三方）

    upstream backend { 
        server squid1:3128; 
        server squid2:3128; 
        hash $request_uri; 
        hash_method crc32; 
    }
</code></pre><h4 id="Nginx安装和删除"><a href="#Nginx安装和删除" class="headerlink" title="Nginx安装和删除"></a>Nginx安装和删除</h4><pre><code>主要步骤: 下载包，压缩、配置编译

$ https://nginx.org/en/download.html    下载一个nginx包版本

$ cd /usr/local/ &amp;&amp; mkdir newNginx     // 进入到local目录并创建一个newNginx目录

$ 将下载的包copy到新创建的newNginx目录, 并将包解压到当前目录   tar zxf nginx-1.12.2.tar.gz 

$ cd nginx-1.12.2

$ ./configure        // 验证过程

$ make

$ make install         // 这时候会创建一个nginx目录 /usr/local/nginx

$ 将newNginx目录的文件copy到nginx目录
</code></pre><h4 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h4><pre><code>默认该配置文件被命名nginx.conf

    配置server

    server {
        listen       9092;                                // 端口
        root /Users/apple/siguang.liu/Hh/hh_h5;            // 指定根目录

        location / {
            proxy_pass  http://174.16.1.82:8080/;        // 代理到的服务器
        }

        error_page   500 502 503 504  /50x.html;        // 错误
        location = /50x.html {
            root   html;
        }

        location ^~ /api {
            proxy_pass  http://172.16.1.82:8080/;        // 如果访问以&quot;/api&quot;开头的代理的服务器
        }

        location ~ \.(gif|jpg|png|js|css|html|map)$ {    // 指定静态资源
            root /Users/apple/siguang.liu/Hh/hh_h5;
        }
    }

    可以通过include来将另一个文件的内容引用

    include servers/*.conf;


一、所存在的目录 /usr/local/nginx/conf            // 本机mac /usr/local/openresty/nginx

二、启动  sudo /usr/local/openresty/nginx/sbin/nginx      // 需要sudo管理员权限

三、启动后的可以通过调用带-s参数来执行文件来控制 

    $ nginx -s 命令

    1、reload - 重启  sudo /usr/local/openresty/nginx/sbin/nginx -s reload

    2、stop - 快速关机 sudo /usr/local/openresty/nginx/sbin/nginx -s stop

    3、quit - 优雅关机 sudo /usr/local/openresty/nginx/sbin/nginx -s quit

    4、reopen - 重新打开日志文件 sudo /usr/local/openresty/nginx/sbin/nginx -s reopen

四、查看、杀掉进程

    $ ps -ex | grep nginx

    $ kill -s quit 1682

五、配置文件结构

    指令分为简单指令和块指令，以空格分隔，以分号(;)结束

四、注释使用 #

    # HTTPS server
    #
    # server {
    #    listen       443 ssl;
    #    server_name  localhost;
    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;
    # }
</code></pre><h4 id="Nginx配置-HTTP2-0"><a href="#Nginx配置-HTTP2-0" class="headerlink" title="Nginx配置 HTTP2.0"></a>Nginx配置 HTTP2.0</h4><pre><code>https://www.nginx.com/blog/nginx-1-9-5/
</code></pre><p>| <a href="http://www.cnblogs.com/felixzh/category/937300.html" target="_blank" rel="noopener">http://www.cnblogs.com/felixzh/category/937300.html</a><br>| <a href="https://www.cnblogs.com/felixzh/p/6283788.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/6283788.html</a><br>| <a href="https://www.cnblogs.com/taiyonghai/p/6728707.html" target="_blank" rel="noopener">https://www.cnblogs.com/taiyonghai/p/6728707.html</a></p>

        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
