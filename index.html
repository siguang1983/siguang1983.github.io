<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/10/23/微信小程序、公众号开发/">微信小程序、公众号开发</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/10/23/微信小程序、公众号开发/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-10-23T08:02:17.000Z" itemprop="datePublished">2017-10-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/微信小程序/">微信小程序</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h4><pre><code>一、appleID的获取

    https://mp.weixin.qq.com/wxopen/basicprofile?action=index&amp;token=767275273&amp;lang=zh_CN

    在开发设置选项 =&gt; AppID(小程序ID)
</code></pre><h4 id="基础配置、文件类型"><a href="#基础配置、文件类型" class="headerlink" title="基础配置、文件类型"></a>基础配置、文件类型</h4><pre><code>一、文件类型

    app.js 脚本文件、app.json 配置文件、app.wxml页面结构、app.wxss样式文件

二、app.json配置

    {
        // 页面路径
        &quot;pages&quot;: [
            &quot;pages/index/index&quot;,
            &quot;pages/logs/index&quot;
        ],
        // 默认页面窗口表现
        &quot;window&quot;: {
            &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
        },
        // 底部tab的表现
        &quot;tabBar&quot;: {
            &quot;list&quot;: [{
            &quot;pagePath&quot;: &quot;pages/index/index&quot;,
            &quot;text&quot;: &quot;首页&quot;
            }, {
            &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
            &quot;text&quot;: &quot;日志&quot;
            }]
        },
        // 设置网络超时时间
        &quot;networkTimeout&quot;: {
            &quot;request&quot;: 10000,
            &quot;downloadFile&quot;: 10000
        },
        // 是否开启debug模式
        &quot;debug&quot;: true
    }

    https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html         // 各类别配置
</code></pre><h4 id="App-js-主函数"><a href="#App-js-主函数" class="headerlink" title="App.js 主函数"></a>App.js 主函数</h4><pre><code>一、事件

    1、onLaunch - 监听小程序初始化，初始化完成会触发onLaunch

    2、onShow - 监听小程序显示，小程序启动、从后台进入前台显示，触发onShow

    3、onHide - 监听小程序隐藏，从前台进入后台，会触发onHide

    4、onError - 错误监听，脚本错误或api调用失败触发


二、onLaunch和onShow的参数 

    App({
        onLaunch: function (path) {
            console.log(path);
        }
    })

    1、path - String    打开小程序的路径

    2、query - Object 打开小程序的query

    3、scene - Number 打开小程序的场景值

    4、shareTicket - String    shareTicket，详见 获取更多转发信息

    5、referrerInfo - Object    当场景为由从另一个小程序或公众号或App打开时，返回此字段

        返回值:
            1020    公众号 profile 页相关小程序列表    返回来源公众号 appId
            1035    公众号自定义菜单    返回来源公众号 appId
            1036    App 分享消息卡片    返回来源应用 appId
            1037    小程序打开小程序    返回来源小程序 appId
            1038    从另一个小程序返回    返回来源小程序 appId
            1043    公众号模板消息    返回来源公众号 appId

    6、referrerInfo.appId - String 来源小程序或公众号或App的 appId，详见下方说明

    7、referrerInfo.extraData - Object 来源小程序传过来的数据，scene=1037或1038时支持


三、getApp() 全局函数用来获取小程序实例

    var appInstance = getApp();

    app.globalData.userInfo;        // 获取当前用户信息
</code></pre><h4 id="Page-用来注册一个页面"><a href="#Page-用来注册一个页面" class="headerlink" title="Page() 用来注册一个页面"></a>Page() 用来注册一个页面</h4><pre><code>指定页面的初始数据、生命周期、事件处理

一、生命周期

    onLoad: 页面加载，一个页面只会调用一次

    onShow: 页面显示 

    onReady: 页面初次渲染完成

    onHide: 页面隐藏

    onUnload: 页面卸载

    /** 生命周期函数--监听页面加载 **/
    onLoad: function (options) {
        console.log(options);
    },

    /** 生命周期函数--监听页面初次渲染完成 **/
    onReady: function () {

    },

    /** 生命周期函数--监听页面显示 **/
    onShow: function () {

    },

    /** 生命周期函数--监听页面隐藏 **/
    onHide: function () {

    },

    /** 生命周期函数--监听页面卸载 **/
    onUnload: function () {

    },

    /** 页面相关事件处理函数--监听用户下拉动作 **/
    onPullDownRefresh: function (e) {
        this.setData({
            updata: JSON.stringify(e)
        })
        console.log(e)
    },

    /** 页面上拉触底事件的处理函数 **/
    onReachBottom: function (e) {
        this.setData({
            updata: JSON.stringify(e)
        })
        console.log(e)
    },

    /** 用户点击右上角分享 **/
    onShareAppMessage: function () {

    }


二、事件方法

    data - 页面初始数据, WXML中调用 {{test}}

    onload - 监听页面加载

    onReady - 监听页面初次渲染完成

    onShow - 监听页面显示

    onHide - 监听页面隐藏

    onUnload - 监听页面卸载

    onPullDowRefesh - 监听用户下拉动作

    onReachBottom - 上拉触底事件

    onShareAppMessage - 用户点击右上角转发

        onShareAppMessage: function () {
            return {
            title: &apos;自定义转发标题&apos;,
            path: &apos;/page/user?id=123&apos;
            }
        }

    onPageScroll - 页面滚动触发


三、绑定事件

    &lt;view bindTap=&quot;viewTap&quot;&gt;click me&lt;/view&gt;

    Page({
        data:{
            message: &apos;view tap&apos;
        },
        viewTap: () =&gt; {
            console.log(this.message)
        }
    })


四、Page.prototype.route - 获取当前页面的路径

五、Page.prototype.setData() - 用于将数据从逻辑层发送到视图层，同时改变对应的this.data的值

    Page({
        data:{
            username: &apos;siguang&apos;
        }
        login: ()=&gt;{
            this.setData({
                username: &apos;lulu&apos;
            })
        }
    })
</code></pre><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><pre><code>所有页面的路由全部由框架管理

一、页面栈

    1、初始化 - 新页面入栈

    2、打开新页面 - 新页面入栈。  调用 API wx.navigateTo 或使用组件 &lt;navigator open-type=&quot;navigateTo&quot;/&gt;

    3、页面重定向 - 当前页面出栈，新页面入栈。  调用 API wx.redirectTo 或使用组件 &lt;navigator open-type=&quot;redirectTo&quot;/&gt;

    4、页面返回 - 页面不断出栈，直到目标返回页，新页面入栈。 调用 API wx.navigateBack 或使用组件&lt;navigator open-type=&quot;navigateBack&quot;&gt;或用户按左上角返回按钮

    5、Tab - 切换    页面全部出栈，只留下新的 Tab 页面。 调用 API wx.switchTab 或使用组件 &lt;navigator open-type=&quot;switchTab&quot;/&gt; 或用户切换 Tab

    6、重加载 - 页面全部出栈，只留下新的页面。 调用 API wx.reLaunch 或使用组件 &lt;navigator open-type=&quot;reLaunch&quot;/&gt;

    Example:
        bindViewTap: function() {
            wx.navigateTo({
                url: &apos;../logs/logs&apos;
            })
        }

二、getCurrentPages() 获取当前页面的栈的实例

三、Tips

    navigateTo, redirectTo 只能打开非 tabBar 页面。
    switchTab 只能打开 tabBar 页面。
    reLaunch 可以打开任意页面。
</code></pre><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><pre><code>一、全局变量和方法

    全局方法通过 getApp()获取全局的应用实例

    全局数据设置:

        App({
            globalData: 1
        })


二、模块化

    1、导出

        module.exports 或 exports对外暴露接口, exports是module.exports的一个引用

        小程序不支持直接引入node_modules, 如果需要就将代码拷到目录中

        // common.js
        function sayHello(name){
            console.log(`Hello ${name}`);
        }

        module.exports.sayHello = sayHello;


    2、引用

        conmmon = require(&apos;common.js&apos;);
        Page({
            helloMina: () =&gt;{
                common.sayHello(&apos;mina&apos;);
            }
        })
</code></pre><h4 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h4><pre><code>视图层WXMWXSS编写, 由组件进行展示

一、WXML

    1、数据绑定

        普通绑定: &lt;view&gt;{{message}}&lt;/view&gt;

        属性绑定: &lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;

        控制属性: &lt;view wx:if=&quot;{{condition}}&quot;&gt; &lt;/view&gt;


    2、循环渲染

        // 注意这里取到当前数据要用item
        &lt;view wx:for=&quot;{{arr}}&quot;&gt;{{item}}&lt;/view&gt;

        数组下标:
            &lt;view wx:for=&quot;{{arr}}&quot;&gt;
                姓名:{{item.name}} 年龄:{{item.age}} 序号:{{index}}
            &lt;/view&gt;

            两者相同
            &lt;view wx:for=&quot;{{arr}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
                姓名:{{itemName.name}} 年龄:{{itemName.age}} 序号:{{idx}}
            &lt;/view&gt;


    3、条件渲染

        &lt;view wx:if=&quot;{{view == 'webView'}}&quot;&gt;web view&lt;/view&gt;
        &lt;view wx:elif=&quot;{{view == 'app'}}&quot;&gt;app&lt;/view&gt;
        &lt;view wx:else=&quot;{{view == 'mina'}}&quot;&gt;mina&lt;/view&gt;

        Page({
            data: {
                view: &apos;app&apos;
            }
        })


    4、模板

        name: 模板名    is: 所要调用的模板名    data: 传入的数据

        &lt;template name=&quot;staffName&quot;&gt;
            &lt;view&gt;
                FirstName: {{firstName}}, lastName: {{lastName}}
            &lt;/view&gt;
        &lt;/template&gt;

        &lt;template is=&quot;staffName&quot; data=&quot;{{...staffA}}&quot;&gt;&lt;/template&gt;
        &lt;template is=&quot;staffName&quot; data=&quot;{{...staffB}}&quot;&gt;&lt;/template&gt;

        Page({
            data: {
                staffName: {fristName: &apos;sigunag&apos;, lastName: &apos;haha&apos;},
                staffName: {fristName: &apos;yuwan&apos;, lastName: &apos;lulu&apos;},
            }
        })
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>&lt;view bindtap=&quot;add&quot;&gt;{{count}}&lt;/view&gt;

Page({
    data: {
        count: 1
    },
    add: (event)=&gt;{
        this.setData({
            count: this.data.count++
        })
    }
})

一、事件分类

    分为冒泡事件和非冒泡事件

    冒泡事件:  bindtouchstart 前面加bind

        touchstart    手指触摸动作开始    
        touchmove    手指触摸后移动    
        touchcancel    手指触摸动作被打断，如来电提醒，弹窗    
        touchend    手指触摸动作结束    
        tap    手指触摸后马上离开    
        longpress    手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发    1.5.0
        longtap    手指触摸后，超过350ms再离开（推荐使用longpress事件代替）    
        transitionend    会在 WXSS transition 或 wx.createAnimation 动画结束后触发    
        animationstart    会在一个 WXSS animation 动画开始时触发    
        animationiteration    会在一个 WXSS animation 一次迭代结束时触发    
        animationend    会在一个 WXSS animation 动画完成时触发

    事件绑定和冒泡:

        bind 不会阻止冒泡事件向上冒泡，bindtap
        catch 可以阻止冒泡事件向上冒泡。catchtap

    事件捕获:

        捕获阶段监听事件时，采用capture-bind、capture-catch关键字, 后者将中断捕获阶段和取消冒泡

    事件对象:

        baseEvent对象


二、view、block标签

    view 渲染单独一行类似块元素

    block 渲染成内联元素
</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>提供两种引用方法import 和 include

一、import 引用外部的&lt;template&gt;模板

    &lt;!-- item.wxml --&gt;
    &lt;template name=&quot;item&quot;&gt;
        &lt;text&gt;{{text}}&lt;/text&gt;
    &lt;/template&gt;

    &lt;!--  index.wxml  --&gt;
    &lt;import src=&quot;item.wxml&quot;/&gt;
    &lt;template is=&quot;item&quot; data=&quot;{{text: 'forbar'}}&quot;/&gt;


二、include 引用非&lt;template&gt;模板的文件，公用的头尾等

    &lt;!-- index.wxml --&gt;
    &lt;include src=&quot;header.wxml&quot;/&gt;
    &lt;view&gt; body &lt;/view&gt;
    &lt;include src=&quot;footer.wxml&quot;/&gt;

    &lt;!-- header.wxml --&gt;
    &lt;view&gt; header &lt;/view&gt;

    &lt;!-- footer.wxml --&gt;
    &lt;view&gt; footer &lt;/view&gt;
</code></pre><h4 id="WXSS-样式语言"><a href="#WXSS-样式语言" class="headerlink" title="WXSS 样式语言"></a>WXSS 样式语言</h4><pre><code>尺寸单位: rex, 可以根据屏幕宽度自行自适应

一、样式导入

    @import &apos;common.wxss&apos;
    .middle-p {
        padding: 15px;
    }

二、内联样式
    data: {
        color: &apos;#ddd&apos;
    }
    &lt;view style=&quot;color: {{color}}&quot;&gt;

    &lt;view class=&quot;middle-p&quot;&gt;        // 多个class使用空格分隔

三、全局、局部样式

    定义在app.wxss中的样式为全局

    每个页的wxss为局部
</code></pre><h4 id="WXS-脚本"><a href="#WXS-脚本" class="headerlink" title="WXS 脚本"></a>WXS 脚本</h4><pre><code>小程序自己的一套脚本语言, 可以直接编写到WXML中, 也可以单独写成一个.wxs文件

一、写到wxml中

    &lt;!-- index.wxml&gt;
    &lt;wxs module=&quot;m1&quot;&gt;
        var msg = &apos;hello world&apos;;
        module.exports.message = msg
    &lt;/wxs&gt;

    &lt;view&gt;
        {{m1.message}}
    &lt;/view&gt;

二、写成一个.wxs文件

    // pages/comm.wxs
    // 如果comm.wxs文件中要引用其它的wxs文件使用require,  var tool = require(&apos;./tools.wxs&apos;);

    var foo = &quot;&apos;hello world&apos; from comm.wxs&quot;;
    var bar = function(d) {
        return d;
    }
    module.exports = {
        foo: foo,
        bar: bar
    };

    // 页面引用
    &lt;wxs src=&quot;./../tools.wxs&quot; module=&quot;tools&quot; /&gt;
    &lt;view&gt; {{tools.msg}} &lt;/view&gt;
</code></pre><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><pre><code>小程序两种启动方式:

    冷启动: 用户首次打开或小程序被微信主动销毁后在次打开的情况，

    热启动: 用户已经打开某个小程序，在一定时间内在次打开，此时无需重新启动，只需将后台切换到前台
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>网络请求request、文件上传下载uploadFile、webSocket都需要设置指定的服务器
</code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code>wx.getSystemInfo 或者 wx.getSystemInfoSync 获取小程序的基本库版本

wx.canIUse 判断是否可以在该基础库版本下直接使用对应的API或者组件
</code></pre><h4 id="开发总结"><a href="#开发总结" class="headerlink" title="开发总结"></a>开发总结</h4><pre><code>1、小程序初始指定页面

    app.json中, 调整pages数组的顺序, 第一个就是最先被载入

    &quot;pages&quot;:[
        &quot;pages/my/my&quot;,
        &quot;pages/index/index&quot;,
        &quot;pages/logs/logs&quot;    
    ]

2、当前页面使用修改标题

    在当前页面下的.json文件中加入

    goods-details.json
    {
        &quot;navigationBarTitleText&quot;: &quot;商品详情&quot;
    }

3、获取元素上的自定义属性值

    1) evt.currentTarget.dataset.propertyindex;        

    2) evt.detail

    &lt;view bindtap=&quot;labelItemTap&quot; data-propertyindex=&quot;{{idx}}&quot;&gt;&lt;/view&gt;        // 注意这里自定义属性需要以&quot;data-&quot;开头，并且不能为大写，如果有大写取值时全部为小写

    js:

    labelItemTap: function(evt){
        let val = evt.currentTarget.dataset.propertyindex;
    }

4、在app.json中配置pages的路径会自动创建目录和基本文件这里

    这里注意创建js时候会将生命周期方法和上拉下拉刷新方法全部都创建好，不必重写 onPullDownRefresh()、onReachBottom();
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>如果修改 checkbox 的样式

时间选择器只有时、分，没有秒

slider滑动组件拖动块不能改颜色

小程序下拉刷新不触发 onPullDownRefresh
</code></pre><h4 id="小程序与RN相比"><a href="#小程序与RN相比" class="headerlink" title="小程序与RN相比"></a>小程序与RN相比</h4><pre><code>小程序布局写法简单，RN的布局比较麻烦

小程序的组件简单，RN组件麻烦，并且IOS和Android兼容

RN可以随意发起网络请求访问数据，小程序需要指定服务器并且需要https协议

RN需要与通过Xcode来进去打包、并且需要在appStor进行发布审核

RN做的app需要到商店下载使用，小程序发布后在微信就可以找到
</code></pre><p>| <a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="noopener">http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html</a>        // 公众服务平台所有的sdk<br>| <a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=20171013" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=20171013</a>  // 小程序<br>| <a href="https://www.w3cschool.cn/weixinapp/9wou1q8j.html" target="_blank" rel="noopener">https://www.w3cschool.cn/weixinapp/9wou1q8j.html</a><br>| <a href="http://203.195.235.76/jssdk/" target="_blank" rel="noopener">http://203.195.235.76/jssdk/</a>   小程序demo<br>| <a href="https://github.com/gooking/awesome-wechat-weapp" target="_blank" rel="noopener">https://github.com/gooking/awesome-wechat-weapp</a>    微信小程序开发资源汇总</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/20/numjucks模板/">numjucks模板</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/20/numjucks模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-09-20T03:41:55.000Z" itemprop="datePublished">2017-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="numjucks"><a href="#numjucks" class="headerlink" title="numjucks"></a>numjucks</h4><pre><code>numjucks可以用任意扩展名来命名模板名文件，推荐使用&apos;.njk&apos;

$ npm install nunjucks

require(&apos;nunjucks&apos;);
</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>{{ usernmae }}    {{ foo.bar }}
</code></pre><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><pre><code>{{ foo | title }}    {{ foo | join(',') }}
</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><pre><code>定义一个&quot;block&quot;，子模板可以覆盖它

一、Example

    A.html

        {% block header %}{% endblock %}

			<div>
				aaaa
			</div>

		B.html

			{% extends 'A.html' %}

			{% block header %}
				<div>
					<ul>
						<li>aaaa</li>
						<li>bbbb</li>
						<li>cccc</li>
					</ul>
				</div>
			{% endblock %}

二、super()
</code></pre><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><pre><code>{% if num > 20 %}
		<div>
			大于20显示些内容
		</div>
	{% endif %}


{% if num > 20 %}
		<span>大于20</span>
	{% elif num < 6 %}
		<span>小于6</span>
	{% else %}
		<span>其它</span>
	{% endif %}
</code></pre><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre><code>一、遍历数组

    var items = [{ title: &quot;foo&quot;, id: 1 }, { title: &quot;bar&quot;, id: 2}];

    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;ul&gt;
        {% for item in items %}
				<li> {{item.title}} </li>
			{% endfor %}
    &lt;/ul&gt;

二、遍历对象

    var food = {
        &apos;ketchup&apos;: &apos;5 tbsp&apos;,
        &apos;mustard&apos;: &apos;1 tbsp&apos;,
        &apos;pickle&apos;: &apos;0 tbsp&apos;
    };

    &lt;div&gt;
        {% for key, value in food %}
				<p>{{key}} - {{value}}</p>
			{% endfor %}
    &lt;/div&gt;
</code></pre><h4 id="set-设置和修改变量"><a href="#set-设置和修改变量" class="headerlink" title="set 设置和修改变量"></a>set 设置和修改变量</h4><pre><code>let username = &apos;siguang&apos;;

{{ username }}            // siguang
{% set username = 'lulu' %}
{{ username }}            // lulu
</code></pre><h4 id="extends-指定模板继承"><a href="#extends-指定模板继承" class="headerlink" title="extends 指定模板继承"></a>extends 指定模板继承</h4><pre><code>{% extends 'A.html' %}

{% block header %}
		<div>
			<ul>
				<li>aaaa</li>
				<li>bbbb</li>
				<li>cccc</li>
			</ul>
		</div>
	{% endblock %}
</code></pre><h4 id="block-区块"><a href="#block-区块" class="headerlink" title="block 区块"></a>block 区块</h4><pre><code>{% block css %}
		<link rel="stylesheet" href="app.css">
	{% endblock %}
</code></pre><h4 id="include-可以引用的模板"><a href="#include-可以引用的模板" class="headerlink" title="include 可以引用的模板"></a>include 可以引用的模板</h4><pre><code>{% include "item.html" %}
</code></pre><h4 id="import-加载不同的模板"><a href="#import-加载不同的模板" class="headerlink" title="import 加载不同的模板"></a>import 加载不同的模板</h4><h4 id="filter-区块中内容调用过滤器"><a href="#filter-区块中内容调用过滤器" class="headerlink" title="filter 区块中内容调用过滤器"></a>filter 区块中内容调用过滤器</h4><pre><code>{% filter replace("force", "forth") %}
		may the force be with you
	{% endfilter %}
</code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><h4 id="去除前后空格"><a href="#去除前后空格" class="headerlink" title="去除前后空格"></a>去除前后空格</h4><pre><code>var str = &apos; sssfsdfs &apos;;

{% -%}
</code></pre><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><pre><code>表达式 String、Number、Array、Dicts、Boolean

运算符 +、-、/、//、%、*、**

比较 ==、===、!=、!==、&gt;、&gt;=、&lt;、&lt;=

逻辑 and、or、not   {% if users and showUsers %} ... {% endif %}
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>传入一个函数，在这里可以执行 {{ foo(1,2,3) }}
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>{{ /bar$/g }}

g: 应用到全局
i: 不区分大小写
m: 多行模式
y: 粘性支持（sticky
</code></pre><blockquote>
<p>参考资料<br><a href="http://mozilla.github.io/nunjucks/cn/templating.html" target="_blank" rel="noopener">http://mozilla.github.io/nunjucks/cn/templating.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/20/Jade模板/">Jade 模板</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/20/Jade模板/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-09-20T03:41:55.000Z" itemprop="datePublished">2017-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/模板引擎/">模板引擎</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="jade介绍、安装"><a href="#jade介绍、安装" class="headerlink" title="jade介绍、安装"></a>jade介绍、安装</h4><pre><code>jade是前后端都可以使用的模板引擎7

1、安装:

    sudo npm i -g jade


2、介绍

    元素标签不需要写&lt;&gt;

    子元素与父元素需要换行并tab缩进

    标签与文本需要使用空格来隔开


3、jade的缺点

    1）可移植性差

    2）调试困难

    3）性能一般

4、初始阶段开发效率，稳定性成和协作的成本
</code></pre><h4 id="jade-头尾标签"><a href="#jade-头尾标签" class="headerlink" title="jade 头尾标签"></a>jade 头尾标签</h4><pre><code>&lt;!DOCTYPE&gt;
html
    head
        title ${title}

    body
        h1 标题内容
</code></pre><h4 id="命令行编译jade文件"><a href="#命令行编译jade文件" class="headerlink" title="命令行编译jade文件"></a>命令行编译jade文件</h4><pre><code># jade index.jade         // 会将jade文件编译成同级目录的index.html文件，并且是没有代码格式的只有一行

# jade -P index.jade     // 有缩进，可读的格式

# jade -P -w index.jade // 侦听jade文件有变化执行转换的命令

小技巧: 在sublime中打开 index.jade 和 index.html文件, 选择view菜单 -&gt; layout/ columns2 变成两列，将index.html放到另一列中，这样每次保存就可以看到html代码
</code></pre><h4 id="属性文本和值"><a href="#属性文本和值" class="headerlink" title="属性文本和值"></a>属性文本和值</h4><pre><code>1、class和id

    div.row

    div#row

    div#row.column-samil    // id=&quot;row&quot; class=&quot;column-samil&quot;

    div.rowA.main        // class=&quot;rowA main&quot;


2、属性

    a标签的href属性值，和自定义属性和值
    a(href=&quot;http://haha.com&quot;,
        title=&quot;jade&quot;,
            data-uid=&quot;siguang&quot;)

    input(name=&quot;course&quot; type=&quot;check&quot; checked)
</code></pre><h4 id="混合的文本和标签"><a href="#混合的文本和标签" class="headerlink" title="混合的文本和标签"></a>混合的文本和标签</h4><pre><code>1、如果字符里有点进行处理

    // 不会把.aa解析成 class=&quot;aa&quot; 并且换行,也能写html标签
    div.row
        p.
            1.aa &lt;strong&gt;这里字体加粗&lt;/string&gt;
            2.bb
            3.cc 
            4.dd

    或者
    div.row
        p
            | 1.aa 
            | 2.bb
            | 3.cc 
            | 4.dd
</code></pre><h4 id="注释和条件注释"><a href="#注释和条件注释" class="headerlink" title="注释和条件注释"></a>注释和条件注释</h4><pre><code>1、单行注释 //

2、不可见的注释 //-

3、块注释        //- 在当前节点的开头

4、条件注释

    &lt;!--[if IE 8]&gt;
        &lt;html class=&apos;ie8&apos;&gt;
    &lt;![endif]&gt;


    &lt;/html&gt;        // 需要html



div.row
    // a(href=&quot;http://haha.com&quot;, title=&quot;siguang&quot;, data-index=&quot;1&quot;) 去主站

    //- input(name=&quot;course&quot; type=&quot;check&quot; checked)

div.row
//-
    p.
        1.aa &lt;strong&gt;这里字体加粗&lt;/string&gt;
        2.bb
        3.cc 
        4.dd
</code></pre><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><pre><code>声明: - var course = &apos;jade&apos;

获取: #{jade}

1、命令行下传值
    jade index.jade -P -w --obj &apos;{&quot;name&quot;:&quot;siguang&quot;, age: 30}&apos;

    div.row
        div.column-12
            姓名: #{name}

        div.column-12
            年龄: #{age}

2、通过json传值

    jade index.jade -P -O test.json

    test.json
    {
        &apos;name&apos;: &apos;siguang&apos;,
        &apos;age&apos;: 30
    }
</code></pre><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><pre><code>1、将html转成字符串输出

    - var data = &apos;&lt;script&gt;alert(123)&lt;/script&gt;&apos;

    p #{data}


2、非转义

    - var data = &apos;&lt;script&gt;alert(123)&lt;/script&gt;&apos;

    p !{data}
</code></pre><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><pre><code>1、if...else...

    - var isData = true
    if isData
        div 对象存在
    else
        对象不存在


2、case

    - var name = &apos;jade&apos;
    case name
        when &apos;java&apos;
            div java

        when &apos;jade&apos;
            p hello jad



3、for 或 each 循环

    - var data = {&apos;name&apos;: &apos;siguang&apos;, &apos;nage&apos;: 30}
    div.row
        - for(var key in data)
            div= key +&apos;=&apos;+data[key]

    each()
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>相同结构的内容可以放到mixin中，相同一个函数

1、无参
    mixin 函数名        // 声明 
        p 这里是函数的块内容
        p 这里是函数的块内容
        p 这里是函数的块内容

    +函数名            // 调用

2、有参

    mixin 函数名(参数)
        each key in data
            li= data[key]

    +函数名({username: &apos;siguang&apos;, age: 30});
</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><pre><code>代码复用

定义一个html的基本结构，内容只写到body中

public.jade

    DOCTYPE html
    html
        head

        body
            block desc
                p 内容继承
            block content    // 这里接收内容


main.jade

    // 通过extends继承到哪个 jade文件
    extends public

    block content        // 这里写到哪里
        div.row
            p aaaa
            p aaaa
            p aaaa

        div.row-b
            p bbb
            p bbb
            p bbb
</code></pre><h4 id="include-引用"><a href="#include-引用" class="headerlink" title="include 引用"></a>include 引用</h4><pre><code>引用一个jade文件

DOCTYPE html
html
    head
        include head

    body
        include login
</code></pre><h4 id="jade-api"><a href="#jade-api" class="headerlink" title="jade api"></a>jade api</h4><pre><code>http的原声写法

1、jade.compile(source, 传值): 返回一个函数来生成html

2、jade.compileFile(path, 传值)

3、jade.compileClient(source, 传值)

4、jade.render(source, 传值):

5、jade.renderFile(jade文件, 传值):


compile()示例
    var http = require(&apos;http&apos;);
    var jade = require(&apos;jade&apos;);

    var server = http.createServer(function(req, res){
        res.writeHead(200, {&apos;ContentType&apos;: &apos;text/html&apos;});

        var fn = jade.compile(&apos;div #{course}&apos;, {});
        var html = fn({course: &apos;jade&apos;});

        res.end(html);
    })

    server.listen(&apos;8081&apos;, &apos;localhost&apos;)


render()示例

    var http = require(&apos;http&apos;);
    var jade = require(&apos;jade&apos;);

    var server = http.createServer(function(req, res){
        res.writeHead(200, {&apos;ContentType&apos;: &apos;text/html&apos;});
        var html = jade.render(&apos;div #{course} #{name}&apos;, {course: &apos;jade&apos;, name: &apos;siguang&apos;});
        res.end(html);
    })

    server.listen(&apos;8081&apos;, &apos;localhost&apos;)


{pretty:true} 如果不加此属性html会是压缩模式，加上格式化的代码
</code></pre><h4 id="将html编译成jade文件"><a href="#将html编译成jade文件" class="headerlink" title="将html编译成jade文件"></a>将html编译成jade文件</h4><pre><code>安装: sudo npm install html2jade -g

生成命令: html2jade ./public/index.html &gt; index.jade

在node中转换

var html2jade = require(&apos;html2jade&apos;);

html2jade.convertDocument(document, {}, function(err, jade){
    console.log(&apos;反编译后的jade文件&apos;)
})


在线转换: http://html2jade.vida.io/
</code></pre><p>| 参考资料<br>| <a href="http://www.cnblogs.com/fullhouse/archive/2011/07/18/2109945.html" target="_blank" rel="noopener">http://www.cnblogs.com/fullhouse/archive/2011/07/18/2109945.html</a><br>|<br>|</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/Rap的使用和mock数据/">Rap的使用和mock数据</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/Rap的使用和mock数据/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/mock数据/">mock数据</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>/<strong><strong>**</strong></strong> Rap <strong><strong>*</strong></strong>/</p>
<h4 id="Rap"><a href="#Rap" class="headerlink" title="Rap"></a>Rap</h4><pre><code>阿里的产品和mockjs，来模拟真实数据

https://github.com/thx/RAP/wiki/user_manual_cn#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE
</code></pre><h4 id="Rap使用"><a href="#Rap使用" class="headerlink" title="Rap使用"></a>Rap使用</h4><pre><code>一、注册和登录Rap

    http://rapapi.org/

二、分为团队、业务线、项目

    1、查找你所在的团队
</code></pre><p><img src="images/rap1.png" alt="查找你所在的团队"></p>
<pre><code>2、进入你所在的团
</code></pre><p><img src="images/rap2.jpeg" alt="查找你所在的团队"></p>
<pre><code>3、创建业务
</code></pre><p><img src="images/rap3.jpeg" alt="查找你所在的团队"></p>
<pre><code>4、创建模块和使用
</code></pre><p><img src="images/rap4.jpeg" alt="查找你所在的团队"></p>
<pre><code>三、其它技巧

    1、将一个接口的字段下所有字段copy到另一个接口

        选择要copy的字段名，到另一个接口粘贴后在control+Enter，就将所有的内容全部copy过来
</code></pre><p><img src="images/rap5.jpeg" alt="查找你所在的团队"></p>
<pre><code>四、MOCK工具

    1、使用参数的变量
        请求字段
            page   

        响应字段
            pageResponse 字段  @mock=${page}        // 这里最终pageResponse的显示就是Request中page的输入

            或者写默认值   @mock=${page=100}    // 如果请求不写page值默认为100

    2、id自动加1

        变量名     备注
        id|+1     @mock=100        // 表示id从100开始，每次加1

    3、其它写法

        @mock=@DATE

        @mock=true

        @mock=function(){return 100 + Math.random()*100}
</code></pre><p><img src="images/rap6.png" alt="查找你所在的团队"></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/hexo安装使用/">Hexo安装使用</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/hexo安装使用/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/hexo/">hexo</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>一、hexo安装

    $ npm install -g hexo-cli

    $ hexo init

    $ npm install

    $ hexo generate            生成静态文件

    $ hexo server            启动服务器


二、github创建项目

    github创建项目并取到ssh路径

三、配置_config.yml

    根目录打开_config.yml，修改下面内容

    theme: concise            // 接下来安装主题的名称

    deploy:
        type: git
        repo: https://github.com/siguang1983/siguang1983.github.io.git
        branch: master

四、安装主题

    https://hexo.io/themes/            选择一个主题

    安装主题每个主题都会有安装的介绍 

    主题安装会在themes目录下，删除其它主题如果不删除还上传后还会显示之前的主题

    设置主题的样式也在这里
</code></pre><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre><code>$ hexo clean

$ hexo d -g         根据设置的deploy中repo的地址发布到github上

文档放到source/_posts目录下
</code></pre><p>| <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/01/前端算法/">前端算法</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/01/前端算法/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-01T08:54:51.000Z" itemprop="datePublished">2017-07-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/算法/">算法</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><pre><code>一、冒泡法

    前后两个值相比

    function bubble(){
        var arr = [34,5,7,2,4,6,8];
        var len = arr.length;

        for(var i=0; i&lt;len; i++){
            // 这里 j&lt;len-1 也可以，但j&lt;len-1-i的目换是不用在去比较之前的结果 
            for(var j=0; j&lt;len-1-i; j++){   
                if(arr[j] &gt; arr[j+1]){        // 从小向大, 如果从大到小改成 &lt;
                    var temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        return arr;
    }
    console.log(bubble());
</code></pre><p><img src="images/冒泡.gif" alt="冒泡"> </p>
<pre><code>二、选择排序

    用当前的所在的数来与之后所有的数来判断找出最小数插入

    function selectionSort(){
        var arr = [34,5,7,26,8,13];
        var len = arr.length;
        var minIndex, temp;

        for(var i=0; i&lt;len; i++){
            minIndex = i;               // 循环进来后先指向当前第一个要比较的数，下面循环会将比较小最值的下标赋给它

            // 找出之后的最小数
            for(var j=i+1; j&lt;len; j++){
                if(arr[j] &lt; arr[minIndex]){     // 这里控制排序
                    minIndex = j;
                }
            }

            // 将最小数排到当前i的位置
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }

        return arr;
    }
    console.log(selectionSort());
</code></pre><p><img src="images/选择排序.gif" alt="选择排序"> </p>
<pre><code>三、插入排序

    将一个值与之前的值进行比较如果大于当前值就插入在当前位置

    function insertionSort(){
        var arr = [34,5,7,26,8,13];
        var len = arr.length;
        var preIndex, current;

        for(var i=1; i&lt;len; i++){
            preIndex = i-1;
            current = arr[i];   // 存储当前值

            while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current){
                console.log(arr[preIndex], current);
                arr[preIndex+1] = arr[preIndex];        // 将
                preIndex--;
            }

            arr[preIndex+1] = current;
        }

        return arr
    }

    console.log(insertionSort());
</code></pre><p><img src="images/插入排序.gif" alt="插入排序"> </p>
<pre><code>快速排序 
</code></pre><p><img src="images/选择排序.gif" alt="选择排序"><br><img src="images/选择排序.gif" alt="选择排序"> </p>
<p>| <a href="https://wowphp.com/post/komxdx8qe862.html" target="_blank" rel="noopener">https://wowphp.com/post/komxdx8qe862.html</a>      // 排序</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/05/08/前端插件收集/">收集插件和工具</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/05/08/前端插件收集/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-05-08T06:08:21.000Z" itemprop="datePublished">2017-05-08</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/插件/">插件</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong> 前端类 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong>/</p>
<h4 id="JS框架"><a href="#JS框架" class="headerlink" title="JS框架"></a>JS框架</h4><pre><code>1、VueJS        2、AngularJS        3、Rreact    4、React-native         5、Weex

6、jQeruy    

7、underscore: http://www.css88.com/doc/underscore/

8、zepto: http://www.bootcss.com/p/zeptojs/
</code></pre><h4 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h4><pre><code>http://emojipedia.org/    小图片🐻 🍒 🥑 🐝 🤠 🚜 👨🏻 

1、Bootstrap中文网：http://www.bootcss.com/       

2、Bootstrap Table API:  http://bootstrap-table.wenzhixin.net.cn/zh-cn/getting-started/

        http://www.cnblogs.com/gamehiboy/p/5176618.html

3、layUI框架: http://www.layui.com/

    页面中加载layui
    &lt;script src=&quot;lib/layui.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;mian.js&quot;&gt;&lt;/script&gt;

    main.js
    layui.use([&apos;laydate&apos;], function(){         // laydate 调用日期插件

          var laydate = layui.laydate;
          var oD = document.getElementById(&quot;dateInput&quot;);

          var start = {
            elem: oD,
            min: laydate.now(),
            max: &apos;2099-06-16 23:59:59&apos;,
            istoday: false,
            choose: function(datas){
                end.min = datas;     // 开始日选好后，重置结束日的最小日期
                end.start = datas     // 将结束日的初始值设定为开始日
            }
        };

        laydate(start);

    });

阿里移动端框架 mui: http://m.sui.taobao.org/

饿了么vue ui移动框架: http://mint-ui.github.io/#!/zh-cn

饿了么vue PC端框架: http://element.eleme.io/#/zh-CN/resource

京东vue UI框架: https://at-ui.github.io/at-ui/#/zh

iView vue UI框架: https://www.iviewui.com/docs/guide/install

蚂蚁金服React ui框架https://ant.design/

    react native https://github.com/ant-design/ant-design-mobile/blob/master/README.zh-CN.md

                  https://mobile.ant.design/docs/react/introduce

React UI: http://rsuite.github.io/#/?_k=1me3ji

脚手架市场: http://scaffold.ant.design/#/
</code></pre><h4 id="前端插件"><a href="#前端插件" class="headerlink" title="前端插件"></a>前端插件</h4><pre><code>一、日期类

    1、http://momentjs.com/         日期

    2、Bootstrap DataPicker:   http://www.bootcss.com/p/bootstrap-datetimepicker/

    3、laydate:  http://laydate.layui.com/

    4、jquery DateTimePicker:  http://www.jq22.com/jquery-info332


二、socket: https://github.com/sockjs/sockjs-client    

三、文件类

    1、二进制转换库: protobuf.js  bytebuffer.js  long.js

    2、前端将table导出Excel文件  http://www.jianshu.com/p/74d405940305

        js-xlsx: https://github.com/SheetJS/js-xlsx      用来读取和写文件，

            暴露一个XLSX全局对象
                读取数据XLSX.reder()，读取文件XLSX.readerFile()
                写数据 XLSX.write()，写文件XLSX.writeFile()、写流文件XLSX.stream
                utils对象

        fileSaver: https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js

四、工具库

    lodashjs  用于处理数组、对象等一次数据上拆分等问题

        中文: http://lodashjs.com/docs/#_chunkarray-size1

        https://lodash.com/docs/4.17.4


图表类

    EChart图表插件


五、ICON库

    http://www.fontawesome.com.cn/

    http://www.iconfont.cn       阿里的图标收集站  使用http://mux.alimama.com/posts/964

    https://at-ui.github.io/feather-font/


六、移动开发插件

    1、iScroll: http://cubiq.org/iscroll-5   http://www.360doc.com/content/14/0724/11/16276861_396699901.shtml

    2、Swipper: http://www.swiper.com.cn/


七、调试工具

    1、browsersync:   http://www.browsersync.cn/            // 三端连调工具

        http://www.browsersync.cn/docs/command-line/
</code></pre><h4 id="前端模拟数据"><a href="#前端模拟数据" class="headerlink" title="前端模拟数据"></a>前端模拟数据</h4><pre><code>一、mock: http://mockjs.com/       // 生成随机数据，拦截 Ajax 请求

二、Rap: http://rap.taobao.org/org/index.do   // 阿里

    复制一个字段名，然后新建一个字段粘贴，在按ctrl+回车，就会将他下面所有的数据都复制过来，对于层级很复杂的比较好用

三、postMan: 提交get、post请求

四、线上接口数据: http://jsonplaceholder.typicode.com/
</code></pre><h4 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h4><pre><code>一、Confluence 用于团的wiki，和日常工作流程

二、JIRA   产品版本  产品需求 - 技术开发 - 测试

三、Stash  git 仓库

四、在线运行代码

    https://codepen.io/pen/

    https://jsfiddle.net/    

    http://jsbin.com/?html,css,js,output


五、chrome 插件

    EditThisCookie   设置cookie

    PostMan        post请求

    AlloyDesigner 腾讯web页面与设置对比工具

        http://alloyteam.github.io/AlloyDesigner/worddoc.html
        http://www.alloyteam.com/2014/03/alloydesigner-lai-zi-xing-xing-di-web-qian-duan-kai-fa-fang-shi/

        需要在服务环境下使用

        $ 安装插件

        $ 打开页面，启动插件下面会出现工具栏，点击视觉稿按钮选择设计图片
</code></pre><h4 id="移动端的Sass框架"><a href="#移动端的Sass框架" class="headerlink" title="移动端的Sass框架"></a>移动端的Sass框架</h4><pre><code>yo: https://github.com/doyoe/Yo#bugs-and-feature-requests
</code></pre><h4 id="构建工具、模块化开发框架"><a href="#构建工具、模块化开发框架" class="headerlink" title="构建工具、模块化开发框架"></a>构建工具、模块化开发框架</h4><pre><code>构建工具: webpack、gulp、grunt

模块化开发: webpack（即是模块开发又是构建工具）、RequireJS    
</code></pre><p>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong> 服务端 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong>/</p>
<h4 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h4><pre><code>Exporess:  http://www.expressjs.com.cn/

egg阿里nodejs框架:https://eggjs.org/zh-cn/basics/middleware.html
</code></pre><h4 id="NodeJS类"><a href="#NodeJS类" class="headerlink" title="NodeJS类"></a>NodeJS类</h4><pre><code>1、ms返回时间  https://github.com/zeit/ms       // ms用来返回一个时间  ms(&apos;2h&apos;) 返回 7200000  

2、MD5加密crypto    https://github.com/jkiss/crypto-js      npm i crypto-js --save  引用 const MD5 = require(&apos;crypto-js/md5&apos;);

3、文件上传    https://github.com/node-modules/formstream

4、JSON串和对象互转  https://github.com/ljharb/qs      // 可以根据key来进行排序 
</code></pre><h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><pre><code>http://www.sketchcn.com/

omniGraffle
</code></pre><p>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong> 工具类 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong>/</p>
<h4 id="查看chrome的DNS缓存对应表-chrome-net-internals-dns"><a href="#查看chrome的DNS缓存对应表-chrome-net-internals-dns" class="headerlink" title="查看chrome的DNS缓存对应表: chrome://net-internals#dns"></a>查看chrome的DNS缓存对应表: chrome://net-internals#dns</h4><h4 id="emmet快捷方法"><a href="#emmet快捷方法" class="headerlink" title="emmet快捷方法"></a>emmet快捷方法</h4><pre><code>http://www.w3cplus.com/tools/emmet-cheat-sheet.html

http://www.iteye.com/news/27580
</code></pre><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><pre><code>一、webStorm

    1、格式化代码: format   command + option + L

    2、install plugins  安装插件

        webstorm/plugins =&gt; 插入插件名，然后添加


二、atom

    用于开发reactatom-react-autocomplete 组件名及状态的自动补全 

    http://blog.csdn.net/crper/article/details/52196675


三、vs-Code

    安装插件： ext install 插件名

    https://marketplace.visualstudio.com/VSCode

    $ js、html等格式化 - https://prettier.io/

        搜索Prettier -&gt; JavaScript formatter  

        执行 CMD + Shift + P -&gt; Format Document

    $ Vue VSCode Snippets    快速创建vue结构  vbase &lt;- https://github.com/sdras/vue-vscode-snippets

    $ vue-beautify: vue格式化

    $ vetur

    $ vue: 语法高亮 不安装


    $ Babel ES6/ES7

    $ Babelrc

    $ Beautify - 美化格式

    $ Egg.js

    $ eggjs

    $ ES7 React/Redux/React-Native/JS snippets

    $ Guides - 代码中的对齐线

    $ weex

    $ html-snippets：H5 提示

    $ vscode-html-css: 写class可以搜索到所有引用class的值

    $ jquerysnippets: jquery提示

    $ vscode-JS-CSS-HTML-formatter: html/css/js文件格式化 使用方法: ⌘ + P 输入formatter

    $ path-intellisense: 路径自动提示

    $ npm-intellisense: 使用require提示

    $ vscode-eslint: 语法验证

    $ Bootstrap: 

    $ vscode-icons: 编辑器菜单中对应文件前加图标   输入icon 选择 File icon Theme

        vscode-icon-theme: 

    $ ReactSnippets: ReactJS  jsx文件内 输入 rcc 就可以创建一个react组件的初始代码  
            https://marketplace.visualstudio.com/items?itemName=xabikos.ReactSnippets


    $ vscode-node-readme: 可以查看node reuqire中引用的node-module的包内容

    $ auto-close-tag: 可以将文档未闭合标签自动加关闭   输入close tag

    $ cssrem  将值转成rem 

    $ px转rem插件   https://github.com/Maroon1/px2rem 


    $ 主题类

        Atom One Dark Theme

        vsc-material-theme

        Material Theme

        切换主题  ⌘ + shift + p   =&gt;  输入 them 选择颜色主题在列表中在选择

    $ guides: 高亮缩进基准线   ext install guides


    ---------- 快捷键 ---------

    1、⌘ + p 搜索插件

    2、⌘ + shift + p  命令

    3、⌘ + , 打开settings.json配置

    4、^(control) + ` 打开vscode自带的终端

    5、miniMap的配置  在settings.json中加入 &quot;editor.minimap.enabled&quot;: true  配置


    6、|http://www.jianshu.com/p/819fc0f7f3b2  配置

    7、http://www.cnblogs.com/huaxingtianxia/p/5481493.html   快捷键

    8、整行粘贴 sb是⌘+D,   vscode是光标在当前行 ⌘+C, 然后在⌘+V

    9、多行光标

        ALT+鼠标

        ALT+上下方向键

        关键词被选中/高亮后，CTRL+D


四、Sublime Text

    http://blog.csdn.net/u013861109/article/details/53106074


    1、安装package control

        https://packagecontrol.io/

        Control + `（mac） 或 Ctrl+～ （win） 调出console  输入下面命令，查看是否安装成功 Perferences-&gt;package settings中看到package control这一项，则安装成功

        import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())

    2、安装编辑器主题

    按下Ctrl+Shift+P，输入install，选择Package Control: Install Package，然后输入Spacegray，选择Theme: Spacegray.

    在菜单栏中选择Preferences-&gt;Settings-User，复制以下代码，覆盖打开的文件内容，保存即可应用主题：    
        {
            &quot;theme&quot;: &quot;Spacegray.sublime-theme&quot;,
            &quot;color_scheme&quot;: &quot;Packages/Theme - Spacegray/base16-ocean.dark.tmTheme&quot;
        }

    3、设置代码行间距、字号

        需要个性哪个就直接在preferences -&gt; settings user 中的配置添加
        {
            &quot;color_scheme&quot;: &quot;Packages/Theme - Spacegray/base16-ocean.dark.tmTheme&quot;,
            &quot;theme&quot;: &quot;Spacegray.sublime-theme&quot;,
            &quot;font_size&quot;: &quot;16&quot;,
            &quot;line_padding_top&quot;: 2,
            &quot;line_padding_bottom&quot;: 2
        }


    4、安装常用插件

        安装：command + shift + p 输入 ip 回车

        卸载：command + shift + p 输入remove 回车

        1) px转rem插件  https://github.com/flashlizi/cssrem

        1）emmet：html、css快速编写

                如果emmet插件失效：http://www.jianshu.com/p/0862e754cf15

        2）syncedSideBar：侧栏与主界面的颜色相同

        3）babel：ES6、JSX、React

        4）AngularJS

        5）jQuery：jQuery提示

        6）Html5：html5捆

        7）Less：一个Less语法高亮插件

        8）Sass

        9）JsFormat：js 格式化插件

        10）SublimeLinter：行内高亮语法

        11）SideBarEnhancements：一个左边栏增强

        12）SublimeCodeintel：一个代码智能提示引擎

        13）Alignment：Js代码对其插件

        14）BracketHighlighter：代码对其线高亮

        15）Git：git的支持插件

        16）Prefixr：Prefixr Api支持，Prefixr是一个生成css3兼容性的api

        17）LiveReload：网页浏览器页面重新加载插件

        18）Tag：格式化代码排版

                Mac OS X: Command-Option-Shift-F
                Windows: Control-Alt-Shift-F



        19) HTML-CSS-JS Prettify 代码格式化插件 cmd+shift+h

        20）cssrem：sublime的px转rem的插件   https://github.com/flashlizi/cssrem      需要手动下载放到packages中，配置cssrem.sublime文件指定px_to_rem的值 

        21）MarioRicalde-SCSS       SCSS的代码提式和高亮

    react插件   http://www.jianshu.com/p/ecf6c802fdc5?open_source=weibo_search
</code></pre><h4 id="gitBook"><a href="#gitBook" class="headerlink" title="gitBook"></a>gitBook</h4><pre><code>https://segmentfault.com/a/1190000005859901
http://www.chengweiyang.cn/gitbook/introduction/README.html
</code></pre><h4 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h4><pre><code>https://sspai.com/post/25137
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/24/EChart图表插件/">EChart</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/24/EChart图表插件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-24T03:43:51.000Z" itemprop="datePublished">2017-04-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端插件类/">前端插件类</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>1、npm install echarts --save

2、引入echarts的两种方式

    页面直接引入文件: &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;

    webpack: import echarts from &apos;echarts&apos;

3、页面创建DOM的容器

    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;        必须要一个高度值
</code></pre><h4 id="异步数据加载和更新"><a href="#异步数据加载和更新" class="headerlink" title="异步数据加载和更新"></a>异步数据加载和更新</h4><pre><code>1、数据异步

    将数据通过ajax异步取到后，在通过setOption()方式直接加到载插件中


2、loading动画

    showLoading()来显示、hideLoading()隐藏

    Exampole
    var myChart = echarts.init(document.getElementById(&apos;main&apos;));

    myChart.showLoading();
    $.ajax({
        success:function(data){
            myChart.hideLoading();
        }
    })


3、数据的动态更新

    只需要加单个数据，先data.push(vlaue), 在通过setOption()将数据渲染出来

    var data = [];        // 存储数据 

    // 创建图表将data数据加入
    ....

    // 添加数据 
    function addData(){
        data.push(Math.random()*100);
    }

    setInterval(function(){
        addData();
        myChart.setOption({
            数据
        })
    },1000)
</code></pre><h4 id="数据区缩放组件-dataZoom"><a href="#数据区缩放组件-dataZoom" class="headerlink" title="数据区缩放组件 dataZoom"></a>数据区缩放组件 dataZoom</h4><pre><code>option = {
    xAxis: {
        type: &apos;value&apos;
    },
    yAxis: {
        type: &apos;value&apos;
    },

    dataZoom: [
        {   // 这个dataZoom组件，默认控制x轴。
            type: &apos;slider&apos;, // 这个 dataZoom 组件是 slider 型 dataZoom 组件
            start: 10,      // 左边在 10% 的位置。
            end: 60         // 右边在 60% 的位置。
        }
    ],

    series: [
        {
            type: &apos;scatter&apos;, // 这是个『散点图』
            itemStyle: {
                normal: {
                    opacity: 0.8
                }
            },
            symbolSize: function (val) {
                return val[2] * 40;
            },
            data: [[&quot;14.616&quot;,&quot;7.241&quot;,&quot;0.896&quot;],[&quot;3.958&quot;,&quot;5.701&quot;,&quot;0.955&quot;],[&quot;2.768&quot;,&quot;8.971&quot;,&quot;0.669&quot;],[&quot;9.051&quot;,&quot;9.710&quot;,&quot;0.171&quot;],[&quot;14.046&quot;,&quot;4.182&quot;,&quot;0.536&quot;],[&quot;12.295&quot;,&quot;1.429&quot;,&quot;0.962&quot;],[&quot;4.417&quot;,&quot;8.167&quot;,&quot;0.113&quot;],[&quot;0.492&quot;,&quot;4.771&quot;,&quot;0.785&quot;],[&quot;7.632&quot;,&quot;2.605&quot;,&quot;0.645&quot;],[&quot;14.242&quot;,&quot;5.042&quot;,&quot;0.368&quot;]]
        }
    ]
}
</code></pre><h4 id="事件和行为"><a href="#事件和行为" class="headerlink" title="事件和行为"></a>事件和行为</h4><pre><code>Echarts中有两种事件，1、用户的鼠标事件   2、交互组件后触发的行为事件

一、鼠标事件

    鼠标事件: &apos;click&apos;、&apos;dblclick&apos;、&apos;mousedown&apos;、&apos;mousemove&apos;、&apos;mouseup&apos;、&apos;mouseover&apos;、&apos;mouseout&apos;

    myChart.on(&apos;click&apos;, function(params){
        console.log(params.name)
    })


二、交互组件

    myChart.dispatchAction({ type: &apos;&apos; })        // 通过dispatchAction触发

    1、legendselectchanged: 切换图例开关时触发

    2、datazoom: 数据区域缩放触发


二、params 对象

    {
        // 当前点击的图形元素所属的组件名称，
        // 其值如 &apos;series&apos;、&apos;markLine&apos;、&apos;markPoint&apos;、&apos;timeLine&apos; 等。
        componentType: string,

        // 系列类型。值可能为：&apos;line&apos;、&apos;bar&apos;、&apos;pie&apos; 等。当 componentType 为 &apos;series&apos; 时有意义。
        seriesType: string,

        // 系列在传入的 option.series 中的 index。当 componentType 为 &apos;series&apos; 时有意义。
        seriesIndex: number,

        // 系列名称。当 componentType 为 &apos;series&apos; 时有意义。
        seriesName: string,

        // 数据名，类目名
        name: string,

        // 数据在传入的 data 数组中的 index
        dataIndex: number,

        // 传入的原始数据项
        data: Object,

        // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data，
        // dataType 的值会是 &apos;node&apos; 或者 &apos;edge&apos;，表示当前点击在 node 还是 edge 上。
        // 其他大部分图表中只有一种 data，dataType 无意义。
        dataType: string,

        // 传入的数据值
        value: number|Array

        // 数据图形的颜色。当 componentType 为 &apos;series&apos; 时有意义。
        color: string
    }
</code></pre><h4 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h4><pre><code>1、title: 标题（包括主副标题、链接、样式）

2、legend: 标记的区域 （对legend的显隐、宽高、位置、横纵向排列）

3、grid: 图表的网格区域 （是否显示网格、位标、宽高、背景色、边线色）

4、xAxis、yAxis: x、y坐标轴

5、dataZoom: 数据缩放 （）

6、toolTip: 提示信息，鼠标移到数据点浮现的提示信息（）

7、axisPointer:

8、toolBox: 工具栏 （导出图表、数据视图、动态类型切换、缩放、重置）

9、series: 系列列表（来决定图表的类型、图表的数据）

10、color: 图表每一项的颜色

11、background: 图表背景色

12、textStyle: 文本样式

13、animate: 是否开启动画

----- 组件 -------

14、timeline: 时间轴组件

15、graphic: 原生图形元素组件

16、calendar: 日历坐标组件

17、brush: 区域选择组件

18、geo: 地理坐标系组件

19、parallel: 平行坐标系

20、parallelAxis: 这个组件是平行坐标系中的坐标轴

21、singleAxis: 单轴。可以被应用到散点图中展现一维数据
</code></pre><h4 id="series对象"><a href="#series对象" class="headerlink" title="series对象"></a>series对象</h4><pre><code>type: 展示图表的类型

name: 名称

label: 图形上文本标签的控制（show、position、offset、formatter、）

    formatter可以是字符串也可以是函数 

        字符串模板，模板变量有 {a}、{b}、{c}，分别表示系列名，数据名，数据值。

        formatter: &apos;{b}: {c}&apos;

        label:{
            normal:{
                formatter: function(data){            // callback
                    return data.percent + &apos;%&apos;;
                }
            }
        }, 

        params:
        {
            componentType: &apos;series&apos;,
            // 系列类型
            seriesType: string,
            // 系列在传入的 option.series 中的 index
            seriesIndex: number,
            // 系列名称
            seriesName: string,
            // 数据名，类目名
            name: string,
            // 数据在传入的 data 数组中的 index
            dataIndex: number,
            // 传入的原始数据项
            data: Object,
            // 传入的数据值
            value: number|Array,
            // 数据图形的颜色
            color: string,

            // 百分比
            percent: number,

        }

labelLine: 图形上图形与文本之间连接线的控制

data: 数据

center: 饼图中心坐标

radius: 半径
</code></pre><blockquote>
<p>参考资料<br><a href="http://echarts.baidu.com/echarts2/doc/doc.html#Title" target="_blank" rel="noopener">http://echarts.baidu.com/echarts2/doc/doc.html#Title</a><br><a href="http://echarts.baidu.com/gallery/editor.html" target="_blank" rel="noopener">http://echarts.baidu.com/gallery/editor.html</a>   在线编辑</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/06/服务器端概念/">大型网站架构</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/06/服务器端概念/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-06T10:18:51.000Z" itemprop="datePublished">2017-04-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/服务端开发/">服务端开发</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="cookie、session、token"><a href="#cookie、session、token" class="headerlink" title="cookie、session、token"></a>cookie、session、token</h4><pre><code>一、Session

    是另一种记录客户端状态的机制，cookie保存客户端，session存储在服务器上

    登录成功 =&gt; 服务器存储Session =&gt; 并在客户端的cookie中也存储一个 =&gt; 之后客户端请求，服务端取到cookie的Session的值，在与服务器保存的来进行比较是否存在（这个过程是session内部的机制，程序只需要判断就行）

二、cookie

    存储在客户端本地，js和服务器都可以存、取、删cookie的值，cookie组成（key、value、domain、域、失效时间）

三、token

    token的意思是令牌，用户身份验证，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串

    作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态

http://blog.csdn.net/qq_33401924/article/details/52947514
http://blog.csdn.net/jikeehuang/article/details/51488020
</code></pre><h4 id="验证码的流程"><a href="#验证码的流程" class="headerlink" title="验证码的流程"></a>验证码的流程</h4><pre><code>通过插件来生成图型 =&gt; 并将图片结果存到session中，并存到用户的cookie中 =&gt; 登录时来判断session中的值与用户请求参数的值是否相同

https://github.com/lemonce/svg-captcha/blob/master/README_CN.md

// 生成验证码
async captcha() {
    const svgCaptcha = require(&apos;svg-captcha&apos;);
    const { ctx } = this;
    const captcha = svgCaptcha.createMathExpr({
        size: 4,                 // 验证码长度
        ignoreChars: &apos;0o1i&apos;,     // 验证码字符中排除 0o1i
        noise: 3,                 // 干扰线条的数量
        color: true,             // 验证码的字符是否有颜色，默认没有，如果设定了背景，则默认有
        background: &apos;rgba(0,0,0,0.3)&apos;, // 验证码图片背景颜色
    });
    ctx.session.captcha = captcha.text;
    ctx.type = &apos;image/svg+xml&apos;;        // 设置header的content-type
    ctx.body = captcha.data;
}

// 用户登录
async login() {
    const { ctx, app, service } = this;

    if (ctx.session.captcha &amp;&amp; ctx.session.captcha !== ctx.request.body.captcha) {
    this.success({
        data: {},
        message: &apos;验证码错误&apos;,
        statusType: app.statusType.otherError,
    });
    return;
    }

    if (
    app.validateParams({
        userName: { type: &apos;string&apos;, max: 100, min: 2 },
        pwd: { type: &apos;string&apos;, min: 1 },
    }, ctx)
    ) {

    const data = await service.auth.login(ctx.request.body);
    this.success(data);
    }
}
</code></pre><h4 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h4><pre><code>https://segmentfault.com/a/1190000003801450
</code></pre><h4 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h4><pre><code>session或token

密码加盐 MD5（username + password + salt）
</code></pre><p>———————– 概念 ———————– </p>
<h4 id="服务器、虚拟机"><a href="#服务器、虚拟机" class="headerlink" title="服务器、虚拟机"></a>服务器、虚拟机</h4><pre><code>服务器: 只是一个硬件虚拟服务只是系统部分

虚拟机: 允许一台HTTP服务器搭建多个web建点，也就是一台服务器可以为多个用户服务，每个用户通过域名运行各自的网站，这就是利用了虚拟机（又称虚拟服务器）的功能
</code></pre><h4 id="前后分离"><a href="#前后分离" class="headerlink" title="前后分离"></a>前后分离</h4><pre><code>前后端数据分离登录失效判断可以通过session服务端来判断 =&gt; 跳转会员管理每个页面 =&gt; 服务器端判断session是否失效 =&gt; 失效跳到登录

其它页面的登录信息可以前端可以通过cookie来获取
</code></pre><h4 id="正向代理、反向代理-Proxy"><a href="#正向代理、反向代理-Proxy" class="headerlink" title="正向代理、反向代理 Proxy"></a>正向代理、反向代理 Proxy</h4><pre><code>一、正向代理: 比如翻墙，直接访问国外网站访问不了，需要可以一个服务器来进行访问。正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。
</code></pre><p><img src="/images/105641260.jpg" alt="正向代理"> </p>
<pre><code>二、反向代理: 代理理服务器来接受网络的连接请求，然后将请求转发给内部网络的服务器 （服务方的需求，为了解决一些负载等问题）

    作用: 保证内网的安全，负载均衡
</code></pre><p><img src="/images/110207878.jpg" alt="反向代理"><br><img src="/images/305504-20161112125907030-1432469707.png" alt="反向代理"></p>
<pre><code>http://www.cnblogs.com/Anker/p/6056540.html
</code></pre><h4 id="CDN和反向代理"><a href="#CDN和反向代理" class="headerlink" title="CDN和反向代理"></a>CDN和反向代理</h4><pre><code>CDN: 部署在网络提供的机房，用户请求时可以从最近的网络提供商机房获取数据
</code></pre><h4 id="负载的均衡"><a href="#负载的均衡" class="headerlink" title="负载的均衡"></a>负载的均衡</h4><pre><code>通过反向代理服务器来优化网站的负载
</code></pre><p><img src="/images/305504-20161112124423530-566240666.png" alt="负载的均衡"></p>
<h4 id="集群、分布式"><a href="#集群、分布式" class="headerlink" title="集群、分布式"></a>集群、分布式</h4><h4 id="跳板机"><a href="#跳板机" class="headerlink" title="跳板机"></a>跳板机</h4><pre><code>跳板机是开发者登录到网站分配给应用服务器的唯一途径。开发者必须首先登录跳板机，再通过跳板机登录到应用服务器

k踏板机属于内控堡垒机范围，用于单点登录的主机，之前是为了运维人员远程登录进行管理，会在机房部署跳板机，踏板机就是一台服务器，维护人员在维护过程先要统一登录在这台服务器上在登录到目录服务器进行维护
</code></pre><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><pre><code>网站缓存有两种：缓存在应用服务器上（本地缓存）和缓存在专门的分布式缓存服务器上（远端缓存）
</code></pre><h4 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h4><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><pre><code>1、通过设置服务器对header设置一个Access-Control-Allow-Origin: *, 开启跨域请求。在被请求的Response header中加入

    // 指定允许其他域名访问  
    header(&apos;Access-Control-Allow-Origin:*&apos;);
    // 响应类型  
    header(&apos;Access-Control-Allow-Methods:POST&apos;);
    // 响应头设置  
    header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);  

2、CORS优点: 跨域最常用的是JSONP但这种方式是通过Get的方式请求src完成的，很多跨域问题JSONP无法解决，比如: 

    1) post请求跨域

    2) &quot;script error&quot; 的脚本错误提示

    3) canvas中无法获取跨域图片的信息，如果使用CORS上面几个问题就可以解决
</code></pre><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><pre><code>一、XSS 攻击: 对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作

二、CSRF 攻击: 伪造用户请求向网站发起恶意请求

三、钓鱼攻击: 利用网站的跳转链接或者图片制造钓鱼陷阱
</code></pre><p>———————– 网络 ———————– </p>
<h4 id="网关、隧道"><a href="#网关、隧道" class="headerlink" title="网关、隧道"></a>网关、隧道</h4><pre><code>网关: 转发其它服务器通信数据的服务器，接收从客户端发送来的

隧道: 将客户端和服务器之间进行中转，并保持双方通信连接的应用程序
</code></pre><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><pre><code>域名系统（英文：Domain Name System，缩写：DNS）是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS 使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。

http://www.alloyteam.com/2015/05/dns%EF%BC%8Cnode%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E5%92%8C%E5%BA%94%E7%94%A8/
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/04/06/Nginx服务器/">Nginx</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/04/06/Nginx服务器/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-04-06T10:18:51.000Z" itemprop="datePublished">2017-04-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/服务器/">服务器</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h4><pre><code>服务器分类: Nginx、Apache、tomcat、Micorsoft Server

ng是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器，超越Apache的高性能和稳定性.
</code></pre><h4 id="四层和七层负载均衡"><a href="#四层和七层负载均衡" class="headerlink" title="四层和七层负载均衡"></a>四层和七层负载均衡</h4><pre><code>负载均衡设备也被称为&quot;四到七层交换机&quot;，四层就是基于IP+端口的负载均衡，七层就是基于URL等应用信息的负载均衡.

如果只做HTTP的负载均衡，用haproxy好了。性能很强。

七层负载均衡优点:

    1、高并发连接: 支撑5万并发连接

    2、内存消耗少: 在3万并发连接，开启10个Nginx进程消耗150M内存

    3、配置文件简单

    4、节省带宽: 支持GZIP压缩，可以添加浏览器本地缓存的Header头，

    5、稳定性高: 用于反向代理, 宕机概率小

    9、支持热部署: 不间断服务进行更新
</code></pre><h4 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h4><pre><code>一、七层负载均衡优势:

    1、对HTTP报头检查，可以检出状态码为400、500、600的错误信息，如果有错误将连接请求重新定向到另一台服务器

    2、可以根据数据类型（判断数据包是图像、压缩文件、或多媒体文件等），将数据引向内容服务器

    3、根据请求类型，将普通文本、图象等静态文档，或是动态文档请求，引向相应的服务器来处理


二、Nginx负载均衡是基于内容和应用的七层资的，Nginx抗并发强，是因为Nginx使用了非阻塞、异步传输

三、模块

    1、nginx负载均衡模块

        配置负载均衡是ngx_http_upstream_module，这模块是默认安装

    2、代理模块

        Proxy为nginx的代理模块, 允许将用户的HTTP请求转发到后端服务器

四、反向代理 

    反向代理是指以代理服务器接受internet上的连接请求，将请求转发给内部服务器，并将从服务器得到结果返回给internet的客户端
</code></pre><h4 id="Nginx负载均衡调试策略"><a href="#Nginx负载均衡调试策略" class="headerlink" title="Nginx负载均衡调试策略"></a>Nginx负载均衡调试策略</h4><pre><code>ng的upstream目前支付几种分配:

1、轮询: 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务down掉，能自动剔除

2、weight: 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况

    upstream bakend { 
        server 192.168.0.14 weight=10; 
        server 192.168.0.15 weight=10; 
    }

3、ip_hash: 每个请求按访问ip的hash结果分配，每个访客访问一个固定的后端服务器

    upstream bakend { 
        ip_hash; 
            server 192.168.0.14:88; 
            server 192.168.0.15:80; 
        }
    }

4、fair（第三方）

5、url_hash（第三方）

    upstream backend { 
        server squid1:3128; 
        server squid2:3128; 
        hash $request_uri; 
        hash_method crc32; 
    }
</code></pre><h4 id="Nginx安装和删除"><a href="#Nginx安装和删除" class="headerlink" title="Nginx安装和删除"></a>Nginx安装和删除</h4><pre><code>主要步骤: 下载包，压缩、配置编译

$ https://nginx.org/en/download.html    下载一个nginx包版本

$ cd /usr/local/ &amp;&amp; mkdir newNginx     // 进入到local目录并创建一个newNginx目录

$ 将下载的包copy到新创建的newNginx目录, 并将包解压到当前目录   tar zxf nginx-1.12.2.tar.gz 

$ cd nginx-1.12.2

$ ./configure        // 验证过程

$ make

$ make install         // 这时候会创建一个nginx目录 /usr/local/nginx

$ 将newNginx目录的文件copy到nginx目录


1、开启服务     /usr/local/nginx/sbin/nginx/    

2、重启  /usr/local/nginx/sbin/nginx/ -s reload

3、快速关机     /usr/local/nginx/sbin/nginx/ -s stop

4、正常关机     /usr/local/nginx/sbin/nginx/ -s quit

5、ps -ef|grep nginx     // 查看ng进程

6、kill -9 xxxx            // 杀进程

7、nginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or directory)

    nginx.pid文件只有在启动的时候才会存，未启动执行reload会出现上面的提示

8、logs日志  /usr/local/nginx/logs

    access.log和error.log
</code></pre><h4 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h4><pre><code>默认该配置文件被命名nginx.conf

    配置server

    server {
        listen       9092;                                // 端口
        root /Users/apple/siguang.liu/Hh/hh_h5;            // 指定根目录

        location / {
            proxy_pass  http://174.16.1.82:8080/;        // 代理到的服务器
        }

        error_page   500 502 503 504  /50x.html;        // 错误
        location = /50x.html {
            root   html;
        }

        location ^~ /api {
            proxy_pass  http://172.16.1.82:8080/;        // 如果访问以&quot;/api&quot;开头的代理的服务器
        }

        location ~ \.(gif|jpg|png|js|css|html|map)$ {    // 指定静态资源
            root /Users/apple/siguang.liu/Hh/hh_h5;
        }
    }

    可以通过include来将另一个文件的内容引用

    include servers/*.conf;


一、所存在的目录 /usr/local/nginx/conf            // 本机mac /usr/local/openresty/nginx

二、启动  sudo /usr/local/openresty/nginx/sbin/nginx      // 需要sudo管理员权限

三、启动后的可以通过调用带-s参数来执行文件来控制 

    $ nginx -s 命令

    1、reload - 重启  sudo /usr/local/openresty/nginx/sbin/nginx -s reload

    2、stop - 快速关机 sudo /usr/local/openresty/nginx/sbin/nginx -s stop

    3、quit - 优雅关机 sudo /usr/local/openresty/nginx/sbin/nginx -s quit

    4、reopen - 重新打开日志文件 sudo /usr/local/openresty/nginx/sbin/nginx -s reopen

四、查看、杀掉进程

    $ ps -ex | grep nginx

    $ kill -s quit 1682

五、配置文件结构

    指令分为简单指令和块指令，以空格分隔，以分号(;)结束

四、注释使用 #

    # HTTPS server
    #
    # server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;
    # }
</code></pre><h4 id="Nginx配置-HTTP2-0"><a href="#Nginx配置-HTTP2-0" class="headerlink" title="Nginx配置 HTTP2.0"></a>Nginx配置 HTTP2.0</h4><pre><code>https://www.nginx.com/blog/nginx-1-9-5/
</code></pre><p>| <a href="http://www.cnblogs.com/felixzh/category/937300.html" target="_blank" rel="noopener">http://www.cnblogs.com/felixzh/category/937300.html</a><br>| <a href="https://www.cnblogs.com/felixzh/p/6283788.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/6283788.html</a><br>| <a href="https://www.cnblogs.com/taiyonghai/p/6728707.html" target="_blank" rel="noopener">https://www.cnblogs.com/taiyonghai/p/6728707.html</a></p>

        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
