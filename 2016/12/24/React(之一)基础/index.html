<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>React（之一）基础 | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="| 创建组件| render| props、propType、state、setState()、replaceState()| 获取DOM this.refs.xxx 或 ReactDOM.findDOMNode(this.refs.xxx)| React.Children 获取父组件传的DOM| mixin
React安装react-cli 见的README.md

React包括几个概念: 1、组件       2、JSX     3、虚拟DOM     4、单向数据绑定

1、核心是封装组" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大前端/">大前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#React"><span class="toc-number">1.</span> <span class="toc-text">React</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react引用方式"><span class="toc-number">2.</span> <span class="toc-text">react引用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生命周期"><span class="toc-number">3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSX语法"><span class="toc-number">4.</span> <span class="toc-text">JSX语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class和style样式加载"><span class="toc-number">5.</span> <span class="toc-text">class和style样式加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语法"><span class="toc-number">6.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件"><span class="toc-number">7.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件嵌套"><span class="toc-number">8.</span> <span class="toc-text">组件嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件间通信"><span class="toc-number">9.</span> <span class="toc-text">组件间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context对象"><span class="toc-number">10.</span> <span class="toc-text">Context对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据流"><span class="toc-number">11.</span> <span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#props"><span class="toc-number">12.</span> <span class="toc-text">props</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state"><span class="toc-number">13.</span> <span class="toc-text">state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作真实DOM"><span class="toc-number">14.</span> <span class="toc-text">操作真实DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React表单组件操作"><span class="toc-number">15.</span> <span class="toc-text">React表单组件操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mixin"><span class="toc-number">16.</span> <span class="toc-text">mixin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">17.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表单"><span class="toc-number">18.</span> <span class="toc-text">表单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React脚手架搭建"><span class="toc-number">19.</span> <span class="toc-text">React脚手架搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Diff算法"><span class="toc-number">20.</span> <span class="toc-text">Diff算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用插件"><span class="toc-number">21.</span> <span class="toc-text">常用插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#积累问题"><span class="toc-number">22.</span> <span class="toc-text">积累问题</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            React（之一）基础
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之一)基础/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 创建组件<br>| render<br>| props、propType、state、setState()、replaceState()<br>| 获取DOM this.refs.xxx 或 ReactDOM.findDOMNode(this.refs.xxx)<br>| React.Children 获取父组件传的DOM<br>| mixin</p>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><pre><code>安装react-cli 见的README.md

React包括几个概念: 1、组件       2、JSX     3、虚拟DOM     4、单向数据绑定

1、核心是封装组件，只关注UI，状态变更重新渲染整个组件

2、JSX: HTML代码可以直接嵌到JS代码中，这就是React提出的叫JSX的语法，原来前端以表现和逻辑层分离为主，但HTML是组件的一部分所以不能分割，JSX 将动态值放到 { ... }

3、单向数据绑定: 当数据更新会渲染整个app

    修改DOM树、修改数据、以旧换新用户输入、异步API数据

    React的渲染方式: 用户输入、从API获取数据、将数据传给顶层组件、React将每个组件渲染出来

        不会象MVC一样的双向数据绑定、和数据模型的脏值检测、不会有确切的DOM操作

4、虚拟DOM树: React重建一个DOM树，找到与上一个版本的DOM的差异，计算出新的DOM更新操作，从操作队列中指执行DOM更新操作

    http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/      // 前沿技术解密——VirtualDOM

5、工具: sublime或Atom

    sublime插件安装: 

    ReactJS  https://packagecontrol.io/packages/ReactJS   用来提示编码还有快捷键

    babel-sublime: https://github.com/babel/babel-sublime   用来语法颜色

    javascriptNext: https://github.com/Benvie/JavaScriptNext.tmLanguage 
</code></pre><h4 id="react引用方式"><a href="#react引用方式" class="headerlink" title="react引用方式"></a>react引用方式</h4><pre><code>一、页面直接加载

    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;

二、ES5的写法

    var React = require(&apos;react&apos;);
    var ReactDOM = require(&apos;react-dom&apos;);

    // 定义组件
    var HelloMessage = React.createClass({
      render: function() {
        return &lt;div&gt; React，我们来了... &lt;/div&gt;;
      }
    });

    // 组件渲染
    ReactDOM.render(&lt;HelloMessage /&gt;, rootElement);

三、ES6的写法

    import React, { Component } from &apos;react&apos;;
    import { render } from &apos;react-dom&apos;;

    // 定义组件
    class SimpleComponent extends Component {
        render(){
            return &lt;div&gt; React，我们来了... &lt;/div&gt;;
        }
    }
    export default SimpleComponent;

    // 组件渲染
    render(&lt;HelloMessage /&gt;, rootElement);
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>一、组件的生命周期三个过程

    1、装载过程(Mount), 把组件第一次在DOM树中渲染的过程

    2、更新过程(Update), 当组件被重新渲染的过程

    3、卸载过程(Unmount), 组件从DOM中删除的过程


二、装载过程

    1、constructor - ES6每个类的构造函数，创建一个组件就会先调用对应的构造函数

    2、getInitialState() - 初始化this.state，【因内受】(ES6不起作用)

    3、getDefaultProps - 设置默认的props (ES6不起作用)

    4、componentWillMount() - 组件挂载前（调用render方法之前），没有任何渲染，就算调用了this.setState()也不会引发绘制

    5、render() - 创建虚拟dom，进行diff算法，更新dom树，如果不需要渲染可以将render函数返回一个null或false

    6、componentDidMount() - 组件渲染后，可以使用refs操作获取或操作DOM节点


三、更新过程(当props或state被修改时就会引发组件的更新过程)

    1、componentWillReceiveProps(nextProps) - 当父组件改变了传递给子组件props的值，这时候子组件此方法会被调用 receive[rɪˈsiv]

    2、shouldComponentUpdata(nextProps, nextState) - react性能环节，父组件传给子组件的props值改变，子组件中的shouldComponentUpdata()方法会先调用，前后两个props相同返回false阻止更新，不需要在创建新的dom树在进行diff算法，默认为true

        shouldComponentUpdate(nextProps, nextState){
            return nextProps.name === nextState.name        // 如果返回false就算父组件传递的props值改变，也不会执行render
        }

    3、componentWillUpdata(nextProps, nextState) - shouldComponentUpdata为true时调用

    4、render() - 

    5、componentDidUpdate() - shouldComponentUpdata为true时调用


四、卸载组件

    1、componentWillUnmount() - 卸载前调用

https://www.jianshu.com/p/4784216b8194
</code></pre><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><pre><code>var HelloMessage = React.createClass({
    render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
    }
});
React.render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode);

如果不使用JSX，就需要使用createElement()来创建元素

render: function() {
    return React.createElement(&quot;div&quot;, null, &quot;Hello &quot;, this.props.name);
}

一、注释

    {/* 一般注释, 用 {} 包围 */}

    /* 多
     行
     注释 */


二、根元素只能有一个

     class ComponentDemo extends Component {
        render(){
            // 以下写法直接报错
            return (
                &lt;div&gt;
                hello
                &lt;/div&gt;
                &lt;h1&gt; hello h1 &lt;/h1&gt;
            );
        }
    }


三、属性名不能和 js 关键字冲突

    class =&gt; className

    read =&gt; readOnly

    for =&gt; htmlfor


四、JSX spread

    { ...spreadObj } 可以直接将spreadObj的对象传递过去

    Spread Demo组件:

        class SpreadDemo extends Component{
            render(){
                return &lt;div&gt;姓名: {this.props.name}  车型: {this.props.carType}&lt;/div&gt;
            }
        }
        export default SpreadDemo;

    main.js:

        import SpreadDemo from &apos;./components/spread&apos;;
        const spreadObj = {
            name: &apos;siguang&apos;,
            carType: &apos;卡宴&apos;
        }
        // render(&lt;SpreadDemo name={spreadObj.name} carType={spreadObj.carType} /&gt;, document.querySelector(&apos;#app&apos;));
        render(&lt;SpreadDemo {...spreadObj} /&gt;, document.querySelector(&apos;#app&apos;));


五、输出html

    const elements = &apos;&lt;p&gt;aaa&lt;/p&gt;&lt;p&gt;bbb&lt;/p&gt;&lt;p&gt;ccc&lt;/p&gt;&apos;;
    &lt;p dangerouslySetInnerHTML={{__html: elements.join('')}}&gt;&lt;/p&gt;
</code></pre><h4 id="class和style样式加载"><a href="#class和style样式加载" class="headerlink" title="class和style样式加载"></a>class和style样式加载</h4><pre><code>一、class

    admin.css:
        .container {.....}

    方法一:
        import &apos;./admin.css&apos;
        render() {
            return (
                &lt;div className=&quot;container&quot;&gt;            // 注意这里的值为字符串而不是{}
                    &lt;div className=&quot;sild&quot;&gt;xxxx&lt;/div&gt;
                &lt;/div&gt;
            );
        }

    方法二:
        import styles from &apos;./admin.css&apos;
        render() {
            return (
                &lt;div className={styles.container}&gt;
                    &lt;div className={style.sild}&gt;xxxx&lt;/div&gt;
                &lt;/div&gt;
            );
        }


二、style 行内样式

    方法一:
        const container = {
            display: flex;
            height: 100%;
        }

        render() {
            return (
                &lt;div style={container}&gt;
                    xxxx
                &lt;/div&gt;
            );
        }

    方法二:
        render() {
            return (
                &lt;div style={{dipslay: flex, height: 100%}}&gt;
                    xxxx
                &lt;/div&gt;
            );
        }
</code></pre><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>一、htmlFrom 不能直接使用for

    &lt;div htmlFor=&apos;male&apos;&gt;Male&lt;/div&gt;
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>创建组件: ES5写法React.createClass() 或 ES6写法React.Component()

渲染组件: ReactDOM.render(&lt;组件名/&gt;, 放到哪个位置, 渲染完成的回调);

一、组件创建三种方法

    1、ES5 创建组件

        let React = require(&apos;react&apos;);
        let ReactDOM = require(&apos;react-dom&apos;);

        let Message = React.createClass({
            render: function(){
                return (
                    &lt;div&gt;
                        &lt;ul&gt;
                            &lt;li&gt;Hello World {this.props.personName}&lt;/li&gt;
                        &lt;/ul&gt;
                    &lt;/div&gt;
                )
            }
        })

        module.exports = Message;        // ES5导出组件

        // ReactDOM.render(
        //        &lt;Message personName=&quot;siguang&quot; /&gt;
        //         , document.querySelector(&apos;#app&apos;)
        // );


    2、ES6 创建组件方法

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;

        // 所有创建的组件都继承于Component对象
        class ShowMessage extends Component{
            constructor(props){
                super(props);
            }
            render(){
                return &lt;div&gt;Hello name {this.props.name}&lt;/div&gt;
            }
        }

        export default ShowMessage;        // ES6导出组件
        // render(&lt;ShowMessage name=&quot;siguang.liu&quot; /&gt;, document.querySelector(&apos;#app&apos;));


    3、函数式组件

        是组件没有状态的时候（相当不需要设置state, 不能使用this、可以写成函数式

        const ShowMessage = () =&gt; &lt;div&gt;Hello name haha&lt;/div&gt;
        render(&lt;ShowMessage /&gt;, document.querySelector(&apos;#app&apos;));

        可以使用props
        const ShowMessage = function(props){
            return &lt;div&gt;Hello name {props.name}&lt;/div&gt;
        }


二、组件的注意地方

    1、组件名首字母必须大写

    2、根元素只能有一个标签元素

        class ComponentDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;boxA&quot;&gt;            {/* 根元素只能有一个 */}
                        aaaaaaaa

                        &lt;div class=&quot;boxB&quot;&gt;
                            bbbbbb
                        &lt;/div&gt;
                    &lt;/div&gt;
                )
            }
        }
        export default ComponentDemo;

    3、可以使用es6的 spread 变量传递 {...obj}

        let person = &lt;Person name={window.isLoggedIn ? window.name : &apos;&apos;} /&gt;

    4、refs属性获取真实的DOM节点

        组件并不是真实的DOM节点，而是在内存中的一种数据结构叫虚拟DOM，如果要从组件内获取真实的DOM节点，需要用到refs属性
</code></pre><h4 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h4><pre><code>childList.jsx:

    import React, { Component } from &apos;react&apos;
    import ReactDom, { render } from &apos;react-dom&apos;

    class ChildrenA extends Component{
        constructor(props){
            super(props);
        }
        render(){
            return (&lt;div&gt;
                {/* 这里是子组件A   this.props.children获取组件的内容，相当前于vue中的solt */}
                {
                    React.Children.map(this.props.children, function(c){        // React.Children是获取组件中的元素
                        return &lt;p&gt;{c}&lt;/p&gt;
                    })
                }
            &lt;/div&gt;)
        }
    }

    class ParentComponent extends Component{
        render(){
            return &lt;div&gt;
                &lt;ChildrenA&gt;
                    &lt;p&gt;福特&lt;/p&gt;
                    &lt;p&gt;丰田&lt;/p&gt;
                    &lt;p&gt;本田&lt;/p&gt;
                &lt;/ChildrenA&gt;
            &lt;/div&gt;
        }
    }
    export default ParentComponent;

index.js:

    import React, { Component } from &apos;react&apos;
    import ReactDom, { render } from &apos;react-dom&apos;
    import ParentComponent from &apos;./components/ParentComponent&apos;

    render(&lt;ParentComponent /&gt;, docuemnt.querySelector(&apos;#box&apos;));
</code></pre><h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><pre><code>一、组件之间有几个通信有几种情况:

    1、父组件向子组件通信

    2、子组件向父组件通信

    3、跨级组件之间通信

    4、非嵌套组件间通信


二、父向子通信 通过props

    parent.jsx
        &lt;child message={this.state.sayMessage} /&gt;

    child.jsx
        {this.props.message}        // 接收


三、子向父通信

    parent.jsx
        getMessage(msg){
            this.setDate({message: msg})
        }
        &lt;child getMessage={this.getMessage.bind(this)} /&gt;

    child.jsx
        this.props.getMessage(&apos;这里告诉父组件消息&apos;)


四、跨级组件

    父组件向很深的几层子组件通信有两种方法: 1、props一层一层传   2、使用context对象


五、非嵌套组件通信

    使用事件订阅，下载events插件

    $ npm i events --save

    1、创建一个ev.js

        import { EventEmitter } from &apos;events&apos;
        export default new EventEmitter();

    2、brotherA.jsx

        // 在组件装载完成以后
        componentDidMount(){
            // 声明一个自定义事件        
            this.eventEmitter = emitter.addListener(&quot;callMe&quot;, (msg)=&gt;{
                this.setState({
                    msg
                })
            });
        }

        // 组件销毁前移除事件监听
        componentWillUnmount(){
            emitter.removeListener(this.eventEmitter);
        }

        render(){
            return (
                &lt;div&gt;
                    {this.state.message}
                &lt;/div&gt;
            )
        }

    3、brotherB.jsx

        sendBrotherMessage(){
            return emitter.emit(&quot;callMe&quot;, &quot;Hello&quot;);     // callMe为自定义函数，hello为发的消息参数
        }
        &lt;input type=&quot;button&quot; value=&quot;向A子组件发消息&quot; onClick={this.sendBrotherMessage.bind(this)} /&gt;
</code></pre><h4 id="Context对象"><a href="#Context对象" class="headerlink" title="Context对象"></a>Context对象</h4><pre><code>如果一个顶层组件想将数据传给多层的组件，不需要一层一层的往下传，使用Context对象

组件和所有子组件都有一个共同的this.context
</code></pre><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><pre><code>React是单向数据流，数据从父组件传到子组件，子组件通过props获取数据，顶层组件改变了props，React会遍历整个组件树，重新渲染整个组件

数据流包括: Props 和 State
</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>从最顶层逐级向下传递，从父组件将数据传到子组件，单向数据流

{this.props.name} 读取props的值

一、props API:

    this.props.children - 所有子组件

    this.props.map

    this.props.filter 


二、设置一个默认的props

    ES5写法

        var ComponentWithDefaultProps = React.createClass({
            // 初始化设置props值
            getDefaultProps: function() {
                return {
                    value: &apos;default value&apos;
                };
            }
        });

    ES6写法 

        /* 通过 defaultProps 来定义 */
        class PropsDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}
                    &lt;/div&gt;
                )
            }
        }

        PropsDemo.defaultProps = {
            name: &apos;123123&apos;        // 默认一个name值，如果父组件没有传值就会取默认值
        }


三、propsType 校验props规则

    $ npm install --save prop-types

    import React, { Component, PropTypes } from &apos;react&apos;;

    class PropTypesDemo extends Component {
        render(){
            return &lt;b&gt;{this.props.title}&lt;/b&gt;
        }
    }

    // 静态属性定义propTypes, title只能为string
    PropTypesDemo.propTypes = {
        title: React.PropTypes.string.isRequired
    }

    export default PropTypesDemo;


四、Example

    PropsComponent组件:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;

        class PropsComponent extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}         {/* 这里接收props值 */}
                    &lt;/div&gt;
                )
            }
        }

        // 输出组件接口
        export default PropsComponent;

    index.js:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;
        import PropsComponent from &apos;../components/props&apos;;

        // 要传的值
        let obj = {
            name: &apos;haha&apos;,
            age: &apos;300&apos;
        }

        // 方法1、直接传给属性
        render(&lt;PropsComponent name={obj.name} age={obj.age} /&gt;, document.querySelector(&apos;body&apos;));

        // ...obj 来对多值进行解析赋值
        render(&lt;PropsComponent {...obj} /&gt;, document.querySelector(&apos;body&apos;));


五、this.props.children 访问自定义子节点

    // 将组件下的所有子节点通过map获取到，并重新包装
    import React, { Component } from &apos;react&apos;;

    class UseChildren extends Component {
        render(){
            return  &lt;ul&gt;
                {
                    // 会将UseChildren组件下所有的元素取出
                    React.Children.map(this.props.children, function(c){
                        return &lt;li&gt; {c} &lt;/li&gt;
                    })
                }
            &lt;/ul&gt;
        }
    }

    class ChildrenDemo extends Component {
        render(){
            return (
                &lt;UseChildren&gt;
                    &lt;a href=&quot;#&quot;&gt;Facebook&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Google&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Space&lt;/a&gt;
                &lt;/UseChildren&gt;
            )
        }
    }
    export default ChildrenDemo;


六、this.props.content 可以传任意结构的JSX结构

    // 父组件通过content传值
    &lt;ContentChildrenComponent content={
        &lt;div&gt;
            &lt;h2&gt;React.js 小书&lt;/h2&gt;
            &lt;div&gt;开源、免费、专业、简单&lt;/div&gt;
            订阅：&lt;input /&gt;
        &lt;/div&gt;
    } /&gt;

    // 子组件调用
    render() {
        return (
            &lt;div&gt;
                { this.props.content }
            &lt;/div&gt;
        );
    }


七、组件传值

    &lt;ChildComponent propsData={this.state.username} /&gt;

    &lt;LikeButton wordings={{likedText: '已赞', unlikedText: '赞'}} onClick={() =&gt; console.log(&apos;Click on like button!&apos;)}/&gt;
</code></pre><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><pre><code>每一个React组件都有一个自己的state对象，与props区别在于，state只能在当前组件内部使用

一、初始化state

    ES5: getInitialState() 

        var Component = React.createClass({
            // getInitialState()方法 初始化 state值
            getInitialState: function() {
                return { userName: &apos;siguang&apos; };
            },

            render: function(){
                return (
                    &lt;div&gt; {this.state.userName} &lt;/div&gt;
                )
            }
        }

    ES6: constructor()

        class StateDemo extends Component {
            constructor(){
                super();            // 继承Component

                // 这里初始化state
                this.state = { 
                    userName: &apos;siguang&apos; 
                }
            }

            render(){
                return (
                    &lt;div&gt; {this.state.username}
                )
            }
        }


二、setState({改变的值}, 回调函数)来设置state的值, RN中是异步所以这块需要注意

    // 改变已有的值
    this.setState({username: &apos;haha&apos;})

    // 替换所有值
    this.replaceState()  


三、获取state值 { this.state.属性名 }

    改变值: this.setState()每当state更新组件就会重新渲染自己

    var Component = React.createClass({

        // 1 初始化 state值
        getInitialState: function() {
            return {userName: &apos;siguang&apos;};
        },
        setUserName: function(){
            this.setState({userName: &apos;lulu&apos;});        // 2 修改state值
        },
        render: function(){
            return (
                &lt;div&gt;
                    这里是props获取的值 {this.state.userName}    // 3 获取state的值
                    &lt;input type=&quot;button&quot; onClick={this.setUserName.bind(this)} value=&quot;点击修改state&quot; /&gt;
                &lt;/div&gt;
            )
        }
    })


四、state示例

    class StateDemo extends Component {
        constructor(){
            super();

            this.state = {
                secondsElapsed: 0
            }
        }

        tick(){
            this.setState({ secondsElapsed: this.state.secondsElapsed + 1 });
        }

        componentDidMount(){
            var that = this;
            this.interval = setInterval(function(){
                that.tick();
            }, 1000);
        }

        componentWillUnmount(){
            clearInterval(this.interval);
        }

        render(){
            return (
                &lt;div&gt;目前已经计时: {this.state.secondsElapsed}秒&lt;/div&gt;
            )
        }
    }

    export default StateDemo;


五、this的指向

    class StateDemo extends Component{
        constructor(props){
            super(props);
            this.state = {
                name: &apos;siguagn&apos;
            }
        }

        // 如果onClick=&quot;this.clickSelectBtn&quot; 这么写，this指向的是p, 所以this.setState()报错
        clickSelectBtn(){
            this.setState({name: &apos;lulu&apos;})
        }

        render(){
            return &lt;div&gt;
                &lt;p&gt;{this.state.name}&lt;/p&gt;
                &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;修改&quot; onClick=&quot;this.clickSelectBtn.bind(this)&quot;&gt;&lt;/p&gt;
            &lt;/div&gt;
        }
    }

    解决方法:

        1、使用bind() - onClick=&quot;this.clickSelectBtn.bind(this)&quot;

        2、使用箭头函数 - onClick={ (e)=&gt;this.clickSelectBtn(e) }
</code></pre><h4 id="操作真实DOM"><a href="#操作真实DOM" class="headerlink" title="操作真实DOM"></a>操作真实DOM</h4><pre><code>两种获取方法

    1、ReactDOM.findDOMNode(this.refs.xxxx);

    2、this.refs.xxx

Example:

    import React, { Component } from &apos;react&apos;;
    import ReactDOM, { findDOMNode } from &apos;react-dom&apos;;
    import $ from &apos;jquery&apos;;

    class RefsDemo extends Component {
        componentDidMount(){

            // findDOMNode()来获取DOM
            let contentA = findDOMNode(this.refs.content);

            // refs直接获取
            let contentB = this.refs.content;

            // jQuery来操作DOM
            console.log($(contentA).html());

            console.log( contentA.innerHTML );
            console.log( contentB.innerHTML );
        }

        render(){
            return(
                &lt;div&gt;
                    &lt;h3&gt;React操作DOM&lt;/h3&gt;
                    &lt;p ref=&quot;content&quot;&gt;这里是DOM元素的内容&lt;/p&gt;        // 这里定义ref访问的名
                &lt;/div&gt;
            )
        }
    }
</code></pre><h4 id="React表单组件操作"><a href="#React表单组件操作" class="headerlink" title="React表单组件操作"></a>React表单组件操作</h4><pre><code>一、react表单组件与html的不同

    1、value、checked: 属性设置值后，用户输入无效

    2、textarea: 的值要设置在value属性

        &lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt;

    3、select: value属性可以是数据，不建使用option的selected属性

        &lt;select multiple={true} value={[&apos;B&apos;, &apos;C&apos;]}&gt;
            &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt;
            &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt;
            &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt;
        &lt;/select&gt;

    4、input/textarea 的 onChange 用户每次输入都会触发（即使不失去焦点）

    5、radio/checkbox/option 点击后触发 onChange
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>通过mixin可以将组件间共享代码，将两个组件共同的属性、方法存储到mixin对象中

mixin不支持ES6的声明组件方式

ES5写法

    import React from &apos;react&apos;;

    // 抽取出的公用方法
    var SetIntervalMixin = {
        componentWillMount: function() {
            this.intervals = [];
        },
        setInterval: function() {
            this.intervals.push(setInterval.apply(null, arguments));
        },
        componentWillUnmount: function() {
            this.intervals.forEach(clearInterval);
        }
    };

    var MixinDemo = React.createClass({

        // 这里加载mixin
        mixins: [SetIntervalMixin],

        getInitialState: function() {
            return {seconds: 0};
        },

        componentDidMount: function() {
            // Call a method on the mixin
            this.setInterval(this.tick, 1000);
        },

        tick: function() {
            this.setState({seconds: this.state.seconds + 1});
        },

        render: function() {
            return (
                &lt;p&gt;
                    计时器已经运行了:  {this.state.seconds} 秒.
                &lt;/p&gt;
            );
        }
    });

    export default MixinDemo;
</code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code>一、react.js

    React.Children: Object
    React.Component: ReactComponent(props, context, updater)
    React.DOM: Object
    React.PropTypes: Object
    React.cloneElement: (element, props, children)
    React.createClass: (spec)
    React.createElement: (type, props, children)
    React.createFactory: (type)
    React.createMixin: (mixin)
    React.isValidElement: (object)

二、Component

    this.context: Object              // DOM元素的内容
    this.props: Object              // 获取props对象
    this.refs: Object                // 通过ref获取指定的DOM
    this.state: Object                // 获取state对象
    this.setState: Object            // 设置state值

三、react-dom.js

    ReactDOM.findDOMNode: findDOMNode(componentOrElement)         // 获取DOM
    ReactDOM.render: ()                                    // 返回组件树
    ReactDOM.unmountComponentAtNode: (container)

四、react-dom-server.js

    ReactDOMServer.renderToString
    ReactDOMServer.renderToStaticMarkup
</code></pre><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><pre><code>一、defaultValue 与 value 的区别

    &lt;input type=&quot;text&quot; value={this.state.inputValue} /&gt;

    如果使用 value来绑定state的值，输入值时不会被改变，使用 defaultValue 值会被改变

    var FromApp = React.createClass({
        getInitialState: function(){
            return {
                inputValue: &apos;input value&apos;
            }
        },

        handleSubmit: function(e){
            this.refs[&apos;goodInput&apos;]
        },

        render: function(){
            return (
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;input type=&quot;text&quot; defaultValue={this.state.inputValue} ref=&quot;goodInput&quot; /&gt;

                    // &lt;input type=&quot;text&quot; ref={node =&gt; { goodInput = node }}&gt;  这种写法
                &lt;/form&gt;
            )
        }
    })
</code></pre><h4 id="React脚手架搭建"><a href="#React脚手架搭建" class="headerlink" title="React脚手架搭建"></a>React脚手架搭建</h4><pre><code>一、可以使用官网的 create-react-app、ant或自己搭  https://github.com/facebook/create-react-app

二、使用的JSX和ES6所以需要转换，使用版本:

    react: &quot;^15.4.2&quot;, react-dom: &quot;^15.4.2&quot;, react-router: &quot;^2.0.0&quot;&quot;, webpack: &quot;^3.10.0&quot;, webpack-dev-server: &quot;^2.11.1&quot;

    react 16以上版本和 react-router 4以上版本会有问题

三、搭建

$ npm init

$ npm i react react-dom react-router --save

$ npm i webpack webpack-dev-server --save

2、安装插件

$ npm i babel babel-loader babel-core babel-preset-es2015 babel-preset-react --save

$ npm i node-sass file-loader url-loader css-loader sass-loader style-loader --save

$ npm i react-hot-loader prop-types events react-slot --save             // react组件，热更新、检测props类型、事件用来通信包、slot

$ npm i html-webpack-plugin open-browser-webpack-plugin --save            // 自动引入静态资源到相应的html、自动打开浏览器

$ touch .babelrc webpack.config.js

$ mkdir src &amp;&amp; cd src &amp;&amp; touch index.html app.js

$ .babelrc 加入

    {
        &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
    }

$ webpack.config.js

    /**
    * User: siguang
    * Date: 2016/12/28
    * Time: 15:04
    */
    const webpack = require(&apos;webpack&apos;);
    const path = require(&apos;path&apos;);
    const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
    const openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);

    const basePath = __dirname;
    const appPath = path.resolve(basePath, &apos;src&apos;);
    const buildPath = path.resolve(basePath, &apos;build&apos;);

    module.exports = {
        entry: {
            app: path.resolve(appPath, &apos;app.js&apos;)
        },

        output: {
            path: buildPath,
            filename: &apos;[name].min.js?[hash]&apos;,
            // chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        module: {
            loaders: [

                // 处理require()引入的css文件，并将代码显示到页面的&lt;style&gt;中
                { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; },

                // 将scss文件转成css文件
                { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;},

                // ES6 转 ES5
                {
                    test: /\.jsx?$/,
                    exclude: /node_modules/,
                    loader: &apos;babel-loader&apos;,
                    query: {
                        presets: [&apos;es2015&apos;,&apos;react&apos;]
                    }
                }
            ]
        },


        plugins: [

            // 压缩打包的文件
            new webpack.optimize.UglifyJsPlugin({
                compress: {
                    //supresses warnings, usually from module minification
                    warnings: false
                }
            }),

            // html
            new HtmlWebpackPlugin({
                // 改变页面的&lt;title&gt;标签的内容
                title: &apos;Hello World app&apos;,
                // 模版地址
                template: path.resolve(appPath, &apos;index.html&apos;),
                // 构建后的文件名和目录
                filename: &apos;index.html&apos;,
                //chunks这个参数告诉插件要引用entry里面的哪几个入口
                // chunks:[&apos;app&apos;],
                //要把script插入标签里
                inject:&apos;body&apos;
            }),

            // 热启动
            new webpack.HotModuleReplacementPlugin(),
            // 自动打开浏览器
            new openBrowserWebpackPlugin({ url: &apos;http://localhost:3000&apos; })
        ],


        // 查找依赖
        resolve:{

            // require或alias时不需要写后缀
            extensions: [&quot;.js&quot;, &quot;.jsx&quot;, &quot;.css&quot;, &quot;.json&quot;],
        },

        // webpack-dev-server 配置
        devServer: {
            port: 3000,                 // 端口
            contentBase: &apos;build&apos;,       // 内容目录
            hot: true,                    // 热刷新
            inline: true
        }
    }

$ package.json

    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
        &quot;dev&quot;: &quot;webpack-dev-server --progress --profile --colors --hot --inline --history-api-fallback&quot;,
        &quot;build&quot;: &quot;webpack --progress --profile --colors --config webpack.production.config.js&quot;
    },

$ 运行

    $ npm run dev     生产环境，并打开webpack服务器

    $ webpack        执行打包到build目录线上环境使用

https://segmentfault.com/a/1190000005969488
</code></pre><h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><pre><code>当组件更新时候，react会创建一个新的虚拟dom树并会和之前的dom树进行比较，这个过程就用到了diff算法
</code></pre><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><pre><code>https://github.com/enaqx/awesome-react#boilerplates

1、路由 - react-router

2、布局 - react-blocks     http://whoisandie.github.io/react-blocks/

3、拖拽 - react-dnd        https://github.com/react-dnd/react-dnd

4、代码编辑器 - react-codemirror        https://github.com/JedWatson/react-codemirror

5、富文本编辑器 - react-quill react-draft-wysiwyg        https://github.com/jpuri/react-draft-wysiwyg

6、拾色器 - rc-color-picker、react-color        https://github.com/react-component/color-picker        http://casesandberg.github.io/react-color/

7、响应式 - react-responsive、react-media    https://github.com/contra/react-responsive        https://github.com/ReactTraining/react-media

8、复制到剪贴板 - react-copy-to-clipboard       https://github.com/nkbt/react-copy-to-clipboard

9、管理 document head - react-helmet          https://github.com/nfl/react-helmet

10、Font Awesome 图标 - react-fa        https://github.com/andreypopp/react-fa

11、二维码 -  qrcode.react         https://ant.design/docs/react/recommendation-cn

12、不在使用className - styled-components

    http://www.alloyteam.com/2017/05/guide-styled-components/
    https://github.com/styled-components/styled-components

13、react写动画效果 - css3transform-react

    $ npm install css3transform-react
    http://www.alloyteam.com/2016/12/react-animations-difficult-to-write-try-react-transformjs/

react-slot - react中写solt    http://npm.taobao.org/package/react-slot
</code></pre><h4 id="积累问题"><a href="#积累问题" class="headerlink" title="积累问题"></a>积累问题</h4><pre><code>一、jsx中for循环出标签并插入到render中

    class SideBar extends Component {
        constructor(props) {
            super(props);
            this.state ={
                menu: [
                    {
                        path: &apos;/home&apos;,
                        name: &apos;主页&apos;
                    },
                    {
                        path: &apos;/parentToChild&apos;,
                        name: &apos;将父向子组件传数据&apos;
                    },
                ]
            }
        }

        render() {
            // 定义一个返回菜单html内容的方法
            let renderMenuHtml = () =&gt; {
                let homeHtml = [];
                this.state.menu.forEach(function(item, idx, arr){
                    homeHtml.push(&lt;li&gt;
                        &lt;Link to={item.path}&gt;{item.name}&lt;/Link&gt;
                    &lt;/li&gt;)
                })
                return homeHtml
            }

            return (
                &lt;div className=&quot;side-box&quot;&gt;
                    &lt;ul&gt;
                        {renderMenuHtml()}        {/* 插入内容 */}
                    &lt;/ul&gt;
                &lt;/div&gt;
            );
        }
    }


2、create-react-app 配置Sass

    注意文件扩展名 *.scss

    $ npm install create-react-app

    $ create-react-app my-app

    $ cd my-app

    $ npm start

    $ npm install sass-loader node-sass --save-dev            // 安装依赖

    $ 在node_modules/react-scripts/config下找到 webpack.config.dev.js 文件，在 exclude 中添加 /.scss$/,

    $ {
        test: /\.scss$/,
        loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;],
    },

    https://www.jianshu.com/p/96658be50642


3、create-react-app 配置router、redux

    npm i react-router --save 
    npm i redux --save 
    npm i react-redux --save 
</code></pre><p>| <a href="http://www.css88.com/react/docs/try-react.html" target="_blank" rel="noopener">http://www.css88.com/react/docs/try-react.html</a><br>| <a href="http://huziketang.com/books/react/" target="_blank" rel="noopener">http://huziketang.com/books/react/</a><br>| <a href="http://blog.csdn.net/liwusen/article/category/6522963" target="_blank" rel="noopener">http://blog.csdn.net/liwusen/article/category/6522963</a><br>| <a href="https://doc.react-china.org/docs/hello-world.html" target="_blank" rel="noopener">https://doc.react-china.org/docs/hello-world.html</a>            中文官网<br>| <a href="http://react-china.org/" target="_blank" rel="noopener">http://react-china.org/</a>           中文社区<br>| <a href="https://github.com/BruceCham/react-cli" target="_blank" rel="noopener">https://github.com/BruceCham/react-cli</a>        // 全家桶<br>| <a href="http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/" target="_blank" rel="noopener">http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/</a>        // virturalDOM 虚拟DOM<br>| <a href="https://www.jianshu.com/p/fb915d9c99c4" target="_blank" rel="noopener">https://www.jianshu.com/p/fb915d9c99c4</a>          // 组件通信<br>| <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">https://github.com/gaearon/redux-devtools</a>        // redux-devtools<br>| <a href="https://guoyongfeng.github.io/book/" target="_blank" rel="noopener">https://guoyongfeng.github.io/book/</a><br>| <a href="http://uprogrammer.cn/react-tutorial-cn/" target="_blank" rel="noopener">http://uprogrammer.cn/react-tutorial-cn/</a><br>| <a href="http://huziketang.com/books/react/lesson1" target="_blank" rel="noopener">http://huziketang.com/books/react/lesson1</a><br>|<br>| <a href="https://github.com/hyy1115/react-redux-webpack2" target="_blank" rel="noopener">https://github.com/hyy1115/react-redux-webpack2</a><br>| <a href="https://github.com/zhbhun/react-learning/tree/master/boilerplate" target="_blank" rel="noopener">https://github.com/zhbhun/react-learning/tree/master/boilerplate</a><br>| <a href="http://blog.csdn.net/u013063153/article/details/52497271" target="_blank" rel="noopener">http://blog.csdn.net/u013063153/article/details/52497271</a>      事件<br>| <a href="https://github.com/gaearon/babel-plugin-react-transform#transforms" target="_blank" rel="noopener">https://github.com/gaearon/babel-plugin-react-transform#transforms</a>   babel-plugin-react-transform 相关插件<br>| <a href="http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/</a><br>| <a href="https://juejin.im/post/5a84682ef265da4e83266cc4" target="_blank" rel="noopener">https://juejin.im/post/5a84682ef265da4e83266cc4</a>        // 源码解析</p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://siguang1983.github.io/2016/12/24/React(之一)基础/';
        this.page.title = 'React（之一）基础';
        this.page.identifier = '2016/12/24/React(之一)基础/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
