<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>ES6 | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="| let块级作用域、 const常量| 解构赋值| 箭头函数、default、rest、spread| 模板字符串| class: extends、super、constructor、静态属性和方法、实例属性| Proxy 对象的拦截器| Promise、Generator、async| 模块化: import、export、as、*、default export| 数据结构: Set不重复值的集合、Map| symbol 独一无二的值
let和const一、let 声明变量

    let" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#let和const"><span class="toc-number">1.</span> <span class="toc-text">let和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解构赋值"><span class="toc-number">2.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板字符串"><span class="toc-number">3.</span> <span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数扩展"><span class="toc-number">4.</span> <span class="toc-text">函数扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象扩展-Object"><span class="toc-number">5.</span> <span class="toc-text">对象扩展 Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类、继承"><span class="toc-number">6.</span> <span class="toc-text">类、继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-异步编程"><span class="toc-number">7.</span> <span class="toc-text">Promise 异步编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Module-模块"><span class="toc-number">8.</span> <span class="toc-text">Module 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据结构-Set-、Map"><span class="toc-number">9.</span> <span class="toc-text">数据结构 Set()、Map()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串扩展"><span class="toc-number">10.</span> <span class="toc-text">字符串扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值-Math"><span class="toc-number">11.</span> <span class="toc-text">数值 Math</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组扩展-Array"><span class="toc-number">12.</span> <span class="toc-text">数组扩展 Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二进制数组-ArrayBuffer对象"><span class="toc-number">13.</span> <span class="toc-text">二进制数组 ArrayBuffer对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol"><span class="toc-number">14.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy-拦截器"><span class="toc-number">15.</span> <span class="toc-text">Proxy 拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator"><span class="toc-number">16.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async、await"><span class="toc-number">17.</span> <span class="toc-text">async、await</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            ES6
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/ES6/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| let块级作用域、 const常量<br>| 解构赋值<br>| 箭头函数、default、rest、spread<br>| 模板字符串<br>| class: extends、super、constructor、静态属性和方法、实例属性<br>| Proxy 对象的拦截器<br>| Promise、Generator、async<br>| 模块化: import、export、as、*、default export<br>| 数据结构: Set不重复值的集合、Map<br>| symbol 独一无二的值</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><pre><code>一、let 声明变量

    let完全可以取代var, 特性: 1、let不允许重复声明        2、没有预解析功能        3、块级作用域

    1、预解析功能

        console.log(a);        // 报错, 如果是原来的var声明这里会是undeined, 所以let没有预解析功能
        let a = 20;

    2、块级作用域 在{ }中声明的变量只能在括号里使用

        var name = &apos;lulu&apos;;
        function prsone(){
            let name = &apos;siguang&apos;;
        }

        prsone();
        console.log(name);            // &apos;lulu&apos;

        // 输出的都是10
        for(var i=0; i&lt;10; i++){
            setTimeout(function(){
                console.log(i);        // 使用var声明的i都会打印出9，如果使用let输出的就是0到10
            })
        }

二、const常量

    1、常量只允许赋一次值不能被修改        2、常量声明都为大写        3、与let相当只在块级作用域有效

    const NAME = &apos;siguang&apos;;        // 不能变化的值
    NAME = &apos;lulu&apos;;                // 报错
</code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><pre><code>允许从数组和对象中提取的值，对变量进行赋值，被称为解构赋值

一、数组解构使用[]

    let [a, b, c] = [1,2,3];    // a=1, b=2, c=3

    # 默认值
    let [x, y = &apos;b&apos;] = [&apos;a&apos;];     // x=&apos;a&apos;, y=&apos;b&apos;


二、对象解构使用{}

    // 对象是按名字来解析赋值
    let obj = {
        getName: function(){}, 
        foo: &apos;aaa&apos;, 
        bar: &apos;bbb&apos;
    };
    let {foo, bar} = obj        // foo=&apos;aaa&apos;, bar=&apos;bbb&apos;

    // 对象的解构赋值，先找到同名，在将值赋给对应的变量
    let { foo: val, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };  
    console.log(val, bar)        // foo=&apos;undefined&apos;, val=&apos;aaa&apos;, bar=&apos;bbb&apos;


三、字符串的解构赋值

    const [a, b, c, d, e] = &apos;hello&apos;;    // a=h, b=e, c=l, d=l, e=o
    const [...tail] = &apos;hello&apos;;            // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]

    # length属性
    let {length: len} = &apos;hello&apos;;        // length = 5


四、默认参数 default

    # 参数作为数组
    function add([x, y]){
        return x * y
    }
    add([3,2]);        // 6

    # 参数作为对象，对x、y的默认初始值
    function move({x = 0, y = 0}) {
        return [x, y];
    }
    move({x: 3, y: 8}); // [3, 8] 


五、不定参数 Rest

    function f(x, ...y) {
        // y是一个数组
        return x * y.length;
    }
    f(3, &quot;hello&quot;, true) == 6


六、扩展运算符 Spread

    function f(x, y, z) {
        return x + y + z;
    }
    // 将数组中的每个元素展开为函数参数
    f(...[1,2,3]) == 6
</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>一、写到`...`之间，值的输出使用 ${...} 

二、可以写多行字符串，只写到`...`之间就可以

二、${...}可以解析变量、对象的值、表达式、函数返回

    let name = &apos;siguang&apos;;
    let obj = {
        age: 33
    }
    console.log(`你的名字是: ${ name } 你的年龄是:  ${ obj.age }`)

三、标签模板

    let a=10, b=20;
    dialog`Hello ${a+b} world ${a*b}`;        // 等同于 dialog()
</code></pre><h4 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h4><pre><code>一、箭头函数

    1、箭头函数的注意问题: 

        * 箭头函数里的this不是指向调用者，而指向对象
        * 不能当构造函数来用
        * 函数内不存在arguments对象
        * 不可以使用yield命令，箭头函数不能用作Generator函数

        arr.sort(function(){  ...  }) 相当于 arr.sort((a, b) =&gt; a-b);

        // 箭头函数的this，不是指向调用者
        const Template = {
            test(){
                console.log(this);        // this指向Template

                document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                    /* 如果非箭头函数this应该指向 #showThis */
                    /* 这里箭头函数不是指向调用者，所以指向了 Template */
                    console.log(this);    
                }
            }
        }
        Template.test();


    2、var f = function(v){
            return v;
        }

        // ES6写法
        var f = v =&gt; v;


    3、var sum = function(num1, num2){
            return num1 + num2;
        }

        // ES6写法
        var sum = (num1, num2) =&gt; {
            return num1 + num2;
        }


    4、对象中方法的简写

        var obj = {
            name: &apos;haha&apos;,
            getName(){                // 是getName: function(){}的简写
                console.log(this.name);
            },
            setName(name){
                this.name = name;
                console.log(this.name);
            }
        }


    5、参数的解构赋值

        const full = ({ first, last }) =&gt; first + &apos; &apos; + last;    
        full({first: 20, last: 30})

        // 等同于
        // function full(person) {
        //      return person.first + &apos; &apos; + person.last;
        // }        


    6、[1,2,3].map(function (x) {
            return x * x;
        });

        // ES6写法
        [1,2,3].map( (x) =&gt; x * x);


二、函数参数默认值

    function fn(a, b=2){
        // b如果不传相当于2，等同于 var b = arguments.length &gt; 1 &amp;&amp; arguments[1] == undefined ? arguments[1] : 2;
        return {a, b}
    }
    console.log(fn(10));        // 返回{a: 10, b: 2}

    // 如果没有参数默认值时还需要在函数体内做兼容
    function fn(name){
        var getName = name || 20;
    }
    fn();


三、rest 参数  获取多余参数

    以&apos;...变量名&apos; 来获取多余的参数，返回一个数组，这样就不需要arguments对象了

    function person(...rest){
        console.log(rest);        // [1,2,3,4,5]
    }
    person(1,2,3,4,5);

    function person(a, ...rest){
        console.log(a);            // 1
        console.log(rest);        // [2,3,4,5]
    }
    person(1,2,3,4,5);


四、spread 扩展操作符 ...  与rest相反

    function add(x, y) {
        return x + y;        // 4+38
    }
    var numbers = [4, 38];
    add(...numbers)         // 42


    # 可以将字符串转成数组
    let arr = [...&apos;hello&apos;];        // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]


五、name属性

    funciton foo(){ ... }
    foo.name;        // &apos;foo&apos; 返回函数名


六、绑定this

    箭头函数可以绑定this对象，减少显式this对象的写法(call、apply、bind)

    ES7提出了函数绑定来取代&quot;call、apply、bind&quot;调用，使用两个&quot;::&quot;

    Example

        foo::bar        // 等同于 bar.bind(foo)
</code></pre><h4 id="对象扩展-Object"><a href="#对象扩展-Object" class="headerlink" title="对象扩展 Object"></a>对象扩展 Object</h4><pre><code>一、简写

    1、对象属性和值相同可以写成一个

        var foo = { name: &apos;siguang&apos;};
        var baz = {
            foo            // 与 foo: foo 相同
        };
        console.log(baz.foo.name);    // siguang


    2、对象中函数的简写

        var o = {
            name: &apos;momo&apos;,
            getName(){            // 等同于 getName: function(){}
                retrun this.name;
            }
        }


    3、示例1 参数作为对象返回

        function f(x, y) {
            return {x, y};
        }

        // 等同于
        function f(x, y) {
            return {x: x, y: y};
        }
        f(1, 2) // Object {x: 1, y: 2}

    // 示例2 CommonJS模块输出变量
        const getItem = function(){ ... }
        const setItem = function(){ ... }
        const clear = function(){ ... }
        module.exports = { getItem, setItem, clear };

        // 等同于
        // module.exports = {
        //   getItem: getItem,
        //   setItem: setItem,
        //   clear: clear
        // };


二、[] 属性名表达式

    // 对象的属性名可以用&apos;[]&apos;字符串拼接
    var sex = &apos;男&apos;;
    var obj = {
        name: &apos;momo&apos;,
        [sex]: false,
        [&apos;get&apos;+&apos;Name&apos;](){
            console.log(this.name, this[&apos;男&apos;]);        // 返回 momo false
        }
    }

    obj.getName();


三、getter 赋值器、setter 取值器

    let cat = { 
        name: &apos;喵喵&apos;, 
        get name(){ return this.name },   
        set name(value){
            if(Object.prototype.toString.call(&apos;xxx&apos;) == &apos;[object String]&apos;){
                this.name += value
            }
        }
    }


四、Object.is(): 用于对比是否相等，相当于 === ，可以正确比较 -0和0，NaN和

    &apos;==&apos;与&apos;===&apos;的缺点:

        相等运算符（==）缺点: 自动转换数据类型
        和严格相等运算符（===）缺点: NaN不等于自身，以及+0等于-0

    Objetc.is(0, -0);        // false
    Object.is(NaN, NaN);    // true


五、Object.assign(全并目标对象， 被合并对象B, 被合并对象C): 合并到第一个参数上，不是深度拷贝，所以还存在引用关系

    /* 注意: 如果后面的对象与前面对象的属性相同会赋盖掉前面的对象的值 */

    var objA = {a: 1, b:2}, objB = {b: 3, c: 4}; 
    let req = Object.assign(objA, objB);         // {a:1, b:3, c:4}

    添加对象的方法: 
        Object.assign(SomeClass.prototype, {
            someMethod(arg1, arg2){
                // ...
            },
            anotherMethod(){
                // ...
            }
        })

        相当于
        SomeClass.prototype.someMethod = function(arg1, arg2){ // ... }
        SomeClass.prototype.anotherMethod = function(){ // ... }

    克隆对象: 
        function clone(obj){
            return Object.assign({}, obj);
        }


六、getPrototypeOf(object)、setPrototype(object, 谁的prototype): 获取、设置对象的prototype

    var Cat = function(name){
        this.name = name;
    }

    Cat.prototype.showName = function(){
        return this.name;
    }

    var c1 = new Cat(&apos;momo&apos;);
    c1.showName();

    console.log(Object.getPrototypeOf(c1))

    // 设置prototype
    var Person = function(nationality){
        this.nationality = nationality;
    }
    Person.prototype = {
        showNationality: function(){
            return this.nationality;
        }
    }
    Object.setPrototypeOf(c1, Person.prototype);
    console.log(Object.getPrototypeOf(c1));


七、keys()、values()

    获取对象的所有keys或所有值, 并返回一个数组

    var obj = {name: &apos;siguang&apos;, age: 33};
    console.log(Object.keys(obj));        // [name, age]
    console.log(Object.values(obj));    // [&apos;siguang&apos;, 33]


八、__proto__属性

    用来读取或设置当前对象的prototype对象

    var Person = function(name){
        this.name = name;
    }
    Person.prototype = {
        constructor: Person,
        getName(){
            console.log(this.name);
        }
    }
    var op = new Person(&apos;lulu&apos;);

    // 继承
    var PersonChilder = function(){}; 
    PersonChilder.__proto__ = op;
    var opc = new PersonChilder(); 
    console.log(opc.getName())


    增强的对象字面量

    // 通过对象字面量创建对象
    var human = {
        breathe() {
            console.log(&apos;breathing...&apos;);
        }
    };

    var worker = {
        __proto__: human, //设置此对象的原型为human,相当于继承human
        company: &apos;freelancer&apos;,
        work() {
            console.log(&apos;working...&apos;);
        }
    };

    human.breathe();//输出 ‘breathing...’

    //调用继承来的breathe方法
    worker.breathe();//输出 ‘breathing...’


九、遍历属性的方法

    1) for...in 循环

    2）Object.keys(obj): 返回obj对象的所有key, 返回是一个数组
</code></pre><h4 id="类、继承"><a href="#类、继承" class="headerlink" title="类、继承"></a>类、继承</h4><pre><code>一、类的一些特性

    1、对象方法的简写方法
        class Cat{
            getName(){        // 老写法 getName: function(){}

            }
        }

    2、通过__proto__属性可以直接调用父类
        var parent = {
            getParentName(){
                console.log(&apos;parent&apos;)
            }
        }

        var childer = {
            __proto__: parent,            // 通过__proto__指向parent, 就可以直接调用parent类中的方法
            getChildeName(){
                console.log(&apos;childer&apos;);
            }
        }

        childer.getChildeName();    // childer
        childer.getParentName();    // parent


二、创建类

    class Cat {

        // ES6中新型构造器, 用来初始化时这里接收参数
        constructor(name){ 
            this.name = name;
        }

        getName(){        // 公有方法
            console.log(this.name);
        }

        _bar(baz){        // 私有方法
            return this.sfn = baz;
        }
    }

    Cat.userName = &apos;siguang&apos;;

    var oCat = new Cat(&apos;哈哈&apos;);
    oCat.getName();


三、继承 extends

    // 创建一个类
    class Person {
        constructor(name){
            this.name = name;
        }

        getName(){
            console.log(this.name);
        }
    }

    // 继承这个类
    class Children extends Person {
        constructor(name, color){
            super(name);                // super指向继承的构造函数Person的constructor
            this.color = color;
        }

        getColor(){
            console.log(this.name, this.color);
        }
    }

    // 实例化
    var op = new Person(&apos;siguang&apos;);
    op.getName();        // output &apos;siguang&apos;

    var oc = new Children(&apos;lulu&apos;, &apos;red&apos;);        
    oc.getColor();        // output &apos;red&apos;
    oc.getName();        // output &apos;lulu&apos;


四、static 静态属性和方法

    类似构造函数，直接挂载到函数下的叫对象的属性和方法，而写到构造函数内部的叫构造函数的属性和方法

    1、静态方法前面需要加上&apos;static&apos;关键字，相当于只是函数下的方法而不是prototype的方法，静态方法可以被子类继承，

        class Foo{
            static methodName(){
                return &apos;hello&apos;
            }
        }

        Foo.methodName();    // hello

        var foo = new Foo();
        foo.methodName();    // 报错

    2、静态属性

        ES6中没有静态属性，只能声明静态方法，ES7中可以直接写到类内在进行转码

        class Foo {
            constructor(...args) {
                this.args = args;
            } 
            outputUserName(){
                console.log(this.username);    // 这里username未定义，除非在constructor中定义 this.username
            }
        }
        Foo.username = &apos;siguang&apos;;       // 类的静态属性

        var foo = new Foo();
        console.log(foo.personName);    // undefined
        foo.outputUserName();   // undefined 


五、实例属性

    注意: 一定要将实例属性和静态属性区分，实例属性写到constructor中this.username, new后的实例时候可以被实例方法调用，而静态属性只挂到了类下直接通过类来调取，Foo.username

    class Foo{
        constructor(){
            this.username = &apos;siguang&apos;;
        }
        showName(){
            console.log(this.username);     // siguang
            console.log(Foo.username);      // lulu
        }
    }
    Foo.username = &apos;lulu&apos;;

    var foo = new Foo();
    foo.showName();

    ****** ES7 中静态属性和实例属性的定义 ******
    class MyClass{
        usernameA = &apos;siguang&apos;;        // 实例属性

        showName(){
            console.log(this.usernameA);
        }
    }


六、super()方法

    继承时必须调用super方法，否则constructor中的this为undefined，调用父类的构造器进行初始化, 子类调用父类的构造函数

    class BaseModel {
        constructor(options, data) { // class constructor，node.js 5.6暂时不支持options = {}, data = []这样传参
            this.name = &apos;Base&apos;;
            this.url = &apos;http://azat.co/api&apos;;
            this.data = data;
            this.options = options;
        }
        getName() { // class method
            console.log(`Class name: ${this.name}`);
        }
    }

    class AccountModel extends BaseModel {
        constructor(options, data) {
            super({private: true}, [&apos;3333&apos;, &apos;4444&apos;]); 
            this.name = &apos;Account Model&apos;;
            this.url +=&apos;/accounts/&apos;;
        }
        getAccountsData() {
            return this.data;
        }
    }

    let accounts = new AccountModel(5);
    accounts.getName();         // Account Model
    console.log(&apos;Data is %s&apos;, accounts.getAccountsData);        // {private: true}

    let base = new BaseModel({public: true}, [&apos;111&apos;, &apos;2222&apos;]);
    console.log(base.getName());        // Base


七、class中的Generator方法

    方法前面加&quot; * &quot; 号表示该方法是Generator函数

    class MyClass = {
        constructor(){
            ...
        }

        * getName(){
            ...
        }
    }
</code></pre><h4 id="Promise-异步编程"><a href="#Promise-异步编程" class="headerlink" title="Promise 异步编程"></a>Promise 异步编程</h4><pre><code>// resolve: 成功、reject: 失败

var pro = new Promise(function(resolve, reject){        // resolve成功, reject失败
    // 将一个耗时长的任务放到执行器里
    setTimeout(function(){
        resolve();            // 4毫秒后执行成功
    }, 400)
})

pro.then(
    function(){                        // 这里执行的就是reslove
        console.log(&apos;成功执行&apos;);
    },
    function(){                        // 这里执行的就是reject
        console.log(&apos;失败执行&apos;);
    }
)
.catch(function(e){                // 捕获异常，如果then中的两个方法成功失败有报错就会走catch
    console.log(e)
})


方法: 

一、Promise.all([实例1，实例2，实例3]): 用于多个promise实例，当三个实例都为真的时候all这个结果为真

    var p1 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p1完成&quot;);
        }, 400);
    })

    var p2 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p2完成&quot;);
        }, 1000);
    })

    var p3 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p3完成&quot;);
        }, 4000);
    })

    var p4 = Promise.all([p1, p2, p3]);
    p4.then(function(){
        console.log(&apos;三个全部执行成功&apos;)
    }, function(){
        console.log(&apos;失败&apos;)
    })

二、Promise.race([实例1，实例2，实例3]): 只要有一个为成功，p4为成功，与all()方法正反

https://www.jianshu.com/p/c98eb98bd00c
</code></pre><h4 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h4><pre><code>一、export: 模块输出

    1、使用对象简写方式

        var name1 = &apos;aaa&apos;;
        var name2 = &apos;bbb&apos;;
        var name3 = &apos;ccc&apos;;

        // 对象的简写 相当于{ name1: name1, name2: name2, name3: name3 }
        export {name1, name2, name3} 

        // 也可以写成    
        export var name1 = &apos;aaa&apos;;
        export var name2 = &apos;bbb&apos;;
        export var name3 = &apos;ccc&apos;;


    2、可以直接输出变量、函数或类

        export function person(){ ... }

        export {...}

        // 不能直接输出变量名
        var name = &apos;siguang&apos;;
        export name;            // 报错

        写成: export var name = &apos;siguang&apos;;        
        写成: var name = &apos;siguang&apos;;   export {name};    


    3、跨模块常量

        const常量只能在当前代码下使用，通过export可以进行跨模块常量，多个文件都可以使用

        export const name = &apos;siguang&apos;;
        export const age = 33;

        import * as info from &apos;userinfo&apos;;        // 或 import { name, age } from &apos;userinfo&apos;


二、as 关键字来修改名字

    meat.js

        export function beef(){
            return &apos;牛肉&apos;;
        }

        export function pork(){
            return &apos;猪肉&apos;;
        }

    main.js

        // * 代表meat.js下所有的对外接口，转换成meat对象下，这样就可以通过meat来调用meat下的
        import * as meat from &apos;./meat.js&apos;;        
        console.log(meat.beef());        // 牛肉
        console.log(meat.pork());        // 猪肉


三、* 将somModule内的所有导出接口

    import * as newSome from &apos;./someModule&apos;        // 将someModule类的所有接口更改到newSome下


四、export default 指定匿名

    import加载时将定义的名与导出的相同，否则无法加载，如果指定默认输出使用export default，在import导入的时候不用在关心命名的问题

    1、meat.js

            // 输出时是匿名
            export default function() {
                console.log(&apos;foo&apos;);
            }

            简写
            export default(){        // export default {}  写成默认对象

            }

        main.js

            // 导入时可以任意起名
            import beef from &apos;./meat.js&apos;


    2、default与不写default输出的区别

        // 使用default来输出，import不需要使用 {}
        export default function crc32() {
            // ...
        }
        import crc32 from &apos;crc32&apos;;

        // 不使用default来输出，import需要使用 {}
        export function crc32() { // 输出
            // ...
        };
        import {crc32} from &apos;crc32&apos;; // 输入


五、import: 模块加载

    // 取整个对象
    import $ from &apos;jquery&apos;;

    // 通过解构取对象
    import {name1, name2, nam3} from &apos;./user.js&apos;;

    // 通过逗号分两整体和解构分别来取
    import React, { Component, PropTypes } from &apos;react&apos;;

    // 重命名
    import * as React from &apos;react&apos;;        // * 对整体模块加载，并通过as转换一个名

    // 按需加载
    button.addEventListener(&apos;click&apos;, event =&gt; {
        imoprt(&apos;dialog.js&apos;)
            .then(dialog =&gt; {
                dialog.show();
            }).
            catch(err =&gt;{
                // error
            })
    }, false)


六、不同写法

    1、普通写法

        meat.js
            export function beef(){
                return &apos;牛肉&apos;;
            }
            export function pork(){
                return &apos;猪肉&apos;;
            }

        main.js

            import { beef, pork } from &apos;meat.js&apos;;
            console.log(beef());        // 牛肉
            console.log(pork());        // 猪肉


    2、key的简写

        var fn1 = funtion(){
            console.log(&apos;fn1&apos;);
        }

        var fn2 = function(){
            console.log(&apos;fn2&apos;);
        }

        export {fn1, fn2}         // 对象名与key相同可以写成一个
</code></pre><h4 id="数据结构-Set-、Map"><a href="#数据结构-Set-、Map" class="headerlink" title="数据结构 Set()、Map()"></a>数据结构 Set()、Map()</h4><pre><code>一、Set(): 类似数组的一种新结构，成员都是唯一的值没有重复值，相当于数组去重

    # 数组去重的新方法
    let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
    console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
    let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    特性: 
        1、不允许数组里有重复数据

    方法: 
        1、set.size(): 获取数据的长度

        2、set.add(value): 添加值

        3、set.delete(value): 删除set的实例值

        4、set.has(value): 传入的参数是否为set的成员

        5、set.clear(): 删除set的所有成员


二、Map(): 传统的对象key只能为字符串, Map可以是对象和其它类型

    var map = new Map([[&apos;name&apos;, &apos;age&apos;]]);
    console.log(map);        // {name: &apos;age&apos;}

    特性: 
        不允许有重复的key值

    方法: 
        1、map.size: 成员总数

        2、map.set(&apos;key&apos;, &apos;value&apos;): 添加成员

        3、map.get(): 获取

        4、map.clear(): 清除所有
</code></pre><h4 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h4><pre><code>一、repeat(): 复制字符串  &apos;哈哈哈！&apos;.repeat(5);    复制五个&apos;哈哈哈！&apos;

二、includes()、startsWith()、endsWith(): 查找三个方法

    var str = &apos;siguang 1983&apos;;
    str.includes(&apos;o&apos;);        // 查找字符串中是否包含值，包含返回true否则返回false
    str.startsWith(&apos;s&apos;);    // 第一个字符是不是s，如果是返回true
    str.endsWith(&apos;d&apos;);        // 最后一个字符是不是 d，返回布尔值
</code></pre><h4 id="数值-Math"><a href="#数值-Math" class="headerlink" title="数值 Math"></a>数值 Math</h4><pre><code>一、trunc(): 去除小数部分

    Math.trunc(123.123123);    // 123

二、sign(): 判断是正数还是负数，如果是正数返回1，负数返回-1，0返回0

    Math.sign(-234);    // -1

三、hypot(): 返回所有参数的平方和的平方根

    Math.hypot(3,4);    // 5 勾股定理
</code></pre><h4 id="数组扩展-Array"><a href="#数组扩展-Array" class="headerlink" title="数组扩展 Array"></a>数组扩展 Array</h4><pre><code>一、form(): 将对象转成数组

    var obj = {&apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;};
    var arr =  Array.form(obj); console.log(arr);        // [a, b, c]


二、of(): 将一组值转成数组

    var arrA = new Array(1, 2, 3);    // 生成一个[1,2,3]
    var arrB = new Array(3);        // arrB.length  等于3 如果传一个参数这样会生成一个3个空值

    var arrC = Array.of(3);            // [3] 解决了new Array的问题


三、find(): 找出第一个符合条件的数据元素

    // 找出数组中值大于3的第一个数
    var arr = [1,2,3,4,5,6];
    var n = arr.find(function(value, index){
        return value &gt; 3;
    })
    console.log(n);        // 4


四、findIndex(): 找出第一个符合条件的位置，也就是所引值

五、fill(填充内容, 填充开始的位置, 填充结束的位置): 填充数组

    var arr = [1,2,3,4,5,6];
    arr.fill(7);        // 数组里全部为7
    arr.fill(7, 1, 3);    // 数组下标从1-3的值为7
    console.log(arr);


六、for...of: 遍历数组、字符串的值，但不能遍历对象

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr){
        console.log(value);        // 1,2,3,4,5,6 只能将遍历出数组的值
    }


七、keys()和values(): 返回数组的Key或value

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr.key()){
        console.log(value);
    }


八、entries(): 将数组的key和value一块输出

    var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];
    for(var [key, value] of arr.entries()){
        console.log(key, value);
    }

    返回: 
        0 &quot;a&quot;
        1 &quot;b&quot;
        2 &quot;c&quot;
        3 &quot;d&quot;
        4 &quot;e&quot;
        5 &quot;f&quot;


九、includes(): 查看数组中是否包含指定的值

    var arr = [1, 2, 3, 4, 5];
    arr.includes(3);        // true
</code></pre><h4 id="二进制数组-ArrayBuffer对象"><a href="#二进制数组-ArrayBuffer对象" class="headerlink" title="二进制数组 ArrayBuffer对象"></a>二进制数组 ArrayBuffer对象</h4><pre><code>二进制数组由三类对象组成: 

    ArrayBuffer对象: 代表原始的二进制数据。

    TypedArray视图: 用来读写简单类型的二进制数据。

    DataView视图: 用来读写复杂类型的二进制数据。


一、ArrayBuffer 对象

    它不能直接读写，只能通过（TypedArray和DataView）来读写。

    ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。

    var buf = new ArrayBuffer(32);        // 生成一段32字节的内存区域，每个字节默认为0


    属性和方法: 

    1、byteLength: 返回分配内存的字节长度

        var buffer = new ArrayBuffer(32);

        buffer.byteLength;        // 32


    2、slice(): 拷贝字节

        var buffer = new ArrayBuffer(8);

        var newBuffer = buffer.slice(0, 3);     //拷贝`buffer`对象的前三个字节（从0到3前结束），生成一个新的ArrayBuffer对象: newBuffer


    3、isView(): 返回一个布尔值，表示参数是否为ArrayBuffer的视图实例

        var buffer = new ArrayBuffer(8);
        ArrayBuffer.isView(buffer) // false

        var v = new Int32Array(buffer);
        ArrayBuffer.isView(v) // true


二、TypedArray 视图

    TypedArray数组只提供9种固定的构造函数
</code></pre><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><pre><code>新的数据类型，独一无二的值，凡是属性名属于Symbol类型，就是独一无二的

# 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();

s1 === s2         // false

# 有参数的情况
var s1 = Symbol(&apos;foo&apos;);
var s2 = Symbol(&apos;foo&apos;);

s1 === s2         // false

一、不能与其它值进行运算

    var sym = Symbol(&apos;My symbol&apos;);
    console.log(&quot;your symbol is &quot; + sym);        // 报错


二、toString()转成字符串

    let sym = Symbol(&apos;my symbol&apos;);
    sym.toString()    // &quot;Symbol(my symbol)&quot;
</code></pre><h4 id="Proxy-拦截器"><a href="#Proxy-拦截器" class="headerlink" title="Proxy 拦截器"></a>Proxy 拦截器</h4><pre><code>可以监听对象身上发生变化，对操作对象属性读取时做一个拦截器

&lt;script&gt;
    let obj = {
        a: 1,
        b: 2
    }

    // 相当于操作对象属性时的一个拦截器
    let p1 = new Proxy(obj, {
        get(obj, key) { // 获取值操作
            return obj[key];
        },
        set(obj, attr, value) { // 赋值操作

            // 这里来做拦截，如果修改的key=a 并且 value值小于10不会就将值修改
            if (attr == &apos;a&apos; &amp;&amp; value &lt; 10) {
                obj[attr] = value;
            }
        }
    })

    // 设置属性
    p1.a = 9; // {a: 9, b: 2}
    p1.a = 20; // {a: 9, b: 2}
    p1.b = 10; // {a: 9, b: 20}

    // 获取属性值
    console.log(p1.a, p1.b);    
&lt;/script&gt;
</code></pre><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><pre><code>Generator是ES6提供的异步函数，Generator可以通过yield表达式来定义步骤，通过next()来获取结果 

Example: 

    function* ouputGenerator() {
        yield &apos;hello&apos;;            // 调用后不会马上执行，只有调用next()才会返回
        yield &apos;world&apos;;
        return &apos;ending&apos;;
    }

    let gen = ouputGenerator();

    console.log(gen.next());     // {value: &quot;hello&quot;, done: false}  value就是返回值
    console.log(gen.next());     // {value: &quot;world&quot;, done: false}
    console.log(gen.next());     // {value: &quot;ending&quot;, done: true}  done为true就是后面没有yeild的定义


一、Generator的特征:

    1、function 关键字与函数名之间有一个&quot;*&quot;号

    2、函数体内有 yield 语句

    3、可以执行暂停

    4、generator也可以不用yield, 但需要执行一次next()


二、属性和方法

    1、next() 可以带一个参数，参数可以是上一个yield的返回值

        done为true 表示结束  Object {value: &quot;ending&quot;, done: true}

    2、value: 就是next返回的值，done为false表示已经结束

    3、yield: 定义表达式


三、Generator与Promise的区别

    promise如果写多个嵌套会很麻烦:

        getArticleList()
            .then(articles =&gt; getArticle(articles[0].id))
            .then(article =&gt; getAuthor(article.authorId))
            .then(author =&gt; {
                alert(author.email);
            });

        function getAuthor(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/E105pDLh&quot;,{
                    author: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticle(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/EkI02vUn&quot;,{
                    id: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticleList(){
            return new Promise(function(resolve, reject){
            $.ajax(
                &quot;http://beta.json-generator.com/api/json/get/Ey8JqwIh&quot;)
                .done(function(result){
                    resolve(result);
                }); 
            });
        }


    Generator的写法:

        function* run(){
            var articles = yield getArticleList();
            var article = yield getArticle(articles[0].id);
            var author = yield getAuthor(article.authorId);
            console.log(author.email);  
        }

        var gen = run();
        gen.next().value
            .then(articles =&gt; {
                gen.next(articles).value.then(article =&gt; {
                    gen.next(article).value.then(author =&gt; {
                    gen.next(author)
                })
            })
        })


Example:

    function* ouputGenerator() {
        console.log(&apos;调用了&apos;)        // ** 如果没执行next不会执行 ** 
    }

    var gen = ouputGenerator();

    setTimeout(()=&gt;{
        gen.next()
    }, 3000)
</code></pre><h4 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h4><pre><code>async 是ES7引入的函数，使的异步变得更加方便

Generator函数执行必须靠执行器，也就是需要调next()，async函数有自带的执行器，async返回的是Promise对象

await: 命令后面是一个Promise对象

Example:

    async function getStockPriceByName(name) {
        var symbol = await getStockSymbol(name);
        var stockPrice = await getStockPrice(symbol);
        return stockPrice;
    }

    getStockPriceByName(&apos;goog&apos;).then(function (result) {
        console.log(result);
    });
</code></pre><p>| 参考资料<br>| <a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/babel.html</a><br>| <a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/style</a><br>| <a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://siguang1983.github.io/2016/12/24/ES6/';
        this.page.title = 'ES6';
        this.page.identifier = '2016/12/24/ES6/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
