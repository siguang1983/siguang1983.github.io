<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>EggJS基础 | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="| this.ctx - 当前请求的上下文 Content对象的实例ctx，Request、Response| this.app - 当前应用对象Application 对象的实例| this.service - 定义的Service，等价于 this.ctx.service| this.config - 应用配置| this.logger - 日志对象 方法debug, info, warn, error| app.cache - 缓存
Egg介绍、安装Egg.js属于MVC类型的NodeJS" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Egg介绍、安装"><span class="toc-number">1.</span> <span class="toc-text">Egg介绍、安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置"><span class="toc-number">2.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Router-路由"><span class="toc-number">3.</span> <span class="toc-text">Router 路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Controller"><span class="toc-number">4.</span> <span class="toc-text">Controller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ctx-header-头"><span class="toc-number">5.</span> <span class="toc-text">ctx.header 头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie"><span class="toc-number">6.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session"><span class="toc-number">7.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#service-处理业务逻辑"><span class="toc-number">8.</span> <span class="toc-text">service 处理业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中间件-Middleware"><span class="toc-number">9.</span> <span class="toc-text">中间件 Middleware</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Validate-参数校验插件"><span class="toc-number">10.</span> <span class="toc-text">Validate 参数校验插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jsonp"><span class="toc-number">11.</span> <span class="toc-text">jsonp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpClient"><span class="toc-number">12.</span> <span class="toc-text">HttpClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板渲染"><span class="toc-number">13.</span> <span class="toc-text">模板渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态资源"><span class="toc-number">14.</span> <span class="toc-text">静态资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内置对象"><span class="toc-number">15.</span> <span class="toc-text">内置对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定时任务"><span class="toc-number">16.</span> <span class="toc-text">定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#框架扩展"><span class="toc-number">17.</span> <span class="toc-text">框架扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动自定义"><span class="toc-number">18.</span> <span class="toc-text">启动自定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#logger-日志"><span class="toc-number">19.</span> <span class="toc-text">logger 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本地开发"><span class="toc-number">20.</span> <span class="toc-text">本地开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插件的开发"><span class="toc-number">21.</span> <span class="toc-text">插件的开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#项目目录"><span class="toc-number">22.</span> <span class="toc-text">项目目录</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            EggJS基础
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/04/Egg.js-框架/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-04T07:15:23.000Z" itemprop="datePublished">2016-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Egg-js/">Egg.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| this.ctx - 当前请求的上下文 Content对象的实例ctx，Request、Response<br>| this.app - 当前应用对象Application 对象的实例<br>| this.service - 定义的Service，等价于 this.ctx.service<br>| this.config - 应用配置<br>| this.logger - 日志对象 方法debug, info, warn, error<br>| app.cache - 缓存</p>
<h4 id="Egg介绍、安装"><a href="#Egg介绍、安装" class="headerlink" title="Egg介绍、安装"></a>Egg介绍、安装</h4><pre><code>Egg.js属于MVC类型的NodeJS框架

一、下载脚手架:

    $ npm i egg-init -g
    $ egg-init egg-example --type=simple
    $ cd egg-example
    $ npm i

二、启动项目:

    $ npm run dev
    $ open localhost:7001
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code>config
    |- config.default.js        // 默认配置文件, 所有环境都会加载这个配置文件, 一般用于开发环境的默认配置文件
    |- config.test.js           // 开发环境配置
    |- config.prod.js           // 生产环境配置
    |- config.unittest.js
    |- plugin.js                // 控制插件
    `- config.local.js

一、引入插件

    module.exports = {
        mysql: {
            enable: true,           // 开启或关闭插件
            package: &apos;egg-mysql&apos;    // package为一个npm模块，package.json中的dependencies中，框架会在node_modules目录中找到这个插件入口
        },
    };

    也可以指定path 来替代 package
    const path = require(&apos;path&apos;);
    module.exports = {
        mysql: {
            enable: true,
            path: path.join(__dirname, &apos;../app/plugin/egg-mysql&apos;),
        },
    };
</code></pre><h4 id="Router-路由"><a href="#Router-路由" class="headerlink" title="Router 路由"></a>Router 路由</h4><pre><code>用来接收请求URL，在交给controller处理

app.get(路由名，路由URL路由，middleware(可以配置多个)，controller)

一、controller的两个写法

    # router
    module.exports = app =&gt; {
        // 1、controller目录的home.js进行处理
        app.get(&apos;/&apos;, &apos;home&apos;);             

        // 2、payTool目录、billquery.js文件、getLoanUser方法
        app.post(&apos;/getLoanUser&apos;, &apos;payTool.billquery.getLoanUser&apos;);
    };

    # controller/home.js
    module.exports = function* () {
        this.body = &apos;Hello World&apos;;  // 响应给客户端
    };

    # controller/payTool/billquery.js
    module.exports = app =&gt; {
        class BillqueryController extends app.Controller {
            async getLoanUser(){
                const { ctx, app, service } = this;
                const response = await service.payTool.billquery.getRepayPlan(ctx.request.body);
                ctx.body = response;
            }
        }
    }


二、路由中间件 - 在访问路由之前通过中间件来对路由进行一些处理

    app.get(&apos;router-name&apos;, &apos;middleware1&apos;, &apos;middleware2&apos;, &apos;controlll&apos;);

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

    2、路由中调用

        注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

        // 引用中间件
        const checkAuth = app.middleware.checkAuth();

        // 不需要验证
        app.get(&apos;/&apos;, &apos;home.index&apos;);
        app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

        // 需要验证是否登录的
        app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表


三、参数获取

    1、获取url参数 ctx.query

        http://127.0.0.1:7001/search?name=egg  取出name的值

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, app.controller.search);
        };

        // app/controller/search.js
        module.exports = function* (ctx) {
            tx.body = `search: ${this.query.name}`;
        };


    2、路由参数 ctx.params

        http://127.0.0.1:7001/user/123/xiaoming   取出 123、xiaoming

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/user/:id/:name&apos;, app.controller.user.info);
        };

        // app/controller/user.js
        exports.info = function* (ctx) {
            ctx.body = `user: ${ctx.params.id}, ${ctx.params.name}`;
        };


四、重定向 - 当路由不存在时会走一个默认的路由

    1、内部重定向

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;index&apos;, &apos;/home/index&apos;, &apos;home.index&apos;);
            app.redirect(&apos;/&apos;, &apos;/home/index&apos;, 302);
        };

    2、外部重定义 controller中来执行路由的跳转 redirect

        // app/router.js
        module.exports = app =&gt; {
            app.get(&apos;/search&apos;, &apos;search&apos;);
        };

        // app/controller/search.js
        module.exports = function* () {
            const type = this.query.type;
            const q = this.query.q || &apos;nodejs&apos;;

            // 这里跳转
            ctx.redirect(&apos;/admin/home&apos;);
        };

五、多路由映射 - 将路由分类并用一个路由主文件加载其它的路由文件

    // router.js 通过一个主文件将两个路由加载进来
    module.exports = app =&gt; {
        require(&apos;./router/news&apos;)(app);
        require(&apos;./router/admin&apos;)(app);
    };

    // router/news.js
    module.exports = app =&gt; {
        app.get(&apos;/news/list&apos;, app.controller.news.list);
        app.get(&apos;/news/detail&apos;, app.controller.news.detail);
    };

    // router/admin.js
    module.exports = app =&gt; {
        app.get(&apos;/admin/user&apos;, app.controller.admin.user);
        app.get(&apos;/admin/log&apos;, app.controller.admin.log);
    };

六、路由规则

    // app/router.js
    module.exports = app =&gt; {
        app.get(/^\/package\/([\w-.]+\/[\w-.]+)$/, app.controller.package.detail);
    };
</code></pre><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><pre><code>controller继承于app.controller, 负责解析用户输入，处理后返回相应的结果, 框架推荐Controller层主要对用户请求参数进行处理（校验、转换），然后用service处理业务结果并返回

用户HTTP请求（路由处理） &lt;=&gt; 校验组装（controller处理）&lt;=&gt; 业务处理（service）

一、Controller的两种写法

    1、函数写法

        // app/controller/posts.js
        exports.index = function* () {};
        exports.new = function* () {};
        exports.create = function* () {};

        // router 调用
        app.get(&apos;/index&apos;, &apos;posts/index&apos;);
        app.get(&apos;/new&apos;, &apos;posts/new&apos;);
        app.get(&apos;/create&apos;, &apos;posts/create&apos;);


    2、类写法

        // app/controller/post.js
        module.exports = app =&gt; {
            class PostController extends app.Controller {       // 定义一个PostController的类，继承了app.Controller
                * create() {
                    const { ctx, service } = this;
                    const createRule = {
                        title: { type: &apos;string&apos; },
                        content: { type: &apos;string&apos; },
                    };
                    // 校验参数
                    ctx.validate(createRule);
                    // 组装参数
                    const author = ctx.session.userId;
                    const req = Object.assign(ctx.request.body, { author });
                    // 调用 Service 进行业务处理
                    const res = yield service.post.create(req);
                    // 设置响应内容和响应状态码
                    ctx.body = { id: res.id };
                    ctx.status = 201;
                }
            }
            return PostController;
        }

        // router 调用   app/router.js
        module.exports = app =&gt; {
            app.post(&apos;createPost&apos;, &apos;/api/posts&apos;, &apos;post.create&apos;);
        }


二、app.Controller下this上挂载的几个属性

    1、this.ctx: 当前请求的上下文Context对象的实例

    2、this.app: Application对象的实例，可以取到框架的全局对象和方法

    3、this.service: 取到service下的方法

    4、this.config: 获取或添加修改config的配置

    5、this.logger: 日志打印


三、获取请求

    ctx.method: 请求方法

    ctx.path: 请求路径

    ctx.host: 请求IP

    1、query 获取GET请求中传递参数

        url: /posts?category=egg&amp;language=node  通过context.query拿到url的参数  

        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;

                const queryName = ctx.query;    // {category: &apos;egg&apos;, language: &apos;node&apos;}
                ctx.body = queryName;
            }
        }

    2、queries 能取到重复的参数key

        // posts?category=egg&amp;id=1&amp;id=2&amp;id=3 参数解析成对象,id有多个

        class QueryController extends app.Controller{
            async getQuery(app){
                const { ctx, app, service } = this;

                const queryName = ctx.queries;    // {category: &apos;egg&apos;, id: [1,2,3]}
                ctx.body = queryName;
            }
        }

    3、params 参数   

        路由: app.get(&apos;/projects/:projectId/app/:appId&apos;, &apos;app.listApp&apos;);

        // 请求: GET /projects/1/app/2
        class QueryController extends app.Controller{
            async getParams(app){
                const { ctx, app, service } = this;

                const params = {
                    id: ctx.params.projectId,
                    appid: ctx.params.appId
                };
                ctx.body = queryName;
            }
        }

    4、body 获取post传的数据

        框架内置bodyParser中间件，挂载到 context.request.body上，来取post的内容

        ctx.request.body  来获取post传过来的参数 {&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;1111&quot;}

        exports.listPosts = function* (ctx) {
            assert.equal(ctx.request.body.title, &apos;controller&apos;);
            assert.equal(ctx.request.body.content, &apos;what is controller&apos;);
        };

        &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;&quot; /&gt;
        &lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot; /&gt;

        config.default.js设置， 默认body最大长度为100kb
        bodyParser: {
            jsonLimit: &apos;1mb&apos;,
            formLimit: &apos;1mb&apos;,
        }

    5、获取上传文件

        浏览器上都是通过 Multipart/form-data 格式发送文件的，框架通过内置 Multipart 插件来支持获取用户上传的文件

        &lt;form method=&quot;POST&quot; action=&quot;/upload?_csrf={{ ctx.csrf | safe }}&quot; enctype=&quot;multipart/form-data&quot;&gt;
            title: &lt;input name=&quot;title&quot; /&gt;
            file: &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;
            &lt;button type=&quot;submit&quot;&gt;上传&lt;/button&gt;
        &lt;/form&gt;

        const path = require(&apos;path&apos;);
        const sendToWormhole = require(&apos;stream-wormhole&apos;);

        module.exports = function* (ctx) {
            const stream = yield ctx.getFileStream();
            const name = &apos;egg-multipart-test/&apos; + path.basename(stream.filename);
            // 文件处理，上传到云存储等等
            let result;
            try {
                result = yield ctx.oss.put(name, stream);
            } catch (err) {
                // 必须将上传的文件流消费掉，要不然浏览器响应会卡死
                yield sendToWormhole(stream);
                throw err;
            }
            ctx.body = {
                url: result.url,
                // 所有表单字段都能通过 `stream.fields` 获取到
                fields: stream.fields,
            };
        };


        在config/config.default.js 中配置来新增支持的文件扩展名，或者重写整个白名单

        新增支持的文件扩展名
        module.exports = {
            multipart: {
                fileExtensions: [ &apos;.apk&apos; ], // 增加对 .apk 扩展名的支持
            },
        };

        覆盖整个白名单
        module.exports = {
            multipart: {
                whitelist: [ &apos;.png&apos; ], // 覆盖整个白名单，只允许上传 &apos;.png&apos; 格式
            },
        };

    6、发送HTTP响应

        1）设置status

            exports.create = function* (ctx) {
                // 设置状态码为 201
                ctx.status = 201;
            };

        2）设置body 响应给请求方

            exports.show = function* (ctx) {
                ctx.body = {
                    name: &apos;egg&apos;,
                    category: &apos;framework&apos;,
                    language: &apos;Node.js&apos;,
                };
            };
            exports.page = function* (ctx) {
                ctx.body = &apos;&lt;html&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/html&gt;&apos;;
            };
</code></pre><h4 id="ctx-header-头"><a href="#ctx-header-头" class="headerlink" title="ctx.header 头"></a>ctx.header 头</h4><pre><code>获取整个 header 对象的方法: context.headers、context.header、context.request.headers、context.request.header

get()方法获取请求 header 中的一个字段的值、字段不存在返回null:  context.get(name)、context.request.get(name)

一、获取header

    1、ctx.header 取出头信息

        async from(ctx){
            console.log(ctx.header);
        }

        返回结果
        { 
            host: &apos;127.0.0.1:7001&apos;,
            connection: &apos;keep-alive&apos;,
            &apos;content-length&apos;: &apos;21&apos;,
            &apos;postman-token&apos;: &apos;a7e094b5-21ce-eb94-e403-3d517c832f30&apos;,
            &apos;cache-control&apos;: &apos;no-cache&apos;,
            origin: &apos;chrome-extension://aicmkgpgakddgnaphhhpliifpcfhicfo&apos;,
            &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;,
            &apos;content-type&apos;: &apos;application/json&apos;,
            accept: &apos;*/*&apos;,
            &apos;accept-encoding&apos;: &apos;gzip, deflate, br&apos;,
            &apos;accept-language&apos;: &apos;zh-CN,zh;q=0.8,en;q=0.6&apos;,
            cookie: &apos;csrfToken=RNHUjeOf0Zsl9jNl2f5BhreT&apos; 
        }

    2、ctx.protocol 协议

    3、ctx.ips 返回ip 一个数组

    4、ctx.ip 返回请求方的ip

    5)、ctx.host


二、设置header

    context.set(key, value) 方法可以设置一个响应头，context.set(headers) 设置多个 Header。

    exports.show = function* (ctx) {
        const start = Date.now();
        ctx.body = yield ctx.service.post.get();
        const used = Date.now() - start;
        // 设置一个响应头
        ctx.set(&apos;show-response-time&apos;, userd.toString());
    };
</code></pre><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><pre><code>可以通过context.cookies来获取和设置cookie值

一、cookie操作

    获取 ctx.cookies.get(&apos;count&apos;);

    设置 ctx.cookies.set(&apos;count&apos;, ++count);

    删除 ctx.cookies.set(&apos;count&apos;, null);


二、设置options

    context.cookies.set(key, value, options)

    1、maxAge: nunber - 在浏览器保存最长时间

    2、expires: date - 设置这个键值的失效时间

    3、path: string - 设置生效的URL路径

    4、domain: string - 设置生效的域名

    5、httpOnly: boolean - 设置是否可以被js访问

    6、secure: boolean - 设置键值只在HTTPS连接上传输

    7、overwrite: boolean - 设置key相当键值如何处理，true为后设置的覆盖前面设置的，false发送两个

    8、sign: boolean - 对cookie是否进行签名，true防止前端对这个值进行篡改

    9、encrypt: boolean - 对cookie进行加密

    ctx.cookies.set(key, value, {
        httpOnly: false,
        sign: false,
    });


三、Cookie 密钥

    config/config.default.js

    module.exports = {
        keys: &apos;key1,key2&apos;,
    };
</code></pre><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><pre><code>context.session 来访问或者修改当前用户 Session 

1、读取和设置 Session

    exports.fetchPosts = function* (ctx) {

        // 获取 Session 上的内容
        const user = ctx.session.user;
        const posts = yield ctx.service.post.fetch(userId);

        // 修改 Session 的值
        ctx.session.user = ctx.session.user ? ctx.session.user++ : 1;

        ctx.body = {
            success: true,
            posts,
        };
    };


2、删除session

    exports.deleteSession = function* (ctx) {
        ctx.session = null;
    };


3、设置 session配置

    // config.default.js

    exports.session = {
        key: &apos;EGG_SESS&apos;,
        maxAge: 24 * 3600 * 1000, // 1 天
        httpOnly: true,
        encrypt: true,
    };
</code></pre><h4 id="service-处理业务逻辑"><a href="#service-处理业务逻辑" class="headerlink" title="service 处理业务逻辑"></a>service 处理业务逻辑</h4><pre><code>service 需要继承于 app.Service，service在复杂业务场景下做业务逻辑封装的抽象层

一、service的ctx

    1、this.ctx.curl - 发起网络调用

    2、this.ctx.service.otherService - 调用service

    3、this.ctx.db - 发起数据库调用


二、Example

    // 调用服务 app/controller/user.js
    module.exports = app =&gt; {
        class User extends app.controller {
            async addUser(){
                let userData = {
                    name: &apos;siguang&apos;,
                    password: &apos;xxxxxx&apos;
                }
                let isAddUser = yield ctx.service.user.createUser(userData)
                if(setUser){
                    ctx.body = &apos;添加成功&apos;
                }
                ctx.body = isAddUser ? &apos;添加成功&apos; : &apos;添加失败&apos;;
            }
        }
    }

    // 定义一个Service app/service/user.js
    module.exports = app =&gt; {                   // 中间件支持两个参数 options中间件配置，app当前应用Application的实例
        class User extends app.Service {

            async createUser(params){
                const url = &apos;/account/blance/createUser&apos;;
                let result = await this.ctx.curl(url, {
                    method: &apos;POST&apos;,
                    dataType: &apos;json&apos;,   // 自动解析 JSON response
                    data: params,
                    timeout: 15000,     // 15 秒超时
                }

                this.ctx.logger.info(&apos;响应结果：&apos;, result.data);
                return result.data;
            }
        }
        return User;
    };
</code></pre><h4 id="中间件-Middleware"><a href="#中间件-Middleware" class="headerlink" title="中间件 Middleware"></a>中间件 Middleware</h4><pre><code>一、config.default.js 配置全局

    module.exports = {
        // 配置需要的中间件，数组顺序即为中间件的加载顺序
        middleware: [ &apos;gzip&apos; ],
        // 配置 gzip 中间件的配置
        gzip: {
            threshold: 1024, // 小于 1k 的响应体不压缩
        },
    };

    // 框架中默认的中间件
    module.exports = {
        bodyParser: {
            jsonLimit: &apos;10mb&apos;,
        },
    };


二、通用配置

    enable：控制中间件是否开启。

    match：设置只有符合某些规则的请求才会经过这个中间件。

    ignore：设置符合某些规则的请求不经过这个中间件。

    bodyParser: {
        enable: false,
        jsonLimit: &apos;10mb&apos;,
    },


三、Example: 

    1、创建中间件 checkAuth.js  middleware

        module.exports = app =&gt; {
            return async function checkAuth(ctx, next){
                const user = ctx.session.user;
                console.log(`UserSession ------ ${JSON.stringify(user)}`)

                if(user){
                    console.log(`visited true`);
                    await next();
                }
                else{
                    console.log(`visited false`);
                    ctx.body = {
                        data:{},
                        status: 10001,
                        message: &apos;Session失效&apos;
                    }
                }
            } 
        }

    2、路由中调用

        注意如果路由中使用中间件分为全局和和单个路由第一次两种，如果配置到config.default.js中的就为全局

        // 引用中间件
        const checkAuth = app.middleware.checkAuth();

        // 不需要验证
        app.get(&apos;/&apos;, &apos;home.index&apos;);
        app.get(&apos;/query&apos;, &apos;query.query.queryPage&apos;);

        // 需要验证是否登录的
        app.post(&apos;/web/getUserList&apos;, checkAuth, &apos;user.user.getUserList&apos;);            // 获取用户列表
</code></pre><h4 id="Validate-参数校验插件"><a href="#Validate-参数校验插件" class="headerlink" title="Validate 参数校验插件"></a>Validate 参数校验插件</h4><pre><code>validate只用于post请求的参数校验，get请求取出的都是字符串

一、在config/plugin.js配置中添加

    exports.validate = {
        enable: true,
        package: &apos;egg-validate&apos;,
    };


二、Exmaple

    async refundApply() {
        const { ctx, app, service } = this;
        const paramRule = {
            partnerUserId: { type: &apos;string&apos; },
            applyUserName: { type: &apos;string&apos; },
            amount: { type: &apos;string&apos; }, 
            sourceAccount: { type: &apos;string&apos; }, 
        };

        const paramErrors = app.validator.validate(paramRule, ctx.request.body);
        if (paramErrors) {
            ctx.body = app.renderBody({
                statusType: app.statusType.paramsError,
                error: paramErrors,
            });
            return;
        }

        const response = await service.payTool.billquery.refundApply(ctx.request.body);
        ctx.body = response;
    }


三、验证规则  

    1、required - 是否当前字段必须有，required: false 可以为空

    2、allowEmpty - 允许为空

    2、int - 只能为整数

    3、number - 可以是整数和浮点数

    4、date - 日期 &apos;YYYY-MM-DD&apos;     birthoday: &apos;date&apos;

    5、dateTime - 日期 YYYY-MM-DD HH:mm:ss

    6、boolean - 是否是布尔值        working: &apos;boolean&apos;

    7、string - 是否是字符串, 字符串的四个规则:            

        allowEmpty - 允许为空字符串

        format - 使用正则来验证字符串的格式

        max - 字符串最大长度

        min - 字符串最小长度

        const rule = {
            username: { allowEmpty: true, min: 10, max: 100, format: /^\d+$/ }
        }

    8、email - 是否是email格式

    9、password - 密码验证规则 max最大、min最小、compare比较  pass: {type: password, max: 32, min: 6}

    10、url - 是否是url

    11、enum - 如果是枚举需要加一个规则

        // operateType的值必须是values数组中的一项，values必须为数组
        const paramRule = {
            operateType: { type: &apos;enum&apos;, values: [&apos;REPAYMENT&apos;, &apos;CHARGE&apos;] },        
        }
        const paramErrors = app.validator.validate(paramRule, ctx.request.body);

    12、object - 如果是对象，需要加一个规则 

    13、array - 如果是数组，需要加一个规则

        itemType 数组中每一个元素的规则 
        rule - An object that validate the items of the array. Only work with itemType.
        max - 数组最大长度
        min - 数组最小长度

    https://github.com/node-modules/parameter#rule
    https://github.com/node-modules/parameter/blob/master/benchmark.js
    https://github.com/node-modules/parameter/blob/master/example.js
</code></pre><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><pre><code>jsonp只能get请求

// config/config.default.js  jsonp的配置
exports.jsonp = {
    callback: &apos;callback&apos;, // 识别 query 中的 `callback` 参数
    limit: 100, // 函数名最长为 100 个字符
};


// app/router.js  路由加jsonp中间件
module.exports = app =&gt; {
    const jsonp = app.jsonp();
    app.get(&apos;/api/posts/:id&apos;, jsonp, &apos;posts.show&apos;);         // 通过jsonp中间件来让路由支付一个中间件
    app.get(&apos;/api/posts&apos;, jsonp, &apos;posts.list&apos;);
};

// app/controller/posts.js
exports.show = function* (ctx) {
    ctx.body = {
        name: &apos;egg&apos;,
        category: &apos;framework&apos;,
        language: &apos;Node.js&apos;,
    };
};

用户请求 /api/posts/1?callback=fn，响应为 JSONP 格式，如果用户请求 /api/posts/1
</code></pre><h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><pre><code>Node模拟客户端请求，curl请求默认 content-type: application/x-www-form-urlencoded,

app.curl(url, options) 和 app.httpclient.request(url, options) 两种方法相同

一、Example:

    module.exports = app =&gt; {
        class HttpClientController extends app.Controller{
            async getHttpClient(){
                const {ctx, app, service} = this;

                let result = await this.ctx.curl(&apos;http://goucai.diyicai.com/lottery/getissue.action?lotteryId=001&amp;issueLen=100&amp;d=1502966960306&apos;, {
                    methods: &apos;get&apos;
                });

                let phones = [];
                let resultObj = JSON.parse(result.data.toString());
                resultObj.forEach((data, idx, arr)=&gt;{
                    console.log(&apos;data------&apos;, data);
                    phones.push(data.endTime);
                })

                ctx.body = phones.join(&apos;,&apos;)
            }
        }
        return HttpClientController;
    }


二、config配置 // config/config.default.js

    exports.httpclient = {
        // 默认开启 http/https KeepAlive 功能
        keepAlive: true,

        // 空闲的 KeepAlive socket 最长可以存活 4 秒
        freeSocketKeepAliveTimeout: 4000,

        // 当 socket 超过 30 秒都没有任何活动，就会被当作超时处理掉
        timeout: 30000,

        // 允许创建的最大 socket 数
        maxSockets: Infinity,

        // 最大空闲 socket 数
        maxFreeSockets: 256,

        // 是否开启本地 DNS 缓存，默认关闭
        // 一旦设置开启，则每个域名的 DNS 查询结果将在进程内缓存 10 秒
        enableDNSCache: false,
    };


三、options对象

    let options = {};
    const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, options);

    1、mothod: 请求方法

    2、data: 需要发送的数据 { foo: &apos;bar&apos; }

    3、dataAsQueryString: Boolean 如果为 true 即使在post情况下，也会强制将options.data以 querystringstringify处理后拼接到url的query参数上

    4、content（String|Buffer）: 发送请求的正文，如果设置了此参数会忽略data参数

        ctx.curl(url, {
            method: &apos;POST&apos;,
            // 直接发送原始 xml 数据，不需要 HttpClient 做特殊处理
            content: &apos;&lt;xml&gt;&lt;hello&gt;world&lt;/hello&gt;&lt;/xml&gt;&apos;,
            headers: {
                &apos;content-type&apos;: &apos;text/html&apos;,
            },
        });

    5、stream（ReadStream）: 发送请求正文的可读数据流

        ctx.curl(url, {
            method: &apos;POST&apos;,
            stream: fs.createReadStream(&apos;/path/to/read&apos;),
        });

    6、writeStream: 接受响应数据的可写数据流

        ctx.curl(url, {
            writeStream: fs.createWriteStream(&apos;/path/to/store&apos;),
        });

    7、consumeWriteStream: Boolean 是否等待 writeStream 完全写完才算响应全部接收完毕，默认是 true

    8、contentType: 请求数据的格式，默认undefined

    9、dataType: 响应数据格式

    10、headers: 自定义请求头

    11、timeout: 请求超时时间 默认是 [ 5000, 5000 ]，即创建连接超时是 5 秒，接收响应超时是 5 秒。

    12、agent: 

    13、httpsAgent

    14、auth、digestAuth

    15、followRedirect：Boolean 是否自动跟进3xx的跳转响应

    16、maxRedirects: number 最大自动跳转次数

    17、formatRedirectUrl: 自定义实现302、301

    18、beforeRequest: 请求发送前会调用beforeRequest钩子

        ctx.curl(url, {
            beforeRequest: options =&gt; {
                // 例如我们可以设置全局请求 id，方便日志跟踪
                options.headers[&apos;x-request-id&apos;] = uuid.v1();
            }
        });

    19、streaming：是否直接返回响应流

    20、gzip: Boolean是否开始gzip

    21、timing: Boolean 是否开启请求各阶段的时间没是


四、Get请求

    1、options.method = &apos;post&apos;  设置请求参数，默认是get请求可以不用加

         const result = yield ctx.curl(&apos;https://httpbin.org/get?foo=bar&apos;, {method: post});

    2、status: 响应状态码

    3、headers: 响应头信息 有{&apos;conent-type&apos;: &apos;text/html&apos;}

    4、data: 响应body, 返回的是Buffer类型, 如果设置了options.dataType会根据参数来处理


五、Post请求

    module.exports = function* post(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {

            // 必须指定 method
            method: &apos;POST&apos;,

            // 通过 contentType 告诉 HttpClient 以 JSON 格式发送
            contentType: &apos;json&apos;,

            // 要传的数据 
            data: {
                hello: &apos;world&apos;,
                now: Date.now(),
            },

            // 明确告诉 HttpClient 以 JSON 格式处理返回的响应 body
            dataType: &apos;json&apos;,
        });
        ctx.body = result.data;
    };


六、From表单提交

    以 ontent-type: application/x-www-form-urlencoded 的格式提交请求数据

    // app/controller/form.js
    module.exports = function* form(ctx) {
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT 和 DELETE
            method: &apos;POST&apos;,
            // 不需要设置 contentType，HttpClient 会默认以 application/x-www-form-urlencoded 格式发送请求
            data: {
                now: Date.now(),
                foo: &apos;bar&apos;,
            },
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.form;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;foo&quot;: &quot;bar&quot;,
        //   &quot;now&quot;: &quot;1483864184348&quot;
        // }
    };


七、Multipart 方式上传

    From 表单提交时包含文件的时候，需要用到 multipart/form-data 进行提交了

    引用fromstream 第三方模块

    // app/controller/multipart.js
    const FormStream = require(&apos;formstream&apos;);
    module.exports = function* multipart(ctx) {
        const form = new FormStream();

        // 设置普通的 key value
        form.field(&apos;foo&apos;, &apos;bar&apos;);

        // 上传当前文件本身用于测试
        form.file(&apos;file&apos;, __filename);
        const result = yield ctx.curl(&apos;https://httpbin.org/post&apos;, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 生成符合 multipart/form-data 要求的请求 headers
            headers: form.headers(),
            // 以 stream 模式提交
            stream: form,
            // 明确告诉 HttpClient 以 JSON 格式处理响应 body
            dataType: &apos;json&apos;,
        });

        ctx.body = result.data.files;
        // 响应最终会是类似以下的结果：
        // {
        //   &quot;file&quot;: &quot;&apos;use strict&apos;;\n\nconst For....&quot;
        // }
    };

    // 添加更多文件
    form.file(&apos;file1&apos;, file1);
    form.file(&apos;file2&apos;, file2);


八、以Stream 方式上传文件

    Stream 实际会以 Transfer-Encoding: chunked 传输编码格式发送

    // app/controller/stream.js
    const fs = require(&apos;fs&apos;);
    module.exports = function* stream(ctx) {
        // 上传当前文件本身用于测试
        const fileStream = fs.createReadStream(__filename);

        // httpbin.org 不支持 stream 模式，使用本地 stream 接口代替
        const url = `${ctx.protocol}://${ctx.host}/stream`;
        const result = yield ctx.curl(url, {
            // 必须指定 method，支持 POST，PUT
            method: &apos;POST&apos;,
            // 以 stream 模式提交
            stream: fileStream,
        });

        ctx.status = result.status;
        ctx.set(result.headers);
        ctx.body = result.data;
        // 响应最终会是类似以下的结果：
        // {&quot;streamSize&quot;:574}
    };
</code></pre><h4 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h4><pre><code>读取数据渲染模板，呈现给用户

一、使用

    1、$ npm i egg-view-ejs --save         // 安装

    2、配置

        // config/plugin.js
        exports.nunjucks = {
            enable: true,
            package: &apos;egg-view-nunjucks&apos;        // 开启插件使用numjucks模板
        };

        // config/config.default.js
        exports.view = {
            defaultViewEngine: &apos;nunjucks&apos;,
            mapping: {
                &apos;.tpl&apos;: &apos;nunjucks&apos;,
            },
        };


    3、render、renderString两个方法

        render(fileName, locals, viewOptions): filenName: 文件路径、locals: 渲染的数据、viewOptions: 用户传入的配置

    render(name, locals) 渲染模板文件, 并赋值给 ctx.body

    renderView(name, locals) 渲染模板文件, 仅返回不赋值

    renderString(tpl, locals) 渲染模板字符串, 仅返回不赋值


- numjucks模板语法: http://mozilla.github.io/nunjucks/cn/templating.html  见模板md -
</code></pre><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><pre><code>Egg内置static插件，static默认映射到 public目录

app/public
├── css
│   └── news.css
└── js
    ├── lib.js
    └── news.js
</code></pre><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><pre><code>一、Application - 全局的方法和对象挂载到Application中

    // extend/application.js 创建全局对象
    module.exports = {
        // 全局返回状态类型
        statusType: &apos;STATUS_TYPE&apos;,

        // 生成返回报文
        renderBody(params) {
            if (typeof params.statusType === &apos;undefined&apos;) {
                throw new Error(&apos;statusType error&apos;);
            }
            const response = {
                data: params.data || {},
                message: params.message || this.statusMessage[params.statusType],
                status: params.statusType,
            };

            if (params.error) response.error = params.error;
            return response;
        }
    }

    // 调用 controller、service都可以
    module.exports = app =&gt; {
        return class UserController extends app.Controller {
            async fetch() {
                this.ctx.body = app.cache.get(this.ctx.query.id);
            }
        };
    };
</code></pre><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><pre><code>有些任务需要定时来完成，如定时上报，定时远程更新本地缓存，定时任务都统一存放在 app/schedule 目录下

创建一个定时任务 app/schedule/update_cache.js

module.exports = {
    // 通过 schedule 属性来设置定时任务的执行间隔等配置
    schedule: {
        interval: &apos;1m&apos;,     // 1 分钟间隔
        type: &apos;all&apos;,        // 指定所有的 worker 都需要执行
    },

    // task 是真正定时任务执行时被运行的函数，第一个参数是一个匿名的 Context 实例
    * task(ctx) {
        const res = yield ctx.curl(&apos;http://www.api.com/cache&apos;, {
            dataType: &apos;json&apos;,
        });
        ctx.app.cache = res.data;
    }
};
</code></pre><h4 id="框架扩展"><a href="#框架扩展" class="headerlink" title="框架扩展"></a>框架扩展</h4><pre><code>框架扩展自身功能: Application、Context、Request、Response、Helper，在这几个对象上扩展就在extend目录里创建相应的js文件，application.js

    Helper用来提供一些实用的utility函数

一、Application 全局应用对象扩展

    访问 ctx.app,  Controller，Middleware，Helper，Service 中都可以通过 this.app 访问到 Application 对象

    // app.js
    module.exports = app =&gt; {
        app.config
    };

    // 扩展 app.foo() 方法 app/extend/application.js
    module.exports = {
        foo(param) {
            // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性
        },
    };


二 、Context 扩展

    extend/content.js

    module.export = {
        async foo(param){
            ...
        }
    }

    引用 await this.ctx.foo({name: &apos;siguang&apos;});


三、Helper 用来编写一些实用函数

    // app/extend/helper.js
    const moment = require(&apos;moment&apos;);
    exports.relativeTime = time =&gt; moment(new Date(time * 1000)).fromNow();

    // 也可以在模板里面使用：
    &lt;!-- app/views/news/list.tpl --&gt;
    {{ helper.relativeTime(item.time) }}
</code></pre><h4 id="启动自定义"><a href="#启动自定义" class="headerlink" title="启动自定义"></a>启动自定义</h4><pre><code>用来进行应用启动时进行初始化工作

// 通过入口文件app.js
module.exports = app =&gt; {
    app.beforeStart(function* () {

        // 应用会等待这个函数执行完成才启动
        app.cities = yield app.curl(&apos;http://example.com/city.json&apos;, {
            method: &apos;GET&apos;,
            dataType: &apos;json&apos;,
        });
    });
};
</code></pre><h4 id="logger-日志"><a href="#logger-日志" class="headerlink" title="logger 日志"></a>logger 日志</h4><pre><code>this.ctx.logger.info(&apos;xxxxxx&apos;);

logger.debug()、logger.info()、logger.warn()、logger.error()

config.deubgger 文件配置

    logger: {
        level: &apos;DEBUG&apos;,
        dir: &apos;../app/logger&apos;,
    }
</code></pre><h4 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h4><pre><code>egg-bin模块（用于本地开发和单元测试）

package.json:

   {
       &quot;scripts&quot;: {
           &quot;dev&quot;: &quot;egg-bin dev --port 7001&quot;
       }
   }
</code></pre><h4 id="插件的开发"><a href="#插件的开发" class="headerlink" title="插件的开发"></a>插件的开发</h4><pre><code>自定义插件存储目录:  lib/plugin/...

egg-ua插件

1、创建package.json

    {
        &quot;eggPlugin&quot;: {
            &quot;name&quot;: &quot;ua&quot;
        }
    }

2、egg-ua/us.js插件文件

    module.exports = {
        get isIOS() {
            const iosReg = /iphone|ipad|ipod/i;
            return iosReg.test(this.get(&apos;user-agent&apos;));
        },
    };

3、config/plugin.js   通过path来挂载插件

    const path = require(&apos;path&apos;);
    exports.ua = {
        enable: true,
        path: path.join(__dirname, &apos;../lib/plugin/egg-ua&apos;),
    };
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>├── package.json
├── app.js (可选)            // 启动初始化
├── agent.js (可选)
├── app
|   ├── router.js           // 路由规则
│   ├── controller          // 处理用户的输入
│   |   └── home.js
│   ├── service (可选)       // 服务，编写业务逻辑
│   |   └── user.js
│   ├── middleware (可选)    // 中间件
│   |   └── response_time.js
│   ├── schedule (可选)      // 定时任务
│   |   └── my_task.js
│   ├── public (可选)        // 静态目录
│   |   └── reset.css
│   ├── view (可选)          // 模板
│   |   └── home.tpl
│   └── extend (可选)        // 框架扩展
│       ├── helper.js (可选)
│       ├── request.js (可选)
│       ├── response.js (可选)
│       ├── context.js (可选)     // ctx扩展
│       ├── application.js (可选)     // 全局方法
│       └── agent.js (可选)
├── config                  // 配置
|   ├── plugin.js
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test                    // 测试
    ├── middleware
    |   └── response_time.test.js
    └── controller
        └── home.test.js
</code></pre><blockquote>
<p>参考资料<br><a href="http://koa.bootcss.com/" target="_blank" rel="noopener">http://koa.bootcss.com/</a></p>
</blockquote>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://siguang1983.github.io/2016/12/04/Egg.js-框架/';
        this.page.title = 'EggJS基础';
        this.page.identifier = '2016/12/04/Egg.js-框架/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
