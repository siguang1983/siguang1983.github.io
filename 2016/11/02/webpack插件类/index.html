<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>webpack插件类 | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="功能1、自动刷新浏览器 - 修改代码编译后自动刷新浏览器

2、热替换 - 在不刷新整个网页的时候做到实时预览

    script: {
        &amp;quot;server&amp;quot;: &amp;quot;webpack-dev-server --open --hot --inline&amp;quot;
    }

    --hot 与在 new webpack.HotModuleReplacementPlugin() 相同

3、提取公用代码

    通过CommonsChunkPlugi" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#功能"><span class="toc-number">1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将业务逻辑与其它组件库分离"><span class="toc-number">2.</span> <span class="toc-text">将业务逻辑与其它组件库分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#require-ensure按需加载"><span class="toc-number">3.</span> <span class="toc-text">require,ensure按需加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插件类详解"><span class="toc-number">4.</span> <span class="toc-text">插件类详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gulp与webpack构建单页面与多页面总结"><span class="toc-number">5.</span> <span class="toc-text">gulp与webpack构建单页面与多页面总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack踩坑"><span class="toc-number">6.</span> <span class="toc-text">webpack踩坑</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            webpack插件类
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/02/webpack插件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-02T03:06:16.000Z" itemprop="datePublished">2016-11-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><pre><code>1、自动刷新浏览器 - 修改代码编译后自动刷新浏览器

2、热替换 - 在不刷新整个网页的时候做到实时预览

    script: {
        &quot;server&quot;: &quot;webpack-dev-server --open --hot --inline&quot;
    }

    --hot 与在 new webpack.HotModuleReplacementPlugin() 相同

3、提取公用代码

    通过CommonsChunkPlugin插件来提取指定业务文件中的公用库

4、按需加载、首屏加载

    &lt;!-- 加载 import(/* webpackChunkName: &quot;show&quot; */&apos;./show&apos;, then((show) =&gt; {
        show(&apos;webpack&apos;)
    })) --&gt;
</code></pre><h4 id="将业务逻辑与其它组件库分离"><a href="#将业务逻辑与其它组件库分离" class="headerlink" title="将业务逻辑与其它组件库分离"></a>将业务逻辑与其它组件库分离</h4><pre><code>将业务逻辑和第三方代码分离，不能将他们都合并到一个文件内，使这个js文件比较大，并且跳转到另一个地址也还会重新加载这些公用的文件

Example: 

    对引用的jquery单独提取

    1、import $ from &apos;jquery&apos;;     // js中引用的jquery, 先npm i jquery下载包

    2、webpack.config.js

        // 入口文件
        entry: {
            app: path.resolve(__dirname, &apos;web/js/index.js&apos;),
            vendor: [&apos;jquery&apos;]
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;,
            chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        plugins: [
            // 将在html文件中添加&lt;script&gt;引用，并生创建到指定的目录中
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,
                filename: &apos;./web/index.html&apos;,
                template: &apos;./web/index.html&apos;,
                chunks: [&apos;app&apos;, &apos;vendor&apos;],            // 这里要把vendor依赖的文件加上，不然生成的html只有引用app.min.js，不会引用jquery.vendor.js
                inject: true,
                hash: true
            }),

            // 拆分插件
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendor&apos;,                            // 上面入口定义的节点组
                filename: &apos;jquery.vendor.js?[hash]&apos;     // 最后生成的文件名
            }),
        }
</code></pre><h4 id="require-ensure按需加载"><a href="#require-ensure按需加载" class="headerlink" title="require,ensure按需加载"></a>require,ensure按需加载</h4><pre><code>require()与require.ensure()加载的不同

1、require(): AMD加载规范，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数

2、require.ensure(): requi.ensure的依赖模块只会被先下载下来，但不会被执行，会将require.ensure()内加载的模块合成一个文件，在

    如果webpack打包会将所有资源加到一个文件中，这样会使这个文件变的很大，require.ensure()来对加载的资源单独打包

    require.ensure([], function(require) {
        var dialog = require(&apos;./components/dialog&apos;);
        // todo ...
    });

    CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好

    webpack.config.js中配置

        var chunks = Object.keys(entries);
        plugins: [
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendors&apos;,             // 将公共模块提取，生成名为`vendors`的chunk
                chunks: chunks,
                minChunks: chunks.length     // 提取所有entry共同依赖的模块
            })
        ]

http://blog.csdn.net/zhbhun/article/details/46826129
https://segmentfault.com/a/1190000007775743
</code></pre><h4 id="插件类详解"><a href="#插件类详解" class="headerlink" title="插件类详解"></a>插件类详解</h4><pre><code>* webpack-dev-server - webpack自带服务

webpack自带的插件
* CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin - 提取公用部分
* uglifyJsPlugin - js压缩

外部加载插件
* HotMooduleReplacementPlugin() - 热替换
* html-webpack-plugin - 解析html模板
* web-webpack-plugin - 与html-webpack-plugin类型国内人写的https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md
* extract-text-webpack-plugin - 单独打包css文件
* open-browser-webpack-plugin - 资源构建成功后自动打开浏览器 
* clean-webpack-plugin - 清除文件夹,添加hash后，会导致改变文件内容重新打包时文件名不同越来越多，使用clean-webpack-plugin

* babel-plugin-react-transform react-transform-hmr - react的热更新, 需要在配置bable.rc
* ExtractTextPlugin - 将js中引用的css文件抽取出一个单独的css文件
* webpack-merge - 合并数组、函数
* webpack-dev-middleware - devServer就是基于webpack-dev-middleware和ExpressJS来实现的
* imagemin-webpacl-plugin - 压缩图片
* webpack-spritesmith - 制作雪碧图
* HotModuleReplacementPlugin - devServer热更新

一、webpack-dev-server webpack自带服务

    webpack-dev-server有两种模式支持自动刷新——iframe模式和inline模式。

    1、iframe模式: 页面是嵌套在一个iframe下的，在代码发生改动的时候，这个iframe会重新加载;使用iframe模式无需额外的配置，只需在浏览器输入以下地址: http://localhost:8080/webpack-dev-server/index.html

    2、inline模式: 一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。

    以下三种配置都可以实现页面的刷新效果: 

        // 1.启动webpack-dev-server的时候带上inline参数
        webpack-dev-server --inline

        // 2.给HTML插入JS
        &lt;script src=&quot;http://localhost:3000/webpack-dev-server.js&quot;|&lt;/script|

        // 3.webpack配置
        entry: [
            &apos;webpack-dev-server/client?http://localhost:3000&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ]


二、HotMooduleReplacementPlugin() 热替换

    webpac-dev-server支持模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉。使用HMR功能也有两种方式: 命令行方式和Node.js API。

    1、cli命令行方式  webpack-dev-server --inline --hot

    2、Node.js API方式

        entry: [
            &apos;webpack/hot/dev-server&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ],
        devServer: {
            hot: true
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin(),
        ]


三、html-webpack-plugin 解析html模板

    插件将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

    $ npm i html-webpack-plugin

    $ const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);            // 引用插件

    1、单入口配置

        // 这里省略其他配置代码
        plugins: [
            // 使用这个plugin，这是最简单的一个配置，更多资料可到github查看
            new HtmlWebpackPlugin({
                title: &apos;zhufeng-react&apos;,
                template: &apos;./src/index.html&apos;,
            })
        ]

    2、多入口配置

        会将两个入口分别对html文件进行加载指定的入口js文件

        // 入口文件
        entry: {
            app: &apos;./web/js/index.js&apos;,
            list: &apos;./web/js/list.js&apos;
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;
        },

        plugins: [
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,                    // 生成html文档的标题
                filename: &apos;./web/index.html&apos;,    // 输出文件名称
                template: &apos;./web/index.html&apos;,    // 本地模板的位置，支持(handlebars、ejs、undersore、html)
                chunks: [&apos;app&apos;],                // 对应的入口entry, 也可以是数组[&apos;app&apos;, &apos;list&apos;]
                inject: true,                    // 向template中注入所有静态资源
                hash: true                        // 为静态资源添加webpack每次编译产生的唯一hash值， &lt;script type=&quot;text/javascript&quot; src=&quot;common.js?a3e1396b501cdd9041be&quot;&gt;&lt;/script&gt;
            }),
            new HtmlWebpackPlugin({
                title: &apos;list&apos;,
                filename: &apos;./web/list.html&apos;,
                template: &apos;./web/list.html&apos;,
                chunks: [&apos;list&apos;],
                inject: true,
                hash: true
            })
        ]

    https://segmentfault.com/q/1010000009810148
    https://www.cnblogs.com/wonyun/p/6030090.html


四、extract-text-webpack-plugin 单独打包css文件

    $ npm i extract-text-webpack-plugin


五、open-browser-webpack-plugin  资源构建成功后自动打开浏览器 --- 已可以在命令中配置

    1、package.json中加 --open，与使用此插件相同

        &quot;scripts&quot;: {
            &quot;start&quot;: &quot;webpack-dev-server --hot --inline --open&quot;,
        }


    2、$ npm install open-browser-webpack-plugin --save-dev

        var openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
            new openBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]


六、CSS Module

    webpack 的 css-loader 是解决这个问题的最好办法之一。简单配置一下: 
    module: {
      loaders: [{
        test: /\.css$/,
        loaders: [
          &apos;style-loader&apos;,
          &apos;css-loader?modules&amp;localIdentName=[name]__[local]___[hash:base64:5]&apos;,
          &apos;postcss-loader&apos;
        ]
      }]
    },
    postcss: [
      require(&apos;postcss-nested&apos;)(),
      require(&apos;cssnext&apos;)(),
      require(&apos;autoprefixer-core&apos;)({ browsers: [&apos;last 2 versions&apos;] })
    ]


七、UglifyJs Plugin 压缩资源

    var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;

    plugins: [
        new uglifyJsPlugin({
            compress: {
                warnings: false
            }
        }),
        new webpack.optimize.MinChunkSizePlugin({
            compress: {
                warnings: false
            }
        }),
        // 查找相等或近似的模块，避免在最终生成的文件中出现重复的模块
        new webpack.optimize.DedupePlugin(),
        // 按引用频度来排序 ID，以便达到减少文件大小的效果
        new webpack.optimize.OccurenceOrderPlugin(),
        new webpack.optimize.AggressiveMergingPlugin({
            minSizeReduce: 1.5,
            moveToParents: true
        })
    ]


八、clean-webpack-plugin 清除文件夹

    $ npm install clean-webpack-plugin --save-dev

    webpack.config.js:

        const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);

        plugins: [
            new CleanWebpackPlugin([&apos;dist&apos;]),
            new HtmlWebpackPlugin({
                title: &apos;Output Management&apos;
            })
        ]


九、react的热替换

    $ npm install --save-dev babel-plugin-react-transform react-transform-hmr

    .babelrc配置
        {
            &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
            &quot;env&quot;: {
                &quot;development&quot;: {
                &quot;plugins&quot;: [[&quot;react-transform&quot;, {
                    &quot;transforms&quot;: [{
                        &quot;transform&quot;: &quot;react-transform-hmr&quot;,

                        &quot;imports&quot;: [&quot;react&quot;],

                        &quot;locals&quot;: [&quot;module&quot;]
                    }]
                }]]
                }
            }
        }

十、ExtractTextPlugin 分享css和js文件

    $ npm install --save extract-text-webpack-plugin

    webpack.config.js

        const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

        module.exports = {
            entry: {},
            output: {},

            plugins:[
                new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
                new ExtractTextPlugin(&quot;style.css&quot;)
            ]

        }

十一、clean-webpack-plugin

    $ npm install clean-webpack-plugin --save

        const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);
        module.exports = {

            plugins: [
                &lt;!-- ...// 这里是之前配置的其它各种插件 --&gt;
                new CleanWebpackPlugin( &apos;build/*.*&apos;, {
                        root: __dirname,
                        verbose: true,
                        dry: false
                    }
                )
            ]
        }

十二、CommonsChunkPlugin

    const CommonsChunkPlugin = require(&apos;CommonsChunkPlugin&apos;);
    module.exports = {
        plugins: [
            new CommonsChunkPlugin({
                // 从哪些Chunk 中提取
                chunks: [&apos;a&apos;, &apos;b&apos;],
                // 提取的公共部分形成一个chunk
                name: &apos;common&apos;
            })
        ]
    }


十三、暴露全局对象

    如果想将report数据上报组件放到全局，有两种办法: 

    方法一: 
    在loader里使expose将report暴露到全局，然后就可以直接使用report进行上报
    {
        test: path.join(config.path.src, &apos;/js/common/report&apos;),
        loader: &apos;expose?report&apos;
    }

    方法二: 
    如果想用R直接代表report，除了要用expose loader之外，还需要用ProvidePlugin帮助，指向report，这样在代码中直接用R.tdw， R.monitor这样就可以
    new webpack.ProvidePlugin({
        &quot;R&quot;: &quot;report&quot;,
    })
</code></pre><h4 id="gulp与webpack构建单页面与多页面总结"><a href="#gulp与webpack构建单页面与多页面总结" class="headerlink" title="gulp与webpack构建单页面与多页面总结"></a>gulp与webpack构建单页面与多页面总结</h4><pre><code>1、gulp: 处理html、css都可以，对处理js依赖这块不占优势

2、webpack: 对js入口进行单页面构建和模块化开发，如果页面较多不占优势，多页面webpack也可以做到，不过将js合并并加载到html中配置比较麻烦，需要HtmlWebpackPlugin插件来完成，每一个页面都需要创建一次，也可以将公用进行提取chunks

3、gulp+webpck 构建多页面

    优点: gulp进行对html和css处理，webpack进行js的处理

    缺点: webpack如果需要合并js，还需要手动去改html的引用
</code></pre><h4 id="webpack踩坑"><a href="#webpack踩坑" class="headerlink" title="webpack踩坑"></a>webpack踩坑</h4><pre><code>一、安装完webpack后执行命令提示需要安装webpack

    webpack -h          // 提示没有装webpack-cli

    $ npm i webpack-cli --save-dev            // 如果全局没有安装就全局装一下 $ sudo npm i webpack-cli -g

    https://segmentfault.com/a/1190000013699050
</code></pre>
        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://siguang1983.github.io/2016/11/02/webpack插件类/';
        this.page.title = 'webpack插件类';
        this.page.identifier = '2016/11/02/webpack插件类/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
