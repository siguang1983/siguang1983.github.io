<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Tag: javascript | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/ES6/">ES6</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/ES6/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| let块级作用域、 const常量<br>| 解构赋值<br>| 箭头函数、default、rest、spread<br>| 模板字符串<br>| class: extends、super、constructor、静态属性和方法、实例属性<br>| Promise、Generator、async/await<br>| 模块化: import、export、as、*、default export<br>| 数据结构: Set不重复值的集合、Map<br>| Proxy 对象的拦截器<br>| Symbol<br>| symbol 独一无二的值<br>| Set、Map数据结构</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><pre><code>一、let 声明变量

    let完全可以取代var, 特性: 1、let不允许重复声明        2、没有预解析功能        3、块级作用域

    1、预解析功能

        console.log(a);        // 报错, 如果是原来的var声明这里会是undeined, 所以let没有预解析功能
        let a = 20;

    2、块级作用域 在{ }中声明的变量只能在括号里使用

        var name = &apos;lulu&apos;;
        function prsone(){
            let name = &apos;siguang&apos;;
        }

        prsone();
        console.log(name);            // &apos;lulu&apos;

        // 输出的都是10
        for(var i=0; i&lt;10; i++){
            setTimeout(function(){
                console.log(i);        // 使用var声明的i都会打印出9，如果使用let输出的就是0到10
            })
        }

二、const常量

    1、常量只允许赋一次值不能被修改        2、常量声明都为大写        3、与let相当只在块级作用域有效

    const NAME = &apos;siguang&apos;;        // 不能变化的值
    NAME = &apos;lulu&apos;;                // 报错

    if (true) {
        const MAX = 5;
    }
    MAX            // 报错，const与let相同都是在块内使用
</code></pre><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><pre><code>允许从数组和对象中提取的值，对变量进行赋值，被称为解构赋值

一、数组解构使用[]

    let [a, b, c] = [1, 2, 3];    // a=1, b=2, c=3

    // 默认值
    let [x, y = &apos;b&apos;] = [&apos;a&apos;];     // x=&apos;a&apos;, y=&apos;b&apos;


二、对象解构使用{}

    // 对象是按名字来解析赋值
    let obj = {
        getName: function(){}, 
        foo: &apos;aaa&apos;, 
        bar: &apos;bbb&apos;
    };
    let {foo, bar} = obj        // foo=&apos;aaa&apos;, bar=&apos;bbb&apos;

    // 对象的解构赋值，先找到同名，在将值赋给对应的变量
    let { foo: val, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };  
    console.log(val, bar)        // foo=&apos;undefined&apos;, val=&apos;aaa&apos;, bar=&apos;bbb&apos;


三、字符串的解构赋值

    const [a, b, c, d, e] = &apos;hello&apos;;    // a=h, b=e, c=l, d=l, e=o
    const [...tail] = &apos;hello&apos;;            // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]

    # length属性
    let {length: len} = &apos;hello&apos;;        // length = 5


四、默认参数 default

    # 参数作为数组
    function add([x, y]){
        return x * y
    }
    add([3,2]);        // 6

    # 参数作为对象，对x、y的默认初始值
    function move({x = 0, y = 0}) {
        return [x, y];
    }
    move({x: 3, y: 8}); // [3, 8] 


五、不定参数 Rest

    function f(x, ...y) {
        // y是一个数组
        return x * y.length;
    }
    f(3, &quot;hello&quot;, true) == 6


六、扩展运算符 Spread

    function f(x, y, z) {
        return x + y + z;
    }
    // 将数组中的每个元素展开为函数参数
    f(...[1,2,3])            // 6
</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>一、写到`...`之间，值的输出使用 ${...} 

二、可以写多行字符串，只写到`...`之间就可以

三、${...}可以解析变量、对象的值、表达式、函数返回

    let name = &apos;siguang&apos;;
    let obj = {
        age: 33
    }
    console.log(`你的名字是: ${ name } 你的年龄是:  ${ obj.age }`)

四、标签模板

    let a=10, b=20;
    dialog`Hello ${a+b} world ${a*b}`;        // 等同于 dialog()
</code></pre><h4 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h4><pre><code>一、箭头函数

    1、箭头函数的注意问题: 

        * 箭头函数里的this不是指向调用者，而指向对象
        * 不能当构造函数来用, 不能使用new
        * 函数内不存在arguments对象
        * 不可以使用yield命令，箭头函数不能用作Generator函数

        arr.sort(function(){  ...  }) 相当于 arr.sort((a, b) =&gt; a-b);

        // 箭头函数的this，不是指向调用者
        const Template = {
            test(){
                console.log(this);        // this指向Template

                document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                    /* 如果非箭头函数this应该指向 #showThis */
                    /* 这里箭头函数不是指向调用者，所以指向了 Template */
                    console.log(this);    
                }
            }
        }
        Template.test();

    2、var f = function(v){ return v; }

        // ES6写法
        var f = v =&gt; v;

    3、var sum = function(num1, num2){
            return num1 + num2;
        }

        // ES6写法
        var sum = (num1, num2) =&gt; {
            return num1 + num2;
        }

    4、对象中方法的简写

        var obj = {
            name: &apos;haha&apos;,
            getName(){                // 是getName: function(){}的简写
                console.log(this.name);
            },
            setName(name){
                this.name = name;
                console.log(this.name);
            }
        }


二、函数参数默认值

    function fn(a, b = 2){
        // b如果不传相当于2，等同于 var b = arguments.length &gt; 1 &amp;&amp; arguments[1] == undefined ? arguments[1] : 2;
        return {a, b}
    }
    console.log(fn(10));        // 返回{a: 10, b: 2}

    // 如果没有参数默认值时还需要在函数体内做兼容
    function fn(name){
        var getName = name || 20;
    }
    fn();


三、参数的解构赋值

        const full = ({ first, last }) =&gt; first + &apos; &apos; + last;    
        full({first: 20, last: 30})

        // 等同于
        // function full(person) {
        //      return person.first + &apos; &apos; + person.last;
        // }


四、rest 获取多余参数

    以&apos;...变量名&apos; 来获取多余的参数，返回一个数组，这样就不需要arguments对象了

    function person(...rest){
        console.log(rest);        // [1,2,3,4,5]
    }
    person(1,2,3,4,5);

    function person(a, ...rest){
        console.log(a);            // 1
        console.log(rest);        // [2,3,4,5]
    }
    person(1,2,3,4,5);


五、spread 扩展操作符 ...  与rest相反

    function add(x, y) {
        return x + y;        // 4+38
    }
    var numbers = [4, 38];            // 只能为数组不能为对象
    add(...numbers)         // 42

    # 可以将字符串转成数组
    let arr = [...&apos;hello&apos;];        // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]


六、name属性

    funciton foo(){ ... }
    foo.name;        // &apos;foo&apos; 返回函数名


七、::运算符

    箭头函数可以绑定this对象，减少显式this对象的写法(call、apply、bind)

    ES7提出了函数绑定来取代&quot;call、apply、bind&quot;调用，使用两个&quot;::&quot;

    foo::bar;        // 等同于 bar.bind(foo);
    foo::bar(...arguments);        // 等同于 bar.apply(foo, arguments);
</code></pre><h4 id="类、继承"><a href="#类、继承" class="headerlink" title="类、继承"></a>类、继承</h4><pre><code>一、类的一些特性

    1、对象方法的简写方法
        class Cat{
            getName(){        // 老写法 getName: function(){}
                ...
            }
        }

    2、通过__proto__属性可以直接调用父类
        var parent = {
            getParentName(){
                console.log(&apos;parent&apos;)
            }
        }

        var childer = {
            __proto__: parent,            // 通过__proto__指向parent, 就可以直接调用parent类中的方法
            getChildeName(){
                console.log(&apos;childer&apos;);
            }
        }

        childer.getChildeName();    // childer
        childer.getParentName();    // parent


二、创建类

    class Cat {
        // ES6中新型构造器, 用来初始化时这里接收参数
        constructor(name){ 
            this.name = name;
        }

        getName(){        // 公有方法
            console.log(this.name);
        }

        static bar(baz){        // 私有方法
            debugger;
            return this.name = baz;
        }

        * gen(){
            let arg = 10;
            yield arg;
        }
    }

    Cat.userName = &apos;siguang&apos;;

    var oCat = new Cat(&apos;哈哈&apos;);
    oCat.getName();
    oCat.bar(&apos;lulu&apos;);                // 报错静态方法调用不到，并且不会被继承
    oCat.gen().next()


三、继承 extends

    // 创建一个类
    class Person {
        constructor(name){
            this.name = name;
        }

        getName(){
            console.log(this.name);
        }
    }

    // 继承这个类
    class Children extends Person {
        constructor(name, color){
            super(name);                // super指向继承的构造函数Person的constructor
            this.color = color;
        }

        getColor(){
            console.log(this.name, this.color);
        }
    }

    // 实例化
    var op = new Person(&apos;siguang&apos;);
    op.getName();            // &apos;siguang&apos;

    var oc = new Children(&apos;lulu&apos;, &apos;red&apos;);        
    oc.getColor();        // &apos;red&apos;
    oc.getName();            // &apos;lulu&apos;


四、static 静态属性和方法

    类似构造函数，直接挂载到函数下的叫对象的属性和方法，而写到构造函数内部的叫构造函数的属性和方法

    1、静态方法前面需要加上&apos;static&apos;关键字，相当于只是函数下的方法而不是prototype的方法，静态方法可以被子类继承，

        class Foo{
            static methodName(){
                return &apos;hello&apos;
            }
        }
        Foo.methodName();    // hello

        var foo = new Foo();
        foo.methodName();    // 报错

    2、静态属性

        ES6中没有静态属性，只能声明静态方法，ES7中可以直接写到类内在进行转码

        class Foo {
            constructor(...arg){
                this.args = args;
            } 
            outputUserName(){
                console.log(this.username);    // 这里username未定义，除非在constructor中定义 this.username
            }
        }
        Foo.username = &apos;siguang&apos;;       // 类的静态属性

        var foo = new Foo();
        console.log(foo.personName);  // undefined
        foo.outputUserName();               // undefined 


五、实例属性

    注意: 一定要将实例属性和静态属性区分，实例属性写到constructor中this.username, new后的实例时候可以被实例方法调用，而静态属性只挂到了类下直接通过类来调取，Foo.username

    class Foo{
        constructor(){
            this.username = &apos;siguang&apos;;
        }
        showName(){
            console.log(this.username);     // siguang
            console.log(Foo.username);      // lulu
        }
    }
    Foo.username = &apos;lulu&apos;;

    var foo = new Foo();
    foo.showName();

    ****** ES7 中静态属性和实例属性的定义 ******
    class MyClass{
        usernameA = &apos;siguang&apos;;        // 实例属性

        showName(){
            console.log(this.usernameA);
        }
    }


六、super()方法

    继承时必须调用一次super方法，否则constructor中的this为undefined，调用父类的构造器进行初始化, 子类调用父类的构造函数

    class BaseModel {
        constructor(options, data) { // class constructor，node.js 5.6暂时不支持options = {}, data = []这样传参
            this.name = &apos;Base&apos;;
            this.url = &apos;http://azat.co/api&apos;;
            this.data = data;
            this.options = options;
        }
        getName() { // class method
            console.log(`Class name: ${this.name}`);
        }
    }

    class AccountModel extends BaseModel {
        constructor(options, data) {
            super({private: true}, [&apos;3333&apos;, &apos;4444&apos;]); 
            this.name = &apos;Account Model&apos;;
            this.url +=&apos;/accounts/&apos;;
        }
        getAccountsData() {
            return this.data;
        }
    }

    let accounts = new AccountModel(5);
    accounts.getName();         // Account Model
    console.log(&apos;Data is %s&apos;, accounts.getAccountsData);        // {private: true}

    let base = new BaseModel({public: true}, [&apos;111&apos;, &apos;2222&apos;]);
    console.log(base.getName());        // Base


七、class中的Generator方法

    方法前面加&quot; * &quot; 号表示该方法是Generator函数

    class MyClass = {
        constructor(){
            ...
        }

        * getName(){
            ...
        }
    }
</code></pre><h4 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h4><pre><code>一、import: 模块加载

    // 取整个对象
    import $ from &apos;jquery&apos;;

    // 通过解构取对象
    import {name1, name2, nam3} from &apos;./user.js&apos;;

    // 通过逗号分两整体和解构分别来取
    import React, { Component, PropTypes } from &apos;react&apos;;

    // 重命名
    import * as React from &apos;react&apos;;        // * 对整体模块加载，并通过as转换一个名

    // 按需加载
    button.addEventListener(&apos;click&apos;, event =&gt; {
        imoprt(&apos;dialog.js&apos;)
            .then(dialog =&gt; {
                dialog.show();
            }).
            catch(err =&gt;{
                // error
            })
    }, false)


    不同写法

        1、普通写法

            meat.js
                export function beef(){
                    return &apos;牛肉&apos;;
                }
                export function pork(){
                    return &apos;猪肉&apos;;
                }

            main.js

                import { beef, pork } from &apos;meat.js&apos;;
                console.log(beef());        // 牛肉
                console.log(pork());        // 猪肉


        2、key的简写

            var fn1 = function(){
                console.log(&apos;fn1&apos;);
            }
            var fn2 = function(){
                console.log(&apos;fn2&apos;);
            }

            export {fn1, fn2}         // 对象名与key相同可以写成一个


二、export: 模块输出

    1、使用对象简写方式

        var name1 = &apos;aaa&apos;;
        var name2 = &apos;bbb&apos;;
        var name3 = &apos;ccc&apos;;
        export {name1, name2, name3} 

        // 也可以写成    
        export var name1 = &apos;aaa&apos;;
        export var name2 = &apos;bbb&apos;;
        export var name3 = &apos;ccc&apos;;


    2、可以直接输出变量、函数或类

        export function person(){ ... }

        // 不能直接输出变量名
        var name = &apos;siguang&apos;;
        export name;            // 报错

        写成: export var name = &apos;siguang&apos;;        
        写成: var name = &apos;siguang&apos;;   export {name};    


    3、跨模块常量

        const常量只能在当前代码下使用，通过export可以进行跨模块常量，多个文件都可以使用

        export const name = &apos;siguang&apos;;
        export const age = 33;

        import * as info from &apos;userinfo&apos;;        // 或 import { name, age } from &apos;userinfo&apos;


三、as 关键字来修改名字

    meat.js

        export function beef(){
            return &apos;牛肉&apos;;
        }

        export function pork(){
            return &apos;猪肉&apos;;
        }

    main.js

        // * 代表meat.js下所有的对外接口，转换成meat对象下，这样就可以通过meat来调用meat下的
        import * as meat from &apos;./meat.js&apos;;        
        console.log(meat.beef());        // 牛肉
        console.log(meat.pork());        // 猪肉


四、* 将somModule内的所有导出接口

    import * as newSome from &apos;./someModule&apos;        // 将someModule类的所有接口更改到newSome下


五、export default指定匿名

    不使用default在import加载定义名与导出名必须相同，否则无法加载，如果指定默认输出使用export default，在import导入的时候不用在关心命名的问题

    1、meat.js

        // 倒出匿名函数
        export default function() {
            console.log(&apos;foo&apos;);
        }

        简写
        export default(){        // export default {}  写成默认对象

        }

    main.js

        // 导入时可以任意起名
        import beef from &apos;./meat.js&apos;


    2、default与不写default输出的区别

        // 使用default来输出，import不需要使用{}
        export default function crc32() {
            // ...
        }
        import crc32 from &apos;crc32&apos;;

        // 不使用default来输出，import需要使用 {}
        export function crc32() { // 输出
            // ...
        };
        import {crc32} from &apos;crc32&apos;; // 输入
</code></pre><h4 id="Set、Map数据结构"><a href="#Set、Map数据结构" class="headerlink" title="Set、Map数据结构"></a>Set、Map数据结构</h4><pre><code>一、Set(): 类似数组的一种新结构，成员都是唯一的值没有重复值，相当于数组去重

    # 数组去重的新方法
    let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
    console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
    let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    特性: 
        1、不允许数组里有重复数据

    方法: 
        1、set.size: 获取数据的长度

        2、set.add(value): 添加值

        3、set.delete(value): 删除set的实例值

        4、set.has(value): 传入的参数是否为set的成员

        5、set.clear(): 删除set的所有成员


二、Map(): 将二维数组转成对象

    var map = new Map([[&apos;username&apos;, &apos;siguang&apos;], [&apos;password&apos;, &apos;ssssss&apos;]]);
    map.get(&apos;username&apos;);        // siguang

    /* new Map([[&apos;usernmae&apos;, &apos;aaa&apos;, &apos;password&apos;, &apos;ssssss&apos;], [&apos;aaaa&apos;, 1111]]);  注意一个数组中只有两个下标的值，这里只能get到username, password不会取到 */

    特性: 不允许有重复的key值

    方法: 
        1、map.size: 成员总数

        2、map.set(&apos;key&apos;, &apos;value&apos;): 添加成员

        3、map.get(): 获取

        4、map.clear(): 清除所有
</code></pre><h4 id="对象扩展-Object"><a href="#对象扩展-Object" class="headerlink" title="对象扩展 Object"></a>对象扩展 Object</h4><pre><code>一、简写

    1、对象属性和值相同可以写成一个

        var foo = { name: &apos;siguang&apos;};
        var baz = {
            foo            // foo: foo 相同
        };
        console.log(baz.foo.name);    // siguang

    2、对象中函数简写

        var o = {
            name: &apos;momo&apos;,
            getName(){            // 等同于 getName: function(){}
                retrun this.name;
            }
        }

    3、参数作为对象返回

        function f(x, y) { return {x, y}; }

        // 等同于
        function f(x, y) {
            return {x: x, y: y};
        }
        f(1, 2)     // Object {x: 1, y: 2}

        // 2、CommonJS模块输出变量
        const getItem = function(){ ... }
        const setItem = function(){ ... }
        const clear = function(){ ... }
        module.exports = { getItem, setItem, clear };

        // 等同于
        // module.exports = {
        //   getItem: getItem,
        //   setItem: setItem,
        //   clear: clear
        // };


二、[] 属性名表达式

    // 对象的属性名可以用&apos;[]&apos;字符串拼接
    var sex = &apos;男&apos;;
    var obj = {
        name: &apos;momo&apos;,
        [sex]: false,
        [&apos;get&apos;+&apos;Name&apos;](){
            console.log(this.name, this[&apos;男&apos;]);        // 返回 momo false
        }
    }
    obj.getName();


三、getter 赋值器、setter 取值器

    let cat = { 
        name: &apos;喵喵&apos;, 
        get name(){ return this.name },   
        set name(value){
            if(Object.prototype.toString.call(&apos;xxx&apos;) == &apos;[object String]&apos;){
                this.name += value
            }
        }
    }


四、Object.is(): 用于对比两个数字或字符串是否相等，相当于 === ，可以正确比较 -0和0，NaN和

    &apos;==&apos;与&apos;===&apos;的缺点:

        相等运算符（==）缺点: 自动转换数据类型
        和严格相等运算符（===）缺点: NaN不等于自身，以及+0等于-0

    Objetc.is(0, -0);        // false
    Object.is(NaN, NaN);    // true


五、Object.assign(目标对象， 被合并对象B, 被合并对象C): 合并对象

    /* 注意: 被合并对象与合并目标对象的属性相同会赋盖掉前面的对象的值 */
    var objA = {a: 1, b:2}, objB = {b: 3, c: 4}; 
    let req = Object.assign(objA, objB);         // {a:1, b:3, c:4}

    添加对象的方法: 
        Object.assign(SomeClass.prototype, {
            someMethod(arg1, arg2){
                // ...
            },
            anotherMethod(){
                // ...
            }
        })

        相当于
        SomeClass.prototype.someMethod = function(arg1, arg2){ // ... }
        SomeClass.prototype.anotherMethod = function(){ // ... }

    克隆对象: 
        function clone(obj){
            return Object.assign({}, obj);
        }

    注意点: 

        1、assign 是浅拷贝

        2、同名属性替换


六、getPrototypeOf(object)、setPrototype(object, 谁的prototype): 获取、设置对象的prototype

    var Cat = function(name){
        this.name = name;
    }

    Cat.prototype.showName = function(){
        return this.name;
    }

    var c1 = new Cat(&apos;momo&apos;);
    c1.showName();

    console.log(Object.getPrototypeOf(c1))

    // 设置prototype
    var Person = function(nationality){
        this.nationality = nationality;
    }
    Person.prototype = {
        showNationality: function(){
            return this.nationality;
        }
    }
    Object.setPrototypeOf(c1, Person.prototype);
    console.log(Object.getPrototypeOf(c1));


七、keys()、values()

    获取对象的所有keys或所有值, 并返回一个数组

    var obj = {name: &apos;siguang&apos;, age: 33};
    console.log(Object.keys(obj));        // [name, age]
    console.log(Object.values(obj));    // [&apos;siguang&apos;, 33]


八、__proto__属性

    用来读取或设置当前对象的prototype对象

    var Person = function(name){
        this.name = name;
    }
    Person.prototype = {
        constructor: Person,
        getName(){
            console.log(this.name);
        }
    }
    var op = new Person(&apos;lulu&apos;);

    // 继承
    var PersonChilder = function(){}; 
    PersonChilder.__proto__ = op;
    var opc = new PersonChilder(); 
    console.log(opc.getName())

    增强的对象字面量

    // 通过对象字面量创建对象
    var human = {
        breathe() {
            console.log(&apos;breathing...&apos;);
        }
    };

    var worker = {
        __proto__: human, //设置此对象的原型为human,相当于继承human
        company: &apos;freelancer&apos;,
        work() {
            console.log(&apos;working...&apos;);
        }
    };

    human.breathe();        // 输出 ‘breathing...’

    // 调用继承来的breathe方法
    worker.breathe();        // 输出 ‘breathing...’


九、遍历属性的方法

    1、for...in 循环

    2、Object.keys(obj): 返回obj对象的所有key, 返回是一个数组
</code></pre><h4 id="字符串对象扩展"><a href="#字符串对象扩展" class="headerlink" title="字符串对象扩展"></a>字符串对象扩展</h4><pre><code>1、repeat(): 复制字符串 

    var str = &apos;哈哈哈！&apos;.repeat(3);        // str输出 &apos;哈哈哈！哈哈哈！哈哈哈！&apos;

2、includes()、startsWith()、endsWith(): 查找三个方法

    var str = &apos;siguang 1983&apos;;
    str.includes(&apos;o&apos;);        // 查找字符串中是否包含值，包含返回true否则返回false
    str.startsWith(&apos;s&apos;);    // 第一个字符是不是s，如果是返回true
    str.endsWith(&apos;d&apos;);        // 最后一个字符是不是 d，返回布尔值

3、padStart(): 补全长度从开头, &apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;

4、padEnd(): 补全长度从结尾, &apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;
</code></pre><h4 id="Number、Math对象扩展"><a href="#Number、Math对象扩展" class="headerlink" title="Number、Math对象扩展"></a>Number、Math对象扩展</h4><pre><code>一、Math扩展

    1、trunc(): 去除小数部分 Math.trunc(123.123123);    // 123

    2、sign(): 判断是正数还是负数，如果是正数返回1，负数返回-1，0返回0

    3、Math.sign(-234);    // -1

    4、hypot(): 返回所有参数的平方和的平方根，Math.hypot(3,4);    // 5 勾股定理

二、Number对象扩展

    1、isFinite(): 是否是无穷数

    2、Number.isNaN(): 是否是NaN

    3、parseInt(&apos;12.34&apos;): es5的写法   Number.parseInt(&apos;12.34&apos;): es6的写法，为了减少全局方法

    4、Number.isInteger(num): 判断是否是一个整数
</code></pre><h4 id="数组扩展-Array"><a href="#数组扩展-Array" class="headerlink" title="数组扩展 Array"></a>数组扩展 Array</h4><pre><code>一、form(): 将对象转成数组

    var obj = {&apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;};
    var arr =  Array.form(obj); console.log(arr);        // [a, b, c]


二、of(): 将一组值转成数组

    var arrA = new Array(1, 2, 3);    // 生成一个[1,2,3]
    var arrB = new Array(3);                // arrB.length  等于3 如果传一个参数这样会生成一个3个空值
    var arrC = Array.of(3);                    // [3] 解决了new Array的问题


三、find(): 找出第一个符合条件的数据元素

    // 找出数组中值大于3的第一个数
    var arr = [1,2,3,4,5,6];
    var n = arr.find(function(value, index){
        return value &gt; 3;
    })
    console.log(n);        // 4


四、findIndex(): 找出第一个符合条件的位置，也就是所引值

五、fill(填充内容, 填充开始的位置, 填充结束的位置): 填充数组

    var arr = [1,2,3,4,5,6];
    arr.fill(7);        // 数组里全部为7
    arr.fill(7, 1, 3);    // 数组下标从1-3的值为7
    console.log(arr);


六、for...of: 遍历数组、字符串的值，但不能遍历对象

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr){
        console.log(value);        // 1,2,3,4,5,6 只能将遍历出数组的值
    }


七、keys()和values(): 返回数组的Key或value

    // var arr = &apos;sdfsfdasdfasdf&apos;;
    var arr = [1,2,3,4,5,6];
    for(var value of arr.key()){
        console.log(value);
    }


八、entries(): 将数组的key和value一块输出

    var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];
    for(var [key, value] of arr.entries()){
        console.log(key, value);
    }

    返回: 
        0 &quot;a&quot;
        1 &quot;b&quot;
        2 &quot;c&quot;
        3 &quot;d&quot;
        4 &quot;e&quot;
        5 &quot;f&quot;


九、includes(): 查看数组中是否包含指定的值

    var arr = [1, 2, 3, 4, 5];
    arr.includes(3);        // true
</code></pre><h4 id="二进制数组-ArrayBuffer对象"><a href="#二进制数组-ArrayBuffer对象" class="headerlink" title="二进制数组 ArrayBuffer对象"></a>二进制数组 ArrayBuffer对象</h4><pre><code>二进制数组由三类对象组成: 

    ArrayBuffer对象: 代表原始的二进制数据。

    TypedArray视图: 用来读写简单类型的二进制数据。

    DataView视图: 用来读写复杂类型的二进制数据。


一、ArrayBuffer 对象

    它不能直接读写，只能通过（TypedArray和DataView）来读写。

    ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。

    var buf = new ArrayBuffer(32);        // 生成一段32字节的内存区域，每个字节默认为0


    属性和方法: 

    1、byteLength: 返回分配内存的字节长度

        var buffer = new ArrayBuffer(32);

        buffer.byteLength;        // 32


    2、slice(): 拷贝字节

        var buffer = new ArrayBuffer(8);

        var newBuffer = buffer.slice(0, 3);     //拷贝`buffer`对象的前三个字节（从0到3前结束），生成一个新的ArrayBuffer对象: newBuffer


    3、isView(): 返回一个布尔值，表示参数是否为ArrayBuffer的视图实例

        var buffer = new ArrayBuffer(8);
        ArrayBuffer.isView(buffer) // false

        var v = new Int32Array(buffer);
        ArrayBuffer.isView(v) // true


二、TypedArray 视图

    TypedArray数组只提供9种固定的构造函数
</code></pre><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><pre><code>JS新的数据类型，独一无二的值，凡是属性名属于Symbol类型，就是独一无二的

# 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();

s1 === s2         // false

# 有参数的情况
var s1 = Symbol(&apos;foo&apos;);
var s2 = Symbol(&apos;foo&apos;);

s1 === s2         // false

一、不能与其它值进行运算

    var sym = Symbol(&apos;My symbol&apos;);
    console.log(&quot;your symbol is &quot; + sym);        // 报错


二、toString()转成字符串

    let sym = Symbol(&apos;my symbol&apos;);
    sym.toString()    // &quot;Symbol(my symbol)&quot;
</code></pre><h4 id="Proxy对象拦截器"><a href="#Proxy对象拦截器" class="headerlink" title="Proxy对象拦截器"></a>Proxy对象拦截器</h4><pre><code>可以监听对象身上发生变化，对操作对象属性读取时做一个拦截器

&lt;script&gt;
    let obj = {
        a: 1,
        b: 2
    }

    // 相当于操作对象属性时的一个拦截器
    let oProxy = new Proxy(obj, {
        get(obj, key) {
            return obj[key];
        },
        set(obj, key, value) {
            // 这里来做拦截，如果修改的key=a 并且 value值小于10不会就将值修改
            if (key == &apos;a&apos; &amp;&amp; value &lt; 10) {
                obj[key] = value;
            }
        }
    })

    // 设置属性
    oProxy.a = 9; // {a: 9, b: 2}
    oProxy.a = 20; // {a: 9, b: 2}
    oProxy.b = 10; // {a: 9, b: 20}

    // 获取属性值
    console.log(oProxy.a, oProxy.b);    
&lt;/script&gt;
</code></pre><h4 id="Promise异步"><a href="#Promise异步" class="headerlink" title="Promise异步"></a>Promise异步</h4><pre><code>// resolve: 成功、reject: 失败
var pro = new Promise(function(resolve, reject){        // resolve成功, reject失败
    // 将一个耗时长的任务放到执行器里
    setTimeout(function(){
        resolve();            // 4毫秒后执行成功
    }, 400)
})

pro.then(
    function(){                        // reslove回调
        console.log(&apos;成功执行&apos;);
    },
    function(){                        // reject回调
        console.log(&apos;失败执行&apos;);
    }
)
.catch(function(e){            // 捕获异常，如果then中的两个方法成功失败有报错就会走catch
    console.log(e)
})

// 如果不需要reslove的回调可以设置为null
por.then(null, functino(){
    console.log(&apos;失败执行&apos;)
})


方法: 
一、Promise.all([实例1，实例2，实例3]): 用于多个promise实例，当三个实例都为真的时候all这个结果为真

    var p1 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p1完成&quot;);
        }, 400);
    })

    var p2 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p2完成&quot;);
        }, 1000);
    })

    var p3 = new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve();
            console.log(&quot;p3完成&quot;);
        }, 4000);
    })

    var p4 = Promise.all([p1, p2, p3]);
    p4.then(function(){
        console.log(&apos;三个全部执行成功&apos;)
    }, function(){
        console.log(&apos;失败&apos;)
    })

二、Promise.race([实例1，实例2，实例3]): 只要有一个为成功，p4为成功，与all()方法正反

https://www.jianshu.com/p/c98eb98bd00c
</code></pre><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><pre><code>Generator是一个状态机，封装了多个内部状态, 也是一个遍历对象生成函数，返回遍历器对象

Example: 

    function* ouputGenerator() {
        yield &apos;hello&apos;;            // 调用后不会马上执行，只有调用next()才会返回
        yield &apos;world&apos;;
        return &apos;ending&apos;;
    }
    let gen = ouputGenerator();

    console.log(gen.next());     // {value: &quot;hello&quot;, done: false}  value就是返回值
    console.log(gen.next());     // {value: &quot;world&quot;, done: false}
    console.log(gen.next());     // {value: &quot;ending&quot;, done: true}  done为true就是后面没有yeild的定义


一、Generator的特征:

    1、function 关键字与函数名之间有一个&quot;*&quot;号

    2、函数体内有 yield 语句

    3、可以执行暂停

    4、generator也可以不用yield, 但需要执行一次next()


二、属性和方法

    1、next() 可以带一个参数，参数可以是上一个yield的返回值

        done为true 表示结束  Object {value: &quot;ending&quot;, done: true}

    2、value: 就是next返回的值，done为false表示已经结束

    3、yield: 定义表达式


三、Generator与Promise的区别

    promise如果写多个嵌套会很麻烦:

        getArticleList()
            .then(articles =&gt; getArticle(articles[0].id))
            .then(article =&gt; getAuthor(article.authorId))
            .then(author =&gt; {
                alert(author.email);
            });

        function getAuthor(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/E105pDLh&quot;,{
                    author: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticle(id){
            return new Promise(function(resolve, reject){
                $.ajax(&quot;http://beta.json-generator.com/api/json/get/EkI02vUn&quot;,{
                    id: id
                }).done(function(result){
                    resolve(result);
                })
            });
        }

        function getArticleList(){
            return new Promise(function(resolve, reject){
            $.ajax(
                &quot;http://beta.json-generator.com/api/json/get/Ey8JqwIh&quot;)
                .done(function(result){
                    resolve(result);
                }); 
            });
        }


    Generator的写法:

        function* run(){
            var articles = yield getArticleList();
            var article = yield getArticle(articles[0].id);
            var author = yield getAuthor(article.authorId);
            console.log(author.email);  
        }

        var gen = run();
        gen.next().value
            .then(articles =&gt; {
                gen.next(articles).value.then(article =&gt; {
                    gen.next(article).value.then(author =&gt; {
                    gen.next(author)
                })
            })
        })
</code></pre><h4 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h4><pre><code>async 是ES7引入的函数，使的异步变得更加方便

await: 命令后面是一个Promise对象

Generator函数执行必须靠执行器，也就是需要调next()，async函数有自带的执行器，async返回的是Promise对象

一、async的多种声明

    // 函数声明
    async function foo() {}

    // 函数表达式
    const foo = async function () {};

    // 对象的方法
    let obj = { async foo() {} };
    obj.foo().then(...)

    // Class 的方法
    class Storage {
        constructor() {
            this.cachePromise = caches.open(&apos;avatars&apos;);
        }

        async getAvatar(name) {
            const cache = await this.cachePromise;
            return cache.match(`/avatars/${name}.jpg`);
        }
    }

    // 箭头函数
    const foo = async () =&gt; {};

二、async函数返回一个Promise对象，函数内部有return返回值，可以通过then方法来接收

    async function f(){
        return &apos;hello world&apos;
    }

    f().then( v =&gt; {
        console.log(v);
    })

Example:

    async function getStockPriceByName(name) {
        var symbol = await getStockSymbol(name);
        var stockPrice = await getStockPrice(symbol);
        return stockPrice;
    }

    getStockPriceByName(&apos;goog&apos;).then(function (result) {
        console.log(result);
    });
</code></pre><p>| <a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/babel.html</a><br>| <a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/style</a><br>| <a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/BOM/">BOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/BOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><pre><code>BOM   浏览器对象模型    B - Browser    O - Object     M - Model

BOM包含: history、location、navigator、screen 对象
</code></pre><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><pre><code>1、hash: 返回hash值

    https://xxx.com/#sdfsdf       // &apos;#sdfsdf&apos;

2、host: 返回主机地址  &apos;xxx.com&apos;

3、hostname: 返回主机名  &apos;xxx.com&apos;

4、href: 整个url地址  &quot;https://xxx.com/search?q=BOM&quot;

5、origin: 起源  &apos;https://xxx.com&apos;

6、pathName: 路由名

    &quot;https://xxx.com/search?q=BOM&quot;   &apos;/search&apos;

7、port: 端口

8、protocol: 协议  &apos;https&apos;

9、search: 参数 &apos;?q=BOM&apos;

10、reload(): 刷新浏览器

    location.reload(); // 重新加载（有可能从缓存中加载）
    location.reload(true); // 重新加载（从服务器重新加载）
</code></pre><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><pre><code>1、width、height: 整天个屏幕的宽、高

2、avaiWidth、avaiHeight: 返回显示屏幕的宽、高 除dock和系统上面的菜单栏

3、pixelDepth: 返回显示屏幕的颜色分辨率

4、updateInteval: 设置或返回屏幕刷新率
</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><pre><code>1、length: 历史记录的个数

2、go(): 指定跳转的历史、-1后退一页，1前进一页

3、back()、forward(): 后退和前进一页
</code></pre><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><pre><code>1、appCodeName: 浏览器代码名 &apos;Mozilla&apos;

2、appName: 浏览器名称    &apos;Netscape&apos;

3、appVersion: 浏览器版本  &apos;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;

4、browserLanguage: 浏览器语言

5、cookieEnabled: 是否启用了cookie 返回Boolean

    如果浏览器关闭cookie，当获取cookie时， document.cookie 返回的是空字符串

6、cpuClass: 返回浏览器系统的cpu等级

8、onLine: 是否处于脱机模式，Boolean

9、platform: 浏览器的操作平台

10、systemLanguage: 系统语言

11、userAgent: 客户机发送服务器的 user-agent 头部的值

12、userLanguage: 返回 OS 的自然语言设置


** 检测插件  ie无效
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

** 检测Flash
function hasPlugin(name){
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i ++){
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1){
            return true;
        }
    }
    return false;
}

function hasIEPlugin(name){
    try{
        new ActiveXObject(name);
        return true;
    }catch(ex){
        return false;
    }
}

function hasFlash(){
    var result = hasPlugin(&quot;Flash&quot;);
    if (!result){
        result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);
    }
    return result;
}

console.log(hasFlash()) //true
</code></pre><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><pre><code>1、window.open(url, target, param): 打开一个新窗口

2、window.close(): 关闭一个窗口

3、setInterval()、clearInterval()

4、setTimeout()、clearTimeout()

5、screenLeft、screenTop: 浏览器当前窗口居屏幕的左、上角的位置  

    兼容:
    screenLeft || screenX
    screenTop || screenY

6、innerWidth、innerHeight: 浏览器可视区的宽高、包括滚动条

    let winHeight = window.innerHeight;

7、moveTo(x, y): 移动到屏幕左上角的位置

8、moveBy(0, 100): 向下移动100像素

9、resizeTo(x,y)、resizeBy(w, h)
</code></pre><h4 id="offset-页面元素偏移量"><a href="#offset-页面元素偏移量" class="headerlink" title="offset 页面元素偏移量"></a>offset 页面元素偏移量</h4><pre><code>1、offsetWidth、offsetHeight: 获取当前元素宽高，相当于 width + padding + border

2、offsetLeft、offsetTop: 获取元素到父级元素定位的左、上偏移，如果父级不是定位就以body元素为定位

3、offsetParent: 获取最近一个带有定位的父级元素

4、clientWidth、clientHeight: 元素本身的宽高、不包括padding和border

    兼容
    document.documentElement.clientWidth || document.body。clientWidth
    document.documentElement.clientHeight || document.body。clientHeight
</code></pre><h4 id="scroll-滚动类"><a href="#scroll-滚动类" class="headerlink" title="scroll 滚动类"></a>scroll 滚动类</h4><pre><code>窗口滚动条或带滚动条元素

1、scrollWidth、scrollheight: 对象内部实际内容的宽、高

2、scrollTop、scrollLeft: 被卷部分的顶部和左侧部分

    只挂载到了Element元素中，window和document下都没有

    let topValue = document.documentElement.scrollTop || document.body.scrollTop;       // 获取整个页面巻上去的高度和兼容方法

    let topValue = document.querySelector(&apos;#sider&apos;).scrollTop;      // 针对某个元素


3、onscroll: 侦听滚动条事件
</code></pre><h4 id="client-鼠标所在的可视区坐标"><a href="#client-鼠标所在的可视区坐标" class="headerlink" title="client 鼠标所在的可视区坐标"></a>client 鼠标所在的可视区坐标</h4><pre><code>1、clientX、clientY: 获取鼠标可视区的位置  clientX = width + padding

2、clientLeft、clientTop: 获取鼠标在可视区域的位置

3、pageX、pageY: 获取鼠标在页面中的位置， pageX = clientX + 页面滚动出的距离

node.onclick = function(evt){
    let evt = evt || window.evnet;
    console.log(evt.pageX, evt.pageY);
    console.log(evt.pageX, evt.pageY);
}
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、target: 点击的目标阶段事件，ie8之前使用srcElement

    var oT = evt.target || srcElement; console.log(oT);     // &lt;p&gt;xxxx&lt;/p&gt;

2、currentTarget: 事件流的捕获，目标及冒泡阶段

3、addEventListener()、attachEvent(): 注册事件

    addEventListener(&apos;click&apos;, fn, false);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/DOM/">DOM</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/DOM/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h4><pre><code>DOM 文档对象模型     D - Document      O - Object      M - Model
</code></pre><h4 id="Node-对象属性"><a href="#Node-对象属性" class="headerlink" title="Node 对象属性"></a>Node 对象属性</h4><pre><code>1、nodeType: 节点类型

    e.target.nodeType 来获取节点的类别

    1、Element 1

    2、Attr  2

    3、Text  3

    4、注释  8

    5、Document 9


2、nodeName: 节点名称   返回的是大写 &apos;DIV&apos;

3、nodeValue: 节点的类型

    元素节点的 nodeValue 是 undefined 或 null
    文本节点的 nodeValue 是文本本身
    属性节点的 nodeValue 是属性值

    &lt;p&gt;dfsdfsdf&lt;/p&gt;

    let oP = document.querySelector(&apos;p&apos;);   
    // 这里注意oP是元素如果直接写成oP.nodeValue返回是null，写成oP下的第一个节点才找到文本元素
    oP.firstChild.nodeValue;            

4、parentNode: 返回当前节点的父节点   e.target.parentNode.nodeName

    document.querySelector(&apos;ul&apos;).parentNode     // &lt;div class=&quot;box&quot;&gt;...&lt;/box&gt;

5、childNodes、children: 返回所有子节点元素，不包括孙节点

    &lt;ul id=&quot;list&quot;&gt;
        &lt;li&gt;111&lt;/li&gt;
        &lt;li&gt;222&lt;/li&gt;
        &lt;li&gt;
            &lt;ul&gt;
                &lt;li&gt;333&lt;/li&gt;
                &lt;li&gt;444&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;

    let oList = document.querySelector(&quot;#list&quot;);
    let lis = oList.children;
    for(let i=0; i&lt;lis.length; i++){
        console.log(lis[i].nodeName);   // output LI LI LI
    }

    ** childeNodes与children区别 ** 

        childeNodes: 包括空行的文本节点, 如果是空行的节点返回是一个text节点
        children: 不包括空行之类的节点

6、hasChildNodes(): 判断是否有子节点，返回Booleanw值

7、firstChild、lastChild: 返回子节点的第一个节点、最后一个节点

    firstChild 相当于 children[0]

    lastChilde 相当于 children[node.children.length-1]

    &lt;div id=&quot;car&quot;&gt;&lt;p&gt;aaa&lt;/p&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;/div&gt;

    let oCars = document.querySelector(&quot;#car&quot;);
    console.log(oCars.firstNode, oCars.lastNode);   //&lt;p&gt;aaa&lt;/p&gt; 、 &lt;span&gt;ccc&lt;/span&gt;

8、previousSibling、nextSibling: 当前节点的前一个节点、后一个节点

    注意: 如果是空行返回的是 text

9、innerHTML: 获取或修改HTML元素内容

    Element.innerHTML = &apos;&lt;div&gt;xxxxx&lt;div&gt;&apos;;

10、innerText: 获取或修改的是除去html的文本

11、outerHTML、outerText: 与innerHTML、innerText相当，不同的是它包含当前节点元素，inner只包含子节点元素

12、offsetParent: 获取当前元素定位的父元素  找到基于设置position的父元素

     document.querySelector(&apos;ul&apos;).offsetParent
</code></pre><h4 id="Node-对象的方法"><a href="#Node-对象的方法" class="headerlink" title="Node 对象的方法"></a>Node 对象的方法</h4><pre><code>一、节点操作方法

    1、getElementById(): 获取指定ID的元素

    2、getElementsByTagName(): 获取指定标签名称的所有元素

    3、getElementsByClassName(): 获取指定类名的元素

    4、appendChild(): 追加子节点  注意这里插入的是一个节点，而不是HTML的字符串 parent.appendChild(children);

    5、removeChild(): 删除子节点，不能删除孙子节点    (removeNode 只支持IE)

        删除节点 并返回删除的节点
        let oSubCar = document.querSelector(&apos;#subCar&apos;);
        document.querySelector(&apos;body&apos;).removeChild(oSubCar);        // &lt;div id=&quot;subCar&quot;&gt;...&lt;/div&gt;

    6、cloneNode(Boolean): 复制节点  如果参数为true复制指定节点下包括所有子节点，如果不写只复制当前节点不手包子节点

        &lt;div class=&quot;car&quot;&gt;
            &lt;ul id=&quot;box&quot;&gt;
                &lt;li&gt;aaa&lt;/li&gt;
                &lt;li&gt;bbb&lt;/li&gt;
                &lt;li&gt;ccc&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div id=&quot;subCar&quot;&gt;&lt;/div&gt;

        &lt;script&gt;
            // 将id=box所有的节点插入到id=subCar中
            let boxList = document.querySelector(&apos;#box&apos;).cloneNode(true);
            var oSubCar = document.querySelector(&apos;#subCar&apos;);
            oSubCar.appendChild(boxList);
        &lt;/script&gt;

    7、hasAttributes(): 判断当前节点是否拥有属性

        &lt;div id=&quot;miniCar&quot;&gt;&lt;/div&gt;
        &lt;div&gt;swsss&lt;/div&gt;

        let isAttribute = document.getElementsByTagName(&apos;div&apos;)[1].hasAttributes();
        console.log(isAttribute);   // false

    8、hasChildNodes(): 判断当前节点是否拥有子节点

    9、insertBefore(newitem, ex): 在指定节点之前插入

        insertAfter(): 这个需要自己来写没有这个方法

        let oMain = document.querySelector(&apos;#main&apos;);
        let oP = document.querySelector(&apos;p&apos;);
        let oUl = document.querySelector(&apos;.uls&apos;).cloneNode(true);
        oMain.insertBefore(oUl, oP);    将ul元素内所有节点复制并插入到oP元素之前

    10、replaceChild(newNode, oldNode): 替换节点

        document.querySelector(&apos;body&apos;).replaceChild(oMiniCar, oSubCar)


二、创建元素方法

    1、createAttribute(): 创建属性节点

    2、createElement(): 创建元素节点

    3、createTextNode(): 创建文本节点


三、操作属性方法

    1、getAttribute(): 获取属性值

    2、setAttribute(): 设置属性值
</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>1、style：获取或设置style值   Element.style.color = &apos;blue&apos; 

2、currentStyle、getCurrentStyle()获取样式中每个属性的值

    var oBox = document.querySelector(&apos;#box&apos;);
    var getStyle = function(obj, attr){
        return window.getComputedStyle ? window.getComputedStyle(obj, null)[attr] : obj.currentStyle[attr];
    }

    var attrTxt = getStyle(oBox, &apos;width&apos;);          // &apos;100px&apos;;

    注意: (1)中style只能获取元素中的内联样式，而currentStyle、getCurrentStyle()无论是内联样式还是在class中都可以找到

3、getComputedStyle(元素， 伪类): 获取指定元素值，currentStyle（ie独有） 

    &lt;script&gt;
        function getStyle(element, attr) {
            if(window.getComputedStyle) {
                return window.getComputedStyle(element, null)[attr];
            } else {
                return element.currentStyle[attr];
            }
        }

        // 获取class=position-node元素上的position值
        var dom = document.querySelector(&quot;.position-node&quot;);
        var style = getStyle(dom);
        console.log(style.position);    // 返回relative
    &lt;/script&gt;


    *** element.getComputedStyle与element.style的区别

    element.getComputedStyle: 只读
    element.style: 可读写

4、className: 获取或设置元素的类名  Element.addClass = &apos;classname&apos;
</code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><pre><code>1、write(): 向输出流写文本或html

2、document.title: 返回标题

4、&quot;javascript:&quot; : 伪协议 来调用javascript http协议(http://)，FTP协议(ftp://)

5、对象检测: 可以测试浏览器是否支持当前对象

    if(document.getElementById){ ...}
</code></pre><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><pre><code>1、createDocumentFragment: 创建文档碎片

    Example: 创建节点并插入到body中，如果不使用文档碎片，每次都需要重新插入一次

    var oFragment = document.createDocumentFragment();
    for(var i = 0 ; i &lt; 10; i ++) {
        var p = document.createElement(&quot;p&quot;);
        var oTxt = document.createTextNode(&quot;段落&quot; + i);
        p.appendChild(oTxt);
        oFragment.appendChild(p);
    }
    document.body.appendChild(oFragment);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、表单事件：

    submit事件

    reset事件

    click事件

    change事件

    focus事件（不冒泡） （IE和ES5支持冒泡的focusin）

    blur事件（不冒泡） （IE和ES5支持冒泡的focusout）

    input事件（ES5 textinput提供更方便的获取输入文字的方案）


2、Window事件

    load: 资源全部加载完成后触发事件（图片、css、js）

    DOMContentLoaded事件: Document对象构建完后就开始调用此事件

    readyStatechage事件:

    unload事件: 关闭borwser的时候触发

    beforeunload事件

    resize: 浏览器窗口发生改变触发

    scroll: 滚动条有变化时触发


3、鼠标事件

    click: 点击事件

    dbclick：双击事件

    mouseover: 鼠标移入事件（冒泡）

    mouseout: 鼠标移出事件（冒泡）

    mousedown: 鼠标按下事件

    mouseup: 鼠标放开事件

    contextmenu: 上下文本菜单事件

    mouseenter: 事件（不冒泡）

    mouseleave: 事件（不冒泡）

    mousewheel: 事件（FF DOMMouseScroll事件、DOM3 wheel事件）


4、键盘事件

    keydown事件

    keyup事件

    keypress事件
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/ES5/">ES5</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/ES5/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h4><pre><code>1、async: 异步下载当前脚本，不阻塞后续代码的执行

2、charset: 字符集

3、defer: 表示当前脚本延迟到文档完全被解析和显示后在执行 defer=&quot;defer&quot;

4、src: 文件路径

5、language: 语言

6、type: 脚本类型

&apos;use strict&apos; 严格模式
</code></pre><h4 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h4><pre><code>作用域: 变量和函数可访问的范围，作用域分为局部和全局，函数中声明的变量叫局部变量，在window对象下定义的变量为全局变量

作用域链: 决定哪些变量能够被当前函数访问及访问顺序

    函数对象有一个[[Scope]]属性，包含了函数被创建作用域中对象的集合，集合被称为函数的作用域链scope chain，它决定了哪些数据能被函数访问

    function doSomething(){
        var blogName=&quot;Jessica&quot;;
        function innerSay(){
            alert(blogName);
        }
        innerSay();
    }
    alert(blogName);        //脚本错误
    innerSay();             //脚本错误
</code></pre><h4 id="js预解析"><a href="#js预解析" class="headerlink" title="js预解析"></a>js预解析</h4><pre><code>JS执行时先将代码中所有 var定义变量和function(){} 进行提取，函数内部变量除外。

将var的变量赋为undefined

将函数都为函数本身function getName(){}，所以在调用函数时无论在前还是在后都会被调用。

Example:
    var add = &apos;bbb&apos;; 
    function add(){console.log(&apos;aaa&apos;)} 

    add();      报错
</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code>闭包: 函数嵌套，内部函数调用外部函数的局部变量，内部函数执行完后自动消毁，外部函数的变量不会被回收一直保存在内存中.

&lt;script&gt;
    var fun = function(){
        var a = 1;
        return function(){
            a++;
            alert(a);
        }
    }

    var f = fun();        // 这里返回了匿名函数的引用，里面的局部变量就不会被消毁
    f();    // 2
    f();    // 3
    f();    // 4
&lt;/script&gt;
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>一、函数没有重载: 当两个函数名相同，后面的函数会覆盖掉之前的函数

    function getUserName(){
        console.log(&apos;a&apos;);
    }

    function getUserName(){
        console.log(&apos;b&apos;);
    }

    getUserName();      // &apos;b&apos;


二、声明函数和匿名函数: 

    function person() {  ...  };          // 声明
    var person = function() {  ...  }     // 匿名

    Example:

        getName();          // b
        var getName = function(){       // 优先级要高于声明函数，但要必须执行到这里才有效
            console.log(&apos;a&apos;);
        };

        getName();          // a

        function getName(){
            console.log(&apos;b&apos;);
        }
        getName();          // a


三、函数参数

    1、形参、实参

        function add(a, b){ return a+b }    // 形参

        add(1,2)    // 实参


    2、arguments数组: 函数参数的数组

    3、callee 函数的调用当前函数的本身，可以使用arguments.caller(), 可以用于递归

        function factorial(num){
            if(num &lt; 1){
                return 1;
            }
            else{
                return num * arguments.callee(num-1);
            }
        }

    4、caller 返回被调用函数的本身

        function outer() {
            inner();
        }

        function inner() {
            alert(arguments.callee);        // function inner(){ ... }
            alert(arguments.callee.caller); // function outer(){ ... }
        }

        outer();

四、如果函数没有return返回undefined

    var fn = function(){ }; 
    fn();       // undefined
</code></pre><h4 id="call-、apply"><a href="#call-、apply" class="headerlink" title="call()、apply()"></a>call()、apply()</h4><pre><code>Function.prototype.call() 和 Function.prototype.apply() 用于改变函数的this指向

一、无参

    var obj1 = {
        name: &apos;siguang&apos;,
        getName: function(){
            return this.name;
        }
    }

    var obj2 = {
        name: &apos;lulu&apos;
    }

    console.log(obj1.getName());  // siguang

    // 注意这里是将getName中的this指定指向了obj2，并且执行了getName()函数
    var n1 = obj1.getName.call(obj2);
    console.log(n1);        // lulu

二、有参

    var objA = {
        num: 10,
        add: function(a, b){
            return a + b + this.num;
        }
    }
    var objB = {
        num: 20
    } 

    var n1 = objA.add(1, 2);
    console.log(n1);    // 13

    var n2 = objA.add.call(objB, 1, 2);     // 如果objA.add.apply(objB, [1,2]);
    console.log(n2)     // 23
</code></pre><h4 id="void-0"><a href="#void-0" class="headerlink" title="void(0)"></a>void(0)</h4><pre><code>这个操作符允许插入一个计算结果等效于undefined的表达式。

void操作符经常仅仅是用来获得undefined值，比如经常使用到的“void(0)”(这等效于“void 0”)

当浏览器遇到一个javascript:URI，它会运算带有URI的代码，然后将计算结果替换当前页面的内容，除非它的返回值是undefined。void操作符可以被用于返回undefined

&lt;a href=&quot;javascript:void(0);&quot;&gt;
    Click here to do nothing
&lt;/a&gt;
</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>一、 数据类型包括

    Number、String、Boolean、null、undefined

    获取数据的类型: 返回的值（number、string、boolean、array、object、function、undefined、null）

    Object.prototype.toString.call(val)

    // 判断类型
    function returnType(val) {
        let typeName;
        if (typeof val === &apos;object&apos;) {
            let typeName = Object.prototype.toString.call(val);

            if (typeName == &apos;[object Array]&apos;) {
                return &apos;array&apos;
            } else if (typeName == &apos;[object Object]&apos;) {
                return &apos;object&apos;
            }
            else if(typeName == &apos;[object Null]&apos;){
                return &apos;null&apos;
            }
        } else {
            return typeof val;
        }
    }


二、NaN 非数值

    isNaN() 是否是一个NaN非数值， 如果是数字返回false, 否则返回true

        isNaN(NaN);     // true
        isNaN(10);      // false
        isNaN(&apos;10&apos;);    // false 转换后是一个数字
        isNaN(&apos;blue&apos;);  // true 转换后不会是一个数字
        isNaN(true);    // false true转换后为1是一个数字


    数值转换:
        Number() 布尔转换成1或0，null返回0，undefined返回NaN，
        parseiInt()
        parseFloat()


toString(): 将该对象的原型始以字符串形式返回   xx.toString();       // &apos;xx&apos;

valueOf(): 返回最适合该对象的类型的原始值
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>var testA = 3 &amp;&amp; 2;             // 返回 2，如果左侧为真返回右侧，否则返回左侧

var testB = 0 || 3;             // 返回3，如果左侧为假返回右侧

var a = 1; console.log(!!a);    // 返回true，!!强制转换成布尔值

var a = &apos;123.563&apos;; console.log( +a );  // 123.563，+转换成数值类型
</code></pre><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><pre><code>for(var i=0; i&lt;10; i++){}

do{....} while(express)

while(){ ... }

for( in ){}

break 退出整个循环        continue 跳出当前循环，继续执行下一个循环

switch case default
</code></pre><h4 id="定时器的运行机制"><a href="#定时器的运行机制" class="headerlink" title="定时器的运行机制"></a>定时器的运行机制</h4><pre><code>JS的执行机制: 

    JS引擎执行JS的机制是基于事件循环，JS是单线程，同一时间只能执行一个任务，其它任务就得排队，后续任务需要前一个任务结束才能执行

    为了避免一些长时间任务造成的无意义等待，JS引入了异步，用另一个线程来管理异步任务

    同步任务在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程，等主线程队列执行完后，在去异步队列查询是否有可执行的异步任务

异步 - ajax、定时器、Promise

Example:

    // HTML5规范规定最小时间不能小于4ms(毫秒)，如果小于4会被当4来处理，Chrome可以设置1ms
    setTimeout(function(){
        console.log(1);
    }, 0);
    console.log(2);         // 先log出2，在log出1
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>一、事件机制: 事件捕获 和 事件冒泡, IE11之前没有捕获

二、事件委托

    事件委托（也称事件代理）: 将事件绑定到父元素上，利用冒泡机制来对点击的元素进行处理

    &lt;div id=&quot;boxList&quot;&gt;
        &lt;ul&gt;
            &lt;li data-attr=&quot;a1&quot;&gt;aaa&lt;/li&gt;
            &lt;li data-attr=&quot;a2&quot;&gt;bbb&lt;/li&gt;
            &lt;li data-attr=&quot;a3&quot;&gt;ccc&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var oList = document.querySelector(&apos;#boxList&apos;);
        oList.onclick = function(e){
            var arrtName = e.target.getAttribute(&apos;data-attr&apos;);
            console.log(arrtName);
        }
    &lt;/script&gt;


三、自定义事件

四、onLoad与DOMContentLoaded事件的区别

    onLoad: 是当所有资源都加载完成后在执行onLoad函数内的程序

    DOMContentLoaded: 是当DOM树加载完成后就执行此函数内的程序


五、onmouseover、onmouseout与onmouseEnter、onmouseLeave

    onmouseover、onmouseout 会冒泡

    onmouseEnter、onmouseLeave 不会冒泡


六、addEventListener(事件类型, 执行函数, boolear): 第三个参数，如果是true表示在捕获取中调用事件，false冒泡时调用

    这里执行的函数不会被重载

    var oSendBtn = document.querySelector(&apos;#sendBtn&apos;);      // 点击会输出&apos;aa&apos;, &apos;bb&apos;

    oSendBtn.addEventListener(&apos;click&apos;, function(){
        console.log(&apos;aa&apos;);
    }, false);

    oSendBtn.addEventListener(&apos;click&apos;, function(){
        console.log(&apos;bb&apos;);
    }, false);
</code></pre><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>一、加载非阻塞脚本:  

    浏览器遇到 &lt;script&gt; 标签时，页面加载都会停下来，先执行js代码，然后在继续加载（因为不知道脚本里有没有document.wirte()
    来向页面写内容，所以会需要先执行完js文件在继续）

    使用动态创建DOM元素，将脚本加载放到&lt;/body&gt;之前来加载，这样不会影响页面的内容展示


二、按需加载: 可以分图片按需加载，js文件按需加载、数据接需加载

    图片按需加载使用的lazyload

    JS按需加载类似模块化开发，只对依赖的文件进行加载


三、图片预加载: 通过new Images()来创建图像对象提前将图片进行加载

    function preloadImg(url) {
        var img = new Image();
        img.src = url;
        if(img.complete) {
            //接下来可以使用图片了
            //do something here
        }
        else {
            img.onload = function() {
                //接下来可以使用图片了
                //do something here
            };
        }
    }
</code></pre><h4 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h4><pre><code>由于同源策略，安全性，ajax不同域下的数据不可以调用

跨域的产生: 1、同域名不同端口        2、同域名不同协议        3、主域和子域之间        4、子域和子域之间

解决跨域的方法: 

一、JSONP

    JSONP利用script标签中的src属性，src属性没有跨域限制，通过url的参数将回调函数的名称和数据请求给服务器，服务器接收到url参数进行处理，并将数据挂载到回调函数的参数并执行回调函数，客户端有与回调函数名相同，来处理这些数据

    // 处理回调函数数据的函数
    function doSomething(data) {
        // 对data处理
    }
    var script = document.createElement(&quot;script&quot;);
    script.src = &quot;http://www.b.com/b.html?callback=doSomething&quot;;
    document.body.appendChild(script);


二、document.domain: 

    适用于主域相同子域不同，比如 www.renrendai.com 和 action.renrendai.com

    例如: 两个域下各有a.html和b.html, a通过iframe嵌到另一个子域b.html是无权访问b.html文档内的元素, 所以通过document.domain来设置

    a.html: 
        document.domain = &quot;www.we.com&quot;;
        var iframe = document.createElement(&quot;iframe&quot;);
            iframe.src = &quot;http://a.we.com/b.html&quot;;
            document.body.appendChild(iframe);
            iframe.onload = function() {
                console.log(iframe.contentWindow....); // 在这里操作b.html里的元素数据
        }

    b.html:
       document.domain = &quot;www.we.com&quot;;       // b页面必须要设置a.html


三、HTML5 postMessage() 处理iframe跨域问题

    如果在一个主域中的a.html嵌套个 &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

    postMessage有两个接口: postMessage(send) 发送数据和 onmessage接收数据事件通过e.data来获取到

    Example: 
        // a.html
        &lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot; id=&quot;messageId&quot;&gt;&lt;/iframe&gt;

        var oMessage = document.getElementById(&apos;messageId&apos;);
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收b的数据
            }, false);
            oMessage.postMessage(&apos;发送给b的数据&apos;, &apos;http://www.b.com/b.html&apos;);
        }

        // b.html
        window.onload = function(){
            window.addEventListener(&apos;message&apos;, function(e){
                console.log(e.data);    // 接收a的数据
            })
            window.parent.postMessage(&apos;发送给a的数据&apos;, &apos;http://www.a.html/a.html&apos;);
        }

    传统的iframe跨域使用方法: http://www.cnblogs.com/snandy/p/3900016.html


四、window.name + iframe

    window.name原理是利用同一个窗口在不同页面共用一个window.name，这个需要在a.com下建立一个代理文件c.html，使同源后a.html能获取c.html的window.name.

        // a.html
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.b.com/b.html&quot;;
        document.body.appendChild(iframe); // 现在a.html里建一个引用b.html的iframe，获得b的数据

        var flag = true;
        iframe.onload = function() {
            if (flag) {
                iframe.src = &quot;c.html&quot;;          // 这里在去加载c.html

                  // 判断是第一次载入的话，设置代理c.html使和a.html在同目录同源，这样才能在下面的else取到data
                flag = false;
            } 
            else { 
                // 第二次载入由于a和c同源，a可以直接获取c的window.name
                alert(iframe.contentWindow.name);

                iframe.contentWindow.close();
                document.body.removeChild(iframe);
                iframe.src = &apos;&apos;;
                iframe = null;
            }
        }

        // b.html
        window.name = &quot;这是 b 页面的数据&quot;;


五、window.location.hash + iframe

    b.html将数据以hash值的方式附加到c.html的url上，在c.html页面通过loaction.hash获取数据后传到a.html

    // a.html
    var iframe = document.createElement(&quot;iframe&quot;);
    iframe.src = &quot;http://www.b.com/b.html&quot;;
    document.body.appendChild(iframe); // 在a页面引用b
    function check() { 
        // 设置个定时器不断监控hash的变化，hash一变说明数据传过来了
        var hashs = window.location.hash;
        if (hashs) {
            clearInterval(time);
            alert(hashs.substring(1));
        }
    }
    var time = setInterval(check, 30);

    //b.html
    window.onload = function() {
        var data = &quot;this is b&apos;s data&quot;; 
        var iframe = document.createElement(&quot;iframe&quot;);
        iframe.src = &quot;http://www.a.com/c.html#&quot; + data;         
        document.body.appendChild(iframe); // 将数据附加在c.html的hash上
    }

    //c.html
    // 获取自身的hash再传到a.html的hash里，数据传输完毕
    parent.parent.location.hash = self.location.hash.substring(1);
</code></pre><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><pre><code>一、CORS概念: 是指跨域资源共享, 用于解决前端跨域问题, 使用自定义头部让浏览器与服务器进行沟通, 来进行请求成功或失败

    原理: 服务器对header设置一个Access-Control-Allow-Origin: *, 开启跨域请求。

    *表示接受所有域名的请求。也可以指定特定的域名 Access-Control-Allow-Origin: http://www.client.com。


二、CORS优点: 跨域最常用的是JSONP但这种方式是通过Get的方式请求src完成的，很多跨域问题JSONP无法解决，比如: 

    1、post请求跨域

    2、&quot;script error&quot; 的脚本错误提示

    3、canvas中无法获取跨域图片的信息，如果使用CORS上面几个问题就可以解决
</code></pre><p>   三、CORS缺点: </p>
<pre><code>1、cookie不会随请求发送，也不会响应

2、不能设置请求头的Content-Type字段

3、不能访问响应头信息
</code></pre><h4 id="Promise异步编程"><a href="#Promise异步编程" class="headerlink" title="Promise异步编程"></a>Promise异步编程</h4><h4 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h4><pre><code>同步: 就是代码逐行执行

异步: Promins、Ajax、setTimeout 来实现，执行到异步的代码时不会等待返回结果后在执行之后的代码，会直接往下执行。

同步和异步是针对单线程来讲的象JS，象Java一般不会说同步和异步，而是阻塞和非阻塞。
</code></pre><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><pre><code>面向对象的特点: 封装、继承、多态

对象组件: 私有、公有属性、方法和特权方法

一、constructor属性: 指向这个原型的构造函数，如果是类式继承需要修改子类的constructor的指向，如果不改子类会指向父类.

二、原型和原型链: 

    prototype原型: 在创建函数的时候JS会为这个函数自动加上prototype属性

    原型链: 每一个构造函数都有一个prototype, prototype包含一个指向构造函数的指针, 而实例包含指向原型的对象的指针, 都是通过 __proto__ 属性来指向

    1）构造函数实例化后，prototype下的所有属性和方法都为公用的一套, 这样为了节省资源提高性能

    2）优先级: 如果同时在构造函数内或prototype中定义相同的属性或方法名, 会先找到执行构造函数内的属性或方法, 如果没有在到prototype中查找。

        __proto__属性: __proto__是实例与prototype之间的链接，实例的__proto__指向构造函数的prototype.function F(){}; 

        var f = new F(); 
        console.log(f.__proto__ === F.prototype);           // true
        Object.prototype是顶级对象，所有对象都继承它

三、继承

    每个对象都是由Object.prototype对象继承的

    继承分为: 类式继承、原型链继承、拷贝继承。

    1、类式继承: 

        function Parent(){}
        Parent.prototype.say = function(){ 
            console.log(&apos;haha&apos;)
        }

        function Childer(){}

        /* 将第一个类的实例赋给第二个类的原形，类式继承的原因
        *  类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问
        */
        Childer.prototype = new Parent();   

        // 上一步执行后prototype的constructor会指向Parent，所以需要修正回来
        Childer.prototype.constructor = Childer;    
        Childer.prototype.getAuthor = function(){ console.log(&apos;siguang&apos;) }


    2、原型链继承: 

        // 原型链式继承
        /*
        * 流程:
        * 1、clonePlan调用blood属性会在clonePlan查找所有属性，
        * 2、如果没有找到在看clonePlan的__proto__指象哪里，这里指向了F，到F对象下的prototype下查找
        * 3、plane将prototype赋给了F的prototype所以最终找到了blood属性
        */

        function extend(obj){
            var F = function(){};
            F.prototype = obj;
            return new F();
        }

        // 定义一个类
        var Plane = function(){
            this.blood = 100;
            this.attackLevel = 1;
            this.defenseLevel = 1;
        }
        Plane.prototype = {
            getBlood: function(){
                console.log(this.blood);
            },
            getAttackLevel: function(){
                console.log(this.attackLevel)
            }
        }
        var plane = new Plane();

        // 将类通过extend函数继承过来
        var clonePlan = extend(plane);
        clonePlan.blood = 1234;
        clonePlan.attackLevel = 4567;

        clonePlan.getBlood();               // 1234
        clonePlan.getAttackLevel();         // 4567


    3、拷贝继承

        function extend(parent, childer){
            for(var key in parent){
                childer[key] = parent[key];
            }
        }

        extend(a.prototype, b.prototype);


    4、Object.create()继承

        function Car(desc){
            this.desc = desc;
            this.color = &apos;red&apos;
        }

        Car.prototype = {
            getInfo: function(){
                return `color: ${this.color}, desc: ${this.desc}`
            }
        }

        // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
        var child = Object.create(Car.prototype);
        child.desc = &apos;aaa&apos;;
        child.color = &apos;bbb&apos;;

        // 改变子类不会影响到父类
        console.log(child);
        var childCar = child.getInfo();
        console.log(childCar)       // color: bbb, desc: aaa


        var oCar = new Car(&apos;ccc&apos;);
        console.log(oCar.getInfo());    /// color: red, desc: ccc


四、SuperClass.prototype = {} 与 SuperClass.prototype.getName = function(){} 区别

    一个是将对象覆盖prototype, 一个是将方法添加到prototype中

    存在的问题，SuperClass.prototype = {}这种方式，实例的对象没有constructor,
</code></pre><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><pre><code>一、XMLHttpRequrest 缓存

    缓存只有在get请求中存在，如果服务端设置了缓存，如果在缓存失效前请求就会取到缓存的数据，解决有两种方法:

    1、加If-Modified-Since头

        xhr.setRequestHeader(&apos;If-Modified-Since&apos;, &apos;0&apos;);

        jquery中设置  $.ajax({ cache: false })

    2、给请求的URL后加参数 

        let sendUrl = &quot;http://host/getUser&quot;+&quot;?&quot;+Math.random();


// 创建一个XMLHttpRequest对象
var xhr = window.XMLHttpRequrest ? new XMLHttpRequrest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);   

属性: 服务器响应

    1、reponseText: 字符串响应数据

    2、responseXML: 获取XML响应数据

    3、timout: 设置超时请求时间

    4、responseType: 设置返回数据类型

        1、text: 字符串      2、document: Document对象       3、json: json数据       4、blob: 二进制对象       5、arrayBuffer: 二进制

方法: 

    1、open(请求类型，请求地址，同步/异步): 请求类型

    2、send(): 请求发送到服务器

    3、setRequestHeader(key，value): 设置请求头

    4、getResponseHeader(header)、getAllResponseHeaders(): 获取响应头

事件: 

    1、onabort: 停止传输

    2、onerror: 错误

    3、onload: 

    4、ontimout: 超时执行的事件

    5、onreadystatechange: 请求发送到服务器时，接收一些响应

        readyState: XMLHttpRequest的状态，

            0: 请求未初始化    1、服务器连接已建立      2、请求已接收     3、请求处理中     4、请求已完成，已响应

        status:  200: 成功  404:  未找到资源

        xhr.onreadystatechange = function(e){
            if(this.readyState == 4 &amp;&amp; this.state == 200){
                console.log(this.reponseText)
            }
        }

    6、upload: 上传 XMLHttpRequestUpload

        function uploadFile() {  
            // 创建FormData对象
            var fd = new FormData();
            // 添加值
            fd.append(&quot;fileToUpload&quot;, document.getElementById(&apos;fileToUpload&apos;).files[0]); 

            // 创建XMLHttpRequest()请求
            var xhr = new XMLHttpRequest();  
            // 文件上传时侦听progress事件
            xhr.upload.addEventListener(&quot;progress&quot;, uploadProgress, false);  

            xhr.addEventListener(&quot;load&quot;, uploadComplete, false);    // 载入 
            xhr.addEventListener(&quot;error&quot;, uploadFailed, false);     // 错误
            xhr.addEventListener(&quot;abort&quot;, uploadCanceled, false);   // 终止

            // 请求方式和地址
            xhr.open(&quot;POST&quot;, &quot;test2.php&quot;);  
            // 发送请求到服务器
            xhr.send(fd);  
        }

        function uploadProgress(evt) { 
            // evt.loaded 当前上传的大小， evt.total 文件总大小
            if (evt.lengthComputable) {  
                var percentComplete = Math.round(evt.loaded * 100 / evt.total);  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = percentComplete.toString() + &apos;%&apos;;  
            }  
            else {  
                document.getElementById(&apos;progressNumber&apos;).innerHTML = &apos;unable to compute&apos;;  
            }
        }

        function uploadComplete(evt) {  
            /* This event is raised when the server send back a response */  
            alert(evt.target.responseText);  
        }

        function uploadFailed(evt) {  
            alert(&quot;There was an error attempting to upload the file.&quot;);  
        }

        function uploadCanceled(evt) {  
            alert(&quot;The upload has been canceled by the user or the browser dropped the connection.&quot;);  
        }
</code></pre><h4 id="content-type四种类型"><a href="#content-type四种类型" class="headerlink" title="content-type四种类型"></a>content-type四种类型</h4><pre><code>get请求包括请求头、状态行

post请求包括请求头、状态行、请求主体（主体类型设置就是content-type来处理）

Content-Type:

一、application/x-www-form-urlencoded: 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据

    jquery和ajax的默认的方式 content-type:「application/x-www-form-urlencoded;charset=utf-8」

    header:
    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/x-www-form-urlencoded;charset=utf-8 

    ** Form Data

        incomeTime: &quot;16:25:13&quot;
        serialNumber: &quot;223&quot;
        incomeBank: &quot;中央银行&quot;
        incomeAccount: &quot;穷逼&quot;


二、multipart/form-data: 一般用来上传文件，必须让 form 的 enctyped 等于这个值

    content-type: multipart/form-data

    POST http://wwwexamplecom HTTP/11 
    Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA 

    ** Request Payload

        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
        Content-Disposition: form-data; name=&quot;text&quot; 

        title 
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
        Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chromepng&quot; 
        Content-Type: image/png 

        PNG  content of chromepng  
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 


三、application/json: 告诉服务端消息主体是序列化后的 JSON 字符串

    POST http://wwwexamplecom HTTP/11 
    Content-Type: application/json;charset=utf-8 

    // ajax请求
    var data = {&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]};
    $ajaxpost(url, data)success(function(result){

    });

    // 发送
    POST http://wwwexamplecom HTTP/11
    Content-Type: application/json;charset=utf-8

    ** Request Payload

        {&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]}


四、text/xml: XML文件作为编码方式的需要用到的类型

    POST http://wwwexamplecom HTTP/11
    Content-Type: text/xml

    ** Request Payload


五、HTML5中的fromData异步上传表单

    这里注意需设置 content-type:false 和 processData: false

    function upThumbSubmit() {
        if(!windowFormData) {　
            alert(&apos;your brower is too old&apos;);
            return false;
        }
        var formData = new FormData($( &quot;#upForm&quot; )[0]);
        var upLoadFile = documentquerySelector(&apos;upfile&apos;)files[0];
        formDataappend(&apos;file&apos;: upLoadFile);

        $ajax({
            url:&apos;?c=api&amp;a=upload&apos;,
            type:&apos;post&apos;,
            data:formData,
            processData: false,        // 不会被序列化
            contentType: false,        
            dataType:&apos;json&apos;,
            success:function(data){
                alert(data);
                return false;

            }
        });
    }
</code></pre><h4 id="iframe父子页面的通信"><a href="#iframe父子页面的通信" class="headerlink" title="iframe父子页面的通信"></a>iframe父子页面的通信</h4><pre><code>Example:

    parent.html:
        &lt;body&gt;
            &lt;iframe src=&quot;child.html&quot; frameborder=&quot;0&quot; id=&quot;child&quot;&gt;&lt;/iframe&gt;
        &lt;/body&gt;

    childe.html:
        &lt;body&gt;
            &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
        &lt;/body&gt;

一、父页面获取子页面

    &lt;script&gt;
        var myIframe = document.querySelector(&apos;#child&apos;), 
            childDocument;

        if(myIframe.document){
            childDocument = myIframe.docuemnt;
        }
        else{
            childDocument = myIframe.contentWindow.docuemnt;
        }

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;
    &lt;/script&gt;

    1、先获取iframe节点

        var myIframe = document.querySelector(&apos;#child&apos;);        // 或 myIframe = window.frames[&apos;child&apos;];

    2、获取iframe页面的document对象

        // ie浏览器
        var childDocument = myIframe.docuemnt;

        // 其它浏览器
        var childWindow = myIframe.contentWindow;     // 获取iframe的window对象
        var childDocument = myIframe.contentWindow.docuemnt;    // 获取iframe的document对象
        var childDocuemnt = myIframe.contentDocument;   // 也是获取document对象  与 myIframe.contentWindow.docuemnt 相同

    3、向id=&apos;box&apos;设置内容

        childDocument.querySelector(&apos;#box&apos;).innerHTML = &apos;xxxx&apos;;


二、子页面获取父页面

    1、获取父页面的document对象

        var parentDocument = window.parent.document;

    2、如果iframe嵌套多个iframe，想直接取到最顶层的iframe

        var selfDocument = window.self.document;
</code></pre><p>——————— ES5 API ————————</p>
<h4 id="提供全局的JSON对象"><a href="#提供全局的JSON对象" class="headerlink" title="提供全局的JSON对象"></a>提供全局的JSON对象</h4><pre><code>1、JSON.parse(): 将字符串转成对象

2、JSON.stringify(): 将对象转成字符串
</code></pre><h4 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h4><pre><code>1、push(): 向数组最后插入内容   unshift():向数据最前面插入一项

2、pop(): 删除数组最后一项内容  shift(): 删除数组第一项内容

    var arr = [1, 2, 3];   
    console.log(arr.pop());     // 3
    console.log(arr)    // [1, 2]

3、reverse(): 数组顺序颠倒

4、sort(): 排序

    let arr = [1, 123, 23, 4, 125, 6, 2, 31];
    arr.sort(function(v1, v2) {
        return v1 &lt; v2 // 从大到小排列
    })

5、concat(): 两个数组进行合并, 也可以拷贝成为一个新数组，而不是带指向

        var arrA = [1,2,3];
        var arrB = arrA.concat();
        arrB.push(5,6,7);
        console.log(arrA);  // [1,2,3]
        console.log(arrB);  // [1,2,3,5,6,7]

6、slice(开始，结束): 返回一个子数组,  如果结束参数不传为从开始取到最后的值

    let arr = [125, 123, 31, 23, 6, 4, 2, 1];
    let newArr = arr.slice(2, 5);  
    console.log(newArr, arr);        // [31, 23, 6]    [125, 123, 31, 23, 6, 4, 2, 1]

7、splice(): 用于替换、插入、删除

    splice(1,3): 删除 下标1-3的数据
    splice(3,0, &apos;insert&apos;): 插入 在位置3一个&apos;insert&apos;字符串
    splice(2,4, &apos;replce&apos;): 替换 将2-4的数组用 &apos;replce&apos;符

8、indexOf(): 查找数组中指定的字位的位置，未找到返回-1

    var arr = [1,2,3,4,5,6];  arr.indexOf(3);         // 返回2

9、lastIndexOf(): 查找数组中指定的字位的位置，从后向前查找，未找到返回-1


* 迭代方法

10、every(): 每一项为true，结果返回true

    // 数组中是否包含大于2的数
    var num = [1,2,3,2,1];
    var result = num.every(function(item,index,array) {    // item: 1, index: 0, array: [1,2,3,2,1]
        return (item &gt; 2);
    })
    console.log(result);        // true


11、some(): 有一项为true就不会往下执行，并返回true

    var dwarfPlanets = [&quot;ceres&quot;, &quot;pluto&quot;, &quot;haumea&quot;, &quot;makemake&quot;, &quot;eris&quot;];
    var result = dwarfPlanets.some(function(element) {
        return (element === &quot;pluto&quot;);
    });   
    console.log(result)     // true


5、filter(): 条件中返回true结果，重新返回一个新数组

    var arr = [1, 2, 3, 2, 5, 7];
    var result = arr.filter(function(item,index,array){
        return (item &gt; 2);
    })
    console.log(result);        // [3, 5, 7];


6、forEach(): 遍历数组, forEach无法跳出循环, 只能通过try...catch

    var arr = [&apos;lulu&apos;, &apos;siguang&apos;, &apos;mama&apos;, &apos;baba&apos;];
    arr.forEach(function(item, index, arr){  // lulu  0  [&quot;lulu&quot;, &quot;siguang&quot;, &quot;mama&quot;, &quot;baba&quot;]
        console.log(&apos;name:&apos;+item, index, arr);
    })


7、map(): 将每次return的数据，最终组成一个数组返回

    var srcColors = [
        {r: 255, g: 255, b: 255 },
        {r: 128, g: 128, b: 128 },
        {r: 0,   g: 0,   b: 0   }
    ];

    var newColor = srcColors.map(function(item, index, arr){         
        return item.r;
    })
    console.log(newColor);        // 返回 [255, 128, 0]


8、reduce(上次执行的结果，当前值，当前索引，数组对象)、reduceRight(): 归并数组，每次循环都会返回上一次值和当前值

    var val = [1,2,3,4,5];
    var sum = val.reduce(function(prev, cur, index, arr){   // prev 第一次执行的是1, 第二次执行的就是上次1+2返回的结果
        return prev + cur;   
    })
    console.log(sum);   // 15
</code></pre><h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><pre><code>1、__proto__: 对象实例与prototype之间的连接，原型链

2、prototype: 原型，公用的，节省内存开支，查找先去对象本身找属性和方法，如果没有到prototype下查找

3、constructor: 保存用于创建当前对象的构造函数名

4、toString()、valueOf()

5、delete: 删除对象属性

6、hasOwnProperty(propertyName): 用来判断属性是否在对象中（而不是原型中） var obj = {name: &apos;aaa&apos;}; obj.hasOwnProperty(&apos;name&apos;)

    var o = { name: &apos;siguang&apos;, getName: function(){ console.log(this.name) } };
    o.hasOwnProperty(&apos;name&apos;);       // true

    判断对象的属性或方法是否存在
    var obj = {};

    判断属性
        obj.name    // 如果属性不存在返回 undefined，也就是false

    判断方法
        typeof obj.getName == &apos;function&apos;      // 如果存在返回true


7、isPrototypeOf(object): 判断一个对象的原型是否是在指定对象的原型链中

    var o = new Object();
    Object.prototype.isPrototypeOf(o)


8、instanceof: 用来判断一个构造函数的prototype属性是否在另一个检测对象的原型链上

    A instanceof B   // 检测B的prototype是否存在于A的原型链上

9、in: 属性是否在对象中能访问，返回true或false

    function Persion(){
        var sex = &apos;男&apos;;
        this.name = &apos;siguang&apos;;
    }
    Persion.prototype.age = &apos;haha&apos;;

    var p1 = new Persion();
    console.log(&apos;name&apos; in p1);      // true
    console.log(&apos;age&apos; in p1);       // true
    console.log(&apos;sex&apos; in p1);       // false;


10、Object.create(o, p): 可以创建一个干净的对象，给o对象创建一个prototype，如果p对象存在

    var oA = Object.create(null);    // 创建一个干净的对象，没有__proto__属性
    var oB = {};        // 存储__proto__

    function Car(desc){
        this.desc = desc;
        this.color = &apos;red&apos;
    }

    Car.prototype = {
        getInfo: function(){
            return `color: ${this.color}, desc: ${this.desc}`
        }
    }

    // 注意这里的name : {value: &apos;lulu&apos;} 必须是对象，必须是value在根一个值，要不报错
    var child = Object.create(Car.prototype);
    child.desc = &apos;aaa&apos;;
    child.color = &apos;bbb&apos;;

    // 改变子类不会影响到父类
    console.log(child);
    var childCar = child.getInfo();
    console.log(childCar)       // color: bbb, desc: aaa

    var oCar = new Car(&apos;ccc&apos;);
    console.log(oCar.getInfo());    /// color: red, desc: ccc

    1) Object.create()与new Object()的区别

        var Base = function () {}
        var o1 = new Base();
        var o2 = Object.create(Base);

        Object.create(null) 是创建一个空对象，这个对象不继承Object.prototype原型链上的属性或方法


11、Object.defineProperty(obj, prop, descriptor): 对象新增或修改一个属性会执行set()、get()方法来通知

    参数: obj 目标对象     prop需要定义的属性      descriptor该属性拥有的特性，可设置的值有

    descriptor的值: 

        value 属性的值，默认为 undefined。

        writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。

        get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。

        set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。

        configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。

        enumerable 是否能在for...in循环中遍历出来或在Object.keys中列举出来。默认为 false。

    Example:
        var obj = {};
        Object.defineProperty(obj, &apos;name&apos;, {
            get: function(){
                debugger;
                // this.name;  
                return 23;
            },
            set: function(newValue){
                debugger
            }
        })

        Object.defineProperty(obj, &apos;sex&apos;, {
            get: function(){
                debugger;
                return &apos;女&apos;;
            },
            set: function(newValue){
                debugger
            }
        })

        obj.name = &apos;sss&apos;;           // 调用set()
        console.log(obj.name);      // 调用get()   23

        obj.sex = &apos;男&apos;;
        console.log(obj.sex);       // 女


    MVVM的核心: 

        &lt;div&gt;
            &lt;p&gt;你好，&lt;span id=&apos;nickName&apos;&gt;&lt;/span&gt;&lt;/p&gt;
            &lt;div id=&quot;introduce&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;

            // 视图控制器
            var userInfo = {};
            Object.defineProperty(userInfo, &quot;nickName&quot;, {
                get: function(){
                    return document.getElementById(&apos;nickName&apos;).innerHTML;
                },
                set: function(nick){
                    document.getElementById(&apos;nickName&apos;).innerHTML = nick;
                }
            });

            Object.defineProperty(userInfo, &quot;introduce&quot;, {
                get: function(){
                    return document.getElementById(&apos;introduce&apos;).innerHTML;
                },
                set: function(introduce){
                    document.getElementById(&apos;introduce&apos;).innerHTML = introduce;
                }
            })

            userInfo.nickName = &quot;siguang&quot;;
            userInfo.introduce = &quot;我是&quot;+ userInfo.nickName +&quot;，我来自黑龙江，...&quot;

        &lt;/script&gt;

    https://segmentfault.com/a/1190000004346467


12、Object.defineProperties: 与defineProperty相同就是可以设置多个属性

    let book = { year: 2004, edit: 1}
    Object.defainProperyies(book, {
        year:{
            get: function(){},
            set: function(){}
        },
        edit: {
            get: function(){},
            set: function(){}
        }
    })


13、Object.getPrototypeOf(object): 调用父类原型上的方法

    // 定义一个父类
    function PersonA(){
        this.methodA = function(){ 
            alert(&quot;a&quot;);
        }
    }
    PersonA.prototype.methodB = function(){
        alert(&apos;b&apos;);
    }

    // 定义一个子类
    function Man(){
        this.m1 = function(){
            //getPrototypeOf只有继承父类的时候才可以调用其方法
            Object.getPrototypeOf(this).methodA();        
        }
    }

    Man.prototype = new PersonA();
    Man.prototype.m2 = function(){
        Object.getPrototypeOf(this).methodB();
    }

    var man = new Man();
    man.m1();        // a
    man.m2();        // b


14、Object.keys(obj): 将对象obj下所有的属性的key，返回一个数组，用可以用它来判断是数组是否为空

    Object.keys(obj).length 是否等于0

15、Object.getOwnPropertyDescriptor(): 
</code></pre><h4 id="Function扩展"><a href="#Function扩展" class="headerlink" title="Function扩展"></a>Function扩展</h4><pre><code>1、bind(): 一个函数绑定之后，可以保持传递this的上下文

    var obj = {
        nameStr: 20,
        getName: function(){
            setTimeout(function(){
                console.log(this.nameStr);
            }.bind(obj), 10)
        }
    }

    // 输出20，如果不加bind()，this指向window所以输出的是undeined
    obj.getName();
</code></pre><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><pre><code>var od = new Date();    // 创建当前中国标准时间 Thu Apr 27 2017 18:39:17 GMT+0800 (CST)
var od = new Date(&apos;2017-04-27 18:40:00&apos;);   // 指定时间 返回当前标准时间 Thu Apr 27 2017 18:40:00 GMT+0800 (CST)

1、getTime(): 返回当前毫秒数

2、setTime(): 以毫秒设置时期

    var od = new Date(); 
    od.setTime(12312312312332); 
    console.log(od);        // Mon Feb 29 2360 22:45:12 GMT+0800 (CST)

3、getFullYear()、setFullYear(): 获取或设置年份

4、getMonth()、setMonth(): 获取或设置月份，值需要+1

5、getDate()、setDate(): 获取或设置日

6、getDay(): 返回星期几，值是0-6

7、getHours(): 小时

8、getMinutes(): 分钟

9、getSeconds(): 秒
</code></pre><h4 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h4><pre><code>1、toFixed(): 将值格式化小数点后几位
</code></pre><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><pre><code>1、length: 字符串长度

2、charAt(): 返回指定位置的字符  &apos;abcde&apos;.charAt(3)  &apos;d&apos;

3、chartCodeAt(): 返回指定位置的字符编码

4、concat(): 两个字符串拼接

5、split(): 将字符串以什么为分割，并返回为一个数组

截取

6、slice(begin,end): 截取字符串指定开始和结束位置的字符并返回， 可以接受负数

7、substring(begin,end): 截取字符串从开始到结束，

8、substr(begin, length): 返回一个指定开始到一个结束长度的字符

位置

9、indexOf(): 查找指定字符所在的位置

10、lastIndexOf(): 从后向前查找指定字符的位置

11、trim(): 删除前后空格  str.replace(/^\s*|$\s*/g, &apos;&apos;);

12、toLocaleUpperCase(): 转成小写字母

13、toUpperCase(): 转成大写字母

正则

14、search(reg): 搜索正则中匹配字符的位置，没有返回-1

15、match(reg): 将匹配的正则返回一个数组

    let text = &quot;cat, bat, sat, fat&quot;;
    let om = text.match(/.at/g);        // [&quot;cat&quot;, &quot;bat&quot;, &quot;sat&quot;, &quot;fat&quot;]

16、exec():

17、replace(reg, 替换字符): 替换指定字符
</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><pre><code>1、min()、max(): 返回最小、最大值

舍入

2、ceil(): 向上舍入

3、floor(): 向下舍入

4、round(): 四舍五入

5、random(): 随机数 0-1之间

6、abs(): 绝对值

7、sin()、cos()
</code></pre><h4 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h4><pre><code>encodeURI()、encodeURIComponent()
</code></pre><h4 id="前端动画实现种类"><a href="#前端动画实现种类" class="headerlink" title="前端动画实现种类"></a>前端动画实现种类</h4><pre><code>1、纯粹的CSS3: transition/animation+transform（大名鼎鼎的animate.css）

2、JS+CSS3 transition或者animation: 这里第一种一样，只是通过js里add class和remove class去增加或者移除对应的动画

3、纯粹JS控制时间轴: 第一和第二种都是自带时间轴，使用 setInterval / setTimeout / requestAnimationFrame 不断地修改 DOM 的 style 属性产生动画
</code></pre><p>| <a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es5/</a>    ES5兼容表<br>| <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/className" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/className</a>        API<br>| <a href="https://segmentfault.com/a/1190000000515151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000515151</a><br>| <a href="https://segmentfault.com/a/1190000005653355" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005653355</a><br>| <a href="https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dn342818(v=vs.94).aspx</a><br>| <a href="http://www.alloyteam.com/2016/05/javascript-timer/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/05/javascript-timer/</a>        js运行机制</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/正则表达式/">正则表达式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/正则表达式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="特殊字符和转义序列"><a href="#特殊字符和转义序列" class="headerlink" title="特殊字符和转义序列"></a>特殊字符和转义序列</h4><pre><code>1、[...] 位于括号内的任意字符            

    /[abcde]/.test(&apos;aboot&apos;);     // 只要含有任意一个字符返回 true

    /a[bo]t/.test(&apos;abot&apos;);        // false 中间只能含有其中一个字符，匹配&apos;abt&apos;或&apos;aot&apos;

2、[^...] 不在括号中之中的任意字符

    /a[^bo]t/.test(&apos;ast&apos;);        // true a|t之间不含有b、o期中一个字符

*3、. 除了换行和Unicode行止符之外的任意字符

    /a.t/.test(&apos;a*t&apos;);        // true , &apos;a\nt&apos;换行false，使用 \.来进行转义

4、\w 任何ASCII字符,等于[a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // true, 不含有其它字符

5、\W 任何非ASCII字符单字字符，等于[^a-zA-Z0-9_]

    /\w/.test(&apos;think&apos;);        // false, 至少需要有一个特殊字符

6、\s 任何空格

    /\s/.test(&apos;I think&apos;);    // true

7、\S 不包含空格

    /\s/.test(&apos;I think&apos;);    // false, 非空格为true

8、\d 任何数字，等于[0-9]

9、\D 除了数字之外的任意字符

10、\b 单词边界

    例: 匹配 hi 这个词，如果写成 /hi/ 这样 &apos;wordhibiry are you&apos; 也会匹配，如果加\b会单词的分界空格处来匹配， /hi\b/.test(&apos;word hi biry are you&apos;);  true

11、\B 非单词边界 
</code></pre><h4 id="指定匹配的位置"><a href="#指定匹配的位置" class="headerlink" title="指定匹配的位置"></a>指定匹配的位置</h4><pre><code>1、^ 匹配字符串的开头

    /^ab/.test(&apos;absolute&apos;);        // true 以ab开头

2、$ 匹配字符串的结尾

    /te$/.test(&apos;absolute&apos;);        // true 以te结尾

* 3、? ! 一个反前向声明者，含义与反前向声明相反
</code></pre><h4 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h4><pre><code>1、| 用于分隔选择的字符，相当于或

    /oa|on|op/.test(&apos;option&apos;);    // true，只要带有oa、on、op都匹配

2、(...) 分组，相当于并且

    /(\d+&amp;)([a-zA-Z]+%)/.test(&apos;1234&amp;abcde%&apos;);        // true, 必须包含数据+&amp;，并且还包含英文字母+%

* 3、(?...) 只组合，把项组合到一个单元，但不记忆与该组匹配的字符

    (?:):

    (?!):

    (?&lt;=):

    (?&lt;!):
</code></pre><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><pre><code>1、{ } 匹配一个字符的重复  **** 注意{3,10} 逗号后不能有空格, 如{3, 10}        

    /^\d{1,3}$/: 最少2个数字，最多4个数字

    /^\d{4,}$/: 最少有4个数字

    /^\d{4}$/: 只能有4个数字

2、* 表示0次或多次重复,等价于{0, }    /^\d*$/

3、？最少0次, 最多1次重复，等价于{0,1}   

4、+ 表示最少出现1次，等价于{1,}

5、\1、\2 重复的子项

    var reg = /(a)(b)(c)\1/;
    var str = &quot;abca&quot;;

    // 返回 true： \1是重复第一个子项(a)，相当于/(a)(b)(c)(a)/.     \2就是第二项(b)
    console.log(reg.test(str));
</code></pre><h4 id="修饰符，高级匹配"><a href="#修饰符，高级匹配" class="headerlink" title="修饰符，高级匹配"></a>修饰符，高级匹配</h4><pre><code>1、g 匹配的是全局，检索字符串的所有匹配

    如果不加g只匹配第一个后就退出

    let reg = /你妈的|去你妈|傻逼/g;
    let content = &apos;你妈的房子傻逼是用来住的你妈的不是用来炒的去你妈的吧&apos;;
    content = content.replace(reg, &apos;***&apos;);
    console.log(content)            // ***房子***是用来住的***不是用来炒的***的吧

2、i 匹配忽略大小写

    /java/i.test(&apos;JavdaScript&apos;);        // true

3、m 进行多行匹配
</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>1、match(reg) 将匹配结果返回一个数组

    var arr = &apos;123kasdo34kk234k234234k&apos;.match(/\d+/g);        // 如果不加g，只返回第一个
    console.log(arr);        // [&quot;123&quot;, &quot;34&quot;, &quot;234&quot;, &quot;234234&quot;]

2、test() 如果没有匹配返回false否则返回true

3、search(reg) 查找并返回所在的位置，如果没有匹配的返回-1

    var result = &apos;房地产行业究竟是白银时代还是钻石时代&apos;.search(/钻石/); 
    console.log(result);        // 返回 8

4、content.replace(reg, str) 用于执行检索和替换操作

5、exec() [ɪɡ&apos;zek] 如果找到返回一个数组并存放匹配的结果，如果没有找到返回null

    var result = /白银|钻石/g.exec(&apos;房地产行业究竟是白银时代还是钻石时代&apos;); 
    console.log(result);        // [&apos;&apos;]
</code></pre><h4 id="整理经验"><a href="#整理经验" class="headerlink" title="整理经验"></a>整理经验</h4><pre><code>1、如果检查全部需要前后加匹配

    /\d+/  只对字符中存在数字就匹配

    /^\d+$/  对字符中全部为数字的进行匹配


2、test()、exec()是对每一个字符串进行匹配，如果为true就不会往下执行，并返回true

    例如: 匹配字符中不能带有.字符
    /[^\.]/.test(&apos;123123.&apos;);    // 返回true，因为第一个字符就不是.返回true不在往下执行

    /[\.]/.test(&apos;23412.34&apos;);    // 如果存在就返回true
    或者
    /^[^\.]$/g.test(&apos;asdfa.sdf&apos;) // 返回true

3、| 或符号只能用到()中，不能在[]中使用
</code></pre><h4 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h4><pre><code>1、密码强度

    // 弱密码 - 纯数字、纯字母或纯特殊字符
    /^(?:\d+|[a-zA-Z]+|[!@#$%^&amp;*]+)$/

    // 中密码 - 字母+数字，字母+特殊字符，数字+特殊字符
    /^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$/

    // 强密码 - 必须有数字、小写字母、大写字母和特殊字符
    /^(?=.*((?=[!@#$%^&amp;*_]+)[^A-Za-z0-9]))(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[^\u4e00-\u9fa5]{8,16}$/


2、手机号码验证

    /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139|186|185|170|156|155|130|131|132|189|180|170|153|133)(\d){8}$/.test(&apos;13012345678&apos;)

    移动号段: /^(139|138|137|136|135|134|178|170|188|187|183|182|159|158|157|152|150|147|139)(\d){8}$/;     

    联通号段: /^(186|185|170|156|155|130|131|132)(\d){8}$/

    电信号段: /^(189|180|170|153|133)(\d){8}$/


3、验证Email - /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/

4、验证中文 - /^[\u4e00-\u9fa5]+$/

5、域名验证 - /^(http(s)?:\/\/)(www)?\.\w+\.(com|cn|net|org)$/

6、手机号前带86或是+86 - /^((\+86)|(86))?(13)\d{9}$/

7、电话号码与手机号码同时验证 - /(^(\d{3,4}-)?\d{7,8})$|(13[0-9]{9})/

8、验证IP地址 - /^((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)$/;    //  匹配0-255, 匹配&apos;255.255.255.255&apos;

9、邮政编码 - /[1-9]{1}(\d+){5}/

10、身份证号码 - /\d{18}|\d{15}/

11、双字节字符串(汉字) - /[^\x00-\xff]*/

12、去除两端空格 - /^\s*|\s*$/

数字正则

    /^\d+$/ - 非负整数（正整数 + 0)

    /^[1-9](\d)+$/ - 正整数(不可以以0开头)  

    /^-(\d)+$/ - 非正整数（负整数 + 0） 

    /^-[1-9]?(\d){0,}$/ - 负整数(-12345), 不可以-012312

    /^[1-9]?(\d)+\.(\d)+$/ - 浮点数   

    /^[+-]?\d+(\.\d{1,2})?$/ - 可以是整数 或 浮点数，并且小数点只能后两位

    ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$    //正浮点数   
    ^((-\\d+(　　//非正浮点数（负浮点数 + 0）   
    ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$  //负浮点数  

    /^[A-Za-z]+$/ - 由26个英文字母组成的字符串   

    /^[A-Z]+$/ - 由26个英文字母的大写组成的字符串   

    /^[a-z]+$/ - 由26个英文字母的小写组成的字符串  

    /^[A-Za-z0-9]+$/ - 由数字和26个英文字母组成的字符串   

    /^\w+$/ - 由数字、26个英文字母或者下划线组成的字符串
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/07/JS作用域和整理经验/">JS作用域和整理经验</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/07/JS作用域和整理经验/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-07T08:54:51.000Z" itemprop="datePublished">2016-12-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/javascript/">javascript</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><pre><code>一、示例

    console.log(str);        // 输出undefined  因为读取的是解析器预先存储的str，还没有被赋值
    var str = 1;         


二、示例2

    alert(a);        // 弹出的是function a(){ alert(&quot;2&quot;)}
    var a = 1;
    function a(){
        alert(&quot;2&quot;)
    }

    预解析会保存a = undefinded，和 a = function a(){alert(&quot;2&quot;)}，
    因为函数与变量重名，函数后最执行所以保留函数，结果输出的就是函数


三、示例3

    var a = 1;
    function a(){
        alert(&quot;2&quot;);
    }

    // 报错，因为a被定义成变量，typeof a 返回的是number，如果 var a;不能定义值那么a()是成功的
    a();


四、示例4

    var a = 1;
    function fn1(){
        alert(a);
        // 注意这里因为是使用var声明所以执行数预解析器才会把它单独存储起来，
        // 如果将var去掉，a=2改成了赋值这样会改变外部的a的值，下面输出的就是1，2
        var a = 2;
    }

    fn1();                        // undefined
    console.log(a);        // 1


五、示例5

    function foo(){
        return fn1;

        function fn1(){};
        var fn1 = 10;
    }

    var f = foo();

    // 输出 function fn1(){};    因为调用foo函数时，return  fn1因为变量还未定义所以 直接调用的函数
    alert(f);                


六、示例6

    var  myname = &quot;global&quot;; // 全局变量
    function func() {

        // &quot;undefined&quot;，如果函数内不在定义myname就会找全局的变量，但函数本身已经定义了，预编译会先将变量定义成undefined
        alert(myname);                 
        var myname = &quot;local&quot;;
        alert(myname);                 // &quot;local&quot;
    }
    func();


七、示例7

    &lt;script&gt;
        window.name = &apos;globalName&apos;;

        var getName = function(){
            return this.name;
        }

        getName();         // &apos;globalName&apos;
    &lt;/script&gt;


八、示例8

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var callback = function(){
                return this.id;        // divA
            }
            callback();            // window
        }
    &lt;/script&gt;


 九、示例9

    1、Example
        var getName;
        console.log(getName)    // undefined

        getName()                // Uncaught TypeError: getName is not a function

        var getName = function() {
            console.log(&apos;wscat&apos;)
        }

    2、Example
        var getName;
        console.log(getName)    // function getName() {console.log(&apos;oaoafly&apos;)}

        getName()                // oaoafly

        function getName() {
            console.log(&apos;oaoafly&apos;)
        }


十、bind()

    &lt;script&gt;
        window.id = &apos;window&apos;;

        document.getElementById(&apos;divA&apos;).onclick = function(){
            alert(this.id);

            var obj = {
                id: &apos;objId&apos;,
                callback: function(){
                    return this.id;         // &apos;divA&apos;
                }.bind(window)                // 通过bind来将callback内的this指向window
            }

            console.log(obj.callback());    // &apos;window&apos;
        }
    &lt;/script&gt;


十一、严格模式下的this

    &lt;script&gt;
        &apos;use strict&apos;

        function fun(){
            alert(this);        // 返回 &apos;undefined&apos;, strict模式下this不会指向全局
        }

        fun();
    &lt;/script&gt;


十二、箭头函数下的this指向

    let Template = {
        test(){
            console.log(this);        // this指向Template

            document.querySelector(&quot;#showThis&quot;).onclick = () =&gt;{
                // 如果非箭头函数this应该指向 #showThis
                // 这里箭头函数不是指向调用者，所以指向了 Template
                console.log(this);    
            }
        }
    }
    Template.test();
</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code>1、函数本身是对象也是构造函数

2、直接挂载到函数下，是对象的属性和方法

    function Foo(){};
    Foo.username = &apos;111&apos;;     // 注意这里Foo的属性不能为name因为被name被函数的名所占用
    Foo.getName = function(){ console.log(this.username) };

    // 调用
    Foo.getName();        // 111

3、在构造函数的内部属性和方法

    function Foo() {
        this.username = &apos;111&apos;
    }
    Foo.username = &apos;222&apos;;

    // 调用
    console.log(new Foo().username);    // 111

&lt;script&gt;
    function Foo() {
        getName = function() {
            console.log(this);
            console.log(1);
        }

        console.log(this);
        return this;
    }
    Foo.getName = function() { // 这里只是Foo对象的方法，而不是构造函数的方法，
        console.log(2);
    }

    // Foo.prototype.getName = function() {
    //     console.log(3);
    // }

    var getName = function() {
        console.log(4)
    }

    function getName() {
        console.log(5)
    }

    Foo.getName(); // 2    Foo.getName=function(){}  是存到Foo下的方法，Foo.getName()可以取到
    getName(); // 4     如果一个作用域下有var的变量名与函数名相当，var的作用域提升高于function
    Foo().getName();     // 1  因为Foo()被调用，定义中加了return this，Foo指向的是window全局，getName没有var升明，所以为全局，所以相当于window.getName()，Foo中如果不加return this那么就会报错，因为Foo没有链式调用，所以this断了
    getName(); // 1   因为上面已经将Foo内的getName()提升成全局，所以会赋盖掉var getName、function getName定义的全局方法

    // var ofo = new Foo;
    // ofo.getName();   // 3

    // Foo既是一个对象也是一个构造函数
    new Foo.getName();             // 2  先执行Foo.getName()，因为&quot;.&quot;运算符优先于new运算符，所以这时候Foo只是一个对象并不是构造函数的实例，所以会调用对象下的方法
    new Foo().getName();         // 1  先执行new Foo()构造函数，然后在构造函数下去找getName方法，Foo构造函数方法没有getName()所以到prototype下去找
    new new Foo().getName();     // 1  与上面相同
&lt;/script&gt;
</code></pre><h4 id="将对象拷贝并不引用指针"><a href="#将对象拷贝并不引用指针" class="headerlink" title="将对象拷贝并不引用指针"></a>将对象拷贝并不引用指针</h4><pre><code>有两种方法，一是使用for...in将一个对象拷贝到另一个对象

另一种方法是使用Object.assign()

let objA = {
    name: &apos;siguang&apos;,
    age: 30
}
let objB = Object.assign({}, objA);
objB.name = &apos;lulu&apos;;         // lulu
console.log(objA.name);     // siguang
</code></pre><h4 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h4><pre><code>浅拷贝就是对象之间还存引用关系，深拷贝就是两个对象之间没有引用关系

一、浅拷贝

    const a = {t: 1, p: &apos;gg&apos;};
    const b = a;
    b.t = 3;
    console.log(a);     // {t: 3, p: &apos;gg&apos;}
    console.log(b);     // {t: 3, p: &apos;gg&apos;}

二 、深拷贝

    1、Object.assign() 方法是将两个对象合并，并返回一个新对象

        **** 注意assig()只能拷贝一层，多层结构还是浅拷贝 ****

        const c = {t: 1, p: &apos;gg&apos;};
        const d = Object.assign({}, c);
        d.t = 3;
        console.log(c);     // {t: 1, p: &apos;gg&apos;}
        console.log(d);     // {t: 3, p: &apos;gg&apos;}

    2、Object.create() 将拷贝的内容入到prototype下，对象和数组都适用

        对象:

            var oA = {
                name: &apos;sg&apos;,
                age: 33
            }
            var oB = {};
            oB = Object.create(oA);

            oB.eat = &apos;bread&apos;;

        数组:

            var oA = [1,2]
            var oB = [];
            oB = Object.create(oA);

            oB.push(3);            // oB.length;   3        

    3、jQuery.extend()

        let oa = {a: 1, b: 2}; let ob = {};  
        $.extend(ob, oa); 
        ob.b = 3; 
        console.log(oa, ob);        // oa: {a: 1, b: 2}、 ob: {a: 1, b: 3}
</code></pre><h4 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h4><pre><code>一、concat()方法

    var arrA = [1,2,3];
    var arrB = arrA.concat();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

二、slice()方法

    var arrA = [1,2,3];
    var arrB = arrA.slice();
    arrB.push(5,6,7);
    console.log(arrA);  // [1,2,3]
    console.log(arrB);  // [1,2,3,5,6,7]

两种方法都是回返一个不带指向的新数组
</code></pre><h4 id="对象处理"><a href="#对象处理" class="headerlink" title="对象处理"></a>对象处理</h4><pre><code>一、查看是否是一个空对象

    // 使用keys来查看对象中所有的kyes并返回一个数组，如果数组为度为0则对象为空
    var obj = {}; 
    var Len = Object.keys(obj);         
    console.log(Len.length);

二、查看对象中属性是否存在

    var obj = {
        a: 1,
        b: 2
    }
    console.log(obj.c);        // undefined
</code></pre><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><pre><code>function isDataType(data){

}
</code></pre><h4 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h4><pre><code>一、数据去重

    1、普通方法

        function clearRepeat(arr){
            var newArr = [], obj = {};
            for(var i=0; i&lt;arr.length; i++){
                if(!obj[arr[i]]){
                    obj[arr[i]] = &apos;&apos;;        // 对象属性相同会直接覆盖
                    newArr.push(key);        
                }
            }
            return newArr;
        }

        let retArray = clearRepeat([3,2,3,4,5,5,2,2,13,3]);


    2、使用ES6的set()方法，set方法就是不允许数组内有重复的值

        let setValue = new Set([1,2,33,1,22,2,2,4,2,1,2])
        console.log(setValue, Object.prototype.toString.call(setValue));        // {size: 5, [1, 2, 33, 22, 4]}, &apos;[Object Set]&apos;
        let arr = [...setValue];        // [1, 2, 33, 22, 4] 需要进行解构

    http://www.jb51.net/article/46154.htm


二、数组排序

    1、使用sort方法

        var arr = [6,7,5,8,4,2342342,23,234,2,34];
        arr.sort(function(v1, v2){
            return v1 - v2        // 正序
        })
        console.log(arr);


三、返回数组中最大最小值

    let arr = [2,1,423,343,5,67,8];
    let min = Math.min.apply(null, arr);
    let max = Math.max.apply(null, arr);
</code></pre><h4 id="编写组件并兼容AMD、ES6写法"><a href="#编写组件并兼容AMD、ES6写法" class="headerlink" title="编写组件并兼容AMD、ES6写法"></a>编写组件并兼容AMD、ES6写法</h4><pre><code>;(function(root, factory){

    // 判断使用的支持定义模块的方式
    if(typeof define === &apos;function&apos; &amp;&amp; define.amd){
        define(factory)
    }
    else if(typeof exports === &apos;object&apos;){
        module.exports = factory();
    }
    else{
        root.NProgress = factory();
    }

})(this, function(){
    console.log(`输出内容`);
})
</code></pre><p>| <a href="https://juejin.im/entry/58db95eaac502e0058f8472e" target="_blank" rel="noopener">https://juejin.im/entry/58db95eaac502e0058f8472e</a><br>| <a href="http://www.iamaddy.net/2015/04/front-end-engineering/" target="_blank" rel="noopener">http://www.iamaddy.net/2015/04/front-end-engineering/</a>       // 前端的发展</p>

        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
