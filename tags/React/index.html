<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Tag: React | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongoose/">Mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件/">前端插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/14/React(之四)其它状态管理及框架/">React（之四）其它框架状态管理及框架</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/12/14/React(之四)其它状态管理及框架/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-14T03:06:16.000Z" itemprop="datePublished">2018-12-14</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| dva<br>| redux<br>| redux-saga<br>| redux-thunk<br>| Ant Design Pro</p>
<h4 id="状态管理框架"><a href="#状态管理框架" class="headerlink" title="状态管理框架"></a>状态管理框架</h4><pre><code>https://cn.mobx.js.org/

// redux-saga 中间件
https://redux-saga-in-chinese.js.org/    

// dva
https://dvajs.com/guide/#%E7%89%B9%E6%80%A7        dva
</code></pre><h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><pre><code>redux-saga 是一个用于管理 Redux 应用异步操作的中间件（又称异步 action），Sagas是通过Generator函数来创建

Reducers 负责处理 action 的 state 更新
Sagas 负责协调那些复杂或异步的操作

一、安装

    $ npm install --save redux-saga


二、使用

    sagas.js   // 创建一saga.js文件

    main.js

        import { createStore, applyMiddleware } from &apos;redux&apos;
        import createSagaMiddleware from &apos;redux-saga&apos;

        import reducer from &apos;./reducers&apos;
        import mySaga from &apos;./sagas&apos;

        // 创建saga中间件
        const sagaMiddleware = createSagaMiddleware()

        // 加到createStore中
        const store = createStore(
            reducer,
            applyMiddleware(sagaMiddleware)
        )

        // 运行 saga
        sagaMiddleware.run(mySaga)


三、核心函数

    1、takeEveny(&apos;actionName&apos;, 执行的saga函数) - type的action触发，就执行goAge()函数

    2、takeLatest()

    3、createSagaMiddleware()：创建一个Reudx中间件，将Sagas与Redux Store链接起来

    4、middleware.run()：运行sagas，


四、Effect 

    import { call, put, takeEveny } from &apos;redux-saga/effects&apos;

    1、take()：监听未来的action

        function* watchFetchData() {
            while(true) {
                // 监听一个type为 &apos;FETCH_REQUESTED&apos; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData)  语句
                yield take(&apos;FETCH_REQUESTED&apos;);
                yield fork(fetchData);
            }
        }

    2、takeEveny(): 

        function* rootSaga() {     // 在store.js中，执行了 sagaMiddleware.run(rootSaga)
            yield takeEvery(&quot;ADD_SAGA&quot;, addSagas)   // 如果有对应type的action触发，就执行goAge()函数
        }

    3、put()：发送action的effect，简单把它理解为dispatch

        export function* toggleItemFlow() {
            let list = []
            // 发送一个type为 &apos;UPDATE_DATA&apos; 的Action，用来更新数据，参数为 `data：list`
            yield put({
                type: actionTypes.UPDATE_DATA,
                data: list
            })
        }

    4、call()：简单的理解为就是可以调用其他函数的函数

        export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

        export function* removeItem() {
            try {
                // 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数
                return yield call(delay, 500)
            } catch (err) {
                yield put({type: actionTypes.ERROR})
            }
        }

    5、fork()：用来调用其它函数，是一个非阻塞函数，

        export default function* rootSaga() {
            // 下面的四个 Generator 函数会一次执行，不会阻塞执行
            yield fork(addItemFlow)
            yield fork(removeItemFlow)
            yield fork(toggleItemFlow)
            yield fork(modifyItem)
        }

    6、select()：获取Store中的state值

        let tempList = yield select(state =&gt; {
            debugger;
        })


https://www.jianshu.com/p/7cac18e8d870
https://github.com/redux-saga/redux-saga/ 官网
https://redux-saga-in-chinese.js.org/ 中文在线文档
https://segmentfault.com/a/1190000007248878 Redux异步方案选型
https://www.jianshu.com/p/f3c7594c4fb4 redux-saga 初级学习教程
https://github.com/Pines-Cheng/blog/issues/9 从redux-thunk到redux-saga实践
http://yanqiw.github.io/react/2017/03/05/redux-saga.html Redux Saga实践
</code></pre><h4 id="dva-js"><a href="#dva-js" class="headerlink" title="dva.js"></a>dva.js</h4><pre><code>dva是redux和redux-saga的数据流文案，还内置了react-router和fetch的一个应用框架

一、安装

    $ sudo npm i dva-cli -g

    $ sudo dva new dva-quickstart


二、定义Model

    把一个领域的模型管理起来，包含同步更新state的reducers，处理异步逻辑

    export default {
        namespace: &apos;products&apos;,  // 表示在全局 state 上的 key，最好与组件名相同保持统一
        state: {},                            // 初始值
        reducers: {                            // 等同于 redux 里的 reducer，接收 action，同步更新 state
            save(state, action) {
                return {
                    ...state,
                    data: action.payload,
                };
            },
        }
    }


三、connect 起来

    通过connect将model和component联接起来

    class products extends Componet {
        ... 

        render {
            const { dispatch, products } = this.props

            return (
                &lt;div&gt;&lt;/div&gt;
            )
        }
    }

    export default connect(({ products }) =&gt; ({
        products,
    }))(Products);


四、models

    dispatch

    Reducer(state, action): 

    effects: 异步操作，底层引入redux-sagas，采用了generator

    Subscription: 

    Router: 


五、整理

    1、调用同步和异步

        调用reducers内的方法是同步，直接改变指定state的值

        调用effects内的方法是异步的调用，调取成功后在调用reducers中的方法来改变state


安装后目录结构:
|- mock                        // mock
|- node_modules        // 包
|- package.json        
|- public
|- src
        |- asserts            // 静态资源，打包会经过webpack处理
        |- components        // 存放React组件，公用的无状态组件
        |- models                // 模型文件
        |- routes                // 存放需要connect model的路由组件
        |- services            // 存放服务文件，一般是网络请求
        |- utils                // 工具库
        |- router.js        // 路由文件
        |- index.js            // 项目入口
        |- index.css
|- .editorconfig        // 编辑器配置文件
|- .eslintrc
|- .gitignore
|- .roadhogrc.mock.js    // Mock配置文件
|- .webpackrc                //  自定义的webpack配置文件


https://dvajs.com/        // dva
</code></pre><h4 id="Ant-Design-Pro"><a href="#Ant-Design-Pro" class="headerlink" title="Ant Design Pro"></a>Ant Design Pro</h4><pre><code>安装:
$ git clone --depth=1 https://github.com/ant-design/ant-design-pro.git my-project
$ cd my-project
$ npm install

启动服务:
$ npm start                            // mock数据
$ npm start:no-mock         // 不走mock数据
$ npm run prettier            // 格式化代码
$ npm run lint-staged        // 检测

构建:
$ npm run build


一、路由

    脚手架默认提供了两种布局模板：基础布局 - BasicLayout 以及 账户相关布局 - UserLayout

    router.config.js

    1、name、icon - 菜单项和图标

    2、hideChildrenInMenu - 菜单子路由是否展示

    3、hideInMenu - 菜单中不展示这个路由

    4、authority - 指写可以看当前菜单的用户 Array

    // app
    {
        path: &apos;/&apos;,
        component: &apos;../layouts/BasicLayout&apos;,
        Routes: [&apos;src/pages/Authorized&apos;],
        authority: [&apos;admin&apos;, &apos;user&apos;],
        routes: [
            {
                path: &apos;/dashboard&apos;,
                name: &apos;dashboard&apos;,
                icon: &apos;dashboard&apos;,
                hideChildrenInMenu: true,                    // 隐藏所有子菜单，但这块需要加一个对应dashboard路由的component: &apos;./Dashboard/Analysis&apos;
                routes: [
                    {
                        path: &apos;/dashboard/analysis&apos;,
                        name: &apos;analysis&apos;,
                        component: &apos;./Dashboard/Analysis&apos;,
                    },
                    ...
                ],
            }
        ]
    }
    // new 这里是新增布局
    {
        path: &apos;/new&apos;,
        component: &apos;../layouts/new_page&apos;,
        routes:[...]
    },


二、config.js 配置代理到后端服务器

    {
        proxy:{
            &apos;/server/api/&apos;: {
                target: &apos;https://preview.pro.ant.design/&apos;,
                changeOrigin: true,
                pathRewrite: { &apos;^/server&apos;: &apos;&apos; }, // /server/api/currentUser -&gt; /api/currentUser
            },
        }
    }

三、支持SASS

    $ npm i node-sass sass-loader --save            // 安装依赖


四、页面添加 dva

    modle - 分两种: 1、全局models（存在/src/models/）   2、页面models （存在于每个业务下/models 不能被其他页面所引用）

    service - 请求数据


五、请求的过程

    1、UI 组件交互操作

    2、调用 model 的 effect

    3、调用统一管理的 service 请求函数

    4、使用封装的 request.js 发送请求

    5、获取服务端返回

    6、然后调用 reducer 改变 state

    7、更新 model


六、Mock

    export default {
        // 支持值为 Object 和 Array
        &apos;GET /api/users&apos;: { users: [1, 2] },

        // GET POST 可省略
        &apos;/api/users/1&apos;: { id: 1 },

        // 支持自定义函数，API 参考 express@4
        &apos;POST /api/users/create&apos;: (req, res) =&gt; { res.end(&apos;OK&apos;); },
    };

    1、可以引用Mock.js第三方库

        import mockjs from &apos;mockjs&apos;;

        export default {
            // 使用 mockjs 等三方库
            &apos;GET /api/tags&apos;: mockjs.mock({
                &apos;list|100&apos;: [{ name: &apos;@city&apos;, &apos;value|1-100&apos;: 50, &apos;type|0-2&apos;: 1 }],
            }),
        };

七、自定义主题

    config/config.js文件

    theme: {
        &apos;font-size-base&apos;: &apos;14px&apos;,
        &apos;badge-font-size&apos;: &apos;12px&apos;,
        &apos;btn-font-size-lg&apos;: &apos;@font-size-base&apos;,
        &apos;menu-dark-bg&apos;: &apos;#00182E&apos;,
        &apos;menu-dark-submenu-bg&apos;: &apos;#000B14&apos;,
        &apos;layout-sider-background&apos;: &apos;#00182E&apos;,
        &apos;layout-body-background&apos;: &apos;#f0f2f5&apos;,
    };


八、项目总结

    1、Mock数据不能在生产环境使用，只能在开发环境

    2、使用动态路由时切换时取不到参数，见下面UMI动态路由解决方法
</code></pre><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><pre><code>├── config              # umi 配置，包含路由，构建等配置
│   ├── config.js                        #    构建
│   ├── plugin.config.js
│   ├── router.config.js      # 路由配置文件
├── mock                # 本地模拟数据
├── public
│   └── favicon.png         # Favicon
├── layouts                            # 框架页面
├──     ├── BasicLayout                # Basic框架页
├──     ├── Header                        # 头  
├──   ├── Footer                        # 尾
├── locales
|          ├── zh-CN
|            |            ├── menu.js            # 配置显示在菜单对应路由的中文名
├── src                                    # 重要
│   ├── assets              # 本地静态资源
│   ├── components          # 业务通用组件
│   │       ├── GlobalHeader        # 顶部右侧部分内容
│   ├── e2e                 # 集成测试用例
│   ├── layouts             # 通用布局
│   │            ├── BasicLayouts      # 基础布局
│   ├── models              # 全局 dva model
│   |            ├── menu.js                    # 菜单处理过滤
│   |            ├── login.js                # 登录请求
│   ├── pages               # 业务页面入口和常用模板
│   │            ├── document.ejs        # 首页模板
│   │            ├── User                        # Login/Register  登录和注册组件
│   ├── services            # 后台接口服务
│   ├── utils               # 工具库
│   ├── locales             # 国际化资源
│   ├── global.less         # 全局样式
│   ├── defaultSettings.js    # 配置菜单样式等
│   └── global.js           # 全局 JS
├── utils                                # 工具
├──     ├── request.js                # 封装Ajax请求
├──     ├── Authorized                # 授权
├── models                            # 全局
├──     ├── menu                            # 菜单的配置和过滤
├──   ├── 
├── tests               # 测试工具
├── README.md
└── package.json
</code></pre><h4 id="Umi-js"><a href="#Umi-js" class="headerlink" title="Umi.js"></a>Umi.js</h4><pre><code>umi，中文可发音为乌米, 内置了react、react-router，以路由为基础，支持next.js的约定式路由

一、安装

    $ yarn global add umi     // 安装 umi -v 来查看版本

    $ mkdir myumi &amp;&amp; cd myumi

    1、脚手架创建

        $ yarn creat umi                 // 通过creat-umi脚手架创建，其实就安装了 Ant Design Pro 的简版没有components


    2、普通创建

        $ umi g page index            // 简单创建页面

            umi g page users

        $ umi dev            // 启动服务

        $ umi build        // 构建


二、路由

    约定式路由 - 启动服务后在pages下产生一个.umi临时目录里面有router.js，umi 会根据 pages 目录自动生成路由配置

    配置式路由 - 如果使用配置可以在，config/router.config.js

    1、路由跳转: 

        import Link from &apos;umi/link&apos;            // 加载link

        export default function(){
            return (
                &lt;div&gt;
                    &lt;Link to=&quot;/user&quot;&gt;跳转到用户&lt;/Link&gt;
                &lt;/div&gt;
            )
        }

        命令式:
            function goToListPage() {
                router.push(&apos;/list&apos;);
            }

    2、动态路由

        umi约定 带 $ 前缀的目录或文件为动态路由

        + pages/
            + $post/
                - index.js
                - comments.js
            + users/
                $id.js
            - index.js

        [
            { path: &apos;/&apos;, component: &apos;./pages/index.js&apos; },
            { path: &apos;/users/:id&apos;, component: &apos;./pages/users/$id.js&apos; },
            { path: &apos;/:post/&apos;, component: &apos;./pages/$post/index.js&apos; },
            { path: &apos;/:post/comments&apos;, component: &apos;./pages/$post/comments.js&apos; },
        ]

        注意: 动态路由切换时不会在调用componentWillMount，需要在componentDidUpdate来侦听

             state = {
                chartId: &apos;&apos;
            };

            componentDidUpdate(){
                const { computedMatch } = this.props;
                const { chartId } = this.state;

                if(chartId !== computedMatch.params.id){
                    this.initChartList();
                }
            }

            initChartList(){
                const { dispatch, computedMatch } = this.props;
                console.log(computedMatch.params.id)

                this.setState({
                    chartId: computedMatch.params.id
                })

                dispatch({
                    type: &apos;chartData/getChartsData&apos;,
                    payload: {
                        pageId: computedMatch.params.id
                    }
                });
            }


    3、路由嵌套

        配置routers

        export default {
            routes: [
                { path: &apos;/users&apos;, component: &apos;./users/_layout&apos;,
                    routes: [
                        { path: &apos;/users/detail&apos;, component: &apos;./users/detail&apos; },
                        { path: &apos;/users/:id&apos;, component: &apos;./users/id&apos; }
                    ]
                },
            ],
        };

    4、权限

        PrivateRoute.js来渲染/list

    https://umijs.org/zh/guide/router.html#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1


三、Mock 数据

    let agentDataList = [...]
    function getAgents(req, res) {
        const dataSource = agentDataList;
        const result = {
            list: dataSource,
            total: dataSource.length,
        };
        return res.json(result);
    }

    export default {
        &apos;POST /api/arbitration/agent/query&apos;: getAgents,
    }

    --- 可以引入mock.js ---
    import mockjs from &apos;mockjs&apos;;
    export default {
        // 使用 mockjs 等三方库
        &apos;GET /api/tags&apos;: mockjs.mock({
            &apos;list|100&apos;: [{ name: &apos;@city&apos;, &apos;value|1-100&apos;: 50, &apos;type|0-2&apos;: 1 }],
        }),
    };
</code></pre><h2 id="antdPro-流程"><a href="#antdPro-流程" class="headerlink" title="antdPro 流程"></a>antdPro 流程</h2><pre><code>一、app.js入口

    // 获取权限路由，也可以在这添加路由
    fetch(&apos;/api/auth_routes&apos;)
  .then(res =&gt; res.json())
  .then(ret =&gt; {
    authRoutes = ret;
    oldRender();
  });


二、login 登录接口

    request: /api/login/account
    response: {status: &quot;ok&quot;, type: &quot;account&quot;, currentAuthority: &quot;admin&quot;}


三、设置和获取权限 

    router.config.js 配置Routes每个页面都调用Authorized.js来判断权限
    {
        path: &apos;/&apos;,
        component: &apos;../layouts/BasicLayout&apos;,
        Routes: [&apos;src/pages/Authorized&apos;],                // 设置
        authority: [&apos;admin&apos;, &apos;user&apos;, &apos;ROLE_RDDPL4WSV0&apos;],
        routes: [
            { path: &apos;/&apos;, redirect: &apos;/dashboard/workplace&apos;, authority: [&apos;admin&apos;, &apos;user&apos;, &apos;ROLE_RDDPL4WSV0&apos;] },
        ]
    }


    utils/authority   getAuthority、setAuthority

    存储到localStrage中的antd-pro-authority


四、菜单

    modules/menu        getMenuData()获取菜单的方法

    layouts/BasicLayouts        页面布局，SiderMenu组件menuData菜单数据

    menuData格式
    [{
        &quot;path&quot;: &quot;/dictionary&quot;,
        &quot;icon&quot;: &quot;book&quot;,
        &quot;name&quot;: &quot;数据字典&quot;,
        &quot;locale&quot;: &quot;menu.dictionary&quot;,
        &quot;authority&quot;: [&quot;admin&quot;, &quot;user&quot;],
        &quot;children&quot;: [{
            &quot;path&quot;: &quot;/dictionary/list&quot;,
            &quot;name&quot;: &quot;字典列表&quot;,
            &quot;exact&quot;: true,
            &quot;locale&quot;: &quot;menu.dictionary.list&quot;
        }, {
            &quot;path&quot;: &quot;/dictionary/create&quot;,
            &quot;name&quot;: &quot;新建字典&quot;,
            &quot;exact&quot;: true,
            &quot;locale&quot;: &quot;menu.dictionary.create&quot;
        }]
    }]
</code></pre><h4 id="react使用typescript"><a href="#react使用typescript" class="headerlink" title="react使用typescript"></a>react使用typescript</h4><pre><code>1、state和props定义

    interface IProps {
        aProps: string;
        bProps: string;
    }
    interface IState {
        aState: string;
        bState: string;
    }

    class App extends React.PureComponent&lt;IProps, IState&gt; {
        state = {
            aState: &apos;&apos;,
            bState: &apos;&apos;,
        };

        render(){
            this.props.aProps;
            this.state.aState;
            return null;
        }
    }

    const mapStateToProps = () =&gt; {
        return {
            aProps: &apos;a&apos;,
            bProps: &apos;b&apos;
        }
    }
    const mapDispatchToProps = {};
    export default connect(mapStateToProps, mapStateToProps)(App)
</code></pre><p>| <a href="https://www.jianshu.com/p/c7b3b9c98d04" target="_blank" rel="noopener">https://www.jianshu.com/p/c7b3b9c98d04</a><br>| <a href="https://umijs.org/zh/plugin/umi-plugin-react.html#%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">https://umijs.org/zh/plugin/umi-plugin-react.html#%E5%AE%89%E8%A3%85</a>            // umiJS</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之三)Redux/">React（之三）Redux</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之三)Redux/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createStroe - 创建一个store<br>| reducer - 用来改变state的值，结合了action的动作来分别处理<br>| action - 要执行的事件<br>| combineReducers - 将多个reducer合到一起,赋给createStroe<br>| replaceReducer - 替换reducer，改变state修改逻辑<br>| subscribe - 侦听Store的变化<br>| store.getState - 获取Store中的state值<br>| store.dispatch - 触发action，改变state的值<br>| provider - 将Store传递给内部组件<br>| connect - 将组件与redux的状态、事件关联起来<br>| applyMiddleware - 加载中间件<br>| bindActionCreators - 直接调用dispatch(action)()<br>| react-redux - react与redux结合</p>
<h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><pre><code>react是纯View层的框架，需要数据流进行支撑, 单一的状态树,主流数据流框架: Flux、Redux

UI -&gt; action -&gt; reducer -&gt; store -&gt; state -&gt; UI

Redux是非异步的流程，如果需要使用异步操作使用 Redux-saga

一、Flux四部分

    1、Dispatcher - 处理动作分发，维持Store之间的依赖关系

    2、Store - 负责存储数据和处理数据相关逻辑

    3、Action - 驱动Dispatcher的JS对象

    4、View - 视图部分，负责显示用户界面

    Dispatcher相当于Controller，Stroe相当于Modle，View相当于View，Action相当于用户的行为


二、Redux三个基本原则

    1、唯一数据源 - 状态数据只存储在唯一的一个Store上

    2、保持状态只读 - 不能直接修改Store的状态，需要派发一个action对象完成

    3、数据改变只能通过纯函数完成
</code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>Facebook官方提出了Flux思想管理数据流，同时也给出了自己的实现方案Flux来管理React应用

实现Flux思想的类库 Redux、Flux、reflux

$ npm i redux --save                    // 安装redux

$ npm i react-redux --save            // redux与react结合

$ npm i react-router-redux --save     // redux-router

$ npm i redux-devtools-extension --save        // 安装可视化工具

    引用：import { composeWithDevTools } from &apos;redux-devtools-extension&apos;

    在chrome中下载redux-devtools插件

    https://github.com/zalmoxisus/redux-devtools-extension#usage

$ npm i redux-thunk --save

$ npm i redux-logger --save

引用redux: import { createStore } from &apos;redux&apos;

一、Redux流程:

    1、view直接触发dispatch

    2、dispatch将action发送到reducer中后，根节点上会更新props，改变全局view

    3、redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中    
</code></pre><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><pre><code>action指令并不能直接改变state，action必须是json

let todoId = 0;
export const addTodo = (text) =&gt; {
    return {
        type: &apos;ADD_TODO&apos;,    // 处理的类型(必要)
        id: todoId++,            // 存储数据当前的id标识
        text                            // 传入的内容
    }
}

通过 store.dispatch(action) 来派发到reducer中, 在reducer中改变state的值
</code></pre><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><pre><code>接收一个action值，纯方法不能定义ajax定义时间等，需要传入一个旧的状态在返回一个新的状态给action, 根据定义的action名对应处理state，并改变state值

let todo = (state, action) =&gt; {

    // 这里通过action的type的值对应不同的事来处理
    switch(action.type){
        case &apos;ADD_TODO&apos;:
            return {
                state + 1;
            }
            break;

        /* 上面只是单个add_todo, 这里要写成多个add_todo
        case &apos;ADD_TODO&apos;:
            return [
                {
                    id: action.id,
                    text: action.text,
                    completed: false
                },
                ...state
            ]
            break;            
        */

        case &apos;SUB_TODO&apos;:
            return {
                state - 1;
            }
            break;

        default: state;
    }
}

1、combineReducers - 将多个的reducer合成一个

    // 目录 reducer/index.js
    import {combineReducers} from &quot;redux&quot;;
    import reducerA from &quot;./reducerA&quot;;
    import reducerB from &quot;./reducerB&quot;;

    export default combineReducers({
        reducerA,
        reducerB,
    });

    // createStore调用reducer
    import reducers from &apos;./reducer/&apos;
    let store = createStore(reducers)
</code></pre><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><pre><code>Store是来保存数据的容器，只有一个Store，可以根据不同业务拆分成多个reducer， createStroe(reducer, 初始化的)

import { createStore } from &apos;redux&apos;;
import reducer from &apos;./reducers&apos;        // 获取定义的reducer

let stroe = createStroe(reducer);    // 使用createStore(reducer, initialState初始化state, 中间件传入)来创建一个数据仓库
store.dispatch();

方法:

    1、store.getState(): 获取State值

    2、store.dispatch(action): 触发action，修改state的值

    3、store.subscribe(listener)，用来订阅状态的变化

        添加一个变化的监听器，每当dispatch action的时候就会执行

        // App组件
        class App extends Component {
            constructor(props){
                super(props);
                this.state = {
                    num: 0
                }
            }

            componentDidMount() {
                store.subscribe(this.handleChange.bind(this));
            }

            handleChange(){
                this.setState({num: store.getState()})
            }

            addClick(){
                store.dispatch({type: &apos;add&apos;});
            }

            subClick(){
                store.dispatch({type: &apos;sub&apos;});
            }

            showState(){
                debugger;
                console.log(store.getState())
            }

            render() {
                return (
                    &lt;div className = &quot;box&quot; &gt;
                        {this.state.num}
                        &lt;input type=&quot;button&quot; onClick={this.addClick} value=&quot;+&quot; /&gt;
                        &lt;input type=&quot;button&quot; onClick={this.subClick} value=&quot;-&quot; /&gt;
                        &lt;input type=&quot;button&quot; onClick={this.showState} value=&quot;查看state&quot; /&gt;
                    &lt;/div&gt;
                )
            }
        }
</code></pre><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><pre><code>state用于存储数据，state是只读的，改变需要触发action

state树就是一个对象，所有的reducer的都会加到state中，取state值，store.getState().
</code></pre><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h4><pre><code>$ npm i react-reudx --save        // 安装

一、provider(store, children) - 将Store传到子组件中，一般用在入口文件

    import React from &apos;react&apos;;
    import ReactDOM from &apos;react-dom&apos;;
    import {Provider} from &quot;react-redux&quot;;
    import Store from &quot;src/store&quot;;
    import App from &apos;src/components/app&apos;;
    import Chat from &apos;src/pages/Chat/Index&apos;;

    // 1、使用Store让所有组件访问到
    ReactDOM.render(
        &lt;Provider store={Store}&gt;
            &lt;App&gt;
                &lt;Chat /&gt;
            &lt;/App&gt;
        &lt;/Provider&gt;,
        document.getElementById(&apos;app&apos;)
    );

    // 2、如果使用路由
    ReactDOM.render(
        &lt;Provider store={store}&gt;
            &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
                &lt;Route path=&apos;/&apos; component={Index}&gt;
                    &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        &lt;/Provider&gt;
    )


二、connect(mapStateToProps, mapDispatchToProps)(Component连接组件) - 连接react组件与redux store

    1、mapStateToProps(state, ownProps) - 侦听Store的变化

            state参数 - 如果Store中有变化此方法就会被调用，该回调函数返回一个纯对象，这个对象会与组件的props合并

            ownProps参数 - 该参数的值为会飞经到组件的props,

    2、mapDispatchToProps - 逻辑输出，相当于用store.dispatch(actionType) 来发出操作指令，来改变state值

    Example:

        // app.jsx
        &lt;Provider store={store}&gt;
            &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
                &lt;Route path=&apos;/&apos; component={Index}&gt;
                    &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        &lt;/Provider&gt;

        // Index.jsx
        import React, { Component } from &apos;react&apos;;
        import ReactDOM from &apos;react-dom&apos;;
        import { bindActionCreators } from &quot;redux&quot;;
        import { connect } from &quot;react-redux&quot;;
        import actions from &quot;src/actions&quot;;

        class wechat extends Component {
            constructor(props){
                super(props);
                this.state = {

                }
            }

            componentDidMount(){
                let { ACTIONS } = this.props;
                ACTIONS.chat_init();
            }

            render(
                // ...
            )
        }

        let mapStateToProps=(state)=&gt;{
            let {sessions,user} = state.chatIndex;
            return {
                _sessions:sessions,
                _user:user
            };
        }; 

        let mapDispatchToProps=(dispatch)=&gt;{
            return {
                ACTIONS: bindActionCreators(actions, dispatch)
            };
        };

        export default connect(mapStateToProps,mapDispatchToProps)(wechat);
</code></pre><h4 id="container组件"><a href="#container组件" class="headerlink" title="container组件"></a>container组件</h4><pre><code>引用Redux将组件分两类container和component

container - 组件中使用redux获取数据，状态更新，从Redux获取state
</code></pre><h4 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators()"></a>bindActionCreators()</h4><pre><code>是通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用）

import * as oldActionCreator from &apos;./action.js&apos;

let newAction = bindActionCreators(oldActionCreator,dispatch)
</code></pre><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><pre><code>两种方法 1、下载redux-devtools包      2、chrome or Firfix 下载 Redux DevTools插件

1、使用Redux DevTools插件 代码中需要加配置

    https://github.com/zalmoxisus/redux-devtools-extension

    /* eslint-disable no-underscore-dangle */        // +
    let store = createStore(
        comput,
        window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()        // +
    )
    /* eslint-enable */                                // +


2、redux-devtool 包的使用 https://github.com/gaearon/redux-devtools
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>|- src
|-- reduxs     // redux
|------ actions
|------ reducers
|-- router    // 路由
|-- util    // 工具
</code></pre><h4 id="react-router-redux路由"><a href="#react-router-redux路由" class="headerlink" title="react-router-redux路由"></a>react-router-redux路由</h4><pre><code>redux管理的是应用状态（state），router管理的是路由，react-router-redux是保持路由与应用状态（state）同步

$ npm install --save react-router-redux        // 安装

原理：允许使用react router库中的api，使用redux一样去管理应用状态state

https://www.jianshu.com/p/bccca5bb6338
http://blog.csdn.net/isaisai/article/details/78086913
https://segmentfault.com/a/1190000007862103

http://blog.csdn.net/sinat_17775997/article/details/69218382
</code></pre><p>| <a href="http://cn.redux.js.org/index.html" target="_blank" rel="noopener">http://cn.redux.js.org/index.html</a>                // Redux中文文档<br>| <a href="http://www.liuyiqi.cn/2016/01/19/r2-counter/" target="_blank" rel="noopener">http://www.liuyiqi.cn/2016/01/19/r2-counter/</a><br>| <a href="https://github.com/lewis617/react-redux-tutorial" target="_blank" rel="noopener">https://github.com/lewis617/react-redux-tutorial</a><br>| <a href="https://github.com/xgrommx/awesome-redux" target="_blank" rel="noopener">https://github.com/xgrommx/awesome-redux</a><br>| <a href="https://www.jianshu.com/p/bccca5bb6338" target="_blank" rel="noopener">https://www.jianshu.com/p/bccca5bb6338</a>        // react－router－redux 保持路由与应用状态（state）同步<br>| <a href="http://www.redux.org.cn/" target="_blank" rel="noopener">http://www.redux.org.cn/</a>                        // react-redux<br>| <a href="https://www.jianshu.com/p/1a2f3db4af61" target="_blank" rel="noopener">https://www.jianshu.com/p/1a2f3db4af61</a>        // react-redux<br>| <a href="https://www.jianshu.com/p/9873d4ccb891" target="_blank" rel="noopener">https://www.jianshu.com/p/9873d4ccb891</a>        // connect 原理<br>| <a href="https://github.com/GuoYongfeng/redux-complete-sample" target="_blank" rel="noopener">https://github.com/GuoYongfeng/redux-complete-sample</a><br>| <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">https://github.com/gaearon/redux-devtools</a><br>| <a href="http://www.aliued.com/?p=3204" target="_blank" rel="noopener">http://www.aliued.com/?p=3204</a><br>| <a href="http://blog.csdn.net/liwusen/article/details/54138854" target="_blank" rel="noopener">http://blog.csdn.net/liwusen/article/details/54138854</a>         // bindActionCreators<br>| <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a><br>| <a href="https://github.com/allan2coder/React-SPA/blob/master/src/store/configureStore.dev.js" target="_blank" rel="noopener">https://github.com/allan2coder/React-SPA/blob/master/src/store/configureStore.dev.js</a>            // 示例 router3.0</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之一)基础/">React（之一）基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之一)基础/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 创建组件<br>| render<br>| props、propType、state、setState()、replaceState()<br>| 获取DOM this.refs.xxx 或 ReactDOM.findDOMNode(this.refs.xxx)<br>| React.Children 获取父组件传的DOM<br>| mixin</p>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><pre><code>React包括几个概念: 1、组件       2、JSX     3、虚拟DOM     4、单向数据绑定        5、受控组件

1、核心是封装组件，只关注UI，状态变更重新渲染整个组件

2、JSX: HTML代码可以直接嵌到JS代码中，这就是React提出的叫JSX的语法，原来前端以表现和逻辑层分离为主，但HTML是组件的一部分所以不能分割，JSX 将动态值放到 { ... }

3、单向数据流: 当数据更新会渲染整个app

    React的渲染方式: 用户输入 ~&gt; 从API获取数据 ~&gt; 将数据传给顶层组件 ~&gt; React将每个组件渲染出来, 不会象MVC一样的双向数据绑定、和数据模型的脏值检测、不会有确切的DOM操作

4、虚拟DOM树: React重建一个DOM树，找到与上一个版本的DOM的差异，计算出新的DOM更新操作，从操作队列中指执行DOM更新操作

    http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/      // 前沿技术解密——VirtualDOM

5、IE浏览器要在8.0版本以上

rrc 创建带redux组件
rcc 创建react组件
rca 创建action
reducer 创建reduer
</code></pre><h4 id="react引用方式"><a href="#react引用方式" class="headerlink" title="react引用方式"></a>react引用方式</h4><pre><code>// Component作为所有组件的基类，提供很多组件共有的功能
import React, { Component } from &apos;react&apos;;
import { reactDom } from &apos;react-dom&apos;;

// 定义组件
class SimpleComponent extends Component {
    render(){
        return &lt;div&gt; React，我们来了... &lt;/div&gt;;
    }
}
export default SimpleComponent;

// 组件渲染
reactDom.render(&lt;HelloMessage /&gt;, document.getElementById(&apos;app&apos;));
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>组件的生命周期三个过程

    装载过程(Mount) - 把组件第一次在DOM树中渲染的过程

    更新过程(Update) - 当组件被重新渲染的过程

    卸载过程(Unmount) - 组件从DOM中删除的过程


一、装载过程

    1、constructor - ES6每个类的构造函数，创建一个组件就会先调用对应的构造函数

    2、getInitialState() - 初始化this.state，(ES6不起作用)

    3、getDefaultProps - 设置默认的props (ES6不起作用)

    4、componentWillMount() - 组件挂载前（调用render方法之前触发, 没有任何渲染，就算调用了this.setState()也不会引发绘制）

    5、render() - 创建虚拟dom，进行diff算法，更新dom树，如果不需要渲染可以将render函数返回一个null或false

    6、componentDidMount() - 组件渲染后已经装载到DOM树中，这时候可以refs操作获取或操作DOM节点


二、更新过程(当props或state被修改时就会引发组件的更新过程)

    1、componentWillReceiveProps(nextProps) - 当父组件改变了传递给子组件props的值，这时候子组件此方法会被调用

    2、shouldComponentUpdate(nextProps, nextState) - react性能环节，父组件传给子组件的props值改变，子组件中的shouldComponentUpdata()方法会先调用，前后两个props相同返回false阻止更新，不需要在创建新的dom树在进行diff算法，默认为true

        shouldComponentUpdate(nextProps, nextState){
            return nextProps.name === nextState.name        // 如果返回false就算父组件传递的props值改变，也不会执行render
        }

    3、componentWillUpdate() - 与装载过程相同 

    4、render() - 与装载过程相同

    5、componentDidUpdate() - 与装载过程相同


三、卸载组件

    1、componentWillUnmount() - 卸载前调用
</code></pre><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><pre><code>一、注释

    {/* 这里用于单多行注释 */}


二、根元素只能有一个

    class ComponentDemo extends Component {
        render(){
            // 以下写法直接报错
            return (
                &lt;div&gt;
                    hello
                &lt;/div&gt;
            );
        }
    }


三、属性名不能和 js 关键字冲突

    1、class =&gt; className

    2、read =&gt; readOnly

    3、for =&gt; htmlFrom 不能直接使用for

        &lt;div htmlFor=&apos;male&apos;&gt;Male&lt;/div&gt;


四、JSX spread

    { ...spreadObj } 可以直接将spreadObj的对象传递过去

    import SpreadDemo from &apos;./components/spread&apos;;
    const spreadObj = {
        name: &apos;siguang&apos;,
        carType: &apos;卡宴&apos;
    }
    render(&lt;SpreadDemo {...spreadObj} /&gt;, document.querySelector(&apos;#app&apos;));


五、渲染HTML

    const elements = &apos;&lt;p&gt;aaa&lt;/p&gt;&lt;p&gt;bbb&lt;/p&gt;&lt;p&gt;ccc&lt;/p&gt;&apos;;
    &lt;p dangerouslySetInnerHTML={{ __html: elements }}&gt;&lt;/p&gt;

http://lib.csdn.net/article/react/22655
</code></pre><h4 id="class和style"><a href="#class和style" class="headerlink" title="class和style"></a>class和style</h4><pre><code>一、class

    方法1:
        import &apos;./admin.css&apos;
        render() {
            return (
                &lt;div className=&quot;container&quot;&gt;            // 注意这里的值为字符串而不是{}
                    &lt;div className=&quot;sild&quot;&gt;xxxx&lt;/div&gt;
                &lt;/div&gt;
            );
        }

    方法2:
        import styles from &apos;./admin.css&apos;
        render() {
            return (
                &lt;div&gt;
                    &lt;div className={style.sild}&gt;xxxx&lt;/div&gt;
                &lt;/div&gt;
            );
        }


二、style 行内样式

    方法1:
        const container = {
            display: flex;
            height: 100%;
        }

        render() {
            return (
                &lt;div style={container}&gt; xxx &lt;/div&gt;
            );
        }

    方法2: &lt;div style={{ width: '100px', float: 'left'}}&gt;       // 注意这里属性值要使用引号
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>一、组件创建

    1、类式组件

        import React, { Component } from &apos;react&apos;
        import ReactDom, { render } from &apos;react-dom&apos;

        // 所有创建的组件都继承于Component对象
        class ShowMessage extends Component{
            constructor(props){
                super(props);
            }
            render(){
                return &lt;div&gt;Hello name {this.props.name}&lt;/div&gt;
            }
        }
        export default ShowMessage;


    2、函数式组件

        const Welcome = (props) =&gt; {
            return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
        }
        &lt;Welcome username=&quot;this.state.username&quot; /&gt;


    函数组件与类式组件的区别:

        类组件有state, 函数组件没有state

        类组件有生命周期函数


二、组件注意的地方

    1、组件名首字母必须大写

    2、根元素只能有一个标签元素

        class ComponentDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;boxA&quot;&gt;            {/* 根元素只能有一个 */}
                        aaaaaaaa
                        &lt;div class=&quot;boxB&quot;&gt;
                            bbbbbb
                        &lt;/div&gt;
                    &lt;/div&gt;
                )
            }
        }
        export default ComponentDemo;

    3、可以使用es6的 spread 变量传递 {...obj}

        let person = &lt;Person name={window.isLoggedIn ? window.name : &apos;&apos;} /&gt;

    4、refs属性获取真实的DOM节点

        组件并不是真实的DOM节点，而是在内存中的一种数据结构叫虚拟DOM，如果要从组件内获取真实的DOM节点，需要用到refs属性
</code></pre><h4 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h4><pre><code>childList.jsx:

    class ChildrenA extends Component{
        constructor(props){
            super(props);
        }
        render(){
            return (&lt;div&gt;
                {/* 这里是子组件A   this.props.children获取组件的内容，相当前于vue中的solt */}
                {
                    React.Children.map(this.props.children, function(c){        // React.Children是获取组件中的元素
                        return &lt;p&gt;{c}&lt;/p&gt;
                    })
                }
            &lt;/div&gt;)
        }
    }

    class ParentComponent extends Component{
        render(){
            return &lt;div&gt;
                &lt;ChildrenA&gt;
                    &lt;p&gt;福特&lt;/p&gt;
                    &lt;p&gt;丰田&lt;/p&gt;
                    &lt;p&gt;本田&lt;/p&gt;
                &lt;/ChildrenA&gt;
            &lt;/div&gt;
        }
    }
    export default ParentComponent;

index.js:

    import ParentComponent from &apos;./components/ParentComponent&apos;
    render(&lt;ParentComponent /&gt;, docuemnt.querySelector(&apos;#box&apos;));
</code></pre><h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><pre><code>一、组件之间通信的几种情况

    1、父组件向子组件通信

    2、子组件向父组件通信

    3、跨级组件之间通信

    4、非嵌套组件间通信


二、父向子通信 通过props

    parent.jsx
        &lt;child message={this.state.sayMessage} /&gt;

    child.jsx
        {this.props.message}        // 接收


三、子向父通信

    parent.jsx
        &lt;child getMessage={this.getMessage.bind(this)} /&gt;
        getMessage(msg){
            this.setDate({message: msg})
        }

    child.jsx
        this.props.getMessage(&apos;这里告诉父组件消息&apos;)


四、跨级组件

    父组件向很深的几层子组件通信有两种方法: 1、props一层一层传   2、使用context对象


五、events非嵌套组件通信, 使用事件订阅

    $ npm i events --save

    1、创建一个ev.js

        import { EventEmitter } from &apos;events&apos;
        export default new EventEmitter();

    2、brotherA.jsx

        // 在组件装载完成以后
        componentDidMount(){
            // 声明一个自定义事件        
            this.eventEmitter = emitter.addListener(&quot;callMe&quot;, (msg)=&gt;{
                this.setState({
                    msg
                })
            });
        }

        // 组件销毁前移除事件监听
        componentWillUnmount(){
            emitter.removeListener(this.eventEmitter);
        }

        render(){
            return (
                &lt;div&gt;
                    {this.state.message}
                &lt;/div&gt;
            )
        }

    3、brotherB.jsx

        sendBrotherMessage(){
            return emitter.emit(&quot;callMe&quot;, &quot;Hello&quot;);     // callMe为自定义函数，hello为发的消息参数
        }
        &lt;input type=&quot;button&quot; value=&quot;向A子组件发消息&quot; onClick={this.sendBrotherMessage.bind(this)} /&gt;


六、redux或其它状态管理库
</code></pre><h4 id="Context对象"><a href="#Context对象" class="headerlink" title="Context对象"></a>Context对象</h4><pre><code>context对象来跨级传递

context与react版本分两种写法，以下为react v16.3版本的示例

一、React.crateContext() - 创建一个Context

二、初始化createContext下的方法

    1、provider - 父组件中传递的值

    2、consumeer - 子组件接收的值

三、示例:

    创建一个contextStor.js:
        import React, { Component } from &apos;react&apos;
        export const { Provider, Consumer } = React.createContext(&quot;Light&quot;);        // 默认主题是Light

    parentPage.jsx:
        import Ca from &apos;./cA&apos;
        import { Provider } from &apos;./ccontextStor&apos;;

        export default class ParnentPage extends Component {
            render () {
                return (
                    &lt;Provider value={{contextVal: '这里是context的传递的内容'}}&gt;
                        &lt;h1&gt;这里是Parent组件&lt;/h1&gt;
                        &lt;Ca /&gt;
                    &lt;/Provider&gt;
                )
            }
        }

    cA.jsx:
        import Cb from &apos;./cB&apos;
        export default class Ca extends Component {
            render () {
                return (
                    &lt;div&gt;
                        &lt;h2&gt;这里是CA&lt;/h2&gt;
                        &lt;Cb /&gt;
                    &lt;/div&gt;
                )
            }
        } 

    cB.jsx:
        import { Consumer } from &apos;./ccontextStor&apos;;
        export default class Cb extends Component {
            render () {
                return (
                    &lt;div&gt;
                        &lt;h3&gt;这里子CB&lt;/h3&gt;
                        &lt;Consumer&gt;
                            {
                                context =&gt; {
                                    return (
                                        &lt;div&gt;{context.contextVal}&lt;/div&gt;
                                    )
                                }
                            }
                        &lt;/Consumer&gt;
                    &lt;/div&gt;     
                )
            }
        }
</code></pre><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><pre><code>React是单向数据流，数据从父组件传到子组件，子组件通过props获取数据，顶层组件改变了props，React会遍历整个组件树，重新渲染整个组件

数据流包括: Props 和 State
</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>{ this.props.name } 读取props的值

一、props API:

    this.props.children - 所有子组件的内容

        &lt;ChildrenComponent&gt;
            &lt;p&gt;aa&lt;/p&gt;
            &lt;p&gt;bb&lt;/p&gt;
            &lt;p&gt;cc&lt;/p&gt;
        &lt;/ChildrenComponent&gt;

    this.props.map

    this.props.filter 


二、设置一个默认的props

    /* 通过 defaultProps 来定义 */
    class PropsDemo extends Component {
        constructor(props) {
    super(props);        // 调用父类，如果不写会调不到
       }
        render(){
            return (
                &lt;div class=&quot;box&quot;&gt;
                    name: {this.props.name}, age: {this.props.age}
                &lt;/div&gt;
            )
        }
    }

    // 初始化props
    PropsDemo.defaultProps = {
        name: &apos;123123&apos;        // 默认一个name值，如果父组件没有传值就会取默认值
    }


三、propsType 校验props类型

    $ npm install --save prop-types

    import React, { Component, PropTypes } from &apos;react&apos;;

    class PropTypesDemo extends Component {
        render(){
            return &lt;b&gt;{this.props.title}&lt;/b&gt;
        }
    }

    // 静态属性定义propTypes, title只能为string
    PropTypesDemo.propTypes = {
        title: React.PropTypes.string.isRequired
    }

    export default PropTypesDemo;


四、Example

    PropsComponent组件:

        class PropsComponent extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}         {/* 这里接收props值 */}
                    &lt;/div&gt;
                )
            }
        }

        // 输出组件接口
        export default PropsComponent;

    index.js:

        import PropsComponent from &apos;../components/props&apos;;

        // 要传的值
        let obj = {
            name: &apos;haha&apos;,
            age: &apos;300&apos;
        }

        // 方法1、直接传给属性
        render(&lt;PropsComponent name={obj.name} age={obj.age} /&gt;, document.querySelector(&apos;body&apos;));

        // ...obj 来对多值进行解析赋值
        render(&lt;PropsComponent {...obj} /&gt;, document.querySelector(&apos;body&apos;));


五、this.props.children 访问自定义子节点

    // 将组件下的所有子节点通过map获取到，并重新包装
    import React, { Component } from &apos;react&apos;;

    class UseChildren extends Component {
        render(){
            return  &lt;ul&gt;
                {
                    // 会将UseChildren组件下所有的元素取出
                    React.Children.map(this.props.children, function(c){
                        return &lt;li&gt; {c} &lt;/li&gt;
                    })
                }
            &lt;/ul&gt;
        }
    }

    class ChildrenDemo extends Component {
        render(){
            return (
                &lt;UseChildren&gt;
                    &lt;a href=&quot;#&quot;&gt;Facebook&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Google&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Space&lt;/a&gt;
                &lt;/UseChildren&gt;
            )
        }
    }
    export default ChildrenDemo;


六、this.props.content 可以传任意结构的JSX结构

    // 父组件通过content传值
    &lt;ContentChildrenComponent content={
        &lt;div&gt;
            &lt;h2&gt;React.js 小书&lt;/h2&gt;
            &lt;div&gt;开源、免费、专业、简单&lt;/div&gt;
            订阅：&lt;input /&gt;
        &lt;/div&gt;
    } /&gt;

    // 子组件调用
    render() {
        return (
            &lt;div&gt;
                { this.props.content }
            &lt;/div&gt;
        );
    }


七、组件传值

    &lt;ChildComponent propsData={this.state.username} /&gt;

    &lt;LikeButton wordings={{likedText: '已赞', unlikedText: '赞'}} onClick={() =&gt; console.log(&apos;Click on like button!&apos;)}/&gt;
</code></pre><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><pre><code>每一个React组件都有一个自己的state对象，与props区别是state只能在当前组件内部使用，props可以将数据传递给子组件

一、初始化state

    class StateDemo extends Component {
        constructor(){
            super();            // 继承Component

            // 这里初始化state
            this.state = { 
                userName: &apos;siguang&apos; 
            }
        }

        setUserName: function(){
            this.setState({userName: &apos;lulu&apos;});        // 修改state值
        },

        render(){
            return (
                &lt;div&gt;
                    这里是props获取的值 {this.state.userName};        // 获取state的值
                    &lt;input type=&quot;button&quot; onClick={this.setUserName.bind(this)} value=&quot;点击修改state&quot; /&gt;
                &lt;/div&gt;
            )
        }
    }


二、setState中this的指向

    1、&lt;Button type=&quot;primary&quot; onClick={ this.addCar.bind(this) }&gt;开始&lt;/Button&gt;
         &lt;Button type=&quot;primary&quot; onClick={ (e) =&gt; this.addCar(e) }&gt;开始&lt;/Button&gt;        // 渲染中箭头函数

    2、&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;

    3、addCar = () =&gt; {
            this.setState(function(state, porps){
                return {
                    car: state.car + 1
                }
            })
        }
        &lt;Button type=&quot;primary&quot; onClick={ this.addCar }&gt;开始&lt;/Button&gt;


三、setState()异步的问题

    setState()是异步导致如果直接在下面在取state值还没变过来，所以第二个回调是当state值设置成功后在执行的函数

    this.setState(
        { username: uname }, 
        () =&gt; {  console.log(this.state.username); }        // 这里还是为之前的值而不是「sg」
    );
</code></pre><h4 id="refs操作真实DOM"><a href="#refs操作真实DOM" class="headerlink" title="refs操作真实DOM"></a>refs操作真实DOM</h4><pre><code>获取ref: this.refs.xxx

Example:

    class RefsDemo extends Component {
        componentDidMount(){
            // refs直接获取
            const contentB = this.refs.content;
            console.log( contentB.innerHTML );
        }

        render(){
            return(
                &lt;div&gt;
                    &lt;h3&gt;React操作DOM&lt;/h3&gt;
                    &lt;p ref=&quot;content&quot;&gt;这里是DOM元素的内容&lt;/p&gt;        // 这里定义ref访问的名
                &lt;/div&gt;
            )
        }
    }
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>通过mixin可以将组件间共享代码，将两个组件共同的属性、方法存储到mixin对象中

mixin不支持ES6的声明组件方式

ES5写法

    import React from &apos;react&apos;;

    // 抽取出的公用方法
    var SetIntervalMixin = {
        componentWillMount: function() {
            this.intervals = [];
        },
        setInterval: function() {
            this.intervals.push(setInterval.apply(null, arguments));
        },
        componentWillUnmount: function() {
            this.intervals.forEach(clearInterval);
        }
    };

    var MixinDemo = React.createClass({

        // 这里加载mixin
        mixins: [SetIntervalMixin],

        getInitialState: function() {
            return {seconds: 0};
        },

        componentDidMount: function() {
            // Call a method on the mixin
            this.setInterval(this.tick, 1000);
        },

        tick: function() {
            this.setState({seconds: this.state.seconds + 1});
        },

        render: function() {
            return (
                &lt;p&gt;
                    计时器已经运行了:  {this.state.seconds} 秒.
                &lt;/p&gt;
            );
        }
    });

    export default MixinDemo;
</code></pre><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><pre><code>一、defaultValue 与 value 的区别

    &lt;input type=&quot;text&quot; value={this.state.inputValue} /&gt;

    如果使用 value来绑定state的值，输入值时不会被改变，使用 defaultValue 值会被改变

    class App extends Component {
        constructor(props) {
            super(props);
            this.state = {
                username: &apos;&apos;
            }
        }
        handleUsername(e){
            const val = e.target.value;
            this.setState({username: val});
        }
        getName(){
            alert(this.state.username)
        }
        render() {
            return (
                &lt;div className=&quot;App&quot;&gt;
                    &lt;input placeholder=&quot;Basic usage&quot; defaultValue={this.state.username} onChange={this.handleUsername.bind(this)} /&gt;
                    &lt;button type=&quot;primary&quot; onClick={this.getName.bind(this)}&gt;Primary&lt;/button&gt;
                &lt;/div&gt;
            );
        }
    }

二、react表单组件与html的不同

    1、value、checked: 属性设置值后，用户输入无效

    2、textarea: 的值要设置在value属性

        &lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt;

    3、select: value属性可以是数据，不建使用option的selected属性

        &lt;select multiple={true} value={[&apos;B&apos;, &apos;C&apos;]}&gt;
            &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt;
            &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt;
            &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt;
        &lt;/select&gt;

    4、radio/checkbox/option 点击后触发 onChange
</code></pre><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><pre><code>受控组件就是为某个form表单组件添加value属性；非受控组件就是没有添加value属性的组件

一、受控组件

    &lt;input&gt;，&lt;textarea&gt;以及&lt;select&gt;通常保持自己的状态和基于用户输入更新它

    handleChange(event) {
        this.setState({value: event.target.value});
    }
    &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;


二、不受控制组件

    this.input = React.createRef();                    // 创建不受控组件
    &lt;input type=&quot;text&quot; ref={this.input} /&gt;    // 绑定
    this.input.current.value                                // 调用不受控组件

    class NameForm extends React.Component {
        constructor(props) {
            super(props);
            this.handleSubmit = this.handleSubmit.bind(this);

            // 创建不受控组件
            this.input = React.createRef();
        }

        handleSubmit(event) {
            alert(&apos;A name was submitted: &apos; + this.input.current.value);
            event.preventDefault();
        }

        render() {
            return (
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;label&gt;
                        Name:
                        &lt;input type=&quot;text&quot; ref={this.input} /&gt;
                    &lt;/label&gt;
                    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
                &lt;/form&gt;
            );
        }
    }
</code></pre><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><pre><code>render的时候需要有一个父的元素，如果组件嵌套会多出来无用的元素，可以使用&lt;React.Fragment&gt; ... &lt;/React.Fragment&gt;

class Columns extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;td&gt;Hello&lt;/td&gt;
                &lt;td&gt;World&lt;/td&gt;
            &lt;/div&gt;
        );
    }
}
class Table extends React.Component {
    render() {
        return (
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;Columns /&gt;                    // 输出&lt;div&gt; ... &lt;/div&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        );
    }
}

可以写成

class Columns extends React.Component {
    render() {
        return (
            &lt;React.Fragment&gt;
                &lt;td&gt;Hello&lt;/td&gt;
                &lt;td&gt;World&lt;/td&gt;
            &lt;/React.Fragment&gt;
        );
    }
}
</code></pre><h4 id="React脚手架搭建"><a href="#React脚手架搭建" class="headerlink" title="React脚手架搭建"></a>React脚手架搭建</h4><pre><code>一、可以使用官网的 create-react-app、ant或自己搭  https://github.com/facebook/create-react-app

二、使用的JSX和ES6所以需要转换，使用版本:

    react: &quot;^15.4.2&quot;, react-dom: &quot;^15.4.2&quot;, react-router: &quot;^2.0.0&quot;&quot;, webpack: &quot;^3.10.0&quot;, webpack-dev-server: &quot;^2.11.1&quot;

    react 16以上版本和 react-router 4以上版本会有问题

三、搭建

    $ npm init

    $ npm i react react-dom react-router --save

    $ npm i webpack webpack-dev-server --save

    2、安装插件

    $ npm i babel babel-loader babel-core babel-preset-es2015 babel-preset-react --save

    $ npm i node-sass file-loader url-loader css-loader sass-loader style-loader --save

    $ npm i react-hot-loader prop-types events react-slot --save             // react组件，热更新、检测props类型、事件用来通信包、slot

    $ npm i html-webpack-plugin open-browser-webpack-plugin --save            // 自动引入静态资源到相应的html、自动打开浏览器

    $ touch .babelrc webpack.config.js

    $ mkdir src &amp;&amp; cd src &amp;&amp; touch index.html app.js

    $ .babelrc 加入

        {
            &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
        }

    $ webpack.config.js

        /**
        * User: siguang
        * Date: 2016/12/28
        * Time: 15:04
        */
        const webpack = require(&apos;webpack&apos;);
        const path = require(&apos;path&apos;);
        const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
        const openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);

        const basePath = __dirname;
        const appPath = path.resolve(basePath, &apos;src&apos;);
        const buildPath = path.resolve(basePath, &apos;build&apos;);

        module.exports = {
            entry: {
                app: path.resolve(appPath, &apos;app.js&apos;)
            },

            output: {
                path: buildPath,
                filename: &apos;[name].min.js?[hash]&apos;,
                // chunkFilename: &quot;[name].min.js?[hash]&quot;
            },

            module: {
                loaders: [

                    // 处理require()引入的css文件，并将代码显示到页面的&lt;style&gt;中
                    { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; },

                    // 将scss文件转成css文件
                    { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                    // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                    { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;},

                    // ES6 转 ES5
                    {
                        test: /\.jsx?$/,
                        exclude: /node_modules/,
                        loader: &apos;babel-loader&apos;,
                        query: {
                            presets: [&apos;es2015&apos;,&apos;react&apos;]
                        }
                    }
                ]
            },


            plugins: [

                // 压缩打包的文件
                new webpack.optimize.UglifyJsPlugin({
                    compress: {
                        //supresses warnings, usually from module minification
                        warnings: false
                    }
                }),

                // html
                new HtmlWebpackPlugin({
                    // 改变页面的&lt;title&gt;标签的内容
                    title: &apos;Hello World app&apos;,
                    // 模版地址
                    template: path.resolve(appPath, &apos;index.html&apos;),
                    // 构建后的文件名和目录
                    filename: &apos;index.html&apos;,
                    //chunks这个参数告诉插件要引用entry里面的哪几个入口
                    // chunks:[&apos;app&apos;],
                    //要把script插入标签里
                    inject:&apos;body&apos;
                }),

                // 热启动
                new webpack.HotModuleReplacementPlugin(),
                // 自动打开浏览器
                new openBrowserWebpackPlugin({ url: &apos;http://localhost:3000&apos; })
            ],

            // 查找依赖
            resolve:{

                // require或alias时不需要写后缀
                extensions: [&quot;.js&quot;, &quot;.jsx&quot;, &quot;.css&quot;, &quot;.json&quot;],
            },

            // webpack-dev-server 配置
            devServer: {
                port: 3000,                 // 端口
                contentBase: &apos;build&apos;,       // 内容目录
                hot: true,                    // 热刷新
                inline: true
            }
        }`

$ package.json

    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
        &quot;dev&quot;: &quot;webpack-dev-server --progress --profile --colors --hot --inline --history-api-fallback&quot;,
        &quot;build&quot;: &quot;webpack --progress --profile --colors --config webpack.production.config.js&quot;
    },

$ 运行

    $ npm run dev     生产环境，并打开webpack服务器

    $ webpack        执行打包到build目录线上环境使用

https://segmentfault.com/a/1190000005969488
</code></pre><h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><pre><code>当组件更新时候，react会创建一个新的虚拟dom树并会和之前的dom树进行比较，这个过程就用到了diff算法
</code></pre><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><pre><code>https://github.com/enaqx/awesome-react#boilerplates

1、路由 - react-router

2、布局 - react-blocks     http://whoisandie.github.io/react-blocks/

3、拖拽 - react-dnd        https://github.com/react-dnd/react-dnd

4、代码编辑器 - react-codemirror        https://github.com/JedWatson/react-codemirror

5、富文本编辑器 - react-quill react-draft-wysiwyg        https://github.com/jpuri/react-draft-wysiwyg

6、拾色器 - rc-color-picker、react-color        https://github.com/react-component/color-picker        http://casesandberg.github.io/react-color/

7、响应式 - react-responsive、react-media    https://github.com/contra/react-responsive        https://github.com/ReactTraining/react-media

8、复制到剪贴板 - react-copy-to-clipboard       https://github.com/nkbt/react-copy-to-clipboard

9、管理 document head - react-helmet          https://github.com/nfl/react-helmet

10、Font Awesome 图标 - react-fa        https://github.com/andreypopp/react-fa

11、二维码 -  qrcode.react         https://ant.design/docs/react/recommendation-cn

12、不在使用className - styled-components

    http://www.alloyteam.com/2017/05/guide-styled-components/
    https://github.com/styled-components/styled-components

13、react写动画效果 - css3transform-react

    $ npm install css3transform-react
    http://www.alloyteam.com/2016/12/react-animations-difficult-to-write-try-react-transformjs/

react-slot - react中写solt    http://npm.taobao.org/package/react-slot
</code></pre><h4 id="积累问题"><a href="#积累问题" class="headerlink" title="积累问题"></a>积累问题</h4><pre><code>1、jsx中for循环出标签并插入到render中, 或使用map

    class SideBar extends Component {
        constructor(props) {
            super(props);
            this.state ={
                menu: [
                    {
                        path: &apos;/home&apos;,
                        name: &apos;主页&apos;
                    },
                    {
                        path: &apos;/parentToChild&apos;,
                        name: &apos;将父向子组件传数据&apos;
                    },
                ]
            }
        }

        render() {
            // 定义一个返回菜单html内容的方法
            let renderMenuHtml = () =&gt; {
                let homeHtml = [];
                this.state.menu.forEach(function(item, idx, arr){
                    homeHtml.push(&lt;li&gt;
                        &lt;Link to={item.path}&gt;{item.name}&lt;/Link&gt;
                    &lt;/li&gt;)
                })
                return homeHtml
            }

            // 另一种写法map推荐
            {/*
                var renderMenuHtml = this.state.menu.map(function(c){
                    return(
                        &lt;li&gt;
                            &lt;Link to={item.path}&gt;{item.name}&lt;/Link&gt;
                        &lt;/li&gt;
                    );
                });
            */}

            return (
                &lt;div className=&quot;side-box&quot;&gt;
                    &lt;ul&gt;
                        {renderMenuHtml()}        {/* 插入内容 */}
                    &lt;/ul&gt;
                &lt;/div&gt;
            );
        }
    }


2、使用redux子组件会取不到 this.props.history

    因为redux会将值传给props，所以就需要通过context来获取

    解决方法: 在子组件中
    import PropTypes from &apos;prop-types&apos;

    子组件名.contextTypes = {
        router: PropTypes.object.isRequired
    }

    console.log( this.context.router.history.push(&apos;/&apos;) );


3、子组件调用父组件中的方法

    class ComponentClider extends Component {
        constructor(props){
            super(props);
        }

        render(){
            return(
                &lt;div&gt;{ this.props.add(111,555) }&lt;/div&gt;
            )
        }
    }

    export default ComponentParent extends Component {
        add(a, b){
            return a + b;
        }

        sub(a, b) {
            return a - b;
        }

        render(){
            return (
                &lt;div&gt;
                    {/* 这里可以父组件中自己的方法直接调用 */}
                    { this.add(100, 200) }
                    { this.sub(200, 10) }

                    &lt;ComponentClider add={(a, b) =&gt; this.add(a, b)} sub={(a, b) =&gt; this.sub(a, b)}&gt;&lt;/ComponentClider&gt;
                &lt;/div&gt;
            )
        }
    } 

    &lt;!-- 父组件也可以写成 --&gt;
    export default ComponentParent extends Component {
        multiplicative(a, b) {
            return a * b
        }

        add = (a, b) =&gt; {
            return a + b;
        }

        sub = (a, b)  =&gt;  {
            return a - b;
        }

        render(){
            const propsFun = {
                add: this.add,
                sub: this.sub
            }

            return (
                &lt;div&gt;
                    {/* 这里可以父组件中自己的方法直接调用 */}
                    { this.multiplicative(100, 200) }

                    &lt;ComponentClider {...propsFun}&gt;&lt;/ComponentClider&gt;
                &lt;/div&gt;
            )
        }
    } 


4、react原生动态添加多个className会报错

    // 下面的引用会报错
    import style from &apos;./style.css&apos;
    &lt;div className={style.class1 style.class2}&lt;/div&gt;

    // 解决 使用classnames
    $ npm install classnames --save

    import classnames from &apos;classnames&apos;
    import styles from &apos;./index.less&apos;;

    const clsString = classNames(styles.submit, className);
    &lt;div className={clsString}&gt;&lt;/div&gt;
</code></pre><h4 id="常用插件-1"><a href="#常用插件-1" class="headerlink" title="常用插件"></a>常用插件</h4><pre><code>1、react-document-title    根据不同的路由改变文档的title
    https://www.jianshu.com/p/07ed93350483

2、react-container-query   媒体查询 响应式组件

3、classnames      react引用多个className会报错问题
</code></pre><h4 id="Antd-UI组件问题收集"><a href="#Antd-UI组件问题收集" class="headerlink" title="Antd UI组件问题收集"></a>Antd UI组件问题收集</h4><pre><code>1、Table的每页条数  通过pagination属性来控制分页的内容

    &lt;Table pagination={{ pageSize: this.state.queryInfo.pageSize }} rowSelection={rowSelection} columns={columns} dataSource={data}  /&gt;

    https://www.cnblogs.com/jenifurs-blog/p/6020737.html
</code></pre><p>| <a href="https://react.docschina.org/docs/hello-world.html" target="_blank" rel="noopener">https://react.docschina.org/docs/hello-world.html</a><br>| <a href="http://www.css88.com/react/docs/try-react.html" target="_blank" rel="noopener">http://www.css88.com/react/docs/try-react.html</a><br>| <a href="https://juejin.im/post/5a9410c25188257a61325eda" target="_blank" rel="noopener">https://juejin.im/post/5a9410c25188257a61325eda</a>          // react 新老context<br>| <a href="https://www.jianshu.com/p/fb915d9c99c4" target="_blank" rel="noopener">https://www.jianshu.com/p/fb915d9c99c4</a>                          // 组件通信<br>| <a href="http://huziketang.com/books/react/" target="_blank" rel="noopener">http://huziketang.com/books/react/</a><br>| <a href="http://blog.csdn.net/liwusen/article/category/6522963" target="_blank" rel="noopener">http://blog.csdn.net/liwusen/article/category/6522963</a><br>| <a href="http://react-china.org/" target="_blank" rel="noopener">http://react-china.org/</a>           中文社区<br>| <a href="https://github.com/BruceCham/react-cli" target="_blank" rel="noopener">https://github.com/BruceCham/react-cli</a>                            // 全家桶<br>| <a href="http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/" target="_blank" rel="noopener">http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/</a>        // virturalDOM 虚拟DOM<br>| <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">https://github.com/gaearon/redux-devtools</a>                        // redux-devtools<br>| <a href="https://guoyongfeng.github.io/book/" target="_blank" rel="noopener">https://guoyongfeng.github.io/book/</a><br>| <a href="http://uprogrammer.cn/react-tutorial-cn/" target="_blank" rel="noopener">http://uprogrammer.cn/react-tutorial-cn/</a><br>| <a href="http://huziketang.com/books/react/lesson1" target="_blank" rel="noopener">http://huziketang.com/books/react/lesson1</a><br>| <a href="https://github.com/hyy1115/react-redux-webpack2" target="_blank" rel="noopener">https://github.com/hyy1115/react-redux-webpack2</a><br>| <a href="https://github.com/zhbhun/react-learning/tree/master/boilerplate" target="_blank" rel="noopener">https://github.com/zhbhun/react-learning/tree/master/boilerplate</a><br>| <a href="http://blog.csdn.net/u013063153/article/details/52497271" target="_blank" rel="noopener">http://blog.csdn.net/u013063153/article/details/52497271</a>      // 事件<br>| <a href="https://github.com/gaearon/babel-plugin-react-transform#transforms" target="_blank" rel="noopener">https://github.com/gaearon/babel-plugin-react-transform#transforms</a>       // babel-plugin-react-transform 相关插件<br>| <a href="http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/</a><br>| <a href="https://juejin.im/post/5a84682ef265da4e83266cc4" target="_blank" rel="noopener">https://juejin.im/post/5a84682ef265da4e83266cc4</a>            // 源码解析<br>| <a href="https://www.jianshu.com/p/ec7c2bab16cc?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/ec7c2bab16cc?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation</a>      // vscode 调试react 通过debugger for chrome</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之二)组件类/">React（之二）组件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之二)组件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| react-create-app 脚手架<br>| Router、Route<br>| Link、Links  router的导航组件，用来切换路由<br>| browserHistory、hashHistory<br>| activeStyle、activeClassName  路由设置样式<br>| query、params 变量<br>| Redirect</p>
<h4 id="react-create-app-脚手架"><a href="#react-create-app-脚手架" class="headerlink" title="react-create-app 脚手架"></a>react-create-app 脚手架</h4><pre><code>$ sudo npm i create-react-app -g            // 全局安装，以后在安装就直接使用create-react-app命令来创建就可以

$ create-react-app my-app            // 创建+创建项目目录名

$ cd my-app

$ yarn start

$ yarn start、yarn build             // 启动服务、打包

$ yarn add antd        // 安装Antd UI框架

    在index.js中引用ant公用样式
    import &apos;antd/dist/antd.css&apos;;

$ yarn add react-router-dom -D            // react-router是安装4.0之前版本，react-router-dom是4之后版本

$ yarn add redux react-router-redux -D

$ npm run eject            // 注意如果对构建工具和配置选择不满意可以使用eject运行, 这里是单项操作只能一次不能回去

一、create-react-app关闭eslint提醒

    需要先npm run eject 生成本地webpack配置文件，在修改package.json中的配置

    &quot;eslintConfig&quot;: {
        &quot;extends&quot;: &quot;react-app&quot;,
        &quot;rules&quot;: {
            &quot;no-undef&quot;: &quot;off&quot;,
            &quot;no-restricted-globals&quot;: &quot;off&quot;,
            &quot;no-unused-vars&quot;: &quot;off&quot;
        }
    }

二、配置反向代理

    &quot;proxy&quot;: {
        &quot;/api/*&quot;: {
            &quot;target&quot;: &quot;http://goucai.diyicai.com&quot;,
            &quot;pathRewrite&quot;: {
                &quot;^/api/&quot;: &quot;/&quot;
            },
            &quot;changeOrigin&quot;: true,
            &quot;secure&quot;: false
        }
    }

三、使用.scss文件

    1、$ npm install file-loader sass-loader node-sass --save-dev            // 安装包

    2、node_modules/react-scripts/config/webpack.config.dev.js 和 webpack.config.prod.js文件中module中配置下面两项

        {
            exclude: [/\.(js|jsx|mjs)$/, /\.html$/, /\.json$/, /\.scss/],            // 这里加添加一个/\.scss/
            loader: require.resolve(&apos;file-loader&apos;),
            options: {
                name: &apos;static/media/[name].[hash:8].[ext]&apos;,
            }
        },
        // 解析scss文件
        {
            test: /\.scss$/,
            loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;],
        }


四、引入样式

    1、&lt;div style={{width: "1000px"}}&gt;&lt;/div&gt;

    2、import &quot;./main.css&quot;

        &lt;div className=&quot;main&quot;&gt;&lt;/div&gt;

    3、import Styles from &apos;./main.css&apos;

        &lt;div className={Styles.main}&gt;&lt;/div&gt;


五、常见问题

    1、&lt;src&gt;引用本地图片无效

        import JzkUrl from &apos;../../assets/img/jzk.png&apos;

        &lt;img src={JzkUrl} /&gt;

六、build的打包的时候注意的地方

    在package.json中的有一个homePage: &apos;.&apos;，这个在打包的时候图片会成为相对路径，如果改成 homePage: &apos;/&apos;


七、修改webpack配置加一个全局配置

    function resolve (dir) {
        return path.join(__dirname, &apos;..&apos;, dir)
    }

    resolve: {
        alias: {
            &apos;react-native&apos;: &apos;react-native-web&apos;,
            &apos;@&apos;: resolve(&apos;src&apos;)
        }
    }

    在页面里可以直接引用@来找到src目录

        import User from &apos;@/views/User/&apos;
</code></pre><h4 id="PropTypes验证"><a href="#PropTypes验证" class="headerlink" title="PropTypes验证"></a>PropTypes验证</h4><pre><code>React.PropTypes 提供很多验证器来验证传入数据的有效性

当向 props 传入无效数据时，JavaScript 控制台会抛出警告。注意为了性能考虑，只在开发环境验证 propTypes。下面用例子来说明不同验证器的区别: 

Example:

    import PropTypes from &apos;prop-types&apos;;
    class Greeting extends React.Component {
        render() {
            return (
                &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
            );
        }
    }
    Greeting.propTypes = {
        name: PropTypes.string
    };

propTypes类型: {

    // 可以声明 prop 为指定的 JS 基本类型。默认
    // 情况下，这些 prop 都是可传可不传的。
    optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,

    // 所有可以被渲染的对象: 数字，
    // 字符串，DOM 元素或包含这些类型的数组。
    optionalNode: React.PropTypes.node,

    // React 元素
    optionalElement: React.PropTypes.element,

    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
    optionalMessage: React.PropTypes.instanceOf(Message),

    // 用 enum 来限制 prop 只接受指定的值。
    optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),

    // 指定的多个对象类型中的一个
    optionalUnion: React.PropTypes.oneOfType([
        React.PropTypes.string,
        React.PropTypes.number,
        React.PropTypes.instanceOf(Message)
    ]),

    // 指定类型组成的数组
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

    // 指定类型的属性构成的对象
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

    // 特定形状参数的对象
    optionalObjectWithShape: React.PropTypes.shape({
        color: React.PropTypes.string,
        fontSize: React.PropTypes.number
    }),

    // 以后任意类型加上 `isRequired` 来使 prop 不可空。
    requiredFunc: React.PropTypes.func.isRequired,

    // 不可空的任意类型
    requiredAny: React.PropTypes.any.isRequired,

    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接
    // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
    customProp: function(props, propName, componentName) {
        if (!/matchme/.test(props[propName])) {
            return new Error(&apos;Validation failed!&apos;);
        }
    }
}
</code></pre><h4 id="react-router-4-0"><a href="#react-router-4-0" class="headerlink" title="react-router 4.0"></a>react-router 4.0</h4><pre><code>v3到v4版本的变化是静态路由到动态路由的变化，并且页面的嵌套路路由嵌套决定

react-router: 是浏览器和原生应用的通用部分, 核心文件

react-router-dom: 用于浏览器

react-router-native: 是用于原生(react-native)应用的    

react-router-redux: React Router 和 Redux 的集成

react-router-config: 静态路由配置的小助手

一、安装

    $ npm i react-router react-router-dom --save

    import { BrowserRouter as Router, Route, Switch, Link, Redirect, withRouter } from &apos;react-router-dom&apos;;


二、使用路由

    1、react-router和react-router-dom，不需要都引用，只是后者多&lt;Link&gt; &lt;BrowserRouter&gt; 这样的 DOM 类组件

    2、如果搭配 redux ，你还需要使用 react-router-redux

    index.js: 在入口文件加上路由配置

        import React from &apos;react&apos;
        import { Router, Route, Link } from &apos;react-router&apos;

        // render中加入路由配置
        React.render((
            &lt;Router&gt;
                &lt;Route path=&quot;/&quot; component={App}&gt;
                    &lt;Route path=&quot;about&quot; component={About}/&gt;
                    &lt;Route path=&quot;users&quot; component={Users}&gt;
                        &lt;Route path=&quot;/user/:userId&quot; component={User}/&gt;
                    &lt;/Route&gt;
                    &lt;Route path=&quot;*&quot; component={NoMatch}/&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        ), document.body)


二、&lt;BrowserRouter&gt; HTML5 history路由组件

    1、basename - 为所有位置添加一个基准的url

        &lt;BrowserRouter basename=&quot;/minooo&quot; /&gt;
        &lt;Link to=&quot;/react&quot; /&gt; // 最终渲染为 &lt;a href=&quot;/minooo/react&quot;&gt;

    2、getUserConfirmation() - 导航到此页执行的函数

        const getConfirmation = (message, callback) =&gt; {
            const allowTransition = window.confirm(message)
            callback(allowTransition)
        }
        &lt;BrowserRouter getUserConfirmation={getConfirmation(&apos;Are you sure?&apos;, yourCallBack)} /&gt;

    3、forceRefresh - bool当浏览器不支持 HTML5 的 history API 时强制刷新页面

        const supportsHistory = &apos;pushState&apos; in window.history
        &lt;BrowserRouter forceRefresh={!supportsHistory} /&gt;    

    4、keyLength - 路由的长度

    5、children - 渲染唯一子元素


三、&lt;HashRouter&gt; 该技术只是用来支持旧版浏览器, Hash history 不支持 location.key 和 location.state


四、&lt;Route&gt; 最重要的组件，页面访问地址与Router的path进行匹配，渲染出对应的UI界面

    &lt;Route path=&quot;/&quot; component={Main}&gt; - 渲染的组件

    &lt;Route&gt; 自带三个 render method 和三个 props

    1、render methods 分别是：

        &lt;Route component&gt; - 当访问地址和路由匹配时，一个组件才会被渲染，此时此组件接受match、location、history

            * &lt;Route path=&quot;/home&quot; component={Home} /&gt;

        &lt;Route render&gt; - 适用于内联渲染，不会产生重复装载问题

            * &lt;Route path=&quot;/home&quot; render={() =&gt; &lt;h1&gt;Home&lt;/h1} /&gt;

        &lt;Route children&gt; -

    2、props分别是: match、location、history

            &lt;Route path=&quot;/:id&quot; component={ListBasic}&gt;&lt;/Route&gt;          // 参数传给子组件
            this.props.match.params.id            // 获取参数值

    3、path: 路由路径

         exact: true，表示独一无二的路由

            // 如果不加exact, &quot;/&quot; 时加载main, &quot;/login&quot; 会显示main和login两个组件，如果加了exact在&quot;/&quot;路由时只会显示main组件
            &lt;div style={{ height: "500px", backgroundColor: "#ccc"}}&gt;
                &lt;Route path=&quot;/&quot; exact component={Main} /&gt;
                &lt;Route path=&quot;/login&quot; component={Login} /&gt;
                &lt;Route path=&quot;/todoList&quot; component={TodoList} /&gt;
            &lt;/div&gt;

         strict: true，如果path为&apos;/one/&apos;将不能匹配&apos;/one&apos;，但可以匹配&apos;/one/two&apos;


五、路由跳转

    1、Link、NavLink

        &lt;Link to=&quot;/course&quot; /&gt;
        &lt;Link to={{
				pathname: '/course',
				search: '?sort=name',
				state: { price: 18 }
			}} /&gt;

        // 给导航使用的
        &lt;NavLink
            to=&quot;/about&quot;
            activeStyle={{ color: 'green', fontWeight: 'bold' }}
        &gt;MyBlog&lt;/NavLink&gt;

    2、JS跳转

        export default class SelectCard extends Component {
            constructor(props){
                super(props);
            }
            goHomePage(){
                this.props.history.push(&apos;/main&apos;);            // 跳转
            }
            render(){
                return {
                    &lt;div&gt;
                        &lt;button onClick={this.goHomePage.bind(this)}&gt;跳转&lt;/button&gt;
                    &lt;/div&gt;
                }
            }
        }

        /** 注意如果使用redux子组件会取不到this.props.history **/
        解决方法: 在子组件中
        import PropTypes from &apos;prop-types&apos;

        子组件名.contextTypes = {
            router: PropTypes.object.isRequired
        }

        console.log( this.context.router.history.push(&apos;/&apos;) );


六、&lt;switch&gt; 只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;

    // v3
    &lt;Route path=&apos;/&apos; component={App}&gt;
        &lt;IndexRoute component={Home} /&gt;
        &lt;Route path=&apos;about&apos; component={About} /&gt;
        &lt;Route path=&apos;contact&apos; component={Contact} /&gt;
    &lt;/Route&gt;

    v4中使用&lt;switch&gt;来取代&lt;IndexRouter&gt;, 当react渲染时switch下第一个子&lt;route&gt;会被渲染
    // v4
    const App = () =&gt; (
        &lt;Switch&gt;
            &lt;Route exact path=&apos;/&apos; component={Home} /&gt;
            &lt;Route path=&apos;/about&apos; component={About} /&gt;
            &lt;Route path=&apos;/contact&apos; component={Contact} /&gt;
        &lt;/Switch&gt;
    )


七、添加图像、字体和文件

    组件中加载图片
    import logo from &apos;./logo.png&apos;;        导入图片
    &lt;img src={logo} alt=&quot;Logo&quot; /&gt;;

    css中加载图片
    .logo{
        background-image: url(&apos;./logo.png&apos;);
    }


八、Redirect重定向 和 未匹配路由跳转到404

    // 跳404用法
    render() {
    return (
    &lt;Router&gt;
      &lt;div className=&quot;main-container&quot;&gt;
        &lt;Route path=&quot;/main&quot; component={Main} /&gt;
        &lt;Route component={Page404}/&gt;                // 没有定义path就是没有路径匹配时
      &lt;/div&gt;
    &lt;/Router&gt;
    )
    }

    // Redirect 用法不渲染组件直接重定到其它页面
    render() {
        if(!this.state.logined){
            return (
                &lt;Redirect to=&quot;/todoList&quot; /&gt;
            )
        }
        return (
            &lt;div&gt;
                这里是Login组件
            &lt;/div&gt;
        )
    }


九、动态路由

    1、路由变量

        定义变量: &lt;Route path=&quot;/:msg&quot; component={Message} /&gt;
        获取变量: props.match.params.定义的名

        &lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan
        &lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan
        &lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg

        Example:

            class Message extends Component {
                render(props){
                    return (
                        &lt;div&gt;
                            // 这里this.props.params.msg 接收的是to的名字
                            &lt;h1&gt;{this.props.match.params.jumpUrl || &apos;hello&apos;}&lt;/h1&gt;
                            &lt;Links /&gt;
                        &lt;/div&gt;
                    )
                }
            }

            const Links = () =&gt;{
                &lt;nav&gt;
                    &lt;Link to=&quot;/&quot;&gt;Hello&lt;/Link&gt;
                    &lt;Link to=&quot;/yong&quot;&gt;Yong&lt;/Link&gt;
                    &lt;Link to=&quot;/feng&quot;&gt;Feng&lt;/Link&gt;
                &lt;/nav&gt;
            }

            class ParamsRoute extends Component {
                render() {
                    return (
                        &lt;Router history={hashHistory}&gt;
                            &lt;Route path=&quot;/(:msg)&quot; component={Message} /&gt;
                        &lt;/Router&gt;
                    );
                }
            }
            export default ParamsRoute;


    2、query: 获取URL中的参数

        1) 获取参数

            http://localhost:8080/#/?message=ssssss

            const Page = (props) =&gt;
                &lt;div&gt;
                    &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;            // props.location.query.message输出 ssssss
                &lt;/div&gt;

        2) &lt;Link&gt;请求时带参数

            const Page = (props) =&gt;
                &lt;div&gt;
                    &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;
                &lt;/div&gt;

            const Links = () =&gt;
                &lt;nav&gt;
                    &lt;Link to={{ pathname: "/", query: {message: "ssssss"} }} /&gt;         
                &lt;/nav&gt;

        3) js中请求参数 

            goToMessage(){
                that.props.history.push({ 
                    pathname : &apos;/success&apos;,
                    query : { messageTitle: &apos;充值成功&apos;, messageContent: &apos;请取您的充值单请取您的充值单请取您的充值单&apos;} 
                })
            }


十、路嵌套和展示

    // v2/3版本 就是一个路由配置文件，在放子路由的地方使用
    &lt;div&gt;
        { this.props.childre }                // 加载子路由的位置
    &lt;/div&gt;

    // v4版本
    // router.jsx
    export default class Index extends Component {
        render() {
            return (
                &lt;Router&gt;
                    &lt;Switch&gt;
                        &lt;Layout /&gt;
                    &lt;/Switch&gt;
                &lt;/Router&gt;
            )
        }
    }

    // layout.jsx
    export default class Layout extends Component {
        render() {
            let menuHtml = () =&gt; {
                const menuItem = [];
                this.state.menuList.forEach(function(menu, idx, arr){
                    menuItem.push(
                        &lt;li&gt;
                            &lt;Link to={menu.path}&gt;{menu.title}&lt;/Link&gt;
                        &lt;/li&gt;
                    )
                })
                return menuItem
            }

            return (
                &lt;div&gt;
                    &lt;header style={{height: "100px"}}&gt;
                        菜单: { menuHtml() }
                    &lt;/header&gt;
                    &lt;main style={{ height: "500px", backgroundColor: "#ccc"}}&gt;
                        // 这下面都是子路由的展示位置
                        &lt;Route path=&quot;/&quot; exact component={Main} /&gt;
                        &lt;Route path=&quot;/login&quot; component={Login} /&gt;
                        &lt;Route path=&quot;/todoList&quot; component={TodoList} /&gt;
                        &lt;Route component={Page404}&gt;&lt;/Route&gt;                        // 注: 如果没有匹配路由指到到404页面, 不需要使用Redirect
                    &lt;/main&gt;
                &lt;/div&gt;
            )
        }
    }

    // login.jsx
    export default class Login extends Component {
        constructor(props){
            super(props);
            this.state = {
                logined: true
            }
        }

        render() {
            /* 这里可以不渲染组件直接重定到其它页面 */
            if(!this.state.logined){
                return (
                    &lt;Redirect to=&quot;/todoList&quot; /&gt;
                )
            }
            return (
                &lt;div&gt;
                    这里是Login组件
                &lt;/div&gt;
            )
        }
    }

https://www.jianshu.com/p/7bb4c1a0530d
https://www.jianshu.com/p/548674270455


十一、withRouter 

    withRouter是专门用来处理数据更新问题，否则可能会出现路由地址改变但页面没有相应改变的bug

    import React, { Component } from &apos;react&apos;
    import { withRouter } from &apos;react-router&apos;
    import { Route, Redirect } from &apos;react-router-dom&apos;

    class AuthRouter extends Component {
        render() {  
            const { component: Component, ...rest } = this.props
            const isLogged = sessionStorage.getItem(&quot;isLogin&quot;) === &quot;1&quot; ? true : false;

            return (
                &lt;Route {...rest} render={props =&gt; {
                    return isLogged
                        ? &lt;Component {...props} /&gt;
                        : &lt;Redirect to=&quot;/login&quot; /&gt;
                }} /&gt;
            )
        }
    }
    export default withRouter(AuthRouter);
</code></pre><h4 id="dva-react-Ant-蚂蚁金服脚手架"><a href="#dva-react-Ant-蚂蚁金服脚手架" class="headerlink" title="dva+react+Ant 蚂蚁金服脚手架"></a>dva+react+Ant 蚂蚁金服脚手架</h4><pre><code>单独加载ant UI框架，也可以使用dva-cli蚂蚁提供的脚手架，支持IE9及以上版本

一、单独添加ant  

    $ cnpm i antd --save

    import &apos;antd/dist/antd.css&apos;;         // 引入样式
    import { DatePicker } from &apos;antd&apos;;    // 这种方法的引用必须要添加babel-plugin-import的按需加载组件
    ReactDOM.render(&lt;DatePicker /&gt;, mountNode);            

二、按需加载插件 babel-plugin-import

    $ cnpm i babel-plugin-import --save

    .babelrc添加参数:
    {
        &quot;plugins&quot;: [
            [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }] // `style: true` 会加载 less 文件
        ]
    }

三、dva-cli安装

    $ cnpm i dva-cli    

    $ dva new [项目名] &amp;&amp; cd [项目名]        // 创建项目

    $ cnpm install antd babel-plugin-import --save        // 安装 ant 和 babel插件（用来按需加载 antd 的脚本和样式的）

        .webpackrc文件加参数
        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ]  
        }

四、运行

    $ npm start         // 生产环境运行

    $ npm run build        // 打包项目，发布线上环境在Dist目录下生成静态文件，js、css压缩

五、redux的使用

    有两个目录，models和components, model来定义state和action的，components来编写组件

    dva提供conect方法，将model和component串联起来

    import { connect } from &apos;dva&apos;;

    const Products = ({ dispatch, products }) =&gt; { ... }
    export default connect(({ products }) =&gt; ({
        products,
    }))(Products);

六、配置

    1、 .roadhogrc.mock.js  用于mock数据的配置

        export default {
            // 支持值为 Object 和 Array
            &apos;GET /api/users&apos;: { users: [1,2] },

            // GET POST 可省略
            &apos;/api/users/1&apos;: { id: 1 },

            // 支持自定义函数，API 参考 express@4
            &apos;POST /api/users/create&apos;: (req, res) =&gt; { res.end(&apos;OK&apos;); },
        };

    2、.webpackrc  

        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ],
            &quot;entry&quot;: &quot;src/index.js&quot;,        // 可以配置webpack的选项，参数见面下roadhog的文档连接
            &quot;proxy&quot;: {                        // 设置代理
                &quot;/api&quot;: {
                    &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;,
                    &quot;changeOrigin&quot;: true,
                    &quot;pathRewrite&quot;: { &quot;^/api&quot; : &quot;&quot; }
                }
            }
        }

    3、设置端口

        默认是8000，可以在package.json中设置
        &quot;scripts&quot;: {
               &quot;start&quot;: &quot;PORT=3000 roadhog server&quot;,        // windowns设置 set PORT=3000&amp;&amp;roadhog dev
        }

    4、public目录会在build的copy到dist目录下，存放一些静态文件

https://github.com/sorrycc/blog/issues/18            // dva
https://github.com/sorrycc/roadhog/blob/master/README_zh-cn.md    // roadhog


七、fatch请求

    dva-cli中utils目录中request.js中定义了一个通过fatch来发ajax请求的方法

    业务中调用:
    function IndexPage() {
        var getUser = () =&gt; {
            Request(&apos;/api/posts&apos;, {method: &apos;GET&apos;})
            .then((data)=&gt;{
                debugger;
            })
        }
        getUser()

        return (
            &lt;div className={styles.normal}&gt;
                ...
            &lt;/div&gt;
        );
    }
    exports default IndexPage;
</code></pre><h4 id="收集组件"><a href="#收集组件" class="headerlink" title="收集组件"></a>收集组件</h4><pre><code>1、react-transition-group - 页面切换过渡效果

https://github.com/reactjs?page=2
</code></pre><p>| <a href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener">https://facebook.github.io/create-react-app/</a>            // create-react-app 官网<br>| <a href="https://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">https://react-guide.github.io/react-router-cn/</a>        // React-router 中文网<br>| <a href="https://reacttraining.com/react-router/web/example/basic" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/example/basic</a>    // 官方示例**<br>| <a href="https://www.jianshu.com/p/25e9ba1ebafb" target="_blank" rel="noopener">https://www.jianshu.com/p/25e9ba1ebafb</a>                        // react源码分析<br>| <a href="https://github.com/YutHelloWorld/Blog/issues/4" target="_blank" rel="noopener">https://github.com/YutHelloWorld/Blog/issues/4</a>        // v2、3迁移v4<br>| <a href="https://www.jianshu.com/p/e0a0ed6c3b8a" target="_blank" rel="noopener">https://www.jianshu.com/p/e0a0ed6c3b8a</a>                // 路由跳转登录验证<br>| <a href="https://www.jianshu.com/p/e3adc9b5f75c/" target="_blank" rel="noopener">https://www.jianshu.com/p/e3adc9b5f75c/</a><br>| <a href="https://segmentfault.com/a/1190000009349377" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009349377</a>        // router ^4<br>| <a href="https://github.com/reactjs/react-router-redux" target="_blank" rel="noopener">https://github.com/reactjs/react-router-redux</a></p>

        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
