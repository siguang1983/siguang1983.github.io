<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Label: React | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Labels</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之三)Redux/">React（之三）Redux</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之三)Redux/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createStroe() - 创建一个store<br>| getState() -  获取state值<br>| dispatch() -  执行action<br>| action  要执行的事件<br>| subscribe() - 侦听state的变化<br>| reducer 用来改变state的值，结合了action的动作来分别处理<br>| combineReducers - 将多个reducer合到一起赋给createStroe()<br>|<br>| React-redux - 让react与redux结合<br>| provider - 将redux的Store传到内部的其它组件，内部都可以对state更新<br>| connect - react与redux连接<br>|<br>| applyMiddleware() - 加载中间件<br>| bindActionCreators() - 直接调用dispatch(action)()<br>| compose</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>Facebook官方提出了Flux思想管理数据流，同时也给出了自己的实现方案Flux来管理React应用

实现Flux思想的类库 Redux、Flux、reflux

$ npm i --save redux        // 安装redux

$ npm i react-redux --save    // redux与react结合

$ npm i redux-devtools --save        // 查看调试

$ npm i redux-thunk --save

$ npm i redux-logger --save

$ import { createStore } from &apos;redux&apos;;    // 引用redux

一、Redux流程:

    1、view直接触发dispatch

    2、dispatch将action发送到reducer中后，根节点上会更新props，改变全局view

    3、redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中    
</code></pre><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><pre><code>Store 保存数据的容器， createStroe(reducer, applyMiddleware)

import { createStore } from &apos;redux&apos;;
import counter from &apos;./reducers&apos;        // 获取定义的reducer

let stroe = createStroe(counter);    // 使用createStore(reducer, initialState初始化state, 中间件传入)来创建一个数据仓库
store.dispatch();

方法:

    1、store.getState(): 获取State值

    2、store.dispatch(action): 将一个 action 对象发送给 reducer

    3、store.subscribe(listener)，用来订阅状态的变化
</code></pre><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><pre><code>state用于存储数据，state是只读的，改变需要触发action

state树就是一个对象，所有的reducer的都会加到state中，取state值，store.getState().
</code></pre><h4 id="dispatch-触发action的变化"><a href="#dispatch-触发action的变化" class="headerlink" title="dispatch() 触发action的变化"></a>dispatch() 触发action的变化</h4><pre><code>store.dispatch(actionJson);
</code></pre><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><pre><code>定义Action指令并不能直接改变state，action必须是json

Action函数和Action不相同

{
    type: &apos;ADD_TODO&apos;,
    text: &apos;hhh&apos;
}

function addTodo(text) {
    return {
        type: ADD_TODO,
        text
    }
}
通过 store.dispatch(action): 来派发到reducer中来改变state的值
</code></pre><h4 id="Reducer-rɪ’dju-sə-瑞丢ser"><a href="#Reducer-rɪ’dju-sə-瑞丢ser" class="headerlink" title="Reducer [rɪ’dju:sə][瑞丢ser]"></a>Reducer [rɪ’dju:sə][瑞丢ser]</h4><pre><code>接收一个action值，根据定义的action名对应处理state，并改变state值

let comput = (state=0, action) =&gt; {
    switch(action.type){
        case &apos;add&apos;:
            return state + 1;
            break;

        case &apos;sub&apos;:
            return state - 1;
            break;

        default: break;
    }
}

let store = createStore(comput);
store.dispatch({type: add});
</code></pre><h4 id="combineReducers-kəmˈbaɪn-rɪ’dju-səre-将所有的reducer合成一个"><a href="#combineReducers-kəmˈbaɪn-rɪ’dju-səre-将所有的reducer合成一个" class="headerlink" title="combineReducers [kəmˈbaɪn rɪ’dju:səre]  将所有的reducer合成一个"></a>combineReducers [kəmˈbaɪn rɪ’dju:səre]  将所有的reducer合成一个</h4><pre><code>import {combineReducers} from &quot;redux&quot;; 
import chatIndex from &quot;./Chat&quot;;

export default combineReducers({
    chatIndex,
});
</code></pre><h4 id="subscribe-səbˈskraɪb-订阅-监听器"><a href="#subscribe-səbˈskraɪb-订阅-监听器" class="headerlink" title="subscribe()[səbˈskraɪb]订阅  监听器"></a>subscribe()[səbˈskraɪb]订阅  监听器</h4><pre><code>添加一个变化的监听器，每当dispatch action的时候就会执行

// App组件
class App extends Component {
    constructor(props){
        super(props);
        this.state = {
            num: 0
        }
    }

    componentDidMount() {
        store.subscribe(this.handleChange.bind(this));
    }

    handleChange(){
        this.setState({num: store.getState()})
    }

    addClick(){
        store.dispatch({type: &apos;add&apos;});
    }

    subClick(){
        store.dispatch({type: &apos;sub&apos;});
    }

    showState(){
        debugger;
        console.log(store.getState())
    }

    render() {
        return (
            &lt;div className = &quot;box&quot; &gt;
                {this.state.num}
                &lt;input type=&quot;button&quot; onClick={this.addClick} value=&quot;+&quot; /&gt;
                &lt;input type=&quot;button&quot; onClick={this.subClick} value=&quot;-&quot; /&gt;
                &lt;input type=&quot;button&quot; onClick={this.showState} value=&quot;查看state&quot; /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h4><pre><code>一、provider(store, children) - 将Store传到子组件中，一般用在入口文件

    import React from &apos;react&apos;;
    import ReactDOM from &apos;react-dom&apos;;
    import {Provider} from &quot;react-redux&quot;;
    import Store from &quot;src/store&quot;;
    import App from &apos;src/components/app&apos;;
    import Chat from &apos;src/pages/Chat/Index&apos;;

    ReactDOM.render(
        &lt;Provider store={Store}&gt;
            &lt;App&gt;
                &lt;Chat /&gt;
            &lt;/App&gt;
        &lt;/Provider&gt;,
        document.getElementById(&apos;app&apos;)
    );

    如果使用路由
    &lt;Provider store={store}&gt;
        &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
            &lt;Route path=&apos;/&apos; component={Index}&gt;
                &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;


二、connect(mapStateToProps, mapDispatchToProps) - 连接react组件与redux store

    1、mapStateToProps - 把状态绑定到组件的props中

    2、mapDispatchToProps - 相当于用store.dispatch(actionType) 来发出操作指令，来改变state值


example

// app.jsx
&lt;Provider store={store}&gt;
    &lt;Router ref=&quot;router&quot; history={hashHistory}&gt;
        &lt;Route path=&apos;/&apos; component={Index}&gt;
            &lt;IndexRoute  component={MainPage}&gt;&lt;/IndexRoute&gt;
        &lt;/Route&gt;
    &lt;/Router&gt;
&lt;/Provider&gt;

// Index.jsx
import React, { Component } from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;
import { bindActionCreators } from &quot;redux&quot;;
import { connect } from &quot;react-redux&quot;;
import actions from &quot;src/actions&quot;;

class wechat extends Component {
    constructor(props){
        super(props);
        this.state = {

        }
    }

    componentDidMount(){
        let { ACTIONS } = this.props;
        ACTIONS.chat_init();
    }

    render(
        // ...
    )
}

let mapStateToProps=(state)=&gt;{
    let {sessions,user} = state.chatIndex;
    return {
        _sessions:sessions,
        _user:user
    };
}; 

let mapDispatchToProps=(dispatch)=&gt;{
    return {
        ACTIONS:bindActionCreators(actions,dispatch)
    };
};

export default connect(mapStateToProps,mapDispatchToProps)(wechat);
</code></pre><h4 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators()"></a>bindActionCreators()</h4><pre><code>是通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用）

import * as oldActionCreator from &apos;./action.js&apos;

let newAction = bindActionCreators(oldActionCreator,dispatch)
</code></pre><h4 id="redux-thunk-中间件"><a href="#redux-thunk-中间件" class="headerlink" title="redux-thunk 中间件"></a>redux-thunk 中间件</h4><pre><code>可以action创建子函数先不返回active对象，

http://blog.csdn.net/kuangshp128/article/details/67632683
</code></pre><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><pre><code>两种方法 1、下载redux-devtools包      2、chrome or Firfix 下载 Redux DevTools插件

1、使用Redux DevTools插件 代码中需要加配置

    https://github.com/zalmoxisus/redux-devtools-extension

    /* eslint-disable no-underscore-dangle */        // +
    let store = createStore(
        comput,
        window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()        // +
    )
    /* eslint-enable */                                // +


2、redux-devtool 包的使用 https://github.com/gaearon/redux-devtools
</code></pre><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>|- src
|-- reduxs     // redux
|------ actions
|------ reducers
|-- router    // 路由
|-- util    // 工具
</code></pre><p>| <a href="https://www.jianshu.com/p/bccca5bb6338" target="_blank" rel="noopener">https://www.jianshu.com/p/bccca5bb6338</a>        // react－router－redux 保持路由与应用状态（state）同步<br>| <a href="http://cn.redux.js.org/index.html" target="_blank" rel="noopener">http://cn.redux.js.org/index.html</a><br>| <a href="https://github.com/GuoYongfeng/redux-complete-sample" target="_blank" rel="noopener">https://github.com/GuoYongfeng/redux-complete-sample</a><br>| <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">https://github.com/gaearon/redux-devtools</a><br>| <a href="http://www.aliued.com/?p=3204" target="_blank" rel="noopener">http://www.aliued.com/?p=3204</a><br>| <a href="https://www.jianshu.com/p/1a2f3db4af61" target="_blank" rel="noopener">https://www.jianshu.com/p/1a2f3db4af61</a>        // react-redux<br>| <a href="https://www.jianshu.com/p/9873d4ccb891" target="_blank" rel="noopener">https://www.jianshu.com/p/9873d4ccb891</a>        // connect 原理<br>| <a href="http://blog.csdn.net/liwusen/article/details/54138854" target="_blank" rel="noopener">http://blog.csdn.net/liwusen/article/details/54138854</a>         // bindActionCreators<br>| <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之一)基础/">React（之一）基础</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之一)基础/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 创建组件<br>| render<br>| props、propType、state、setState()、replaceState()<br>| 获取DOM this.refs.xxx 或 ReactDOM.findDOMNode(this.refs.xxx)<br>| React.Children 获取父组件传的DOM<br>| mixin</p>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><pre><code>安装react-cli 见的README.md

React包括几个概念: 1、组件       2、JSX     3、虚拟DOM     4、单向数据绑定

1、核心是封装组件，只关注UI，状态变更重新渲染整个组件

2、JSX: HTML代码可以直接嵌到JS代码中，这就是React提出的叫JSX的语法，原来前端以表现和逻辑层分离为主，但HTML是组件的一部分所以不能分割，JSX 将动态值放到 { ... }

3、单向数据绑定: 当数据更新会渲染整个app

    修改DOM树、修改数据、以旧换新用户输入、异步API数据

    React的渲染方式: 用户输入、从API获取数据、将数据传给顶层组件、React将每个组件渲染出来

        不会象MVC一样的双向数据绑定、和数据模型的脏值检测、不会有确切的DOM操作

4、虚拟DOM树: React重建一个DOM树，找到与上一个版本的DOM的差异，计算出新的DOM更新操作，从操作队列中指执行DOM更新操作

    http://www.alloyteam.com/2015/04/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%AF%86-virtualdom/      // 前沿技术解密——VirtualDOM

5、工具: sublime或Atom

    sublime插件安装: 

    ReactJS  https://packagecontrol.io/packages/ReactJS   用来提示编码还有快捷键

    babel-sublime: https://github.com/babel/babel-sublime   用来语法颜色

    javascriptNext: https://github.com/Benvie/JavaScriptNext.tmLanguage 
</code></pre><h4 id="react引用方式"><a href="#react引用方式" class="headerlink" title="react引用方式"></a>react引用方式</h4><pre><code>1、页面直接加载

    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;

2、ES5的写法

    var React = require(&apos;react&apos;);
    var ReactDOM = require(&apos;react-dom&apos;);

    // 定义组件
    var HelloMessage = React.createClass({
      render: function() {
        return &lt;div&gt; React，我们来了... &lt;/div&gt;;
      }
    });

    // 组件渲染
    ReactDOM.render(&lt;HelloMessage /&gt;, rootElement);

3、ES6的写法

    import React, { Component } from &apos;react&apos;;
    import { render } from &apos;react-dom&apos;;

    // 定义组件
    class SimpleComponent extends Component {
        render(){
            return &lt;div&gt; React，我们来了... &lt;/div&gt;;
        }
    }
    export default SimpleComponent;

    // 组件渲染
    render(&lt;HelloMessage /&gt;, rootElement);
</code></pre><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><pre><code>var HelloMessage = React.createClass({
    render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
    }
});
React.render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode);

如果不使用JSX，就需要使用createElement()来创建元素

render: function() {
    return React.createElement(&quot;div&quot;, null, &quot;Hello &quot;, this.props.name);
}

一、注释

    {/* 一般注释, 用 {} 包围 */}

    /* 多
     行
     注释 */

二、根元素只能有一个

     class ComponentDemo extends Component {
        render(){
            // 以下写法直接报错
            return (
                &lt;div&gt;
                hello
                &lt;/div&gt;
                &lt;h1&gt; hello h1 &lt;/h1&gt;
            );
        }
    }

三、styles 写法

    class StyleDemo extends Component {
        render(){
            // 在JS文件里面给组件定义样式
            var MyComponentStyles = {
                color: &apos;blue&apos;,
                fontSize: &apos;28px&apos;
            };

            return (
                &lt;div style={MyComponentStyles}&gt;
                  可以直接这样写行内样式
                &lt;/div&gt;
            )
        }
    }

四、属性名不能和 js 关键字冲突

    class =&gt; className 

    read =&gt; readOnly 

    for =&gt; htmlfor

五、JSX spread

    {...spreadObj} 可以直接将spreadObj的对象传递过去

    Spread Demo组件:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;

        class SpreadDemo extends Component{
            render(){
                return &lt;div&gt;姓名: {this.props.name}  车型: {this.props.carType}&lt;/div&gt;
            }
        }
        export default SpreadDemo;

    main.js:

        import SpreadDemo from &apos;./components/spread&apos;;
        const spreadObj = {
            name: &apos;siguang&apos;,
            carType: &apos;卡宴&apos;
        }
        // render(&lt;SpreadDemo name={spreadObj.name} carType={spreadObj.carType} /&gt;, document.querySelector(&apos;#app&apos;));
        render(&lt;SpreadDemo {...spreadObj} /&gt;, document.querySelector(&apos;#app&apos;));
</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><pre><code>创建组件: React.createClass() 或 React.Component()

渲染组件: ReactDOM.render(&lt;组件名/&gt;, 放到哪个位置, 渲染完成的回调);

一、组件创建三种方法

    1、ES5 创建组件: 

        let React = require(&apos;react&apos;);
        let ReactDOM = require(&apos;react-dom&apos;);

        let Message = React.createClass({
            render: function(){
                return (
                    &lt;div&gt;
                        &lt;ul&gt;
                            &lt;li&gt;Hello World {this.props.personName}&lt;/li&gt;
                        &lt;/ul&gt;
                    &lt;/div&gt;
                )
            }
        })

        module.exports = Message;        // ES5导出组件

        // ReactDOM.render(
        //        &lt;Message personName=&quot;siguang&quot; /&gt;
        //         , document.querySelector(&apos;#app&apos;)
        // );


    2、ES6 创建组件方法

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;

        // 所有创建的组件都继承于Component对象
        class ShowMessage extends Component{
            render(){
                return &lt;div&gt;Hello name {this.props.name}&lt;/div&gt;
            }
        }

        export default ShowMessage;        // ES6导出组件

        // render(&lt;ShowMessage name=&quot;siguang.liu&quot; /&gt;, document.querySelector(&apos;#app&apos;));


    3、函数式组件

        是组件没有状态的时候（相当不需要设置state, 不能使用this、可以写成函数式

        const ShowMessage = () =&gt; &lt;div&gt;Hello name haha&lt;/div&gt;
        render(&lt;ShowMessage /&gt;, document.querySelector(&apos;#app&apos;));

        可以使用props

        const ShowMessage = function(props){
            return &lt;div&gt;Hello name {props.name}&lt;/div&gt;
        }


二、组件的注意地方

    1、组件名首字母必须大写

    2、根元素的个数只能是一个

        class ComponentDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;boxA&quot;&gt;            {/* 根元素只能有一个 */}
                        aaaaaaaa

                        &lt;div class=&quot;boxB&quot;&gt;
                            bbbbbb
                        &lt;/div&gt;
                    &lt;/div&gt;
                )
            }
        }
        export default ComponentDemo;

    3、spread变量传递可以使用es6的 {...obj}

        let person = &lt;Person name={window.isLoggedIn ? window.name : &apos;&apos;} /&gt;

    4、获取真实的DOM节点

        组件并不是真实的DOM节点，而是在内存中的一种数据结构叫虚拟DOM，如果要从组件内获取真实的DOM节点，需要用到refs属性
</code></pre><h4 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h4><pre><code>childList.jsx:

    import React, { Component } from &apos;react&apos;
    import ReactDom, { render } from &apos;react-dom&apos;

    class ChildrenA extends Component{
        constructor(props){
            super(props);
        }
        render(){
            return (&lt;div&gt;
                {/* 这里是子组件A   this.props.children获取组件的内容，相当前于vue中的solt */}
                {
                    React.Children.map(this.props.children, function(c){        // React.Children是获取组件中的元素
                        return &lt;p&gt;{c}&lt;/p&gt;
                    })
                }
            &lt;/div&gt;)
        }
    }

    class ParentComponent extends Component{
        render(){
            return &lt;div&gt;
                &lt;ChildrenA&gt;
                    &lt;p&gt;福特&lt;/p&gt;
                    &lt;p&gt;丰田&lt;/p&gt;
                    &lt;p&gt;本田&lt;/p&gt;
                &lt;/ChildrenA&gt;
            &lt;/div&gt;
        }
    }
    export default ParentComponent;

index.js:

    import React, { Component } from &apos;react&apos;
    import ReactDom, { render } from &apos;react-dom&apos;
    import ParentComponent from &apos;./components/ParentComponent&apos;

    render(&lt;ParentComponent /&gt;, docuemnt.querySelector(&apos;#box&apos;));
</code></pre><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><pre><code>React是单向数据流，数据从父组件传到子组件，子组件通过props获取数据，顶层组件改变了props，React会遍历整个组件树，重新渲染整个组件

数据流包括: Props 和 State
</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>从最顶层逐级向下传递，从父组件将数据传到子组件，单向数据流

{this.props.name} 读取props的值

1、props API:

    this.props.children

    this.props.map

    this.props.filter 


2、getDefaultProps() 设置一个默认的props

    ES5写法

        var ComponentWithDefaultProps = React.createClass({
            // 初始化设置props值
            getDefaultProps: function() {
                return {
                    value: &apos;default value&apos;
                };
            }
        });

    ES6写法 

        /* 通过 defaultProps 来定义 */
        class PropsDemo extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}
                    &lt;/div&gt;
                )
            }
        }

        PropsDemo.defaultProps = {
            name: &apos;123123&apos;        // 默认一个name值，如果父组件没有传值就会取默认值
        }


3、propsType 校验props规则

    import React, { Component, PropTypes } from &apos;react&apos;;

    class PropTypesDemo extends Component {
        render(){
            return &lt;b&gt;{this.props.title}&lt;/b&gt;
        }
    }

    // 静态属性定义propTypes, title只能为string
    PropTypesDemo.propTypes = {
        title: React.PropTypes.string.isRequired
    }

    export default PropTypesDemo;


4、Example

    PropsComponent组件:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;

        class PropsComponent extends Component {
            render(){
                return (
                    &lt;div class=&quot;box&quot;&gt;
                        name: {this.props.name}, age: {this.props.age}         {/* 这里接收props值 */}
                    &lt;/div&gt;
                )
            }
        }

        // 输出组件接口
        export default PropsComponent;


    index.js:

        import React, { Component } from &apos;react&apos;;
        import ReactDOM, { render } from &apos;react-dom&apos;;
        import PropsComponent from &apos;../components/props&apos;;

        // 要传的值
        let obj = {
            name: &apos;haha&apos;,
            age: &apos;300&apos;
        }

        // 方法1、直接传给属性
        render(&lt;PropsComponent name={obj.name} age={obj.age} /&gt;, document.querySelector(&apos;body&apos;));

        // ...obj 来对多值进行解析赋值
        render(&lt;PropsComponent {...obj} /&gt;, document.querySelector(&apos;body&apos;));


5、this.props.children 访问自定义子节点

    // 将组件下的所有子节点通过map获取到，并重新包装
    import React, { Component } from &apos;react&apos;;

    class UseChildren extends Component {
        render(){
            return  &lt;ul&gt;
                {
                    // 会将UseChildren组件下所有的元素取出
                    React.Children.map(this.props.children, function(c){
                        return &lt;li&gt; {c} &lt;/li&gt;
                    })
                }
            &lt;/ul&gt;
        }
    }

    class ChildrenDemo extends Component {
        render(){
            return (
                &lt;UseChildren&gt;
                    &lt;a href=&quot;#&quot;&gt;Facebook&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Google&lt;/a&gt;
                    &lt;a href=&quot;#&quot;&gt;Space&lt;/a&gt;
                &lt;/UseChildren&gt;
            )
        }
    }

    export default ChildrenDemo;
</code></pre><h4 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h4><pre><code>每一个React组件都有一个自己的state对象，与props区别在于，state只能在当前组件内部使用

1、初始化state

    ES5: 通过getInitialState()

        var Component = React.createClass({
            // getInitialState()方法 初始化 state值
            getInitialState: function() {
                return { userName: &apos;siguang&apos; };
            },

            render: function(){
                return (
                    &lt;div&gt; {this.state.userName} &lt;/div&gt;
                )
            }
        }

    ES6: 通过类的constructor()来初始化

        class StateDemo extends Component {
            constructor(){
                super();            // 继承Component

                // 这里初始化state
                this.state = { 
                    userName: &apos;siguang&apos; 
                }
            }

            render(){
                return (
                    &lt;div&gt; {this.state.username}
                )
            }
        }


2、setState({改变的值}, 回调函数)来设置state的值, RN中是异步所以这块需要注意

    // 改变已有的值
    this.setState({username: &apos;haha&apos;})

    // 替换所有值
    this.replaceState()  


3、获取state值 { this.state.属性名 }

    改变值: this.setState()每当state更新组件就会重新渲染自己

    var Component = React.createClass({

        // 1 初始化 state值
        getInitialState: function() {
            return {userName: &apos;siguang&apos;};
        },
        setUserName: function(){
            this.setState({userName: &apos;lulu&apos;});        // 2 修改state值
        },
        render: function(){
            return (
                &lt;div&gt;
                    这里是props获取的值 {this.state.userName}    // 3 获取state的值
                    &lt;input type=&quot;button&quot; onClick={this.setUserName.bind(this)} value=&quot;点击修改state&quot; /&gt;
                &lt;/div&gt;
            )
        }
    })


4、state示例

    class StateDemo extends Component {
        constructor(){
            super();

            this.state = {
                secondsElapsed: 0
            }
        }

        tick(){
            this.setState({ secondsElapsed: this.state.secondsElapsed + 1 });
        }

        componentDidMount(){
            var that = this;
            this.interval = setInterval(function(){
                debugger;
                that.tick();
            }, 1000);
        }

        componentWillUnmount(){
            clearInterval(this.interval);
        }

        render(){
            return (
                &lt;div&gt;目前已经计时: {this.state.secondsElapsed}秒&lt;/div&gt;
            )
        }
    }

    export default StateDemo;


5、this的指向

    class StateDemo extends Component{
        constructor(props){
            super(props);
            this.state = {
                name: &apos;siguagn&apos;
            }
        }

        // 如果onClick=&quot;this.clickSelectBtn&quot; 这么写，this指向的是p, 所以this.setState()报错
        clickSelectBtn(){
            this.setState({name: &apos;lulu&apos;})
        }

        render(){
            return &lt;div&gt;
                &lt;p&gt;{this.state.name}&lt;/p&gt;
                &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;修改&quot; onClick=&quot;this.clickSelectBtn.bind(this)&quot;&gt;&lt;/p&gt;
            &lt;/div&gt;
        }
    }

    解决方法: 

    1、onClick=&quot;this.clickSelectBtn.bind(this)&quot;         // bind()改变this指向

    2、使用箭头函数

        clickSelectBtn = (event) =&gt; {
            this.setState({name: &apos;lulu&apos;})
        }
</code></pre><h4 id="react操作DOM"><a href="#react操作DOM" class="headerlink" title="react操作DOM"></a>react操作DOM</h4><pre><code>两种获取方法

    1、ReactDOM.findDOMNode(this.refs.xxxx);

    2、this.refs.xxx

Example:

    import React, { Component } from &apos;react&apos;;
    import ReactDOM, { findDOMNode } from &apos;react-dom&apos;;
    import $ from &apos;jquery&apos;;

    class RefsDemo extends Component {
        componentDidMount(){

            // findDOMNode()来获取DOM
            let contentA = findDOMNode(this.refs.content);

            // refs直接获取
            let contentB = this.refs.content;

            // jQuery来操作DOM
            console.log($(contentA).html());

            console.log( contentA.innerHTML );
            console.log( contentB.innerHTML );
        }

        render(){
            return(
                &lt;div&gt;
                    &lt;h3&gt;React操作DOM&lt;/h3&gt;
                    &lt;p ref=&quot;content&quot;&gt;这里是DOM元素的内容&lt;/p&gt;        // 这里定义ref访问的名
                &lt;/div&gt;
            )
        }
    }
</code></pre><h4 id="React表单组件操作"><a href="#React表单组件操作" class="headerlink" title="React表单组件操作"></a>React表单组件操作</h4><pre><code>1、react表单组件与html的不同

    1）value、checked: 属性设置值后，用户输入无效

    2) textarea: 的值要设置在value属性

        &lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt;

    3）select: value属性可以是数据，不建使用option的selected属性

        &lt;select multiple={true} value={[&apos;B&apos;, &apos;C&apos;]}&gt;
            &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt;
            &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt;
            &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt;
        &lt;/select&gt;

    4) input/textarea 的 onChange 用户每次输入都会触发（即使不失去焦点）

    5) radio/checkbox/option 点击后触发 onChange
</code></pre><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code>通过mixin可以将组件间共享代码，将两个组件共同的属性、方法存储到mixin对象中

mixin不支持ES6的声明组件方式

ES5写法

    import React from &apos;react&apos;;

    // 抽取出的公用方法
    var SetIntervalMixin = {
        componentWillMount: function() {
            this.intervals = [];
        },
        setInterval: function() {
            this.intervals.push(setInterval.apply(null, arguments));
        },
        componentWillUnmount: function() {
            this.intervals.forEach(clearInterval);
        }
    };

    var MixinDemo = React.createClass({

        // 这里加载mixin
        mixins: [SetIntervalMixin],

        getInitialState: function() {
            return {seconds: 0};
        },

        componentDidMount: function() {
            // Call a method on the mixin
            this.setInterval(this.tick, 1000);
        },

        tick: function() {
            this.setState({seconds: this.state.seconds + 1});
        },

        render: function() {
            return (
                &lt;p&gt;
                    计时器已经运行了:  {this.state.seconds} 秒.
                &lt;/p&gt;
            );
        }
    });

    export default MixinDemo;
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>一、创建组件时:

    1、getDefaultProps - 设置默认的props

    2、getInitialState() - 定义state，【因内受】

    3、componentWillMount() - 组件挂载前，只调用一次，在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次

    4、render() - 创建虚拟dom，进行diff算法，更新dom树

    5、componentDidMount() - 组件渲染后，可以使用refs操作获取或操作DOM节点

二、更新组件时:

    1、componentWillReceiveProps() - props是父组件传递给子组件的，父组件发生render的时候子组件就会调用componentWillReceiveProps(不管props有没有更新)  receive[rɪˈsiv]

    2、shouldComponentUpdata(nextProps, nextState) - react性能环节，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件，前后两个props、state相同返回false阻止更新，不需要在创建新的dom树在进行diff算法，默认为true

    3、componentWillUpdata(nextProps, nextState) - shouldComponentUpdata为true时调用

    4、render() - 

    5、componentDidUpdate() - 

三、卸载组件

    1、componentWillUnmount() - 卸载前调用

https://www.jianshu.com/p/4784216b8194
</code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code>一、react.js

    React.Children: Object
    React.Component: ReactComponent(props, context, updater)
    React.DOM: Object
    React.PropTypes: Object
    React.cloneElement: (element, props, children)
    React.createClass: (spec)
    React.createElement: (type, props, children)
    React.createFactory: (type)
    React.createMixin: (mixin)
    React.isValidElement: (object)

二、Component

    this.context: Object              // DOM元素的内容
    this.props: Object              // 获取props对象
    this.refs: Object                // 通过ref获取指定的DOM
    this.state: Object                // 获取state对象
    this.setState: Object            // 设置state值

三、react-dom.js

    ReactDOM.findDOMNode: findDOMNode(componentOrElement)         // 获取DOM
    ReactDOM.render: ()                                    // 返回组件树
    ReactDOM.unmountComponentAtNode: (container)

四、react-dom-server.js

    ReactDOMServer.renderToString
    ReactDOMServer.renderToStaticMarkup
</code></pre><h4 id="PropTypes验证"><a href="#PropTypes验证" class="headerlink" title="PropTypes验证"></a>PropTypes验证</h4><pre><code>React.PropTypes 提供很多验证器来验证传入数据的有效性

当向 props 传入无效数据时，JavaScript 控制台会抛出警告。注意为了性能考虑，只在开发环境验证 propTypes。下面用例子来说明不同验证器的区别: 

&lt;script type=&quot;text/babel&quot;&gt;
    var data = 123;

    var MyTitle = React.createClass({
        propTypes: {
            title: React.PropTypes.string.isRequired
        },

        render: function() {
            return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
        }
    });

    ReactDOM.render(
        &lt;MyTitle title={data} /&gt;,
        document.querySelector(&apos;#app&apos;)
    );
&lt;/script&gt;

React.createClass({
    propTypes: {

        // 可以声明 prop 为指定的 JS 基本类型。默认
        // 情况下，这些 prop 都是可传可不传的。
        optionalArray: React.PropTypes.array,
        optionalBool: React.PropTypes.bool,
        optionalFunc: React.PropTypes.func,
        optionalNumber: React.PropTypes.number,
        optionalObject: React.PropTypes.object,
        optionalString: React.PropTypes.string,

        // 所有可以被渲染的对象: 数字，
        // 字符串，DOM 元素或包含这些类型的数组。
        optionalNode: React.PropTypes.node,

        // React 元素
        optionalElement: React.PropTypes.element,

        // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
        optionalMessage: React.PropTypes.instanceOf(Message),

        // 用 enum 来限制 prop 只接受指定的值。
        optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),

        // 指定的多个对象类型中的一个
        optionalUnion: React.PropTypes.oneOfType([
            React.PropTypes.string,
            React.PropTypes.number,
            React.PropTypes.instanceOf(Message)
        ]),

        // 指定类型组成的数组
        optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

        // 指定类型的属性构成的对象
        optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

        // 特定形状参数的对象
        optionalObjectWithShape: React.PropTypes.shape({
            color: React.PropTypes.string,
            fontSize: React.PropTypes.number
        }),

        // 以后任意类型加上 `isRequired` 来使 prop 不可空。
        requiredFunc: React.PropTypes.func.isRequired,

        // 不可空的任意类型
        requiredAny: React.PropTypes.any.isRequired,

        // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接
        // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
        customProp: function(props, propName, componentName) {
            if (!/matchme/.test(props[propName])) {
                return new Error(&apos;Validation failed!&apos;);
            }
        }
    }
});
</code></pre><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><pre><code>1、defaultValue 与 value 的区别

    &lt;input type=&quot;text&quot; Value={this.state.inputValue} /&gt;

    如果使用 value来绑定state的值，输入值时不会被改变

    使用 defaultValue 值会被改变

    var FromApp = React.createClass({
        getInitialState: function(){
            return {
                inputValue: &apos;input value&apos;
            }
        },

        handleSubmit: function(e){
            this.refs[&apos;goodInput&apos;]
        },

        render: function(){
            return (
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;input type=&quot;text&quot; defaultValue={this.state.inputValue} ref=&quot;goodInput&quot; /&gt;
                &lt;/form&gt;
            )
        }
    })
</code></pre><h4 id="React构建配置"><a href="#React构建配置" class="headerlink" title="React构建配置"></a>React构建配置</h4><pre><code>使用的JSX和ES6所以需要转换，通过webpack + babel插件

1、$ npm install webpack

2、安装插件

    $ npm install babel --save-dev

    $ npm install babel-loader --save-dev

    $ npm install babel-core --save-dev

    $ npm install babel-preset-es2015 --save-dev            # ES6转ES5

    $ npm install babel-preset-react --save-dev            # JSX转码

3、webpack.config.js

    var path = require(&apos;path&apos;);
    module.exports = {
        entry: &apos;./src/app.js&apos;,
        output: {
            path: path.join(__dirname, &apos;/dist&apos;),
            filename: &apos;app.min.js&apos;
        },
        resolve: {
            extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]
        },
        module: {
            loaders:  [
                {
                    include: /\.js?$/,
                    exclude: /node_modules/,
                    loader: &apos;babel&apos;,
                    query: {
                        presets: [&apos;react&apos;, &apos;es2015&apos;]
                    }
                  }
            ]
        }
    }

4、使用gulp来进行分别打包
</code></pre><h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><pre><code>当组件更新时候，react会创建一个新的虚拟dom树并会和之前的dom树进行比较，这个过程就用到了diff算法
</code></pre><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><pre><code>https://github.com/enaqx/awesome-react#boilerplates

1、路由 - react-router

2、布局 - react-blocks     http://whoisandie.github.io/react-blocks/

3、拖拽 - react-dnd        https://github.com/react-dnd/react-dnd

4、代码编辑器 - react-codemirror        https://github.com/JedWatson/react-codemirror

5、富文本编辑器 - react-quill react-draft-wysiwyg        https://github.com/jpuri/react-draft-wysiwyg

6、拾色器 - rc-color-picker、react-color        https://github.com/react-component/color-picker        http://casesandberg.github.io/react-color/

7、响应式 - react-responsive、react-media        https://github.com/contra/react-responsive        https://github.com/ReactTraining/react-media

8、复制到剪贴板 - react-copy-to-clipboard       https://github.com/nkbt/react-copy-to-clipboard

9、管理 document head - react-helmet          https://github.com/nfl/react-helmet

10、Font Awesome 图标 - react-fa        https://github.com/andreypopp/react-fa

11、二维码 -  qrcode.react         https://ant.design/docs/react/recommendation-cn

12、不在使用className - styled-components     

    http://www.alloyteam.com/2017/05/guide-styled-components/
    https://github.com/styled-components/styled-components

13、react写动画效果 - css3transform-react

    $ npm install css3transform-react
    http://www.alloyteam.com/2016/12/react-animations-difficult-to-write-try-react-transformjs/
</code></pre><p>| 参考资料<br>| <a href="https://doc.react-china.org/docs/hello-world.html" target="_blank" rel="noopener">https://doc.react-china.org/docs/hello-world.html</a>            中文官网<br>| <a href="https://github.com/BruceCham/react-cli" target="_blank" rel="noopener">https://github.com/BruceCham/react-cli</a>            // 全家桶<br>| <a href="https://guoyongfeng.github.io/book/" target="_blank" rel="noopener">https://guoyongfeng.github.io/book/</a><br>| <a href="http://uprogrammer.cn/react-tutorial-cn/" target="_blank" rel="noopener">http://uprogrammer.cn/react-tutorial-cn/</a><br>| <a href="http://huziketang.com/books/react/lesson1" target="_blank" rel="noopener">http://huziketang.com/books/react/lesson1</a><br>|<br>| <a href="https://github.com/hyy1115/react-redux-webpack2" target="_blank" rel="noopener">https://github.com/hyy1115/react-redux-webpack2</a><br>| <a href="https://github.com/zhbhun/react-learning/tree/master/boilerplate" target="_blank" rel="noopener">https://github.com/zhbhun/react-learning/tree/master/boilerplate</a><br>| <a href="http://blog.csdn.net/u013063153/article/details/52497271" target="_blank" rel="noopener">http://blog.csdn.net/u013063153/article/details/52497271</a>      事件<br>| <a href="https://github.com/gaearon/babel-plugin-react-transform#transforms" target="_blank" rel="noopener">https://github.com/gaearon/babel-plugin-react-transform#transforms</a>   babel-plugin-react-transform 相关插件<br>| <a href="http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/using-react-to-write-a-simple-activity-pages-design-of-operating-system-article/</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/24/React(之二)组件类/">React（之二）组件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/24/React(之二)组件类/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-24T03:06:16.000Z" itemprop="datePublished">2016-12-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React/">React</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| Router、Route<br>| Link、Links  router的导航组件，用来切换路由<br>| browserHistory、hashHistory<br>| activeStyle、activeClassName  路由设置样式<br>| IndexRoute<br>| component、components<br>| query<br>| params 变量<br>| Redirect<br>| setRouteLeaveHook</p>
<h4 id="react-router安装"><a href="#react-router安装" class="headerlink" title="react-router安装"></a>react-router安装</h4><pre><code>$ npm install react-router history --save        // 安装

import React, { Component } from &apos;react&apos;;
import { Router, Route, hashHistory, Link } from &apos;react-router&apos;;
</code></pre><h4 id="Router和Route"><a href="#Router和Route" class="headerlink" title="Router和Route"></a>Router和Route</h4><pre><code>Router是一个容器，路由要通过Route组件定义

import { Router, Route, hashHistory } from &apos;react-router&apos;;
render((
    &lt;Router history={hashHistory}&gt;
        &lt;Route path=&quot;/&quot; component={App}/&gt;
    &lt;/Router&gt;
), document.getElementById(&apos;app&apos;));
</code></pre><h4 id="browserHistory-和-hashHistory"><a href="#browserHistory-和-hashHistory" class="headerlink" title="browserHistory 和 hashHistory"></a>browserHistory 和 hashHistory</h4><pre><code>import React, { Component } from &apos;react&apos;;
import { Router, Route, browserHistory, Link } from &apos;react-router&apos;;

class App extends Component {
    render() {
        return (
            &lt;Router history={browserHistory}&gt;            // 这里要加
                &lt;Route path=&quot;/&quot; component={Home} /&gt;
                &lt;Route path=&quot;/about&quot; component={About} /&gt;
                &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
            &lt;/Router&gt;
        );
    }
}

二者区别:

    hashHistory: 带有&apos;#/&apos; http://localhost:5001/#/About

    browserHistory: 不会带有&apos;#/&apos; http://localhost:5001/List   生产环境使用  --history-api-fallback

    注意:

    使用browserHistory，正常点击路由切换没有问题，但是重新刷新URL就会报找不到路由，
    需要在webpack-dev-server启动的时候需要加上参数--history-api-fallback。

    或者在webpack.config.js配置中 

        devServer: {
            port: 5000,                 // 端口
            contentBase: &apos;build&apos;,       // 内容目录
            hot: true,                    // 热刷新
            inline: true,
            historyApiFallBack: true,   // react路由历史管理使用
        }
</code></pre><h4 id="Link、Links、IndexLink"><a href="#Link、Links、IndexLink" class="headerlink" title="Link、Links、IndexLink"></a>Link、Links、IndexLink</h4><pre><code>是router的导航组件，用来切换路由

1、Example:

    import React, { Component } from &apos;react&apos;;
    import { Router, Route, hashHistory, Link } from &apos;react-router&apos;;

    const Home = () =&gt; &lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const About = () =&gt; &lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const Contact = () =&gt; &lt;div&gt;&lt;h1&gt;Contact&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;

    // 相当于一个导航将Link包装成一个
    const Links = () =&gt;
        &lt;nav&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
            &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;
            &lt;Link to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt;
        &lt;/nav&gt;

    class App extends Component {
        render() {
            return (
                &lt;Router history={hashHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/about&quot; component={About} /&gt;
                    &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
                &lt;/Router&gt;
            );
        }
    }

    export default App;

2、IndexLink

    如果是根路由&quot;/&quot;，不要使用link组件，需要使用IndexLink，因为如果是根路由activeStyle和activeClassName都会失效
</code></pre><h4 id="子路由、IndexRoute-路由初始的默认"><a href="#子路由、IndexRoute-路由初始的默认" class="headerlink" title="子路由、IndexRoute 路由初始的默认"></a>子路由、IndexRoute 路由初始的默认</h4><pre><code>一、子路由的显示

    在加载子路由的组件中的位置使用 {this.props.children}, 如果子路由没有设置IndexRoute默认路由 this.props.children返回undefined

    let IndexPage = funciton(){
        return (
            &lt;div&gt;
                &lt;div className=&quot;side&quot;&gt;&lt;/side&gt;
                &lt;div className=&quot;content&quot;&gt;
                    {this.props.children}
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    home页面加载显示子路由方式:

        vue使用的是&lt;router-view&gt;&lt;/router-view&gt;显示

        react 显示子路由  {this.props.children}


二、IndexRouter

    import { Router, Route, browserHistory, Link, IndexRoute } from &apos;react-router&apos;;
    class RouterConfig extends Component {
        render() {
            return (
                &lt;Router history={browserHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home}&gt;            // localhost:8080/        调用的是Home
                        &lt;IndexRoute component={About} /&gt;         // 子路由，默认路由
                        &lt;Route path=&quot;contact&quot; component={Contact} /&gt;
                    &lt;/Route&gt;
                &lt;/Router&gt;
            );
        }
    }
    export defualt RouterConfig;
</code></pre><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><pre><code>一、路由变量

    定义变量: &lt;Route path=&quot;/(:msg)&quot; component={Message} /&gt;

    获取变量: props.params 来获取

    &lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan
    &lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan
    &lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg

    Example:

        import React, { Component } from &apos;react&apos;;
        import { Router, Route, hashHistory, Link, IndexRoute } from &apos;react-router&apos;;

        class Message extends Component {
            constructor(props){
                super();
                debugger
                console.log(props);
            }

            render(props){
                return (
                    &lt;div&gt;
                        // 这里this.props.params.msg 接收的是to的名字

                        &lt;h1&gt;{this.props.params.msg || &apos;hello&apos;}&lt;/h1&gt;
                        &lt;Links /&gt;
                    &lt;/div&gt;
                )
            }
        }

        const Links = () =&gt;
            &lt;nav&gt;
                &lt;Link to=&quot;/&quot;&gt;Hello&lt;/Link&gt;
                &lt;Link to=&quot;/yong&quot;&gt;Yong&lt;/Link&gt;
                &lt;Link to=&quot;/feng&quot;&gt;Feng&lt;/Link&gt;
            &lt;/nav&gt;

        class ParamsRoute extends Component {
            render() {
                return (
                    &lt;Router history={hashHistory}&gt;
                        &lt;Route path=&quot;/(:msg)&quot; component={Message} /&gt;
                    &lt;/Router&gt;
                );
            }
        }
        export default ParamsRoute;


二、query: 获取URL中的参数

    1、获取参数

        http://localhost:8080/#/?message=ssssss

        const Page = (props) =&gt;
            &lt;div&gt;
                &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;            // props.location.query.message输出 ssssss
            &lt;/div&gt;


    2、请求时带参数

        const Page = (props) =&gt;
            &lt;div&gt;
                &lt;h1&gt;{props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;
            &lt;/div&gt;

        const Links = () =&gt;
            &lt;nav&gt;
                &lt;Link to={{ pathname: "/", query: {message: "ssssss"} }} /&gt;         
            &lt;/nav&gt;


    Example:

        import React, {Component} from &apos;react&apos;
        import { Router, Route, Link, browserHistory } from &apos;react-router&apos;

        class Page extends Component {
            constructor(props){
                super();
                console.log(props);
            }
            render(){
                return (
                    &lt;div&gt;
                        &lt;h1&gt;{this.props.location.query.message || &apos;Hello&apos;}&lt;/h1&gt;      // url带有message参数就输出, 否则输出Hello
                    &lt;/div&gt;
                )
            }
        }

        class QueryRoute extends Component {
            render() {
                return (
                    &lt;Router history={browserHistory}&gt;
                        &lt;Route path=&quot;/(message)&quot; component={Page} /&gt;        // http://localhost:5001/?message=12312312
                    &lt;/Router&gt;
                );
            }
        }
        export default QueryRoute;
</code></pre><h4 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h4><pre><code>return false  可以取消此次跳转

方法一、onEnter、onLeave事件绑定到Route上

    const backLogin = (nextState, replace) =&gt; {
        console.log(nextState)
        debugger;
    }

    class App extends Component {
        render() {
            return (
                &lt;Router history={hashHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/about&quot; component={About} /&gt;
                    &lt;Route path=&quot;/contact&quot; component={Contact} onEnter={backLogin} /&gt;
                    &lt;Route path=&quot;*&quot; onEnter={backLogin} /&gt;
                &lt;/Router&gt;
            );
        }
    }


方法二、setRouteLeaveHook(单条路由， 要处理的函数) 路由钩子，切换路由时操作，可以用于对登录判断进行操作

    import React, { Component, PropTypes } from &apos;react&apos;;
    import { Router, Route, hashHistory, Link } from &apos;react-router&apos;;

    class Home extends Component {
        componentWillMount(){

            console.log(this.context);

            this.context.router.setRouteLeaveHook(
                this.props.route,
                this.routerWillLeave
            )
        }

        routerWillLeave( nextLocation ){
            alert(`页面即将从Home切换到${nextLocation.pathname}`);
        }

        render(){
            return &lt;div&gt;
                &lt;h1&gt;Home&lt;/h1&gt;
                &lt;Links /&gt;
            &lt;/div&gt;
        }
    }

    Home.contextTypes = {
        router: PropTypes.object.isRequired
    };
    const Contact = () =&gt; &lt;div&gt;&lt;h1&gt;Contact&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const Links = () =&gt; {
        &lt;nav&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
            &lt;Link to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt;
        &lt;/nav&gt;
    }

    class SetRouteLeaveHookDemo extends Component {
        render() {
            return (
                &lt;Router history={hashHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
                &lt;/Router&gt;
            );
        }
    }
    export default SetRouteLeaveHookDemo;    
</code></pre><h4 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向:"></a>Redirect重定向:</h4><pre><code>如果一个路由不存在就通过设置Redirect来跳转到指定的路由，用于404的跳转 定义&lt;Redirect from=&quot;/contact&quot; to=&quot;/contact-us&quot; /&gt;

一、Redirect

    import React, { Component } from &apos;react&apos;;
    import { Router, Route, browserHistory, Link, Redirect } from &apos;react-router&apos;;

    const Home = () =&gt; &lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
    const Links = () =&gt; {
        &lt;nav&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
        &lt;/nav&gt;
    }

    class RedirectRoute extends Component {
        render() {
            return (
                &lt;Router history={browserHistory}&gt;
                    &lt;Route path=&quot;/&quot; component={Home} /&gt;
                    &lt;Redirect from=&quot;*&quot; to=&quot;/&quot; /&gt;
                &lt;/Router&gt;
            );
        }
    }
    export default RedirectRoute;


2、IndexRedirect: 用于访问根路由重定向到某个子路由 ＜IndexRedirect to=&quot;/welcome&quot; /&gt;

    &lt;Route path=&quot;/&quot; component={App}&gt;
        ＜IndexRedirect to=&quot;/welcome&quot; /&gt;
        &lt;Route path=&quot;welcome&quot; component={Welcome} /&gt;
        &lt;Route path=&quot;about&quot; component={About} /&gt;
    &lt;/Route&gt;
</code></pre><h4 id="js跳转路由"><a href="#js跳转路由" class="headerlink" title="js跳转路由"></a>js跳转路由</h4><pre><code>方法一、browserHistory.push(要路转路由)

方法二、context对象

    export default React.createClass({

        // ask for `router` from context
        contextTypes: {
            router: React.PropTypes.object
        },

        handleSubmit(event) {
            // ...
            this.context.router.push(path)
        }
    })
</code></pre><h4 id="activeStyle-activeClassName"><a href="#activeStyle-activeClassName" class="headerlink" title="activeStyle, activeClassName"></a>activeStyle, activeClassName</h4><pre><code>当前路由被点击处于触发显示状态的时候，使用activeStyle来设置颜色，atciveClassName来设置class的名

import React, { Component } from &apos;react&apos;;
import { Router, Route, browserHistory, Link } from &apos;react-router&apos;;

const Home = () =&gt; &lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
const About = () =&gt; &lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;
const Contact = () =&gt; &lt;div&gt;&lt;h1&gt;Contact&lt;/h1&gt;&lt;Links /&gt;&lt;/div&gt;;

const Links = () =&gt;
    &lt;nav&gt;
        &lt;Link activeStyle={{color: 'red'}} to=&quot;/&quot;&gt;Home&lt;/Link&gt;
        &lt;Link activeStyle={{color: 'red'}} to=&quot;/about&quot;&gt;About&lt;/Link&gt;
        &lt;Link activeStyle={{color: 'red'}} to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt;
    &lt;/nav&gt;

// className的写法 &lt;Link activeClassName=&quot;active&quot; to=&quot;/&quot;&gt;Home&lt;/Link&gt;

class App extends Component {
    render() {
        return (
            &lt;Router history={browserHistory}&gt;
                &lt;Route path=&quot;/&quot; component={Home} /&gt;
                &lt;Route path=&quot;/about&quot; component={About} /&gt;
                &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;
            &lt;/Router&gt;
        );
    }
}

export default App;
</code></pre><h4 id="component、components"><a href="#component、components" class="headerlink" title="component、components"></a>component、components</h4><pre><code>component来指定一个路由对应加载的组件

// 可以加载两个组件，并要指定组件中对应
&lt;Route Componets={{ header: AppHeader, body: AppBody }}&gt;

import React, { Component } from &apos;react&apos;;
import { Router, Route, hashHistory, Link, IndexRoute } from &apos;react-router&apos;;

const HomeHeader = () =&gt; &lt;h1&gt;HomeHeader&lt;/h1&gt;
const HomeBody = () =&gt; &lt;h1&gt;HomeBody&lt;/h1&gt;
const AboutHeader = () =&gt; &lt;h1&gt;AboutHeader&lt;/h1&gt;
const AboutBody = () =&gt; &lt;h1&gt;AboutBody&lt;/h1&gt;

const Container = (props) =&gt;
    &lt;div&gt;
        {props.header}
        {props.body}
        &lt;Links /&gt;
    &lt;/div&gt;

const Links = () =&gt;
    &lt;nav&gt;
        &lt;Link to=&quot;/&quot;&gt;Hello&lt;/Link&gt;
        &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;
    &lt;/nav&gt;

class App extends Component {
    render() {
        return (
            &lt;Router history={hashHistory}&gt;
                &lt;Route path=&quot;/&quot; component={Container}&gt;
                    &lt;IndexRoute components={{ header:HomeHeader, body:HomeBody }} /&gt;
                    &lt;Route path=&quot;about&quot; components={{ header:AboutHeader, body:AboutBody }} /&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        );
    }
}

export default App;
</code></pre><h4 id="react-router-redux路由"><a href="#react-router-redux路由" class="headerlink" title="react-router-redux路由"></a>react-router-redux路由</h4><pre><code>保持路由与应用状态（state）同步

$ npm install --save react-router-redux        // 安装

原理：允许使用react router库中的api，使用redux一样去管理应用状态state

https://www.jianshu.com/p/bccca5bb6338
http://blog.csdn.net/isaisai/article/details/78086913
https://segmentfault.com/a/1190000007862103
</code></pre><h4 id="dva-react-Ant-蚂蚁金服脚手架"><a href="#dva-react-Ant-蚂蚁金服脚手架" class="headerlink" title="dva + react + Ant 蚂蚁金服脚手架"></a>dva + react + Ant 蚂蚁金服脚手架</h4><pre><code>单独加载ant UI框架，也可以使用dva-cli蚂蚁提供的脚手架，支持IE9及以上版本

一、单独添加ant  

    $ cnpm i antd --save

    import &apos;antd/dist/antd.css&apos;;         // 引入样式
    import { DatePicker } from &apos;antd&apos;;    // 这种方法的引用必须要添加babel-plugin-import的按需加载组件
    ReactDOM.render(&lt;DatePicker /&gt;, mountNode);            

二、按需加载插件 babel-plugin-import

    $ cnpm i babel-plugin-import --save

    .babelrc添加参数:
    {
        &quot;plugins&quot;: [
            [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }] // `style: true` 会加载 less 文件
        ]
    }

三、dva-cli安装

    $ cnpm i dva-cli    

    $ dva new [项目名] &amp;&amp; cd [项目名]        // 创建项目

    $ cnpm install antd babel-plugin-import --save        // 安装 ant 和 babel插件（用来按需加载 antd 的脚本和样式的）

        .webpackrc文件加参数
        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ]  
        }

四、运行

    $ npm start         // 生产环境运行

    $ npm run build        // 打包项目，发布线上环境在Dist目录下生成静态文件，js、css压缩

五、redux的使用

    有两个目录，models和components, model来定义state和action的，components来编写组件

    dva提供conect方法，将model和component串联起来

    import { connect } from &apos;dva&apos;;

    const Products = ({ dispatch, products }) =&gt; { ... }
    export default connect(({ products }) =&gt; ({
        products,
    }))(Products);

六、配置

    1、 .roadhogrc.mock.js  用于mock数据的配置

        export default {
            // 支持值为 Object 和 Array
            &apos;GET /api/users&apos;: { users: [1,2] },

            // GET POST 可省略
            &apos;/api/users/1&apos;: { id: 1 },

            // 支持自定义函数，API 参考 express@4
            &apos;POST /api/users/create&apos;: (req, res) =&gt; { res.end(&apos;OK&apos;); },
        };

    2、.webpackrc  

        {
            &quot;extraBabelPlugins&quot;: [
                [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]
            ],
            &quot;entry&quot;: &quot;src/index.js&quot;,        // 可以配置webpack的选项，参数见面下roadhog的文档连接
            &quot;proxy&quot;: {                        // 设置代理
                &quot;/api&quot;: {
                    &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;,
                    &quot;changeOrigin&quot;: true,
                    &quot;pathRewrite&quot;: { &quot;^/api&quot; : &quot;&quot; }
                }
            }
        }

    3、设置端口

        默认是8000，可以在package.json中设置
        &quot;scripts&quot;: {
               &quot;start&quot;: &quot;PORT=3000 roadhog server&quot;,        // windowns设置 set PORT=3000&amp;&amp;roadhog dev
        }

    4、public目录会在build的copy到dist目录下，存放一些静态文件

https://github.com/sorrycc/blog/issues/18            // dva
https://github.com/sorrycc/roadhog/blob/master/README_zh-cn.md    // roadhog


七、fatch请求

    dva-cli中utils目录中request.js中定义了一个通过fatch来发ajax请求的方法

    业务中调用:
    function IndexPage() {
        var getUser = () =&gt; {
            Request(&apos;/api/posts&apos;, {method: &apos;GET&apos;})
            .then((data)=&gt;{
                debugger;
            })
        }
        getUser()

        return (
            &lt;div className={styles.normal}&gt;
                ...
            &lt;/div&gt;
        );
    }
    exports default IndexPage;
</code></pre><h4 id="ant内还介绍了另一个脚手架-create-react-app"><a href="#ant内还介绍了另一个脚手架-create-react-app" class="headerlink" title="ant内还介绍了另一个脚手架 create-react-app"></a>ant内还介绍了另一个脚手架 create-react-app</h4><pre><code>https://ant.design/docs/react/use-with-create-react-app-cn
</code></pre><p>| <a href="http://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">http://react-guide.github.io/react-router-cn/</a>             React-router 中文网<br>| <a href="https://github.com/reactjs/react-router-redux" target="_blank" rel="noopener">https://github.com/reactjs/react-router-redux</a><br>| <a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</a><br>| <a href="https://github.com/react-guide/react-router-cn" target="_blank" rel="noopener">https://github.com/react-guide/react-router-cn</a><br>| <a href="https://github.com/ReactTraining/react-router/tree/master/examples" target="_blank" rel="noopener">https://github.com/ReactTraining/react-router/tree/master/examples</a></p>

        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
