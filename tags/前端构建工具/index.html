<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Tag: 前端构建工具 | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端积累/">移动端积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/22/babel/">Babel</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/22/babel/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-22T02:10:21.000Z" itemprop="datePublished">2016-12-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>涉及知识点</p>
<p>babel安装<br>ES6转ES5 babel-preset-es2015<br>jsx文件的转换 npm i babel-preset-react<br>.babelrc 文件配置 presets来解析<br>加UMD模块，可以自带模块代码</p>
</blockquote>
<h4 id="一、babel"><a href="#一、babel" class="headerlink" title="一、babel"></a>一、babel</h4><pre><code>1、安装：

    npm install babel-cli

    包括了: babel、babel-node、babel-core、babel-register


        1) babel-register模块改写require命令，为它加上一个钩子。require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。

            npm install --save-dev babel-register

            // 先加载babel-register，这样就会不在对index.js进行转码了
            require(&quot;babel-register&quot;);
            require(&quot;./index.js&quot;);

        2) 浏览器环境

            下载babel-core: npm install babel-core@5

            &lt;!-- 引用browser.js --&gt;
            &lt;script src=&quot;node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt;
            &lt;!-- type值为text/babel --&gt;
            &lt;script type=&quot;text/babel&quot;&gt;
                // 这里写es6的代码
            &lt;/script&gt;


2、    babel用处

    1）将ES6转成ES5代码在安装 babel-preset-es2015

        npm i babel-preset-es2015 --save-dev

        需要创建一个 .babelrc 文件
        {
              &quot;presets&quot;: [&quot;es2015&quot;]
        }

    2）babel-polyfill: 可以在在浏览器直接解析    npm i babel-polyfill --save-dev

    3）React的JSX代码: npm i babel-preset-react --save-dev

        对.babelrc文件配置
        {
              &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
        }


2、执行编译

    # babel main.js     // 将文件直接编译

    # babel main.js --out-file  main-component.js     // 将main.js编译成一个main-component.js, 缩定--out-file 写成 -o

    # babel src --out-dir build   // 将 src目录下的所有文件编译到build目录下，--out-dir简写 -d

    # babel --watch main.js --out-file main-component.js  --source-maps  // --watch 侦听文件的变化，--source-maps 会在文件打出文件的目录, 简写 -w

    # babel src --out-dir lib  // 编译目录，src目录下的所有文件进行编辑并放到lib文件夹中


3、浏览器上直接编译 browser.js

    可以直接转换，不需要执行编译命令

    1、加载需要文件
        babel-core/browser.js 
        babel-core/browser-polyfill.js     // 修补浏览器工具的，浏览器不支持的时候需要它

    2、&lt;script&gt;调用
        type中必须写成 &apos;text/babel&apos;
        &lt;script src=&quot;main.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;


4、brower-sync 创建一个server环境

    命令：brower-sync start --server
</code></pre><h4 id="二、使用模块plugins"><a href="#二、使用模块plugins" class="headerlink" title="二、使用模块plugins"></a>二、使用模块plugins</h4><pre><code>1、对模块的处理

UMD模块，可以将代码转成模块化的模式

npm install --save-dev babel-plugin-transform-es2015-modules-umd

.babelrc文件
{
    &quot;plugins&quot;: [&quot;transform-es2015-modules-umd&quot;]
}

index.js:

    export default 42;

output:

    (function (global, factory) {
        if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
            define([&quot;exports&quot;], factory);
        } 
        else if (typeof exports !== &quot;undefined&quot;) {
            factory(exports);
        } 
        else {
            var mod = {
                exports: {}
            };
            factory(mod.exports);
            global.actual = mod.exports;
        }
    })(this, function (exports) {
        &quot;use strict&quot;;

        Object.defineProperty(exports, &quot;__esModule&quot;, {
            value: true
        });

        exports.default = 42;
    });
</code></pre><h4 id="二、Balel与Gulp结合"><a href="#二、Balel与Gulp结合" class="headerlink" title="二、Balel与Gulp结合"></a>二、Balel与Gulp结合</h4><pre><code>下载gulp和gulp-bable包

npm i gulp gulp-babel --save

gulpFile:

    var gulp = require(&apos;gulp&apos;);
    var babel = require(&apos;gulp-babel&apos;);

    gulp.task(&apos;babel&apos;, function(){
        return gulp.src(&apos;./src/*.js&apos;)
            .pipe(babel())
            .pipe(gulp.dest(&apos;build&apos;))
    })

    gulp.task(&apos;default&apos;,[&apos;babel&apos;]);
</code></pre><h4 id="三、Babel与Webpack结合"><a href="#三、Babel与Webpack结合" class="headerlink" title="三、Babel与Webpack结合"></a>三、Babel与Webpack结合</h4><pre><code>下载webpack和babel需要的包

npm install babel-loader babel-core babel-preset-es2015 webpack --save-dev

webpack.config.js:

    var webpack = require(&apos;webpack&apos;);
    var path = require(&apos;path&apos;);

    module.exports = {

        /* 页面入口 - 单入口文件 */
        entry: {
            index : &apos;./src/js/webpackPackMain.js&apos;          // 单入口文件
        },

        output: {
            path: &apos;./dist/js/&apos;,
            filename: &apos;[name].min.js?[hash]&apos;            // [hash] 将文件输出后加一个hash值
        },

        //加载器配置
        module: {
            loaders: [
                &lt;!-- { test: /\.css$/, loader: &apos;style-loader!css-loader&apos;},
                { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},
                { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;}, --&gt;

                // es6转es5
                {
                    test: /\.js$/,
                    exclude: /(node_modules|bower_components)/,
                    loader: &apos;babel-loader&apos;,
                    query: {
                        presets: [&apos;es2015&apos;]
                    }
                }
            ]
        }
    };
</code></pre><h4 id="四、相关插件"><a href="#四、相关插件" class="headerlink" title="四、相关插件"></a>四、相关插件</h4><pre><code>babel-preset-es2015     将ES6编译成ES5的代码

babel-preset-react        用于React中JSX语法的转码 不需要使用jsx-loader

{
    &quot;presets&quot;: [
        &quot;es2015&quot;,
        &quot;react&quot;
    ],
    &quot;plugins&quot;: []
}
</code></pre><h4 id="五、babel-preset-stage-x"><a href="#五、babel-preset-stage-x" class="headerlink" title="五、babel-preset-stage-x"></a>五、babel-preset-stage-x</h4><pre><code>http://www.cnblogs.com/chris-oil/p/5717544.html

用于ES7的提案

这个流程分为 5（0－4）个阶段。 随着提案得到越多的关注就越有可能被标准采纳，于是他们就继续通过各个阶段，最终在阶段 4 被标准正式采纳。

以下是4 个不同阶段的（打包的）预设：

babel-preset-stage-0
babel-preset-stage-1
babel-preset-stage-2
babel-preset-stage-3

注意 stage-4 预设是不存在的因为它就是上面的 es2015 预设。

以上每种预设都依赖于紧随的后期阶段预设。例如，babel-preset-stage-1 依赖 babel-preset-stage-2，后者又依赖 babel-preset-stage-3。.

Stage 0：

    Function Bind Syntax：函数的绑定运算符
    String.prototype.at：字符串的静态方法at

Stage 1：

    Class and Property Decorators：Class的修饰器
    Class Property Declarations：Class的属性声明
    Additional export-from Statements：export的写法改进
    String.prototype.{trimLeft,trimRight}：字符串删除头尾空格的方法

Stage 2：

    Rest/Spread Properties：对象的Rest参数和扩展运算符

Stage 3

    SIMD API：“单指令，多数据”命令集
    Async Functions：async函数
    Object.values/Object.entries：Object的静态方法values()和entries()
    String padding：字符串长度补全
    Trailing commas in function parameter lists and calls：函数参数的尾逗号
    Object.getOwnPropertyDescriptors：Object的静态方法getOwnPropertyDescriptors

Stage 4：

    Array.prototype.includes：数组实例的includes方法
    Exponentiation Operator：指数运算符

使用的时候只需要安装你想要的阶段就可以了： $ npm install --save-dev babel-preset-stage-2

添加 .babelrc 配置文件。
  {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;react&quot;,
      &quot;stage-2&quot;
    ],
    &quot;plugins&quot;: []
  }
</code></pre><blockquote>
<p>参考资料</p>
<p><a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a>            // 官网</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/11/Gulp/">Gulp</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/11/Gulp/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-11T10:39:38.000Z" itemprop="datePublished">2016-11-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="一、gulp"><a href="#一、gulp" class="headerlink" title="一、gulp"></a>一、gulp</h4><pre><code>可以自动化执行任务的工具，主要用于生产环境和开发环境的文件处理

Gulp是一个新的基于流的管道式构建系统，需要很少的配置并且更快

主要作用:

    1、多个js或css文件合并、压缩

    2、Sass或Less的编译

    3、图像的压缩

    3、实时刷新页面的本地服务器
</code></pre><h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><pre><code>1、先安装node.js

2、# npm install -g gulp     通过npm 安装Gulp

3、# npm init                  创建package.json 项目描述文件

4、npm install gulp --save-dev           将gulp作为项目的开发依赖(只在开发时用，不会发布到线上)
</code></pre><h4 id="三、gulp-执行命令"><a href="#三、gulp-执行命令" class="headerlink" title="三、gulp 执行命令"></a>三、gulp 执行命令</h4><pre><code>-v 或 --version 会显示全局和项目本地所安装的 gulp 版本号

--gulpfile 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录

--cwd dirpath 手动指定 CWD。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径

-T 或 --tasks 会显示所指定 gulpfile 的 task 依赖树

--tasks-simple 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表

--color 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持

--no-color 强制不显示颜色，即便检测到有颜色支持

--silent 禁止所有的 gulp 日志
</code></pre><h4 id="四、gulp-方法"><a href="#四、gulp-方法" class="headerlink" title="四、gulp 方法"></a>四、gulp 方法</h4><pre><code>1、gulp.src(): 获取到想要处理的文件流

2、gulp.pipe(): 将获取到的文件流通过pipe()导入到gulp的插件中进行处理

3、gulp.dest(): 用来写文件的，插件处理完，通过dest()处理完成后把流中的内容写到指定的文件中

    var gulp = require(&apos;gulp&apos;);
    gulp.src(&apos;js/main.js&apos;)                 // 获取文件的流的api
        .pipe(gulp.uglify())            // 文件进行压缩
        .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));     // 写文件的api


4、gulp.task(&apos;任务名&apos; [需要依赖的其它任务], callback): 定义任务

    gulp.task(&apos;test&apos;, [&apos;styles&apos;], function() {
        // 将你的默认的任务代码放在这
    });

    # gulp test     // 执行任务


5、gulp.watch(&apos;要监视文件的匹配模式&apos;, [要执行的task定义的任务], callback): 监视文件的变化，变化后来执行定义的任务
</code></pre><h4 id="五、Gulp-扩散操作"><a href="#五、Gulp-扩散操作" class="headerlink" title="五、Gulp 扩散操作"></a>五、Gulp 扩散操作</h4><pre><code>1、复制单个文件task

    gulp.task(&apos;copy-html&apos;,function(){
        return gulp.src(&apos;app/index.html&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });


2、复制多个文件

    gulp.task(&apos;copy-images&apos;,function(){
        return gulp.src(&apos;app/imgs/**/*.{jpg,png}&apos;).pipe(gulp.dest(&apos;dist&apos;));
    });

    gulp.task(&apos;copy-other&apos;,function(){
        return gulp.src([&apos;app/css/*.css&apos;,&apos;app/js/*.js&apos;],{base:&apos;app&apos;}).pipe(gulp.dest(&apos;dist&apos;));
    });
</code></pre><h4 id="六、gulp-插件"><a href="#六、gulp-插件" class="headerlink" title="六、gulp 插件"></a>六、gulp 插件</h4><pre><code>1、插件安装 npm install 插件名  --save-dev

2、gulpfile.js中引用插件   

    var uglify = require(&apos;gulp-uglify&apos;);


4、gulp-load-plugins 模块化管理插件

    1）一般情况下，gulpfile.js中的模块需要一个个加载。

        var gulp = require(&apos;gulp&apos;),
               jshint = require(&apos;gulp-jshint&apos;),
            uglify = require(&apos;gulp-uglify&apos;),
            concat = require(&apos;gulp-concat&apos;);

        gulp.task(&apos;js&apos;, function () {
               return gulp.src(&apos;js/*.js&apos;)
                  .pipe(uglify())
                  .pipe(concat(&apos;app.js&apos;))
                  .pipe(gulp.dest(&apos;build&apos;));
        });



    2）gulp-load-plugins 会加载 package.json中存在下面的插件依赖：

        &quot;devDependencies&quot;: {
            &quot;gulp&quot;: &quot;^3.9.0&quot;,
            &quot;gulp-uglify&quot;: &quot;^2.6.0&quot;,
            &quot;gulp-concat&quot;: &quot;^2.2.0&quot;
        }


        var gulp = require(&apos;gulp&apos;);
        var $ = require(&apos;gulp-load-plugins&apos;)();            // 加载gulp-load-plugins插件，并立刻运行


        使用：$.uglify  可以省去单个引入

        gulp.task(&apos;add&apos;, function(){
            gulp.src([&apos;js/main.js&apos;])
                .pipe($.concat)
                .pipe($.uglify)            // $.uglify就可以调用了
                .pipe(gulp.dest(&apos;dist/[name].min.js&apos;));    // 如果不改变文件名就直接写成 dist/js/
        })
</code></pre><h4 id="七、package-json"><a href="#七、package-json" class="headerlink" title="七、package.json:"></a>七、package.json:</h4><pre><code>npm install 插件名 --save-dev        // 安装插件下到node_modules目录下并配置到package.json中的devDependencies{}对象下

{
    &quot;name&quot;: &quot;test&quot;,                    // 项目名
    &quot;version&quot;: &quot;1.0.0&quot;,                // 版本
    &quot;description&quot;: &quot;This is for study gulp project !&quot;,    // 项目描述
    &quot;homepage&quot;: &quot;https://siguang1983.github.io/&quot;,
    &quot;main&quot;: &quot;index.js&quot;,                // 入口文件 npm start 会执行的文件
    &quot;keywords&quot;: [                    // 在npmjs官网搜索时的关键字
        &quot;node.js&quot;,
        &quot;gulp&quot;
    ],
    &quot;scripts&quot;: {                    // 测试脚本  npm test 会执行此文件
        &quot;test&quot;: &quot;test.js&quot;
    },
    &quot;repository&quot;: {                    // 模块的git仓库
        &quot;type&quot;: &quot;git&quot;,
        &quot;url&quot;: &quot;https://github.com/siguang1983/siguang1983.github.io.git&quot;
    },
    &quot;author&quot;: {                        // 作者
        &quot;name&quot;: &quot;siguang&quot;
    },
    &quot;license&quot;: &quot;ISC&quot;,
    &quot;devDependencies&quot;: {
        &quot;gulp&quot;: &quot;^3.9.0&quot;,
        &quot;gulp-amd-optimizer&quot;: &quot;^0.4.0&quot;,
        &quot;gulp-autoprefixer&quot;: &quot;^3.1.0&quot;,
        &quot;gulp-cache&quot;: &quot;^0.4.1&quot;,
        &quot;gulp-concat&quot;: &quot;^2.6.0&quot;,
        &quot;gulp-htmlmin&quot;: &quot;^1.3.0&quot;,
        &quot;gulp-imagemin&quot;: &quot;^2.4.0&quot;,
        &quot;gulp-jshint&quot;: &quot;^2.0.0&quot;,
        &quot;gulp-less&quot;: &quot;^3.0.5&quot;,
        &quot;gulp-livereload&quot;: &quot;^3.8.1&quot;,
        &quot;gulp-minify-css&quot;: &quot;^1.2.2&quot;,
        &quot;gulp-notify&quot;: &quot;^2.2.0&quot;,
        &quot;gulp-plumber&quot;: &quot;^1.1.0&quot;,
        &quot;gulp-react&quot;: &quot;^3.1.0&quot;,
        &quot;gulp-rev-append&quot;: &quot;^0.1.6&quot;,
        &quot;gulp-rimraf&quot;: &quot;^0.2.0&quot;,
        &quot;gulp-sass&quot;: &quot;^2.2.0&quot;,
        &quot;gulp-uglify&quot;: &quot;^1.5.1&quot;,
        &quot;gulp-watch&quot;: &quot;^4.3.5&quot;,
        &quot;gulp.spritesmith&quot;: &quot;^6.2.1&quot;,
        &quot;imagemin-pngquant&quot;: &quot;^4.2.0&quot;,
        &quot;livereload&quot;: &quot;^0.4.0&quot;,
        &quot;merge-stream&quot;: &quot;^1.0.0&quot;,
        &quot;vinyl-buffer&quot;: &quot;^1.0.0&quot;
    },
    &quot;dependencies&quot;: {
        &quot;gulp-header&quot;: &quot;^1.7.1&quot;
    }
}
</code></pre><h4 id="八、gulpfile-js-配置文件"><a href="#八、gulpfile-js-配置文件" class="headerlink" title="八、gulpfile.js 配置文件"></a>八、gulpfile.js 配置文件</h4><pre><code>// 导入工具包 require(&apos;node_modules里对应模块&apos;)
var gulp        = require(&apos;gulp&apos;),
    uglify      = require(&apos;gulp-uglify&apos;),                   // 压缩js
    concat      = require(&apos;gulp-concat&apos;),                   // 合并js
    jshint      = require(&apos;gulp-jshint&apos;),                   // js语法检测
    less        = require(&apos;gulp-less&apos;),                     // less编译
    sass        = require(&apos;gulp-sass&apos;),                     // sass编译
    cssmin      = require(&apos;gulp-minify-css&apos;),               // css压缩
    htmlmin     = require(&apos;gulp-htmlmin&apos;),                  // html压缩
    spritesmith = require(&apos;gulp.spritesmith&apos;),              // 雪碧图
    imagemin    = require(&apos;gulp-imagemin&apos;),                 // 压缩图片
    pngquant    = require(&apos;imagemin-pngquant&apos;),             // 图片的深度压缩
    cache       = require(&apos;gulp-cache&apos;),                    // 只压缩修改的图片
    rev         = require(&apos;gulp-rev-append&apos;),               // 加版本号，给页面文件引用的js和css资源
    autoprefixer = require(&apos;gulp-autoprefixer&apos;),            // 自动补齐前缀，根据设置浏览器版本自动处理浏览器前缀 CSS3的前缀

    react       = require(&apos;gulp-react&apos;),                    // react区分jsx文件进行转换
    webpack     = require(&apos;gulp-webpack&apos;),                  // webpack
    amdOptimize = require(&apos;gulp-amd-optimizer&apos;),            // requirejs 压缩
    bf          = require(&apos;vinyl-buffer&apos;),                  // 流缓存
    merge       = require(&apos;merge-stream&apos;),                  // 合并流

    watch       = require(&apos;gulp-watch&apos;),                    // 侦听变化自动执行task
    livereload  = require(&apos;gulp-livereload&apos;),               // 当监听文件发生变化时，浏览器自动刷新页面
    header      = require(&apos;gulp-header&apos;),                   // 注释自定义插件
    rimraf      = require(&apos;gulp-rimraf&apos;),                   // 清除文件
    plumber     = require(&apos;gulp-plumber&apos;),                  // 错误提示
    notify      = require(&apos;gulp-notify&apos;),                   // 消息提示
    rename      = require(&apos;gulp-rename&apos;),                   // 将文件重命名

    connect = require(&apos;gulp-connect&apos;),                      // gulp创建本地服务器
    browserify = require(&apos;gulp-browserify&apos;);                //


/**
 * 路径变量( s =&gt; source , d =&gt; distribute , o =&gt; other project)
 */
var current = false,                                               //变化路径的开关,true开启,false关闭
    o_dist = &apos;F://LQH/WORK/Anzipay-mall/oneyuan/&apos;,                 //其他项目的根目录
    o_css = o_dist + &apos;dist/css/&apos;,                                  //其他项目下的CSS
    o_js = o_dist + &apos;dist/js/&apos;,                                    //其他项目下的JS
    o_img = o_dist + &apos;dist/img/&apos;,                                  //其他项目下的IMG
    o_mod = o_dist + &apos;dist/mod/&apos;,                                  //其他目录下的模块
    path = {
        s_sass      : &quot;webstart/build/scss/&quot;,                      //待编译的源文件路径
        s_css       : &quot;webstart/build/css/&quot;,
        s_js        : &quot;webstart/build/js/&quot;,
        s_es        : &quot;webstart/build/es6/&quot;,                       //待转换的ES6文件
        s_img       : &quot;webstart/build/img/&quot;,                       //待压缩的图片
        s_simg      : &quot;webstart/build/img/sprite/&quot;,                //待合并成雪碧图的文件
        dist        : &quot;webstart/dist/&quot;,
        d_css       : &quot;webstart/dist/css/&quot;,                        //输出的文件
        d_img       : &apos;webstart/dist/img/&apos;,
        d_js        : &apos;webstart/dist/js/&apos;,
        server_root : [&quot;webstart&quot;, &quot;webstart/static&quot;],
        o_dist      : o_dist,
        o_css       : o_css,                                       //其他项目输出文件
        o_js        : o_js,
        o_img       : o_img,
        o_mod       : o_mod,
        selectPath  : function (current) {                         //开始替换路径
            if (current) {
                path.d_css       = path.o_css;
                path.d_img       = path.o_img;
                path.d_js        = path.o_js;
                path.d_mod       = path.o_mod;
                path.server_root = path.o_dist;                    //本地服务器启动根目录
            }
        }
    };
path.selectPath(current);


//------------------------------- 任务 ------------------------------------


/**
 * 获取package.json配置，添加注释
 */
var pkg = require(&apos;./package.json&apos;);
var banner = [&apos;/**&apos;,
  &apos; * &lt;%= pkg.author.name %&gt; - &lt;%= pkg.author.description %&gt;&apos;,
  &apos; * @version v&lt;%= pkg.version %&gt;&apos;,
  &apos; */&apos;,
  &apos;&apos;].join(&apos;\n&apos;);



// 第一个参数是要执行任务名称     第二个参数是在执行前要执行的任务
gulp.task(&apos;test&apos;, [&apos;styles&apos;], function() {
  // 将你的默认的任务代码放在这
});


/************* 文件压缩任务 **************/
// 如果需要压缩前先执行其它任务可以写到第二个参数里，这里我们先执行合并任务
gulp.task(&apos;mainUglify&apos;, function () {

    // 单文件压缩
    gulp.src([&apos;js/main.js&apos;])
        .pipe(uglify())
        .pipe(header(banner, { pkg : pkg } ))       // 压缩后加注释
        .pipe(gulp.dest(&apos;dist/js/main.min.js&apos;));    // 如果不改变文件名就直接写成 dist/js/
});


/************* 文件合并任务 **************/
gulp.task(&apos;mainConcat&apos;, function () {
    gulp.src([&apos;js/dialog.js&apos;, &apos;js/focusPic.js&apos;, &apos;js/marquee.js&apos;])        // 可以使用*.js来取所有js文件
        .pipe(plumber({errorHandler: notify.onError(&quot;错误信息: &lt;%= error.message %&gt;&quot;)}))
        .pipe(concat(&apos;main.concat.js&apos;))         // 合并成一个文件名为main.concat.js
        .pipe(plumber())
        .pipe(gulp.dest(&apos;dist/js&apos;))
});


/************* 文件代码检测 **************/
gulp.task(&apos;jsLint&apos;, function () {
    gulp.src(&apos;src/*.js&apos;)
        .pipe(jshint())                 // 进行代码检查
        .pipe(jshint.reporter());         // 输出检查结果
});


/************* Less **************/
gulp.task(&apos;mainLess&apos;, function () {
    gulp.src(&apos;less/page.less&apos;)
        .pipe(less())
        .pipe(cssmin())     // 转换完后压缩 兼容IE7及以下需设置compatibility属性 .pipe(cssmin({compatibility: &apos;ie7&apos;}))
        .pipe(gulp.dest(&apos;dist/css/&apos;));
});

gulp.task(&apos;mainLessWatch&apos;, function () {
    gulp.watch(&apos;less/*.less&apos;, [&apos;mainLess&apos;]);    // 当所有less文件发生改变时，调用testLess任务
});


/************* css压缩 **************/
gulp.task(&apos;mainCssmin&apos;, function () {
    gulp.src(&apos;css/*.css&apos;)
        .pipe(cssmin())
        .pipe(gulp.dest(&apos;dist/css&apos;));
});


/************* html压缩 **************/
gulp.task(&apos;mainHtmlmin&apos;, function () {
    var options = {
        removeComments: true,               // 清除HTML注释
        collapseWhitespace: true,           // 压缩HTML
        collapseBooleanAttributes: true,    // 省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;
        removeEmptyAttributes: true,        // 删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;
        removeScriptTypeAttributes: true,   // 删除&lt;script&gt;的type=&quot;text/javascript&quot;
        removeStyleLinkTypeAttributes: true,// 删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;
        minifyJS: true,                     // 压缩页面JS
        minifyCSS: true                     // 压缩页面CSS
    };

    gulp.src(&apos;*.html&apos;)
        .pipe(htmlmin(options))
        .pipe(gulp.dest(&apos;dist/html/&apos;));
});


/************* 图片压缩 **************/
gulp.task(&apos;mainImagemin&apos;, function () {
    gulp.src(&apos;images/*.{png,jpg,gif,ico}&apos;)
        .pipe(imagemin({
            optimizationLevel: 1,           // 类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true,              // 类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true,               // 类型：Boolean 默认：false 隔行扫描gif进行渲染
            multipass: true                 // 类型：Boolean 默认：false 多次优化svg直到完全优化
        }))
        .pipe(gulp.dest(&apos;dist/img&apos;));
});

//图片的深度压缩
gulp.task(&apos;mainPngquantImg&apos;, function () {
    gulp.src(&apos;images/*.{png,jpg,gif,ico}&apos;)
        .pipe(imagemin({
            progressive: true,
            svgoPlugins: [{removeViewBox: false}],  //不要移除svg的viewbox属性
            use: [pngquant()]                       //使用pngquant深度压缩png图片的imagemin插件
        }))
        .pipe(gulp.dest(&apos;dist/img&apos;));
});


/************* 给页面加版本号，刷缓存 **************/
gulp.task(&apos;mainRev&apos;, function () {
    gulp.src(&apos;*.html&apos;)   // 页面里需要加rev=@@hash
        .pipe(rev())
        .pipe(gulp.dest(&apos;dist/&apos;));
});


/************* 浏览器版本自动处理浏览器前缀 **************/
gulp.task(&apos;testAutoFx&apos;, function () {
    gulp.src(&apos;css/autoprefixer.css&apos;)
        .pipe(autoprefixer({
            browsers: [&apos;last 2 versions&apos;, &apos;last 1 Chrome versions&apos;, &apos;last 2 Explorer versions&apos;, &apos;last 3 Safari versions&apos;, &apos;iOS 7&apos;, &apos;Firefox ESR&apos;],
            cascade: true, //是否美化属性值 默认：true 像这样：
            //-webkit-transform: rotate(45deg);
            //        transform: rotate(45deg);
            remove:true //是否去掉不必要的前缀 默认：true
        }))
        .pipe(rename(&apos;autoprefixer.min.css&apos;))       // 设置压缩后的文件名
        .pipe(gulp.dest(&apos;dist/css&apos;));
});


/************* 侦听自动执行Task **************/
gulp.task(&apos;mainWatch&apos;, function () {
    return gulp.src(&apos;css/*.css&apos;)
        .pipe(watch(&apos;css/*.css&apos;))
        .pipe(gulp.dest(&apos;build&apos;));
});


/********* 当文件变化时自动刷新浏览器 **********/
gulp.task(&apos;mainLivereload&apos;, function () {
    return gulp.src([&apos;css/*.css&apos;, &apos;*.html&apos;])
        .pipe(livereload());
});


/************* React **************/
gulp.task(&apos;mainReact&apos;, function () {
    return gulp.src(&apos;template.jsx&apos;)
        .pipe(react())
        .pipe(gulp.dest(&apos;dist&apos;));
});


/************* connect **************/
gulp.task(&apos;connectDist&apos;, function () {
    connect.server({
        name: &apos;Dist App&apos;,    
        root: &apos;dist&apos;,        // 服务器名
        port: 8001,            // 服务器端口
        livereload: true      // 启用实时刷新的功能，这里是本地服务后，如果未使用connect, 还需要livereload插件的方法
    });
});

gulp.task(&apos;scripts&apos;, function() {
    gulp.src([&apos;src/index.js&apos;])
        .pipe(browserify({
            nobuiltins: &apos;events querystring&apos;
        }))
        .pipe(gulp.dest(&apos;./build/js&apos;))
});



/**
 * 配置任务
 */
gulp.task(&quot;default&quot;, [&apos;mainConcat&apos;, &apos;mainUglify&apos;, &apos;mainLess&apos;]);
gulp.task(&quot;mainWatch&quot;, [&apos;mainWatch&apos;]);



/**
 * 监听任务 运行语句 gulp watch
 */
gulp.task(&apos;watch&apos;, function () {

    // 监听sass
    gulp.watch(path.s_sass + &apos;**/*.scss&apos;, [&apos;scss_2_css&apos;]);

    // 监听css
    gulp.watch(path.s_css + &apos;**/*.css&apos;, [&apos;cssmin&apos;]);

    // 监听images
    gulp.watch(path.s_img + &apos;*&apos;, [&apos;imagemin&apos;]);

    //监听ES6 JS
    gulp.watch(path.s_es+&apos;**/*.js&apos;,[&apos;es6_2_es5&apos;]);

    // 监听js
    gulp.watch(path.d_js + &apos;**/*.js&apos;, [&apos;uglify&apos;]);


});
</code></pre><blockquote>
<p>参考资料</p>
<p>gulp中文网 <a href="http://www.gulpjs.com.cn/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/</a><br><a href="http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">http://www.ydcss.com/archives/category/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7</a><br>gulp 技巧集 <a href="http://www.gulpjs.com.cn/docs/recipes/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/recipes/</a><br>gulp api <a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/api/</a><br>gulp使用指南 <a href="http://www.techug.com/gulp" target="_blank" rel="noopener">http://www.techug.com/gulp</a><br>gulp开发教程 <a href="http://www.w3ctech.com/topic/134" target="_blank" rel="noopener">http://www.w3ctech.com/topic/134</a><br>gulp-load-plugins[模块化管理插件] <a href="http://www.qianduancun.com/nodejs/33.html" target="_blank" rel="noopener">http://www.qianduancun.com/nodejs/33.html</a><br>利用 gulp 处理前端工作流程 <a href="http://segmentfault.com/a/1190000003098076#articleHeader0" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003098076#articleHeader0</a><br>前端构建工具gulpjs的使用介绍及技巧 <a href="http://www.cnblogs.com/2050/p/4198792.html" target="_blank" rel="noopener">http://www.cnblogs.com/2050/p/4198792.html</a></p>
<p>文件流<br>nodejs中流(stream)的理解 <a href="http://segmentfault.com/a/1190000000519006" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000519006</a><br>Node.js Stream（流）的学习笔记 <a href="http://www.it165.net/pro/html/201406/15924.html" target="_blank" rel="noopener">http://www.it165.net/pro/html/201406/15924.html</a><br>Node 中的流（Stream） <a href="http://segmentfault.com/a/1190000000357044" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000357044</a></p>
<p>Promise</p>
<p>深入理解Promise实现细节 <a href="http://segmentfault.com/a/1190000002591145" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002591145</a><br>Promise实现原理 <a href="http://www.tuicool.com/articles/fe6Jbyz" target="_blank" rel="noopener">http://www.tuicool.com/articles/fe6Jbyz</a><br>异步编程 promise模式 的简单实现 <a href="http://segmentfault.com/a/1190000003028634" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003028634</a><br><a href="http://sentsin.com/web/861.html" target="_blank" rel="noopener">http://sentsin.com/web/861.html</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/11/02/webpack/">webpack</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/11/02/webpack/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-11-02T03:06:16.000Z" itemprop="datePublished">2016-11-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端构建工具/">前端构建工具</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| webapck介绍、优点与缺点<br>| AMD、CMD、CommonJS模式<br>| require()、define()、export()<br>| requires.ensure(): 用来按需加载，将文件使用时在进行加载<br>| vendor: 将库、框架文件与业务分离分别打包<br>| entry: 入口<br>| output: 打包输出<br>| loader: 加载器<br>| reslove: 依赖文件<br>| plugins: 插件<br>| webpack-dev-server: 本地服务器，可以设置代理，用来前后端分离跨域</p>
<h4 id="webpack介绍"><a href="#webpack介绍" class="headerlink" title="webpack介绍"></a>webpack介绍</h4><pre><code>一、webpack是模块加载 和 打包合为一体的工具，可以加载所有的资源都是模块(js,css,图片等)

    1、webpack的优势: 对 CommonJS 、AMD 、ES6的语法做了兼容; 对js、css、图片等资源文件都支持打包; 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间;

    2、文件配置 - 在项目的根目录创建三个或多个webpack配置文件，我们创建两个: 

        webpack.dev.config.js -&gt; 开发环境中用到的配置文件
        webpack.pub.config.js -&gt; 生产环境中用到的配置文件
</code></pre><h4 id="webpack用法"><a href="#webpack用法" class="headerlink" title="webpack用法"></a>webpack用法</h4><pre><code>一、定义模块

    define(&apos;&apos;, function(){})

    require.ensure()

    直接使用ES6模块语法


二、加载模块

    var cat = require(&apos;./cat.js&apos;)     // 普通加载模块 webpack默认加载

    import cat form &apos;./cat&apos;            // ES6写法需要安装bable-loader


三、导出接口  module.exports = &apos;...&apos;;

    cats.js  创建一个模块
        var cats = [&apos;dave&apos;, &apos;henry&apos;, &apos;martha&apos;];
        module.exports = cats;

    app.js 入口
        let cats = require(&apos;./cats.js&apos;);
        console.log(cats);
</code></pre><h4 id="入口-Entry"><a href="#入口-Entry" class="headerlink" title="入口 Entry"></a>入口 Entry</h4><pre><code>// 单入口
module.exports = {
    entry: {
        main: &apos;./src/main.js&apos;
    }
}

// 多入口
module.exports = {
    entry: {
        app: [&quot;./home.js&quot;, &quot;./events.js&quot;]
        /* 也可以写成
        * app: &quot;./home.js&quot;, 
        * events: &quot;./events.js&quot;
        */
    }
}

// 多入口，app(应用主入口)，vendors(公共库)入口
module.exports = {
    entry: {
        app: &apos;./src/main.js&apos;,
        vendors: &apos;./src/jquery.js&apos;
    }
}
</code></pre><h4 id="出口-Output"><a href="#出口-Output" class="headerlink" title="出口 Output"></a>出口 Output</h4><pre><code>一、配置 output 选项可以控制 webpack 如何向硬盘写入编译文件

    1、path: 目标输出的目录，绝对路径

    2、filename: 用于输出文件的文件名

    3、publicPath: 指定了你在浏览器中用什么地址来引用你的静态文件，它会包括你的图片、脚本以及样式加载的地址，一般用于线上发布以及CDN部署的时候使用。

        将publicPath设置成了http://rynxiao.com/assets/，其中设置到了插件的一些东西，这点下面会讲到，总之这个插件的作用是生成了上线发布时候的首页文件，其中script中引用的路径将会被替换。

        html生成 &lt;script src=&quot;http://rynxiao.com/assets/main.bundle.js&quot;&lt;/script&gt;

    4、chunkFilename  用于模块中采用代码分割

        id: 会被对应块的id替换
        name: 会被对应块的name替换
        hash: 会被文件hash替换
        chunkhash: 会被文件hash替换
        output : {
            path : &apos;./assets/&apos;,
            filename : &apos;[name].[hash].bundle.js&apos;,
            chunkFilename: &quot;chunk/[chunkhash].chunk.js&quot;
        }

    Example:

        const path = require(&apos;path&apos;);
        module.exports = {
            output: {
                path: path.resolve(__dirname, &apos;./dist&apos;),
                publicPath: &apos;/dist/&apos;,
                filename: &apos;my-first-bundle.js&apos; 
            }
        }


二、多个入口的输出

    写入到硬盘: ./dist/app.js, ./dist/search.js
    {
        entry: {
            app: &apos;./src/app.js&apos;,
            search: &apos;./src/search.js&apos;
        },
        output: {
            filename: &apos;[name].js&apos;,
            path: __dirname + &apos;/dist&apos;
        }
    }


三、使用CDN和资源hash

    output: {
        filename: &apos;[name].js?[hash]&apos;,            // 生成后会在&lt;script&gt;引用的加入hash来
        path: &quot;/home/proj/cdn/assets&quot;,
        publicPath: &quot;http://cdn.example.com/assets&quot;
    }
</code></pre><h4 id="第三方库与业务文件处理"><a href="#第三方库与业务文件处理" class="headerlink" title="第三方库与业务文件处理"></a>第三方库与业务文件处理</h4><pre><code>业务代码和第三方代码分离，这时候会把他们都压缩到一个文件中，使这个js文件比较大，并且跳转到另一个地址也还会重新加载这些公用的文件

Example: 

    对引用的jquery单独提取

    1、import $ from &apos;jquery&apos;;     // js中引用的jquery, 先npm i jquery下载包

    2、webpack.config.js

        // 入口文件
        entry: {
            app: path.resolve(__dirname, &apos;web/js/index.js&apos;),
            vendor: [&apos;jquery&apos;]
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;,
            chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        plugins: [
            // 将在html文件中添加&lt;script&gt;引用，并生创建到指定的目录中
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,
                filename: &apos;./web/index.html&apos;,
                template: &apos;./web/index.html&apos;,
                chunks: [&apos;app&apos;, &apos;vendor&apos;],            // 这里要把vendor依赖的文件加上，不然生成的html只有引用app.min.js，不会引用jquery.vendor.js
                inject: true,
                hash: true
            }),

            // 拆分插件
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendor&apos;,                            // 上面入口定义的节点组
                filename: &apos;jquery.vendor.js?[hash]&apos;     //最后生成的文件名
            }),
        }
</code></pre><h4 id="加载器-Loader"><a href="#加载器-Loader" class="headerlink" title="加载器 Loader"></a>加载器 Loader</h4><pre><code>将所有引用资源(.css、.html、.scss、.jpg)作为模块处理，webpack loader文件添加到依赖中，将其转换成模块.
module: {
    loaders: [
        { test : /\.js\.jsx$/, loader : &apos;babel&apos; },
    ]
}
</code></pre><h4 id="给文件加hash"><a href="#给文件加hash" class="headerlink" title="给文件加hash"></a>给文件加hash</h4><pre><code>只需要给output的文件的后面加上?[hash]

output: {
    path: buildPath,
    filename: &apos;[name].js?[hash]&apos;
}
</code></pre><h4 id="require-ensure按需加载"><a href="#require-ensure按需加载" class="headerlink" title="require,ensure按需加载"></a>require,ensure按需加载</h4><pre><code>require()与require.ensure()加载的不同

1、require(): AMD加载规范，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数

2、require.ensure(): requi.ensure的依赖模块只会被先下载下来，但不会被执行，会将require.ensure()内加载的模块合成一个文件，在

    如果webpack打包会将所有资源加到一个文件中，这样会使这个文件变的很大，require.ensure()来对加载的资源单独打包

    require.ensure([], function(require) {
        var dialog = require(&apos;./components/dialog&apos;);
        // todo ...
    });

    CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好

    webpack.config.js中配置

        var chunks = Object.keys(entries);
        plugins: [
            new webpack.optimize.CommonsChunkPlugin({
                name: &apos;vendors&apos;,             // 将公共模块提取，生成名为`vendors`的chunk
                chunks: chunks,
                minChunks: chunks.length     // 提取所有entry共同依赖的模块
            })
        ]

http://blog.csdn.net/zhbhun/article/details/46826129
https://segmentfault.com/a/1190000007775743
</code></pre><h4 id="webpack安装-ES6开发"><a href="#webpack安装-ES6开发" class="headerlink" title="webpack安装 + ES6开发"></a>webpack安装 + ES6开发</h4><pre><code>1、$ npm install webpack --save        // 安装webpack, 指定版本 npm i webpack@1.2.x --save

2、安装babel-loader相关插件

   $ npm install babel-loader babel-core babel-preset-es2015 --save-dev

3、webpack.config.js文件配置

    var Webpack = require(&quot;webpack&quot;);
    var path = require(&apos;path&apos;);

    module.exports = {
        entry: &quot;./js/main.js&quot;,

        output: {
            path: &apos;./dist/&apos;,
            filename: &quot;[name].min.js&quot;
        },

        module: {
            loaders: [
                {
                    test: /\.js$/,
                    exclude: /(node_modules|bower_components)/,
                    loader: &apos;babel-loader&apos;, // &apos;babel-loader&apos; is also a valid name to reference 
                    query: {
                        presets: [&apos;es2015&apos;]
                    }
                }
            ]
        }
    }
</code></pre><h4 id="webpack-webpack-dev-server-ES6-构建单-多入口项目基础配置"><a href="#webpack-webpack-dev-server-ES6-构建单-多入口项目基础配置" class="headerlink" title="webpack + webpack-dev-server + ES6 构建单/多入口项目基础配置"></a>webpack + webpack-dev-server + ES6 构建单/多入口项目基础配置</h4><pre><code>webpack-dev-server - 可以创建一个本地服务，并能设置代理服务，并且能够实时重新加载

一、创建项目目录和基础配置文件

    // 创建项目目录并进行目录
    $ mkdir webpack_base_demo &amp;&amp; cd webpack_base_demo      

    // 创建文件
    $ touch README.md  .gitignore  .babelrc  webpck-config.js

    // 创建package.json
    $ npm init                                 

    // 配置.babelrc文件
    {
        &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;, &quot;stage-0&quot;],
        &quot;plugins&quot;: []
    }


二、安装webpack、webpack-dev-server

    $ npm i webpack webpack-dev-server --save-dev


三、安装插件

    // 如果使用react框架来做项目，先下载包
    $ npm i --save react react-dom

    // 使用Babel-loader来解析es6和jsx
    $ npm i babel-loader babel-core

    $ npm i babel-preset-es2015 babel-preset-react babel-preset-stage-0

    // jsx转换
    $ npm i jsx-loader --save

    // 解析样式文件
    $ npm install style-loader css-loader less-loader sass-loader    


四、其它插件

    1、html-webpack-plugin 解析html模板

        将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

        $ npm i html-webpack-plugin


    2、extract-text-webpack-plugin 单独打包css文件

        $ npm i extract-text-webpack-plugin


    3、open-browser-webpack-plugin   自动打开浏览器

        $ npm i open-browser-webpack-plugin

        var openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
          new openBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]

    4、webpack-spritesmith   雪碧图

        $ npm i webpack-spritesmith

        https://www.cnblogs.com/weiweisuo/p/6912740.html


五、创建webpack.config.js、webpack.production.config配置文件

    webpack.config.js 开发环境所用配置文件
    webpack.pub.config.js  生产环境所用配置文件

    二者区别: 

        webpack.config.js 开发时使用启用server, webpack.production.config.js 打包构建时使用不需要启动server，直接将代码执行到build目录

    // 创建配置文件
    $ touch webpack.config.js webpack.production.config.js


    /**
     * User: siguang
     * Date: 2016/12/28
     * Time: 15:04
     */
    let webpack = require(&apos;webpack&apos;);
    let path = require(&apos;path&apos;);
    let HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
    // let ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); // 单独打包CSS
    let openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);

    /*  文件路径配置 */
    let basePath = __dirname;
    let appPath = path.resolve(basePath, &apos;src&apos;);
    let buildPath = path.resolve(basePath, &apos;build&apos;);

    /* libs 目录下的库文件 */
    let libsPath = path.resolve(basePath, &apos;src/libs&apos;);
    let jquery = path.resolve(libsPath, &apos;jquery.min&apos;)

    // webpack配置对象
    module.exports = {

        // 入口文件
        entry: {
            app: path.resolve(appPath, &apos;js/index.js&apos;),
            list: path.resolve(appPath, &apos;js/list.js&apos;)
        },

        // 出口文件
        output: {
            path: buildPath,
            filename: &apos;/js/[name].min.js?[hash]&apos;,
            chunkFilename: &quot;[name].min.js?[hash]&quot;
        },

        // 加载器配置
        module: {
            loaders: [

                // 处理require()引入的css文件，并将代码显示到页面的&lt;style|中
                { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; },

                // 将jsx文件转成js文件
                { test: /\.js$/, loader: &apos;jsx-loader?harmony&apos;},

                // 将scss文件转成css文件
                { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

                // ?limit=8192  limit设置小于8k的图片转成64位编码，大小8于不会被转码
                { test: /\.(png|jpg|woff|eot|ttf|svg|gif)$/, loader: &apos;url-loader?limit=8192&apos;},

                // ES6 转 ES5
                {    
                    test: /\.js?$/,
                    loader: &apos;babel-loader&apos;,
                    query: {
                        presets: [&apos;es2015&apos;]
                    }
                }   
            ]
        },

        // 插件
        plugins: [

            // 压缩打包的文件
            // new webpack.optimize.UglifyJsPlugin({
            //     compress: {
            //         //supresses warnings, usually from module minification
            //         warnings: false
            //     }
            // }),

            // 将vendor中的库合并到一起
            new webpack.optimize.CommonsChunkPlugin({
                name: jquery,
                filename: &apos;jquery.bundle.js&apos;
            }),      

            // html
            new HtmlWebpackPlugin({
                // 改变页面的&lt;title|标签的内容 
                title: &apos;Hello World app&apos;,                   // 页面调用&lt;%= htmlWebpackPlugin.options.title %|
                // 模版地址
                template: path.resolve(appPath, &apos;index.html&apos;),
                // 构建后的文件名和目录
                filename: &apos;index.html&apos;,
                //chunks这个参数告诉插件要引用entry里面的哪几个入口
                chunks:[&apos;app&apos;,&apos;vendor&apos;],
                //要把script插入标签里
                inject:&apos;body&apos;
            }),

            new HtmlWebpackPlugin({
                // 改变页面的&lt;title|标签的内容 
                title: &apos;Hello World appList&apos;, 
                // 模版地址
                template: path.resolve(appPath, &apos;list.html&apos;),
                // 构建后的文件名和目录
                filename: &apos;list.html&apos;,
                //chunks这个参数告诉插件要引用entry里面的哪几个入口
                chunks:[&apos;list&apos;,&apos;vendor&apos;],
                //要把script插入标签里
                inject:&apos;body&apos;
            }),

            // css
            // new ExtractTextPlugin(&quot;[name].css?[hash]&quot;),

            // 热启动
            new webpack.HotModuleReplacementPlugin(),

            // 自动开启浏览器
            new openBrowserWebpackPlugin({ url: &apos;http://localhost:5000&apos; })
        ],

        // 查找依赖
        resolve:{

            // require或alias时不需要写后缀
            extensions: [&quot;.js&quot;, &quot;.jsx&quot;, &quot;.css&quot;, &quot;.json&quot;],
        },

        // webpack-dev-server 配置
        devServer: {
            port: 5000,                 // 端口
            contentBase: &apos;build&apos;,       // 内容目录
            hot: true,                    // 热刷新
            inline: true,
            // proxy: [                 // 设置代理服务器
            //     {
            //         path: [&quot;/api&quot;,&quot;/user&quot;], //
            //         target: &quot;http://10.20.1.8:3002/&quot;, // 转发的服务器地址
            //         // rewrite: rewriteUrl(&apos;/$1\.json&apos;),
            //         changeOrigin: true
            //     }
            // ]
        }
    }


六、启动服务

    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;webpack-dev-server --hot --inline&quot;,
        &quot;build&quot;: &quot;webpack --progress --profile --colors --config webpack.production.config.js&quot;
    },

    通过npm中的scripts来配置npm启动项

    npm run start        // 开发环境下启动

        localhost://5000             // 访问的index.html
        localhost://5000/list.html     // 访问的list.html

    npm run build         // 开发完成后上线前，将开发代码构建到build目录的生成目录


七、 webpack-dev-server要执行参数

    webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器

    webpack-dev-server --devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号

    webpack-dev-server --progress - 显示合并代码进度

    webpack-dev-server --colors - 命令行中显示颜色

    webpack-dev-server --content-base build  // webpack-dev-server服务会默认以当前目录伺服文件，如果设置了content-base的话，服务的根路径则为build目录

    webpack-dev-server --inline  可以自动加上dev-server的管理代码，实现热更新

    webpack-dev-server --hot  开启代码热替换，可以加上HotModuleReplacementPlugin

    webpack-dev-server --port 3000 设置服务端口
</code></pre><h4 id="CommonJS，AMD，CMD区别"><a href="#CommonJS，AMD，CMD区别" class="headerlink" title="CommonJS，AMD，CMD区别"></a>CommonJS，AMD，CMD区别</h4><pre><code>Commonjs是用在服务器端的，同步的，如nodejs 

AMD、CMD是用在浏览器端的，异步的，如requirejs和seajs 

一、模块

    ES2015 - import 语句
    CommonJS - require() 语句
    AMD define 和 require 语句
    css/sass/less - 文件中的 @import 语句

二、CommonJS

    CommonJS 是服务器端模块的规范，Node.js采用了这个规范。

    一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。

    Example: 

        // 私有变量
        var test = 123; 

        // 公有方法 
        function foobar () { 
            this.foo = function () { 
                // do someing ... 
            } 
            this.bar = function () { 
                //do someing ... 
            } 
        } 

        // exports对象上的方法和变量是公有的 
        var foobar = new foobar(); 
        exports.foobar = foobar;         // module.exports 与 exports

        // require方法默认读取js文件，所以可以省略js后缀 
        var test = require(&apos;./boobar&apos;).foobar; 
        test.bar(); 

三、AMD

    RequireJS使用的AMD模式，异步加载模块    

    // 定义模块
    define([&apos;依赖文件&apos;], function(md){
        let person = ()=&gt;{
            console.log(&apos;这里是模块方法&apos;)
        }

        // 模块的对外接口
        return person;

    })

    // AMD规范允许输出模块兼容CommonJS规范，这时define方法如下:  
    define(function (require, exports, module) {      
        var reqModule = require(&quot;./someModule&quot;); 
        requModule.test(); 

        exports.asplode = function () { 
            //someing 
        } 
    }); 

四、CMD模式

    SeaJS使用的CMD模式，CMD与AMD的区别: 

        1）依赖模块AMD先执行，这样js可以方便知道依赖模块是谁，立即加载;

        2）CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。

    define(function (requie, exports, module) {     // 注意 requie, exports, module 参数名称不能变

        //依赖可以就近书写 
        var a = require(&apos;./a&apos;); 
        a.test(); 

        ... 
        //软依赖 
        if (status) { 

            var b = requie(&apos;./b&apos;); 
            b.test(); 
        } 

        // 模板对外接口中
        exports.getApp = function(){
            ...
        }
    }); 

五、ES6 模块

    import $ from &quot;jquery&quot;;
    export function doStuff() {}
    module &quot;localModule&quot; {}

六、除了JS，加载其它静态文件

    样式、图片、web字体、html模板，还可以加载一些预处理: coffeescript =| javascript、less =| css、jade =| 生成模板html
    require(&apos;./style.css&apos;);
    require(&apos;./style.less&apos;);
    require(&apos;./template.jade&apos;);
    require(&apos;./image.png&apos;);
</code></pre><h4 id="webpack安装和执行命令"><a href="#webpack安装和执行命令" class="headerlink" title="webpack安装和执行命令"></a>webpack安装和执行命令</h4><pre><code>一、webpack命令参数

    1、webpack            // 最基本的启动webpack命令

    2、webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包

    3、webpack -w         // 提供watch方法，实时进行打包更新 相当于 -watch 

    4、webpack -p         // 对打包后的文件进行压缩

    5、webpack -d         // 提供SourceMaps，方便调试

    6、webpack --colors     // 输出结果带彩色，比如: 会用红色显示耗时较长的步骤

    7、webpack --profile // 输出性能数据，可以看到每一步的耗时

    8、webpack --display-modules     // 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块

    9、webpack --progress --colors   // 展示一些进度条，同时增加颜色

    10、webpack --display-error-details    // 打印出错在哪个文件和行


二、--save-dev和--save的不同

    --save-dev: 写到了 devDependencies 对象里，devDependencies是只在开发时需要依赖

    --save: 写到了 dependencies 对象里是运行时被使用

    1、npm install --save jquery  

    2、src/app.js

        import &apos;babel-polyfill&apos;;
        import cats from &apos;./cats&apos;;
        import $ from &apos;jquery&apos;;            

        # 这里去找的就是dependencies对象内，会将jquery文件与业务打包到一起

        $(&apos;&lt;h1|Cats&lt;/h1|&apos;).appendTo(&apos;body&apos;);
        const ul = $(&apos;&lt;ul|&lt;/ul|&apos;).appendTo(&apos;body&apos;);
        for (const cat of cats) {
            $(&apos;&lt;li|&lt;/li|&apos;).text(cat).appendTo(ul);
        }
</code></pre><h4 id="插件类"><a href="#插件类" class="headerlink" title="插件类"></a>插件类</h4><pre><code>一、自动刷新

    webpack-dev-server有两种模式支持自动刷新——iframe模式和inline模式。

    1、iframe模式: 页面是嵌套在一个iframe下的，在代码发生改动的时候，这个iframe会重新加载;使用iframe模式无需额外的配置，只需在浏览器输入以下地址: http://localhost:8080/webpack-dev-server/index.html

    2、inline模式: 一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。

    以下三种配置都可以实现页面的刷新效果: 

        // 1.启动webpack-dev-server的时候带上inline参数
        webpack-dev-server --inline

        // 2.给HTML插入JS
        &lt;script src=&quot;http://localhost:3000/webpack-dev-server.js&quot;|&lt;/script|

        // 3.webpack配置
        entry: [
            &apos;webpack-dev-server/client?http://localhost:3000&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ]


二、HotMooduleReplacementPlugin()热替换

    webpac-dev-server支持模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉。使用HMR功能也有两种方式: 命令行方式和Node.js API。

    1、cli命令行方式  webpack-dev-server --inline --hot

    2、Node.js API方式

        entry: [
            &apos;webpack/hot/dev-server&apos;,
            path.resolve(__dirname, &apos;src/index.js&apos;)
        ],
        devServer: {
            hot: true
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin(),
        ]


三、html-webpack-plugin 解析html模板

    插件将入口js文件直接构建到指定的html中，并构建到build目录，这样不用手动在html引用js文件，和将html手动放到build目录下

    $ npm i html-webpack-plugin

    $ const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);            // 引用插件

    1、单入口配置

        // 这里省略其他配置代码
        plugins: [
            // 使用这个plugin，这是最简单的一个配置，更多资料可到github查看
            new HtmlWebpackPlugin({
                title: &apos;zhufeng-react&apos;,
                template: &apos;./src/index.html&apos;,
            })
        ]

    2、多入口配置

        会将两个入口分别对html文件进行加载指定的入口js文件

        // 入口文件
        entry: {
            app: &apos;./web/js/index.js&apos;,
            list: &apos;./web/js/list.js&apos;
        },

        // 出口文件
        output: {
            path: path.resolve(buildPath, &apos;dist&apos;),
            filename: &apos;[name].min.js?[hash]&apos;
        },

        plugins: [
            new HtmlWebpackPlugin({
                title: &apos;index&apos;,                    // 生成html文档的标题
                filename: &apos;./web/index.html&apos;,    // 输出文件名称
                template: &apos;./web/index.html&apos;,    // 本地模板的位置，支持(handlebars、ejs、undersore、html)
                chunks: [&apos;app&apos;],                // 对应的入口entry, 也可以是数组[&apos;app&apos;, &apos;list&apos;]
                inject: true,                    // 向template中注入所有静态资源
                hash: true                        // 为静态资源添加webpack每次编译产生的唯一hash值， &lt;script type=&quot;text/javascript&quot; src=&quot;common.js?a3e1396b501cdd9041be&quot;&gt;&lt;/script&gt;
            }),
            new HtmlWebpackPlugin({
                title: &apos;list&apos;,
                filename: &apos;./web/list.html&apos;,
                template: &apos;./web/list.html&apos;,
                chunks: [&apos;list&apos;],
                inject: true,
                hash: true
            })
        ]

    https://segmentfault.com/q/1010000009810148
    https://www.cnblogs.com/wonyun/p/6030090.html


四、extract-text-webpack-plugin 单独打包css文件

    $ npm i extract-text-webpack-plugin


五、open-browser-webpack-plugin   资源构建成功后自动打开浏览器 --- 已可以在命令中配置

    1、package.json中加 --open，与使用此插件相同

        &quot;scripts&quot;: {
            &quot;start&quot;: &quot;webpack-dev-server --hot --inline --open&quot;,
        }


    2、$ npm install open-browser-webpack-plugin --save-dev

        var openBrowserWebpackPlugin = require(&apos;open-browser-webpack-plugin&apos;);
        plugin: [
            new openBrowserWebpackPlugin({ url: &apos;http://localhost:8080&apos; })
        ]


六、CSS Module

    webpack 的 css-loader 是解决这个问题的最好办法之一。简单配置一下: 
    module: {
      loaders: [{
        test: /\.css$/,
        loaders: [
          &apos;style-loader&apos;,
          &apos;css-loader?modules&amp;localIdentName=[name]__[local]___[hash:base64:5]&apos;,
          &apos;postcss-loader&apos;
        ]
      }]
    },
    postcss: [
      require(&apos;postcss-nested&apos;)(),
      require(&apos;cssnext&apos;)(),
      require(&apos;autoprefixer-core&apos;)({ browsers: [&apos;last 2 versions&apos;] })
    ]


七、UglifyJs Plugin 压缩资源

    var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;

    plugins: [
        new uglifyJsPlugin({
            compress: {
                warnings: false
            }
        }),
        new webpack.optimize.MinChunkSizePlugin({
            compress: {
                warnings: false
            }
        }),
        // 查找相等或近似的模块，避免在最终生成的文件中出现重复的模块
        new webpack.optimize.DedupePlugin(),
        // 按引用频度来排序 ID，以便达到减少文件大小的效果
        new webpack.optimize.OccurenceOrderPlugin(),
        new webpack.optimize.AggressiveMergingPlugin({
            minSizeReduce: 1.5,
            moveToParents: true
        })
    ]


八、clean-webpack-plugin 清除文件夹

    $ npm install clean-webpack-plugin --save-dev

    webpack.config.js:

        const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);

        plugins: [
            new CleanWebpackPlugin([&apos;dist&apos;]),
            new HtmlWebpackPlugin({
                title: &apos;Output Management&apos;
            })
        ]


九、暴露全局对象

    如果想将report数据上报组件放到全局，有两种办法: 

    方法一: 
    在loader里使expose将report暴露到全局，然后就可以直接使用report进行上报
    {
        test: path.join(config.path.src, &apos;/js/common/report&apos;),
        loader: &apos;expose?report&apos;
    }

    方法二: 
    如果想用R直接代表report，除了要用expose loader之外，还需要用ProvidePlugin帮助，指向report，这样在代码中直接用R.tdw， R.monitor这样就可以
    new webpack.ProvidePlugin({
        &quot;R&quot;: &quot;report&quot;,
    })
</code></pre><p>| <a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">https://doc.webpack-china.org/concepts/</a>        webpack中文网<br>| <a href="http://www.css88.com/doc/webpack2/loaders/raw-loader/" target="_blank" rel="noopener">http://www.css88.com/doc/webpack2/loaders/raw-loader/</a><br>| <a href="http://liunian.github.io/webpack-doc/" target="_blank" rel="noopener">http://liunian.github.io/webpack-doc/</a><br>| <a href="http://www.imooc.com/article/10965" target="_blank" rel="noopener">http://www.imooc.com/article/10965</a><br>| <a href="https://zhuanlan.zhihu.com/FrontendMagazine?topic=%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/FrontendMagazine?topic=%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91</a><br>| <a href="http://blog.csdn.net/keliyxyz/article/details/51527476" target="_blank" rel="noopener">http://blog.csdn.net/keliyxyz/article/details/51527476</a><br>| <a href="http://cnodejs.org/topic/57528759adc77ac170409e79" target="_blank" rel="noopener">http://cnodejs.org/topic/57528759adc77ac170409e79</a><br>| <a href="http://blog.csdn.net/xiaozhuxmen/article/details/51597923" target="_blank" rel="noopener">http://blog.csdn.net/xiaozhuxmen/article/details/51597923</a><br>| <a href="http://react-china.org/t/webpack-output-filename-output-chunkfilename/2256/2" target="_blank" rel="noopener">http://react-china.org/t/webpack-output-filename-output-chunkfilename/2256/2</a>   // output.filename 和output.chunkFilename<br>| <a href="http://www.jianshu.com/p/8adf4c2bfa51" target="_blank" rel="noopener">http://www.jianshu.com/p/8adf4c2bfa51</a><br>| <a href="http://www.alloyteam.com/2016/02/code-split-by-routes/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/02/code-split-by-routes/</a>  按需加载<br>|<br>| 插件<br>| <a href="http://www.cnblogs.com/haogj/p/5160821.html" target="_blank" rel="noopener">http://www.cnblogs.com/haogj/p/5160821.html</a>     // html-webpack-plugin html多页面构建<br>|<br>| 热更新<br>| <a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">https://github.com/gaearon/react-hot-loader</a>    // react<br>| <a href="https://github.com/vuejs/vue-loader" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader</a>            // vue</p>

        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
