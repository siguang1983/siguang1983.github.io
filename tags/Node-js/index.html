<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Label: Node.js | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Labels</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/06/nodeJS（之四）Strame/">nodeJS（之一）Stream</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/06/nodeJS（之四）Strame/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-06T02:43:21.000Z" itemprop="datePublished">2017-03-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| createReadStream() - 创建可读流<br>| createWriteStream() - 创建可写流<br>| setEncodeing() - 设置编码<br>| </p>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><pre><code>Stream把较大的数据，拆分成小的部分

读取文件的两种: fs.readFile()和fs.createReadStream()

stream提供了以下四种类型的流：

    var Stream = require(&apos;stream&apos;);

    var Readable = Stream.Readable;
    var Writable = Stream.Writable;
    var Duplex = Stream.Duplex;
    var Transform = Stream.Transform;
</code></pre><h4 id="createReadStream-、createWriteStream"><a href="#createReadStream-、createWriteStream" class="headerlink" title="createReadStream()、createWriteStream()"></a>createReadStream()、createWriteStream()</h4><pre><code>// 创建一个Readable对象以读取bigFile内容
// 如果使用fs.readFile()可以会由于文件过大而失败
fs.createReadStream(bigFile);
</code></pre><h4 id="setEncodeing-设置编码"><a href="#setEncodeing-设置编码" class="headerlink" title="setEncodeing() 设置编码"></a>setEncodeing() 设置编码</h4><pre><code>var readerStream = fs.createReadStream(&apos;input.txt&apos;);

readerStream.setEncodeing(&apos;UTF8&apos;);
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>可读数据流的事件

    readable 数据向外流时触发

    data 对于那些没有显式暂停的数据流，添加data事件监听函数，会将数据流切换到流动态，尽快向外提供数据

    end 读取完数据时触发。注意不能和 writeableStream.end() 混淆，writeableStream 并没有 end 事件，只有 .end() 方法

    close 数据源关闭时触发

    error 读取数据发生错误时触发


可写数据流的事件

    drain writable.write(chunk) 返回 false 之后，缓存全部写入完成，可以重新写入时就会触发

    finish 调用 .end 方法时，所有缓存的数据释放后触发，类似于可读数据流中的 end 事件，表示写入过程结束

    pipe 作为 pipe 目标时触发

    unpipe 作为 unpipe 目标时触发

    error 写入数据发生错误时触发
</code></pre><p>| <a href="https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8" target="_blank" rel="noopener">https://cnodejs.org/topic/570b1fa494b38dcb3c09a7f8</a><br>| <a href="http://fe.meituan.com/stream-basics.html" target="_blank" rel="noopener">http://fe.meituan.com/stream-basics.html</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/04/nodeJS（之三）Buffer/">nodeJS (之三) Buffer</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/04/nodeJS（之三）Buffer/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-04T10:30:21.000Z" itemprop="datePublished">2017-03-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| Buffer.from() - 创建buffer  // 老方法 new Buffer(str, encode);<br>| toString() - Buffer转字符串<br>| length - 返回Buffer的长度<br>| concat([buf1, buf2], 输出的长度) - 合并<br>| slice(start, end) - 截取<br>| copy(buffer, 开始目标位置, start, end) - 拷贝<br>| compare() - 比较两个buffer的大小<br>| fill() - 用指定的值填充Buffer<br>| indexOf(val) - 返回指定字符所在Buffer的位置<br>| lastIndexOf() - 从后向前查找<br>| includes(val, begin, uncode) - 查找是否存在<br>| keys() - 获取<br>| write() - 向指定的buffer写入内容<br>|<br>| Buffer.isBuffer(buf) - 是否是一个buffer<br>| Buffer.isEncoding(‘utf-8’) - 检测是否是一个有效的编码<br>| Buffer.byteLength - 判断字符的长度</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><pre><code>Buffer用于创建存放和处理二进制数据的缓存区，buffer是全局不需要require(&apos;buffer&apos;)

网络上发送和接收经常是以二进制传输数据:

    - 通过TCP连接发送和接收数据；
    - 从图像或者压缩文件读取二进制数据；
    - 从文件系统读写数据；
    - 处理来自网络的二进制数据流


1、字节byte: 1个字节等于8位二进制

       位bit: 每位存储0或1，每8位等于一个字节，最大0-255字节

       一个汉字三个字节，其它两个字节


2、Node.js 目前支持的字符编码包括: 

    &apos;ascii&apos; - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。

    &apos;utf8&apos; - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。

    &apos;utf16le&apos; - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。

    &apos;ucs2&apos; - &apos;utf16le&apos; 的别名。

    &apos;base64&apos; - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。

    &apos;latin1&apos; - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。

    &apos;binary&apos; - &apos;latin1&apos; 的别名。

    &apos;hex&apos; - 将每个字节编码为两个十六进制字符。
</code></pre><h4 id="new-Buffer"><a href="#new-Buffer" class="headerlink" title="new Buffer"></a>new Buffer</h4><pre><code>new Buffer(size): 创建一个Buffer对象, 并返回一个数组

Buffer创建的三种类型:

    1、new Buffer(2)            // 创建buffer的长度

        let buf = new Buffer(2);
        buf[1] = &apos;232&apos;;
        buf[2] = &apos;2312&apos;;
        buf[3] = &apos;asasdf&apos;;
        console.log(&apos;输出buffer: &apos;, buf);        // 输出buffer:  &lt;Buffer 00 e8&gt;  只能输出两个字节

    2、new Buffer(数组)            // new Buffer([1,3,5])

    3、new Buffer(字符串)        // new Buffer(&apos;我&apos;)
</code></pre><h4 id="字符串与buffer互转"><a href="#字符串与buffer互转" class="headerlink" title="字符串与buffer互转"></a>字符串与buffer互转</h4><pre><code>1、字符串转buffer

    let buf = new Buffer(&apos;sss&apos;)
    console.log(buf);            // &lt;Buffer 73 73 73&gt;


2、toString(编码, 获取开始位置 , 获取结束位置): buffer转换成字符串

    let buf = Buffer.from(&apos;sss&apos;);
    console.log(buf);            // Buffer e7 be 8e e5 a5 bd  输出的6个字符
    console.log(buf.length);    // 6 buffer的长度
    console.log(&apos;输出buffer: &apos;, buf.toString(&apos;utf-8&apos;, 3, 6));    // 输出好     
</code></pre><h4 id="length-获取长度"><a href="#length-获取长度" class="headerlink" title="length 获取长度"></a>length 获取长度</h4><pre><code>let buf = new Buffer(&apos;sssss&apos;);
console.log(buf.length);     // 5
</code></pre><h4 id="concat-要合并的数据集合-要输出的长度-合并"><a href="#concat-要合并的数据集合-要输出的长度-合并" class="headerlink" title="concat([ 要合并的数据集合 ], 要输出的长度):  合并"></a>concat([ 要合并的数据集合 ], 要输出的长度):  合并</h4><pre><code>let buf1 = new Buffer(&apos;忍&apos;);
let buf2 = new Buffer(&apos;者&apos;);
let buf3 = new Buffer(&apos;神&apos;);
let buf4 = new Buffer(&apos;龟&apos;);

let newBuf = Buffer.concat([buf1, buf2, buf3, buf4]);
console.log(newBuf);                // 12字节
console.log(newBuf.toString());     // 输出忍者神龟
</code></pre><h4 id="slice-start-end-截取"><a href="#slice-start-end-截取" class="headerlink" title="slice(start, end): 截取"></a>slice(start, end): 截取</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
console.log(buf.slice(9, 15).toString());        // 返回 截取
</code></pre><h4 id="copy-buffer-开始目标位置-start-end-拷贝"><a href="#copy-buffer-开始目标位置-start-end-拷贝" class="headerlink" title="copy(buffer, 开始目标位置, start, end): 拷贝"></a>copy(buffer, 开始目标位置, start, end): 拷贝</h4><pre><code>let buf = new Buffer(&apos;怎么来截取buffer中的字符&apos;);
let copyBuf = new Buffer(9);
buf.copy(copyBuf, 6, 0, 9);     // 从buf的第六个字节开始,0到9字符copy

console.log(copyBuf.toString());        // 输出 来截取
</code></pre><h4 id="Buffer-byteLength-判断字符的长度"><a href="#Buffer-byteLength-判断字符的长度" class="headerlink" title="Buffer.byteLength:  判断字符的长度"></a>Buffer.byteLength:  判断字符的长度</h4><h4 id="toString-Buffer转字符串"><a href="#toString-Buffer转字符串" class="headerlink" title="toString() Buffer转字符串"></a>toString() Buffer转字符串</h4><pre><code>toString([字符编码], [开始转换位置], [结束转换位置])

let buf = new Buffer(&apos;哈哈哈&apos;);
console.log(buf.toString(&apos;utf8&apos;));        // urt8输出为 哈哈哈

可以转换成:  ascii、utf8、utf16le、ucs2、base64
</code></pre><h4 id="compare-比较buffer"><a href="#compare-比较buffer" class="headerlink" title="compare() 比较buffer"></a>compare() 比较buffer</h4><pre><code>返回比较结果: 0 两个buffer相等， -1 前者小于后者， 1 前者大于后者

const bufA = new Buffer(&apos;123345&apos;);
const bufB = new Buffer(&apos;123345aaaaa&apos;);
const result = bufA.compare(bufB);

switch(result){
    case -1: 
        console.log(`bufA 小于 bufB`);
        break;

    case 0: 
        console.log(`bufA 等于 bufB`);
        break;

    case 1: 
        console.log(`bufA 大于 bufB`);
        break;

    default: break;
}
</code></pre><h4 id="fill-用指定的值来填充Buffer"><a href="#fill-用指定的值来填充Buffer" class="headerlink" title="fill() 用指定的值来填充Buffer"></a>fill() 用指定的值来填充Buffer</h4><pre><code>fill(val,[offset], [end], [encode]): 用指定的值来填充Buffer

Example:
    let buf = new Buffer(5);    
    buf.fill(&apos;#&apos;);
    console.log(buf);
</code></pre><p>/<strong><strong><strong>**</strong></strong></strong> 查找与搜索  <strong><strong><strong>*</strong></strong></strong>/</p>
<h4 id="indexOf-返回指定字符所在Buffer的位置"><a href="#indexOf-返回指定字符所在Buffer的位置" class="headerlink" title="indexOf() 返回指定字符所在Buffer的位置"></a>indexOf() 返回指定字符所在Buffer的位置</h4><pre><code>let buf = new Buffer(&apos;aabbbccc&apos;);
console.log(buf.indexOf(&apos;b&apos;));      // 返回2 如果不存在返回-1
</code></pre><h4 id="lastIndexOf-从尾查找所在的位置"><a href="#lastIndexOf-从尾查找所在的位置" class="headerlink" title="lastIndexOf() 从尾查找所在的位置"></a>lastIndexOf() 从尾查找所在的位置</h4><h4 id="includes-val-返回指定字符是否存在"><a href="#includes-val-返回指定字符是否存在" class="headerlink" title="includes(val) 返回指定字符是否存在"></a>includes(val) 返回指定字符是否存在</h4><pre><code>includes(搜索的值, [buf开始搜索的位置], [搜索的编码])

Example:
    let buf = new Buffer(&apos;aaabbbcccddd&apos;);
    console.log(buf.includes(&apos;b&apos;, 2));     // true 或  false
</code></pre><h4 id="keys-把buffer中的数组下标"><a href="#keys-把buffer中的数组下标" class="headerlink" title="keys() 把buffer中的数组下标"></a>keys() 把buffer中的数组下标</h4><pre><code>const buf = new Buffer(&apos;buffer&apos;);
console.log(buf)

for(const key of buf.keys()){
    console.log(key);            // 0、1、2、3、4、5
}
</code></pre><h4 id="write-将值写入到buffer的指定位置"><a href="#write-将值写入到buffer的指定位置" class="headerlink" title="write() 将值写入到buffer的指定位置"></a>write() 将值写入到buffer的指定位置</h4><pre><code>write(string, [写入的位置], [写入的字节], [字符编码])
</code></pre><h4 id="Buffer-isBuffer-判断是否是Buffer"><a href="#Buffer-isBuffer-判断是否是Buffer" class="headerlink" title="Buffer.isBuffer() 判断是否是Buffer"></a>Buffer.isBuffer() 判断是否是Buffer</h4><pre><code>let str = &apos;&apos;;
let buf = new Buffer(10);
console.log(Buffer.isBuffer(str));      // false
console.log(Buffer.isBuffer(buf));      // true
</code></pre><h4 id="Buffer-isEncoding-endcode-判断编码"><a href="#Buffer-isEncoding-endcode-判断编码" class="headerlink" title="Buffer.isEncoding(endcode): 判断编码"></a>Buffer.isEncoding(endcode): 判断编码</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/03/nodeJS（之六）QueryString/">nodeJS（之六）Querystring</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/03/nodeJS（之六）QueryString/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-03T07:54:45.000Z" itemprop="datePublished">2017-03-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="parse-str-sep-eq-options-解析url的查询字符串"><a href="#parse-str-sep-eq-options-解析url的查询字符串" class="headerlink" title="parse(str, [sep], [eq], [options]) 解析url的查询字符串"></a>parse(str, [sep], [eq], [options]) 解析url的查询字符串</h4><pre><code>var param = &apos;user=siguang&amp;age=30&apos;;
qs.parse(param).user;    // &apos;siguang&apos;
</code></pre><h4 id="stringify-obj-sep-eq-将对象转成url的参数字符串"><a href="#stringify-obj-sep-eq-将对象转成url的参数字符串" class="headerlink" title="stringify(obj, [sep], [eq])  将对象转成url的参数字符串"></a>stringify(obj, [sep], [eq])  将对象转成url的参数字符串</h4><pre><code>const obj = {name: &apos;一介布衣&apos;, url: &apos;http://yijiebuyi.com&apos;};
const param = querystring.stringify(obj);
console.log(param);            // name=%E4%B8%80%E4%BB%8B%E5%B8%83%E8%A1%A3&amp;url=http%3A%2F%2Fyijiebuyi.com

qs.stringify({foo: &apos;bar&apos;, baz: &apos;qux&apos;}, &apos;;&apos;, &apos;:&apos;)
// 返回 &apos;foo:bar;baz:qux&apos;
</code></pre><h4 id="escape-str-字符进行编码"><a href="#escape-str-字符进行编码" class="headerlink" title="escape(str) 字符进行编码"></a>escape(str) 字符进行编码</h4><pre><code>let url = &apos;https://github.com/siguang1983&apos;;
console.log(qs.escape(url));        // https%3A%2F%2Fgithub.com%2Fsiguang1983
</code></pre><h4 id="unescape-str-字符进行解码"><a href="#unescape-str-字符进行解码" class="headerlink" title="unescape(str) 字符进行解码"></a>unescape(str) 字符进行解码</h4><pre><code>let code = &apos;https%3A%2F%2Fgithub.com%2Fsiguang1983&apos;;
console.log(qs.unescape(url));        // https://github.com/siguang1983
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/02/nodeJS（之七）URL/">nodeJS（之七）URL</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/02/nodeJS（之七）URL/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-02T10:05:25.000Z" itemprop="datePublished">2017-03-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| URL 用于URL的处理和解析<br>| const url = require(‘url’)    // 引用</p>
<h4 id="href-解析后的完整url"><a href="#href-解析后的完整url" class="headerlink" title="href 解析后的完整url"></a>href 解析后的完整url</h4><pre><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;
</code></pre><h4 id="protocol-返回协议-‘http’"><a href="#protocol-返回协议-‘http’" class="headerlink" title="protocol 返回协议 ‘http’"></a>protocol 返回协议 ‘http’</h4><h4 id="host-返回主机和端口"><a href="#host-返回主机和端口" class="headerlink" title="host 返回主机和端口"></a>host 返回主机和端口</h4><h4 id="auth-返回-URL-的用户名与密码部分"><a href="#auth-返回-URL-的用户名与密码部分" class="headerlink" title="auth 返回 URL 的用户名与密码部分"></a>auth 返回 URL 的用户名与密码部分</h4><h4 id="hostname-主机"><a href="#hostname-主机" class="headerlink" title="hostname 主机"></a>hostname 主机</h4><h4 id="port-端口"><a href="#port-端口" class="headerlink" title="port 端口"></a>port 端口</h4><h4 id="pathname-URL的整个路径部分"><a href="#pathname-URL的整个路径部分" class="headerlink" title="pathname URL的整个路径部分"></a>pathname URL的整个路径部分</h4><h4 id="search-获取url参数-‘-query-string’-包括-号"><a href="#search-获取url参数-‘-query-string’-包括-号" class="headerlink" title="search 获取url参数 ‘?query=string’  包括?号"></a>search 获取url参数 ‘?query=string’  包括?号</h4><h4 id="path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’"><a href="#path-返回url和参数不包括协议和主机-‘-p-a-t-h-query-string’" class="headerlink" title="path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’"></a>path 返回url和参数不包括协议和主机 ‘/p/a/t/h?query=string’</h4><h4 id="query-返回参数对象返回-‘query-string’-or-‘query’-‘string’"><a href="#query-返回参数对象返回-‘query-string’-or-‘query’-‘string’" class="headerlink" title="query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}"></a>query 返回参数对象返回 ‘query=string’ or {‘query’: ‘string’}</h4><h4 id="hash-返回hash部分-‘-’"><a href="#hash-返回hash部分-‘-’" class="headerlink" title="hash 返回hash部分 ‘#’"></a>hash 返回hash部分 ‘#’</h4><h4 id="url-format-urlObject-根据对象构建一个路径"><a href="#url-format-urlObject-根据对象构建一个路径" class="headerlink" title="url.format(urlObject) 根据对象构建一个路径"></a>url.format(urlObject) 根据对象构建一个路径</h4><pre><code>var obj = { 
    protocol: &apos;https&apos;,
    host: &apos;www.sss.com:4000&apos;,
    pathname: &apos;index&apos; 
}
url.format(obj)
//returns &apos;https://www.sss.com:4000/index&apos;
</code></pre><h4 id="parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符"><a href="#parse-urlString-parseQueryString-slashesDenoteHost-返回url的一些信息-querystring为true使用querstring模块来解析url中的查询字符" class="headerlink" title="parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符"></a>parse(urlString[, parseQueryString[, slashesDenoteHost]]) 返回url的一些信息, querystring为true使用querstring模块来解析url中的查询字符</h4><pre><code>exports.createServer2 = function(){
    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url);
        console.log(&apos;路径&apos;, oUrl);               
    });

    server.listen(8081, &apos;localhost&apos;);
}

返回：
{
    protocol: null,            // 协议 http
    slashes: null,
    auth: null,                // 身份
    host: null,                // 主机    
    port: null,                // 端口
    hostname: null,            // 主机名
    hash: null,
    search: null,
    query: null,            // 查询参数或者使用querystring.parse() 返回{username:&apos;siguang&apos;};
    pathname: &apos;/apples/&apos;,    // 路径名
    path: &apos;/apples/&apos;,        // 路由
    href: &apos;/apples/&apos;         // 链接
}
</code></pre><h4 id="resolve-from-to-两个网址拼接"><a href="#resolve-from-to-两个网址拼接" class="headerlink" title="resolve(from, to) 两个网址拼接"></a>resolve(from, to) 两个网址拼接</h4><pre><code>url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;
</code></pre><h4 id="slashes"><a href="#slashes" class="headerlink" title="slashes"></a>slashes</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之九）Connect中间件/">nodeJS（之九）Connect中间件</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之九）Connect中间件/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><pre><code>Connect是HTTP服务的中间件

$ 安装 npm i connect --save


// 引用模块
var connect = require(&apos;connect&apos;);

// 创建服务器
var server = connect.createServer();

// 处理静态文件
server.use(connect.static(__dirname + &apos;/statice&apos;));     // connect.static 静态文件目录

// 监听
server.listen(3000);
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>1、静态目录设置 -  server.use(connect.static(__dirname + &apos;/statice&apos;));

2、客户端缓存时间 -  server.use(connect.static(__dirname + &apos;/statice&apos;), {maxAge: 100000});

3、静态文件以&quot;.&quot;开始都认为是隐藏文件 - server.use(connect.static(__dirname + &apos;/statice&apos;), {hidden: true});

4、query中间件，解析字符串  &apos;/posts?page=5&apos;

    server.use(connect.query);
    server.use(function(req, res){
        let page = req.query.page;
    })

5、logger，打印日志，四种日志格式，default/dev/short/tiny

    connect.createServer(
        connect.logger(&apos;dev&apos;),
        function(req, res){
            res.writeHead(200);
            res.end(&apos;hello);
        }
    )

7、body parser  文件上传
</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><pre><code>使用cookieParser()

// cookie: secret1=val1; secret2=val2

server.use(cookieParser());
server.use(function(req, res){
    let ser1 = req.cookies.secret1;
    let ser2 = req.cookies.secret2;
})
</code></pre><h4 id="session-会话"><a href="#session-会话" class="headerlink" title="session 会话"></a>session 会话</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之五）Path/">nodeJS基 (之五) Path模块</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之五）Path/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| baseName() - 返回文件名，带扩展<br>| dirname() - 返回一个指定的绝对路径<br>| join() - 两个路径进行拼接<br>| extname() - 返回文件的扩展名<br>| isAbsolute() - 是否是一个绝对路径<br>| resolve() - 把路径解析成一个绝对路径<br>| format() - 从配置中返回一个路径<br>| parse() - 拆分一个路径，与format相反</p>
<h4 id="baseName-返回文件名-带扩展名"><a href="#baseName-返回文件名-带扩展名" class="headerlink" title="baseName(): 返回文件名(带扩展名)"></a>baseName(): 返回文件名(带扩展名)</h4><pre><code>let name = path.basename(&apos;./resource/haha.txt&apos;, &apos;.txt&apos;);    // 返回 haha
let allName = path.basename(&apos;./resource/haha.txt&apos;);         // 返回 haha.txt
</code></pre><h4 id="dirname-返回一个path目录"><a href="#dirname-返回一个path目录" class="headerlink" title="dirname() 返回一个path目录"></a>dirname() 返回一个path目录</h4><pre><code>let pathName = path.dirname(&apos;./&apos;);
console.log(pathName, __dirname);
</code></pre><h4 id="extname-fileStr-返回文件的扩展名"><a href="#extname-fileStr-返回文件的扩展名" class="headerlink" title="extname(fileStr) 返回文件的扩展名"></a>extname(fileStr) 返回文件的扩展名</h4><pre><code>let extension = path.extname(&apos;权限申请.xlsx&apos;);
console.log(extension);        // .xlsx
</code></pre><h4 id="isAbsolute-path-判断path是否是一个绝对路径"><a href="#isAbsolute-path-判断path是否是一个绝对路径" class="headerlink" title="isAbsolute(path) 判断path是否是一个绝对路径"></a>isAbsolute(path) 判断path是否是一个绝对路径</h4><pre><code>var absolutePath =  path.isAbsolute(&apos;./ss&apos;);
var notAbsolutePath = path.isAbsolute(&apos;/Users/apple/&apos;)
console.log(absolutePath);      // false
console.log(notAbsolutePath);   // true
</code></pre><h4 id="join-paths-多个路径拼接成一个路径"><a href="#join-paths-多个路径拼接成一个路径" class="headerlink" title="join(paths) 多个路径拼接成一个路径"></a>join(paths) 多个路径拼接成一个路径</h4><pre><code>let pathStr = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;);
let parentDirectory = path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;bar/asdf&apos;, &apos;quux&apos;, &apos;..&apos;);    // ..减少一级目录
console.log(pathStr);           // /foo/bar/bar/asdf/quux
console.log(parentDirectory);   // /foo/bar/bar/asdf
</code></pre><h4 id="resolve-p1-p2-把路径解析为一个绝对路径"><a href="#resolve-p1-p2-把路径解析为一个绝对路径" class="headerlink" title="resolve(p1, p2) 把路径解析为一个绝对路径"></a>resolve(p1, p2) 把路径解析为一个绝对路径</h4><pre><code>var newPath = path.resolve(__dirname, &apos;sss.txt&apos;);
console.log(newPath);
</code></pre><h4 id="format-pathobject-从配置对象返回一个路径字符串"><a href="#format-pathobject-从配置对象返回一个路径字符串" class="headerlink" title="format(pathobject) 从配置对象返回一个路径字符串"></a>format(pathobject) 从配置对象返回一个路径字符串</h4><pre><code>let basePath = path.format({
    root: &apos;/book&apos;,
    dir: &apos;/home/user/dir&apos;,
    base: &apos;file.txt&apos;
})
console.log(basePath);      // output -&gt;  /home/user/dir/file.txt
</code></pre><h4 id="parse-path-将一个路径拆分与format相反"><a href="#parse-path-将一个路径拆分与format相反" class="headerlink" title="parse(path) 将一个路径拆分与format相反"></a>parse(path) 将一个路径拆分与format相反</h4><pre><code>let pathStr = path.parse(__dirname);
console.log(pathStr);
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之八）HTTP/">nodeJS（之八）HTTP</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之八）HTTP/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h4><pre><code>let http = require(&apos;http&apos;);        // 导入http模块

HTTP协议构建就是在请求和响应上，由http.ServerRequest和http.ServerResponse构造出来的。
</code></pre><h4 id="http-server类"><a href="#http-server类" class="headerlink" title="http.server类"></a>http.server类</h4><pre><code>是一个创建服务的类 ServerRequest()

方法:

    1、close([callback]): 停止服务器连接

    2、listen(path, [callback]): 侦听, 与TCP使用方法相同

属性:

    1、listening: 返回是否在监听连接服务器的布尔值

    2、maxHeadersCount: 限制最大的请求头数据，默认2000

    3、keepAliveTimeout

    3、setTimeout(msecs, callback): 为socket设置超时值，如果一个超时发生

事件

    1、connect - 请求时触发


Example:

    const HOST = &apos;127.0.0.1&apos;;
    const PORT = 3000;

    // 创建服务器
    let server = http.createServer((req, res) =&gt; {
        console.log(&apos;请求方法:&apos;, request.method);       // 请求方法
        console.log(&apos;请求url:&apos;, request.url);          // 请求url
        console.log(&apos;请求头:&apos;, request.headers);       // 请求头

        res.writeHead(200);
        res.end(&apos;hello world&apos;);    
    })            

    // 侦听3000端口
    server.listen(PORT, HOST, ()=&gt; {
        console.log(`server running at http://${hostname}:${port}`);
    })
</code></pre><h4 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h4><pre><code>url - 返回url地址

method - 返回请求方法
</code></pre><h4 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h4><pre><code>// 这里res返回的就是ServerResponse类
const server = http.createServer((req, res) =&gt; { ..... });   

方法:

    1、addTrailers(headers)

    2、end([data],[encoding],[callback]) - 告诉服务器所有响应头和主体都已被发送，等同于response.write()

    3、finished: 

    4、getHeader(name): 

    5、headersSent: 返回消息头是否被发送，发送为true否则false

    6、removeHeader(name): 移出一个头消息 response.removeHeader(&apos;Content-Encoding&apos;);

    7、sendDate: 如果设置为true消息头存在日期消息头则自动生成并且响应在发送

    8、setHeader(name, value): 设置头信息

        response.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);
        response.setHeader(&apos;Set-Cookie&apos;, [&apos;type=ninja&apos;, &apos;language=javascript&apos;]);

    9、setTimeout(msecs, callback): 设置 socket 的超时时间

    10、statusCode: 设置向客户端响应的状态码  res.statusCode = 200;

    11、statusMessage

    12、write(chunk[, encoding][, callback])

    13、writeContinue()

    14、writeHead(statusCode[, statusMessage][, headers]): 发送一个响应头给请求

        writeHead(状态码, [状态消息], {响应头信息})

        Example: res.writeHead(200, { content-Type: &apos;text/html&apos;, Connection: &apos;keep-alive&apos;})

    15、setEncoding(编码): 设置编码格式 res.setEncoding(&apos;utf8&apos;);


res.connection

事件:

    1、close - 关闭连接，会自动调用response.end();

    2、finish - 当响应已被发送时触发
</code></pre><h4 id="http-IncomingMessage-类"><a href="#http-IncomingMessage-类" class="headerlink" title="http.IncomingMessage 类"></a>http.IncomingMessage 类</h4><pre><code>const server = http.createServer((req, res) =&gt; { ..... });  就是req返回的类

1、headers: 客户端的请求头

2、method: 获取请求方式

3、url: 请求url

4、statusCode: 状态码

5、statusMessage: 状态消息

6、socket: 与连接有关的 net.Socket 对象。

7、destroy([error])

8、httpVersion: http的版本

9、rawHeaders

10、rawTrailers

11、setTimeout(msecs, callback)

12、trailers
</code></pre><h4 id="http-createServer-创建server服务"><a href="#http-createServer-创建server服务" class="headerlink" title="http.createServer(): 创建server服务"></a>http.createServer(): 创建server服务</h4><h4 id="http-get-options-callback-用来模拟客户端向服务器发送请求"><a href="#http-get-options-callback-用来模拟客户端向服务器发送请求" class="headerlink" title="http.get(options, [callback]): 用来模拟客户端向服务器发送请求"></a>http.get(options, [callback]): 用来模拟客户端向服务器发送请求</h4><pre><code>Example： 请求nodejs.org的index.json文件，返回json的内容

const http = require(&apos;http&apos;);

http.get(&apos;http://nodejs.org/dist/index.json&apos;, (res) =&gt; {
    const statusCode = res.statusCode;
    const contentType = res.headers[&apos;content-type&apos;];

    let error;
    if (statusCode !== 200) {
        error = new Error(`请求失败。\n` +
            `状态码: ${statusCode}`);
    } else if (!/^application\/json/.test(contentType)) {
        error = new Error(`无效的 content-type.\n` +
            `期望 application/json 但获取的是 ${contentType}`);
    }
    if (error) {
        console.log(error.message);
        // 消耗响应数据以释放内存
        res.resume();
        return;
    }

    res.setEncoding(&apos;utf8&apos;);
    let rawData = &apos;&apos;;
    res.on(&apos;data&apos;, (chunk) =&gt; rawData += chunk);
    res.on(&apos;end&apos;, () =&gt; {
        try {
            let parsedData = JSON.parse(rawData);
            console.log(parsedData);
        } catch (e) {
            console.log(e.message);
        }
    });
}).on(&apos;error&apos;, (e) =&gt; {
    console.log(`错误: ${e.message}`);
});
</code></pre><h4 id="http-request-options-callback-模拟HTTP请求"><a href="#http-request-options-callback-模拟HTTP请求" class="headerlink" title="http.request(options, [callback]): 模拟HTTP请求"></a>http.request(options, [callback]): 模拟HTTP请求</h4><pre><code>options:

    protocol &lt;String&gt; 使用的协议。默认为 &apos;http:&apos;。

    host &lt;String&gt; 请求发送至的服务器的域名或 IP 地址。默认为 &apos;localhost&apos;。

    hostname &lt;String&gt; host 的别名。为了支持 url.parse()，hostname 优于 host。

    family &lt;Number&gt; 当解析 host 和 hostname 时使用的 IP 地址族。 有效值是 4 或 6。当未指定时，则同时使用 IP v4 和 v6。

    port &lt;Number&gt; 远程服务器的端口。默认为 80。

    localAddress &lt;String&gt; 要绑定到网络连接的本地接口。

    socketPath &lt;String&gt; Unix 域 Socket（使用 host:port 或 socketPath 的其中之一）。

    method &lt;String&gt; 一个指定 HTTP 请求方法的字符串。默认为 &apos;GET&apos;。

    path &lt;String&gt; 请求的路径。默认为 &apos;/&apos;。 应包括查询字符串（如有的话）。如 &apos;/index.html?page=12&apos;。 
    当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。

    headers &lt;Object&gt; 一个包含请求头的对象。

    auth &lt;String&gt; 基本身份验证，如 &apos;user:password&apos; 来计算 Authorization 头。

    agent &lt;http.Agent&gt; | &lt;Boolean&gt; 控制 Agent 的行为。 当使用 Agent 是，请求默认为 Connection: keep-alive。 可能的值有：
    undefined (默认): 对该主机和端口使用 http.globalAgent。

    Agent 对象：显式地使用传入的 Agent。

    false: 不对连接池使用 Agent，默认请求 Connection: close。

    createConnection &lt;Function&gt; 当不使用 agent 选项时，产生一个用于请求的 socket/stream 的函数。 这可以用于避免创建一个自定义的 Agent 类，只是为了覆盖默认的 createConnection 函数。详见 agent.createConnection()。

    timeout &lt;Integer&gt;: 一个数值，指定 socket 超时的毫秒数。 它会在 socket 被连接时设置超时。


Example:

    var postData = querystring.stringify({
            &apos;msg&apos; : &apos;Hello World!&apos;
        });

    var options = {
        hostname: &apos;www.google.com&apos;,
        port: 80,
        path: &apos;/upload&apos;,
        method: &apos;POST&apos;,
        headers: {
            &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,
            &apos;Content-Length&apos;: Buffer.byteLength(postData)
        }
    };

    var req = http.request(options, (res) =&gt; {
        console.log(`STATUS: ${res.statusCode}`);
        console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
        res.setEncoding(&apos;utf8&apos;);
        res.on(&apos;data&apos;, (chunk) =&gt; {
            console.log(`主体: ${chunk}`);
        });
        res.on(&apos;end&apos;, () =&gt; {
            console.log(&apos;响应中已无数据。&apos;);
        });
    });

    req.on(&apos;error&apos;, (e) =&gt; {
        console.log(`请求遇到问题: ${e.message}`);
    });

    // 写入数据到请求主体
    req.write(postData);
    req.end();
</code></pre><h4 id="http概念"><a href="#http概念" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、请求方法:

    Get: 请求从服务器获取数据，没有请求体，不会影响服务器数据

    Post: 从服务器获取数据，有请求体，会影响服务器端的数据

    DELETE: 从服务器删除资源

    HEAD: 向服务器获取响应头，不要响应体

    PUT: 要新的服务器一个资源

    OPTIONS: 获取服务器支持的方法


2、文件类型 Content-type

    html: text/html

    ASCII文本: text/plain

    jpeg图片: image/jpeg

    GIF图片: image/gif

    javascript: text/javascript

    css: text/css

    表单: application/x-www-form-urlencoded



# 获取 index.html 文件内容返回给客户端

    var http = require(&apos;http&apos;);
    var fs = require(&apos;fs&apos;);

    exports.createServer2 = function(){
        var server = http.createServer(function(request, response){

            var url = request.url;

            // 获取 index.html 文件内容返回给客户端
            fs.readFile(&apos;./index.html&apos;, &apos;utf-8&apos;, function(err, data){
                console.log(err, data);

                response.write(data);
                response.end();
            })
        });

        server.listen(8081, &apos;localhost&apos;);
    }


# 处理Get请求的参数

    var server = http.createServer(function(request, response){
        var oUrl = url.parse(request.url, true);

        console.log(oUrl.query);        // { username: &apos;siguang&apos;, age: &apos;30&apos; }

        var urlQuery = oUrl.query;
        if(urlQuery){
            response.write(&apos;服务器接收GET请求参数成功\n&apos;)
            response.write(&apos;用户名:&apos;+ urlQuery.username +&apos;\n&apos;);
            response.write(&apos;年级:&apos;+ urlQuery.age +&apos;\n&apos;);
        }
        else{
            response.write(&apos;服务器接收参数失败&apos;);
        }
        response.end();
    });

    server.listen(8081, &apos;localhost&apos;);


# 处理POST请求

    if(urlObj.pathname == &apos;/register&apos;){           // 处理 &apos;/clock&apos; 的请求
        var str = &apos;&apos;;
        var userList = {};

        // 通过on来侦听 data事件, data事件就是接收客户端传输过来的事件, 用可接收post的数据
        request.on(&apos;data&apos;, function(data){
            console.log(data.toString());          // 返回的是 Buffer
            str += data.toString();
        })

        // 所有接收完成后处理接收数据
        request.on(&apos;end&apos;, function(data){
            userList = JSON.parse(str);

            response.writeHead(&apos;200&apos;, {&apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;});
            if(userList.username == &apos;aaa&apos; &amp;&amp; userList.password == &apos;ssssss&apos;){
                 response.end(JSON.stringify({&quot;res&quot;:true,&quot;message&quot;:&quot;注册成功&quot;}));        // 这里一定要用JSON.stringify来转成串
            }
            else{
                response.end(JSON.stringify({&apos;res&apos;:false,&apos;message&apos;:&apos;注册失败&apos;}));
            }
            response.end();
        })
    }

    注意：

        1、客户端发送ajax请求时

            如果data是字符串，接收过来就是 &apos;{&apos;username&apos;: &apos;aaa&apos;, &apos;password&apos;: &apos;ssssss&apos;}&apos; 字符串可以直接转成json,

            如果data传的是一个对象，jquery会转成&quot;{&apos;username&apos;=&apos;aaa&apos;&amp;&apos;password&apos;=&apos;ssssss&apos;}&quot;, 还需要node重组
</code></pre><h4 id="http概念-1"><a href="#http概念-1" class="headerlink" title="http概念"></a>http概念</h4><pre><code>1、up 工具 通过nodeAPI来监听文件或目录下所有文件，如果有文件改变不需要重启服务器

    $ sudo npm i up -g   

    运行命令: up -watch -port 8080 server.js 
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之一）Global全局/">nodeJS基 (之一) Global全局对象</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之一）Global全局/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| <strong>filename - 前当文件名<br>| </strong>dirname - 当前所在的目录<br>| setTimeout、clearTimeout - 定时器<br>| setInterval、clearInterval - 定时器<br>| console - 打印到控制台<br>| process - 进程<br>| exports、require() - 导入、导出<br>| </p>
<h4 id="dirname-当前的绝对路径"><a href="#dirname-当前的绝对路径" class="headerlink" title="__dirname  当前的绝对路径"></a>__dirname  当前的绝对路径</h4><h4 id="filename-当前文件名"><a href="#filename-当前文件名" class="headerlink" title="__filename  当前文件名"></a>__filename  当前文件名</h4><h4 id="exports-暴露接口"><a href="#exports-暴露接口" class="headerlink" title="exports  暴露接口"></a>exports  暴露接口</h4><h4 id="require-引入模板"><a href="#require-引入模板" class="headerlink" title="require()  引入模板"></a>require()  引入模板</h4><pre><code>1、模块分为

    模块加载：require(&apos;2.js&apos;);

    1）内置模块:  var fs = require(&apos;fs&apos;);        // 加载Node的内置模块 fs文件系统

    2）文件模块: 自己定义的业务模块

        定义一个food.common.js

        var food = reuqire(&apos;./js/food.common&apos;);        // 加载业务模块

    3）加载第三方模块

        require(&apos;./2&apos;);        // 先按照加载的模块文件进行查找，如果没有找到会在文件名加上.js


2、绝对和相对路径

    var fs = require(&apos;fs&apos;);        // 绝对路径，是在Node通过内部的node_modules查找到的模块

    var moduleA = reuqire(&apos;./lib/moduleA&apos;);        // 相对路径


2、npm 全局安装和局部安装

    1）全局安装会安装到Node目录中，各项目都可以使用 npm install -g gulp

    2）局部安装，将一个模块安装到node_modules中，只在当前和子目录中使用


require.cache
require.resolve()
</code></pre><h4 id="global-全局对象"><a href="#global-全局对象" class="headerlink" title="global  全局对象"></a>global  全局对象</h4><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><pre><code>module和exports两个全局变量

1）module：每个模块下都包括module对象

    Module {
        id: &apos;.&apos;,
        exports: {},
        parent: null,
        filename: &apos;/Users/apple/siguang.liu/nodeProject/server.js&apos;,
        loaded: false,
        children: [],
        paths: [
            &apos;/Users/apple/siguang.liu/nodeProject/node_modules&apos;,
            &apos;/Users/apple/siguang.liu/node_modules&apos;,
            &apos;/Users/apple/node_modules&apos;,
            &apos;/Users/node_modules&apos;,
            &apos;/node_modules&apos;
        ]
     }

 2）exports外部接口，通过require就可以调用这个接口

     其实exports就是module.exports的引用

    exports.name = &apos;siguang&apos;;
    exports.getPrivate = function(){
        return &apos;haha&apos;;
    }
</code></pre><h4 id="process-进程"><a href="#process-进程" class="headerlink" title="process  进程"></a>process  进程</h4><h4 id="console-打印到控制台"><a href="#console-打印到控制台" class="headerlink" title="console 打印到控制台"></a>console 打印到控制台</h4><pre><code>log()、info()、error()、warn()、time()、timeEnd()
</code></pre><h4 id="setImmediate-callback-…args-、clearImmediate-immediateObject"><a href="#setImmediate-callback-…args-、clearImmediate-immediateObject" class="headerlink" title="setImmediate(callback[, …args])、clearImmediate(immediateObject)"></a>setImmediate(callback[, …args])、clearImmediate(immediateObject)</h4><h4 id="setInterval-、clearInterval"><a href="#setInterval-、clearInterval" class="headerlink" title="setInterval()、clearInterval()"></a>setInterval()、clearInterval()</h4><h4 id="setTimeout-、clearTimeout"><a href="#setTimeout-、clearTimeout" class="headerlink" title="setTimeout()、clearTimeout()"></a>setTimeout()、clearTimeout()</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJS（之十）TCP/">nodeJS（之十）TCP</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJS（之十）TCP/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><pre><code>NodeJS中有三种socket: 1、TCP   2、UDP   3、Unix域套接字

TPC套接字分为: 服务端和客户端

    服务端TCP监听来自客户端的连接请求，并使用TCP连接向客户端发送数据；客户端TCP连接到服务端并与服务器交互数据。客户端与服务端之间依靠套接字进行双向通信。

1、引用TCP模块

    const net = require(&apos;net&apos;);
    const PROT = 6969;

2、HTTP模块也是继承TCP模块
</code></pre><h4 id="net-Server类"><a href="#net-Server类" class="headerlink" title="net.Server类"></a>net.Server类</h4><pre><code>1、createServer() 创建tcp服务器

2、close() - 关闭

3、listen() - 侦听

    const HOST = &apos;127.0.0.1&apos;;
    const PORT = 6969;

    // 写法1 
    let server = net.crateServer(function(conn){
        ...
    });
    server.listen({host: HOST, port: PORT}, function(){    // 或 server.listen(PORT, HOST, function(){
        console.log(&apos;这里是异步的&apos;);
    });

    // 写法2
    let server = net.crateServer(function(conn){
        ...
    }).listen(PORT, HOST);


4、address() - 返回绑定的IP端口等信息 {&quot;address&quot;:&quot;::&quot;,&quot;family&quot;:&quot;IPv6&quot;,&quot;port&quot;:6969}

属性

1、listening - server是否正在监听连接

2、maxConnections - 当前server连接数过多时拒绝连接


事件

1、close - 关闭

2、connection - 建立连接时触发

3、error - 错误时触发

4、listening - 服务被绑定后调用
</code></pre><h4 id="net-Socket类"><a href="#net-Socket类" class="headerlink" title="net.Socket类"></a>net.Socket类</h4><h4 id="net-connect"><a href="#net-connect" class="headerlink" title="net.connect"></a>net.connect</h4>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/03/01/nodeJs（之二）FileSystem/">nodeJS (之二) FileSystem</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/03/01/nodeJs（之二）FileSystem/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-03-01T15:12:21.000Z" itemprop="datePublished">2017-03-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Node-js/">Node.js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| open() - 打开文件<br>| close() - 关闭文件<br>| stat() - 文件信息<br>| read()、write() - 读文件数据并写入Buffer<br>| readFile()、readFileSync() - 读、写取文件，可以读图片并写出图片，但不能写流文件<br>| createReadStream()、createWriteStream() - 读/写文件流<br>| rename()、renameSync() - 修改文件或目录<br>| ftruncate() - 截断文件<br>| appendFile() - 将数据追加到文件中<br>| mkdir() - 创建/删除目录<br>| rmdir() - 删除空目录<br>| readDir()、readdirSync() - 读取目录下所有文件<br>|<br>| stat() - 文件信息<br>| utimes() - 修改文件时间<br>| watchFile() - 监视文件<br>| access() - 判断文件或目录权限<br>| link() - 硬链接<br>| unlink() - 删除文件链接<br>| symlink() - 符号链接<br>| readlink() - 读取链接源地址<br>| watchFile()、watch() - 侦听文件/文件夹内文件的变化 </p>
<h4 id="fs-模块引用"><a href="#fs-模块引用" class="headerlink" title="fs 模块引用"></a>fs 模块引用</h4><pre><code>var fs = reuqire(&apos;fs&apos;);        // 加载文件模块

文件系统方法有异步和同步两种

1、readFile()与createReadStream()区别

    readFile是整个文件都读取完后在载入内存中，createReadStream()分片来读取内容块，直接读取完成，缓存与文件流的区别
</code></pre><h3 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h3><h4 id="open-异步打开文件"><a href="#open-异步打开文件" class="headerlink" title="open() 异步打开文件"></a>open() 异步打开文件</h4><pre><code>open(文件路径， 打开方式（读/写），设置模式（读4/写2/执行1）, callback(err, fd文件句柄)): 异步打开文件

    打开方式: r 读、 w 写

opensync(): 同步打开文件

Example:

    const fileName = path.resolve(__dirname, &apos;test.txt&apos;);
    fs.open(fileName, &apos;r&apos;, (err, fd) =&gt; {
        console.log(err);
        fs.close();
    })
</code></pre><h4 id="close-关闭一个文件"><a href="#close-关闭一个文件" class="headerlink" title="close() 关闭一个文件"></a>close() 关闭一个文件</h4><pre><code>fs.close(fd, callback)
</code></pre><h4 id="read-指定的文件中读取数据，并写入缓存区buffer"><a href="#read-指定的文件中读取数据，并写入缓存区buffer" class="headerlink" title="read() 指定的文件中读取数据，并写入缓存区buffer"></a>read() 指定的文件中读取数据，并写入缓存区buffer</h4><pre><code>read(fd, buffer, offset, length, position, callback): 读文件

// read(路径, 指定存到的缓存区, buf的开始, buf的结束, 文件读取的起启位置, callback)

Example: 
    var buf = new Buffer(6);
    fs.open(path.resolve(basePath, &apos;append.txt&apos;), &apos;r&apos;, (err, fd) =&gt; {
        if(err){
            console.log(err);
            return false;
        }

        fs.read(fd, buf, 0, buf.length, 3, (err, bytesRead, buffer) =&gt; {
            var str = new Buffer(buffer);
            console.log(str.toString())
            console.log(&apos;bytesRead : &apos; + bytesRead);
        })
    })
</code></pre><h4 id="write-指定的文件中写数据"><a href="#write-指定的文件中写数据" class="headerlink" title="write() 指定的文件中写数据"></a>write() 指定的文件中写数据</h4><pre><code>fs.write(fd, buffer, offset, length, position, callback)
</code></pre><h4 id="readFile-读取文件"><a href="#readFile-读取文件" class="headerlink" title="readFile() 读取文件"></a>readFile() 读取文件</h4><pre><code>readFile(&apos;filename&apos;, [编码方式], callback): 读取文件(异步) , readFileSync同步读取文件

缺点: readFile()是先将数据全部读入内存，文件大时候，读取效率低下，而createReadStream会把文件分割成小块，然后通过事件和来最后得到数据

*注意*: 编码方式不设置返回的是Buffer, 如果设置了utf-8返回的是字符串

Example:
    fs.readFile(&apos;./nodeJS学习笔记.txt&apos;, &apos;utf-8&apos;, function(err, data){
        if(err){
            console.log(&apos;文件读取错误&apos;)
        }
        else{
            var buf = new Buffer(data);        // 将读取到的数据转成Buffer
            console.log(buf.toString());    // 二进制转成字符串
        }                
    })
</code></pre><h4 id="writeFile-向文件写内容"><a href="#writeFile-向文件写内容" class="headerlink" title="writeFile() 向文件写内容"></a>writeFile() 向文件写内容</h4><pre><code>可以使用readFile读图片并写出图片，但不能写流文件

writeFile(filename, data, [flag], callback(err)err不为真写入成功) 向文件写内容，文件不存在自动创建文件

writeFileSync同步

    filename: 路径加文件名, 如果文件不存在会创建一个文件**
    data: 写入的内容可以是字符串或二进制
    flag: 对文件怎么来操作,  &apos;w&apos; 清空后在写入  &apos;a&apos; 将新内容加到之后  {flag: &apos;w&apos;}
    writeFileSync(&apos;文件名&apos;, &apos;内容&apos;): 同步写文件

Example: 
    var writeBuf = new Buffer(writeStr);

    fs.writeFile(&apos;./buffer/file/user.txt&apos;, writeStr, {flag: &apos;a&apos;}, function(err){
        err ? console.log(&apos;文件写入失败&apos;) : console.log(&apos;文件写入成功&apos;);
    })
</code></pre><h4 id="createReadStream-path-options-读取文件流"><a href="#createReadStream-path-options-读取文件流" class="headerlink" title="createReadStream(path, [options]): 读取文件流"></a>createReadStream(path, [options]): 读取文件流</h4><pre><code>fs模块允许你通过Stream来对数据进行读取操作，与readFile、writeFile不同是它对内存分配不是一次完成的.

options:
    { 
        flags: &apos;r&apos;,            // r只读 w写
        encoding: null,        // 字符编码 utf-8
        fd: null,
        mode: 0666,
        autoClose: true,    // 读完数据是否关闭文件描述符
        start: 0,            // 读取流的开始
        end: 300            // 读取流的结束
    }

Example: 
    var fs = require(&apos;fs&apos;);
    var rs = fs.createReadStream(path.resolve(basePath, &apos;test.txt&apos;), {statr:100});
    var str = &apos;&apos;;        // 存储读取的数据

    // 读取数据
    rs.on(&apos;data&apos;, (data)=&gt;{
        str += data;
    })

    // 数据读取完成
    rs.on(&apos;end&apos;, ()=&gt;{
        console.log(&apos;读取完成&apos;)
        console.log(str);            // 打印出读取数据
    })

    // 读取出错
    rs.on(&apos;error&apos;, (err) =&gt; {
        console.log(err);
    })
</code></pre><h4 id="createWriteStream-文件路径-options-可写数据流"><a href="#createWriteStream-文件路径-options-可写数据流" class="headerlink" title="createWriteStream(文件路径, {options}): 可写数据流"></a>createWriteStream(文件路径, {options}): 可写数据流</h4><pre><code>write(): 写入内容, 把文件内容清空后在写入

end(): 关闭写入

    var fs = require(&apos;fs&apos;);
    var ws = fs.createWriteStream(&apos;./files/stream.txt&apos;);

    // 写入内容
    ws.write(&apos;内容加入到文件中&apos;, &apos;utf-8&apos;, function(){
        console.log(arguments);
    })
    ws.end(function(){

    })
</code></pre><h4 id="rename-修改文件或目录名"><a href="#rename-修改文件或目录名" class="headerlink" title="rename() 修改文件或目录名"></a>rename() 修改文件或目录名</h4><pre><code>rename(oldPath, newPath, callback) 修改文件或目录名, renameSync同步

Example: 
    let oldName = path.resolve(basePath, &apos;newTest.txt&apos;);
    let newName = path.resolve(basePath, &apos;test.txt&apos;);
    fs.rename(oldName, newName, (err) =&gt; {
        if(err){
            console.log(err);
        }
        console.log(&apos;文件名修改成功&apos;)
    })
</code></pre><h4 id="ftruncate-截断文件"><a href="#ftruncate-截断文件" class="headerlink" title="ftruncate() 截断文件"></a>ftruncate() 截断文件</h4><pre><code>ftruncate(文件路径, 第几个字符截断, callback) 截断文件， ftruncateSync同步

一个中文四个字节，英文两个字节

Example: 
    const basePath = __dirname;
    fs.open(path.resolve(basePath, &apos;test.txt&apos;), &apos;r+&apos;, (err, fd)=&gt;{
        if(err){
            console.log(err);
        }
        else{
            fs.truncate(fd, 400, (err)=&gt;{        // 截取四百个字节
                var readNewFile = fs.readFile(fd, &apos;utf8&apos;, (err, data)=&gt;{    // 读取文件
                    var buf = new Buffer(data);
                    console.log(buf.toString(&apos;utf-8&apos;));        //
                    fs.close();
                });
            })
        }
    })
</code></pre><h4 id="appendFile-将数据追加到文件中"><a href="#appendFile-将数据追加到文件中" class="headerlink" title="appendFile(): 将数据追加到文件中"></a>appendFile(): 将数据追加到文件中</h4><pre><code>appendFile(文件名, 加入内容): 异步地追加数据到一个文件，如果文件不存在则创建文件，与writeFile()中设置flag: &apos;a&apos; 一样

Example: 
    fs.appendFile(path.resolve(basePath, &apos;append.txt&apos;), &apos;这是要加入的字符串&apos;, (err) =&gt; {
        console.log(&apos;complate&apos;);
    })
</code></pre><h3 id="二、操作目录"><a href="#二、操作目录" class="headerlink" title="二、操作目录"></a>二、操作目录</h3><h4 id="mkdir-目录名-callback-err-、rmdir-创建-删除目录"><a href="#mkdir-目录名-callback-err-、rmdir-创建-删除目录" class="headerlink" title="mkdir(目录名, callback(err))、rmdir(): 创建/删除目录"></a>mkdir(目录名, callback(err))、rmdir(): 创建/删除目录</h4><pre><code>fs.mkdir(&apos;js/lib&apos;, function(err){        // 可以连续创建子目录， 先创建js，并在js目录下在创建lib目录
    console.log(err)
})
</code></pre><h4 id="rmdir-path-callback-删除空目录"><a href="#rmdir-path-callback-删除空目录" class="headerlink" title="rmdir(path, callback): 删除空目录"></a>rmdir(path, callback): 删除空目录</h4><h4 id="readdir-path-callback-err-files-获取目录下所有文件"><a href="#readdir-path-callback-err-files-获取目录下所有文件" class="headerlink" title="readdir(path, callback(err, files)): 获取目录下所有文件"></a>readdir(path, callback(err, files)): 获取目录下所有文件</h4><pre><code>eaddirSync()同步

files: 将目录下所有文件返回一个数组

fs.readdir(basePath, &apos;utf-8&apos;, (err, files) =&gt; {
    if(err){
        console.log(&apos;文件目录获取失败&apos;, err);
    }
    else{
        files.forEach(function(data){
            var buf = new Buffer(data);
            console.log(buf);       // 输出文件名的二进制
        })
    }
})
</code></pre><h3 id="三、文件权限"><a href="#三、文件权限" class="headerlink" title="三、文件权限"></a>三、文件权限</h3><h4 id="chown-文件所有者变更"><a href="#chown-文件所有者变更" class="headerlink" title="chown() 文件所有者变更"></a>chown() 文件所有者变更</h4><pre><code>fs.chown(文件名,uid,gid,回调函数);
fs.fchown(文件句柄fd,uid,gid,回调函数);
fs.lchown(链接路径,uid,gid,回调函数);    
</code></pre><h4 id="chmod-文件权限变更"><a href="#chmod-文件权限变更" class="headerlink" title="chmod()文件权限变更"></a>chmod()文件权限变更</h4><pre><code>fs.chmod(文件名,mode,回调函数);
fs.fchmod(文件句柄,mode,回调函数);
fs.lchmod(链接路径,mode,回调函数);
</code></pre><h4 id="stat-文件信息"><a href="#stat-文件信息" class="headerlink" title="stat() 文件信息"></a>stat() 文件信息</h4><pre><code>也可以判断文件是否存在

fs.stat(文件路径, 回调函数(err.fs.Stats对象)); 获取文件或目录下的文件详情
fs.fstat(文件句柄fd, 回调函数(err.fs.Stats对象)); 显示文件或文件系统状态
fs.lstat(链接路径, 回调函数(err.fs.Stats对象)); 显示文件或文件系统状态(符号链接)

stat(path, callback(err, stats)): 获取文件详情， statSync同步

    fs.stat(`${dir}/img/readText.txt`, function (err, stats) {
        console.log(stats);                    // stats类
        console.log(stats.isFile());        // true
    })

    stats.isFile() - 是否是文件
    stats.isDirectory() - 是否是目录
    stats.isBlockDevice() - 是否是块设备
    stats.isCharacterDevice() - 是否是是字符
    stats.isSymbolicLink() (仅对 fs.lstat() 有效) - 是否是软链接
    stats.isFIFO() - 是不是FIFO
    stats.isSocket() - 是不是Socket


Example: fileSystem目录下有两个文件， a.txt、main.js

    fs.readdir(&apos;./fileSystem&apos;, function(err, files){
        files.forEach(function(file){
            console.log(file)
            fs.stat(&apos;./fileSystem/&apos;+file, function(erro, stats){
                console.log(&apos;是否是目录:&apos; + stats.isDirectory());
                console.log(&apos;是否是文件:&apos; + stats.isFile());
                console.log(stats);      // 输出所有文件的详情
            })
        })
    })
</code></pre><h4 id="utimes-修改文件时间"><a href="#utimes-修改文件时间" class="headerlink" title="utimes() 修改文件时间"></a>utimes() 修改文件时间</h4><pre><code>fs.utimes(文件路径,访问时间,新建时间,回调函数);
fs.futimes(文件句柄,访问时间,新建时间,回调函数);      
</code></pre><h4 id="watchFile-监视文件"><a href="#watchFile-监视文件" class="headerlink" title="watchFile()监视文件"></a>watchFile()监视文件</h4><pre><code>fs.watchFile(文件名,[options],listener_callback(当前文件的stats,改变前的stats));      
fs.unwatchFile(文件名);
</code></pre><h4 id="access-path-mode-callback-也是判断文件或目录的权限"><a href="#access-path-mode-callback-也是判断文件或目录的权限" class="headerlink" title="access(path, [mode], callback): 也是判断文件或目录的权限"></a>access(path, [mode], callback): 也是判断文件或目录的权限</h4><pre><code>fs.constants.F_OK - path 文件对调用进程可见。 这在确定文件是否存在时很有用，但不涉及 rwx 权限。 如果没指定 mode，则默认为该值。
fs.constants.R_OK - path 文件可被调用进程读取。
fs.constants.W_OK - path 文件可被调用进程写入。
fs.constants.X_OK - path 文件可被调用进程执行。 对 Windows 系统没作用（相当于 fs.constants.F_OK）
</code></pre><h3 id="四、链接文件操作"><a href="#四、链接文件操作" class="headerlink" title="四、链接文件操作"></a>四、链接文件操作</h3><h4 id="创建一个硬链接"><a href="#创建一个硬链接" class="headerlink" title="创建一个硬链接"></a>创建一个硬链接</h4><pre><code>fs.link(srcpath, dstpath, [callback]): 硬链接 

fs.symlink(destination, path, [type], [callback]): 符号链接
</code></pre><h4 id="读取链接指向的路径"><a href="#读取链接指向的路径" class="headerlink" title="读取链接指向的路径"></a>读取链接指向的路径</h4><pre><code>fs.readlink(path, [callback(err,linkstr)]): 读取链接源地址 

fs.unlink(path,[callback]); 删除文件链接
</code></pre><h4 id="watchFile-、watch-侦听文件-文件夹内的文件的变化"><a href="#watchFile-、watch-侦听文件-文件夹内的文件的变化" class="headerlink" title="watchFile()、watch(): 侦听文件/文件夹内的文件的变化"></a>watchFile()、watch(): 侦听文件/文件夹内的文件的变化</h4><pre><code>unwatchFile(): 停止侦听

// 侦听文件
fs.watch(&apos;./buffer/file/password.txt&apos;, {encoding: &apos;buffer&apos;}, (eventType, filename) =&gt; {
    console.log(eventType, filename);
    if (filename){
        console.log(filename);
    }
});

// 向password.txt写内容
fs.writeFile(&apos;./buffer/file/password.txt&apos;, &apos;添加新内容&apos;, {flag: &apos;a&apos;}, function(err, data){
    if(!err){
        console.log(&apos;写入成功&apos;);
    }
})
</code></pre>
        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/tags/Node-js/page/2/">2</a><a class="extend next" rel="next" href="/tags/Node-js/page/2/">Volgende &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
