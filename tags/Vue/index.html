<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Tag: Vue | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/26/VueJS之-“Vuex篇“（四）/">VueJS之-“Vuex篇“（四）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/26/VueJS之-“Vuex篇“（四）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-26T02:40:24.000Z" itemprop="datePublished">2016-10-26</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><pre><code>Vuex借鉴了Flux和Redux设计思想.

优点:
    Vue组件父子之间通过$on、$emit自定义事件来进行通信
    Vuex可以解决同级组件之间无法传递消息
</code></pre><h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h4><pre><code>Store: 定义仓库，包含state对象，组件通过getter从store读取数据，通过Getter

核心模块:

    1、state: 定义存储状态

    2、getter: 对数据进行过滤，获取state数据，在计算属性中获取state的值

    3、mutation: 更改 Vuex 的 store 中的state值的唯一方法是提交 mutation

    4、action: 类似于 mutation，不同在于可以包含任意异步操作，Action通过commit()方法来调用mutation中的方法在改变来改变state的值，而不是直接改变state中的值

            分发Action: store.dispatch()方法触发

    5、modules: 如果应用过大，便可以使用 modules 来分割管理，不至于 store 变得非常臃肿


模块示例详解:

一、state: 

    用来存储数据，如果在组件中获取state中的数据，可以通过两种方法来获取: 计算属性computed 和 Getters

    在组件中显示state值可以通过computed来获取:

        &lt;template&gt;
            &lt;div class=&quot;box&quot;&gt;
                {{getSideData}}
            &lt;/div&gt;
        &lt;/template&gt;

        方法1: 计算属性中获取

        computed: {
            getSideData () {
                return this.$store.state.sideData;            // 当getSideData的值改变就会显示出来
            }
        }


        方法2: mapState函数获取

        import { mapState } from &apos;vuex&apos;;        // 引用mapState()

        export default {
            name: &apos;side&apos;,
            computed: {
                ...mapState({    // 对象展开运算符
                    getSideData: (state) =&gt; {
                        return state.sideData
                    }
                })
            }
        }

        getters.js
            export const sideData = (state) =&gt; {
                return state.sideData;
            } 


2、Getter

    获取state中数据的第二种方法

    getters.js中定义获取state的方法: 

        export const sideData = (state) =&gt; {
            return state.sideData;
        }

    组件中调用

        1）computed方式

            computed: {
                getSideData(){
                    return this.$store.getters.sideData;        // $store.getters下找到定义的sideDap
                }
            }

        2）通过mapGetters获取

            &lt;template&gt;
                &lt;div&gt;{{ getSideData }}&lt;/div&gt;
            &lt;/tempate&gt;

            import { mapState, mapGetters } from &apos;vuex&apos;;

            computed: {
                ...mapGetters({
                    getSideData: &quot;sideData&quot;            // 映射到getters.js中定义的sideData, 并将数据返回给getSideData
                })
            }

3、Mutations

    用来更改Vuex中state的数据，它是同步的

    1、commit()触发Action, Action触发mutation

        定义mutations 

            export default {
                changeSideData(state, sideJson){
                    state.sideData.push(sideJson)
                }
            }

        触发
            methods:{
                addSideData(){
                    let side = {
                        id: 1,
                        name: this.name,
                        introduce: this.introduce
                    }
                    this.$store.commit(&apos;changeSideData&apos;, side);
                }
            }


    2、使用mapMutations() 来定义改变


4、Actions

    Actions提交到 Mutations中，而不能直接改变state的值

    Actions可以包含异步操作，Mutations是同步的

    1）Example

        定义actions

            export const holderSilde = ({commit}, {name, introduce}) =&gt; {    
                // {name, introduce} 这里注意一定对象传过来，这里为解析赋值写法，函数不接收第三个参数
                var side = {
                    id: 1,
                    name: name,
                    introduce: introduce
                }
                commit(&apos;changeSideData&apos;, side)
            }


        调用 分发dispatch

            methods:{
                addSideData(){
                    // 第二个为传过去的参数
                    this.$store.dispatch(&apos;holderSilde&apos;, {name: this.name, introduce: this.introduce});
                }
            }


5、Modules

    Vuex可以将Store分割到各模块，每个模块都有自己的store、mutations、actions、getters

    const moduleA = {
        state: { ... },
        mutations: { ... },
        actions: { ... },
        getters: { ... }
    }

    const moduleB = {
        state: { ... },
        mutations: { ... },
        actions: { ... }
    }

    const store = new Vuex.Store({
        modules: {
            a: moduleA,
            b: moduleB
        }
    })

    store.state.a // -&gt; moduleA 的状态
    store.state.b // -&gt; moduleB 的状态
</code></pre><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><pre><code>1、App.vue:

    &lt;template&gt;
        &lt;div&gt;
            &lt;Display&gt;&lt;/Display&gt;
            &lt;Increment&gt;&lt;/Increment&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import Display from &apos;./components/Display.vue&apos;
        import Increment from &apos;./components/Increment.vue&apos;
        import store from &apos;./vuex/store&apos;

        export default {
            components: {
                Display,
                Increment
            },
            store           // 在根组件加入store
        }
    &lt;/script&gt;

    &lt;style&gt;
    body {
        font-family: Helvetica, sans-serif;
    }
    &lt;/style&gt;


2、Display.vue:

    &lt;template&gt;
        &lt;div&gt;
            &lt;h3&gt;Count is {{ counterValue }}&lt;/h3&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import { getCount } from &apos;../vuex/getters&apos;

        export default {
            vuex: {
                getters: {
                    counterValue: getCount
                }
            }
        }
    &lt;/script&gt;


3、Increment.vue

    &lt;template&gt;
        &lt;div&gt;
        &lt;button @click=&quot;increment&quot;&gt;Increment +1&lt;/button&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import { incrementCounter } from &apos;../vuex/action&apos;

        export default {

            vuex: {
                actions: {
                    increment: incrementCounter
                }
            }

        }
    &lt;/script&gt;


4、main.js

    import Vue from &apos;vue&apos; 
    import App from &apos;./App.vue&apos;

    new Vue({
        el: &apos;body&apos;,
        components: { 
            App
        }
    })


5、store.js

    import Vue from &apos;vue&apos;
    import Vuex from &apos;vuex&apos;

    // 引用vuex
    Vue.use(Vuex);

    // 启动时的初始状态
    const state = {
        // 放置初始化状态
        count: 0
    }

    const mutations = {
        // 放置要变更的函数
        INCREMENT(state, amount){
            state.count = state.count + amount;
        }
    }

    export default new Vuex.Store({
        state,
        mutations
    })


6、action.js

    // action 会收到 store 作为它的第一个参数
    // 既然我们只对事件的分发（dispatch 对象）感兴趣。（state 也可以作为可选项放入）
    // 我们可以利用 ES6 的解构（destructuring）功能来简化对参数的导入
    export const incrementCounter = function ({ dispatch, state }) {
        console.log(dispatch, state)
        dispatch(&apos;INCREMENT&apos;, 1)
    }


7、getter.js

    // 这个 getter 函数会返回 count 的值
    // 在 ES6 里你可以写成: 
    // export const getCount = state =&gt; state.count
    export function getCount(state){
        return state.count;
    }
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/23/VueJS之-“插件篇“（三）/">VueJS 之 “插件篇“（三）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/23/VueJS之-“插件篇“（三）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-23T11:19:24.000Z" itemprop="datePublished">2016-10-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| vue-router 路由插件<br>| vue-validator 表单校验插件<br>| vue-resource ajax插件</p>
<h4 id="外部插件的加载方式"><a href="#外部插件的加载方式" class="headerlink" title="外部插件的加载方式"></a>外部插件的加载方式</h4><pre><code>import Vue from &apos;vue&apos;;                        // 不使用ES6写法: var Vue require(&apos;vue&apos;);      由webpack来解析
import VueValidator from &apos;vue-validator&apos;    // 引用插件

// 注册插件
Vue.use(VueValidator);
</code></pre><h4 id="vue-cli-脚手架"><a href="#vue-cli-脚手架" class="headerlink" title="vue-cli 脚手架"></a>vue-cli 脚手架</h4><pre><code>一、下载

    // 下载最新版本 2.0，一些插件未升级还不能用
    $ npm install -g vue-cli        

    // 下载之前版本 1.0或其它
    $ vue init webpack my-project        // vue init webpack-simple#1.0 mynewproject

    // 下载依赖包
    $ cd my-project 
    $ npm install


二、main.js 入口文件

    import Vue from &apos;vue&apos;
    import chat from &apos;./components/chat.vue&apos;;

    new Vue({
        el: &apos;#app&apos;,
        render: h =&gt; h(chat)         // 调用其它.vue文件必须这么写
    })

    render: h =&gt; h(chat) 相当于

    render: (function (h) {  
          return h(App);
    });  


三、不需要代码校验

    在webpack.base.conf.js里面删掉下面:

    preLoaders: [
        {
            test: /\.vue$/,
            loader: &apos;eslint&apos;,
            include: projectRoot,
            exclude: [/node_modules/, /ignore_lib/]
        },
        {
            test: /\.js$/,
            loader: &apos;eslint&apos;,
            include: projectRoot,
            exclude: [/node_modules/, /ignore_lib/]
        }
    ]


四、配置代理服务器进行跨域

    config/index.js

    proxyTable: {
        &apos;/operate&apos;:{
            target:&apos;http://192.168.2.155:8079&apos;,
            changeOrigin: true,            // 只能设置changeOrigin本地会虚拟一个代理服务端，来解决跨域问题
            pathRewrite:{
                &apos;^/operate&apos;:&apos;/&apos;
            }
        }
    }

    代码里调用的url，例如 /operate/getUsername 就相当于通过代理调用到 http://192.168.2.155:8079/getUsername


五、常用及目录命令

    npm run dev  启动服务   

    npm run build  将开发环境打包到一个dist目录下，用于生产环境

    src: 开发环境目录    static: 静态文件目录
</code></pre><h4 id="vue-router2-路由"><a href="#vue-router2-路由" class="headerlink" title="vue-router2 路由"></a>vue-router2 路由</h4><pre><code>一、安装调用方式

    $ npm install vue-router --save

    html:
        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;
            &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;

            &lt;!-- 加载路由视图 --&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
        &lt;/div&gt;

    js:
        import Vue from &apos;vue&apos;
        import VueRouter from &apos;vue-router&apos;
        import login from &apos;./components/login&apos;

        // 将路由插件加载到Vue中
        Vue.use(VueRouter);

        // 路由映射配置
        const routes = [
            { 
                path: &apos;/login&apos;, 
                component: login
            },
            {
                path: &apos;/*&apos;,
                redirect: &apos;/404&apos;        // 重定向
            }
        ]

        // 创建路由实例
        const router = new VueRouter({
            routes // （缩写）相当于 routes: routes
        })

        // 创建Vue实例
        const app = new Vue({
            el: &apos;#app&apos;,
            router
        })

二、路由设置

    1、 {
            path: &apos;/admin&apos;,
            component: (resolve) =&gt; require([&apos;../views/admin.vue&apos;], resolve),
            children: [   // 子路由
                {
                    path: &apos;sample&apos;,
                    name: &apos;sample&apos;,
                    meta: {
                        requiresAuth: true
                    },
                    component: (resolve) =&gt; require([&apos;../views/contents/pay_router/sample/sampleList.vue&apos;], resolve),
                }
            ]
        }

    2、import main from &apos;../components/main&apos;

        {
            path: &apos;/main&apos;,
            name: &apos;main&apos;,
            component: main
        }

三、动态路由 - 带参数

    $route.params  获取参数

    const User = {
        template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;
    }

    const router = new VueRouter({
        routes: [
            // 动态路径参数 以冒号开头
            { path: &apos;/user/:id&apos;, component: User }
        ]
    })

    // 路由参数  /user/:username     匹配/user/evan    $route.params 来取参数  { username: &apos;evan&apos; }

四、路由跳转

    1）router.push(location): js内加路由跳转  router.push({path: &apos;/admin/&apos;})

    2）router.go(n): history历史记录跳转

    &lt;router-link to=&quot;home&quot;&gt;home&lt;/router-link&gt;

五、&lt;router-view&gt; 渲染路由视图组件

    &lt;router-view&gt;&lt;/router-view&gt;

六、重命定向 redirect

    {
        path: &apos;*&apos;,
        redirect: function () {
            return &apos;/admin&apos;;
        }
    }

七、History模式

    export default new VueRouter({
        mode: &apos;history&apos;,
        routes: [...]
    })

    mode值:

        hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。

        history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式. （url不会带hash “#“）

        abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式


八、router 钩子

    1、beforeEach

        var auth = {
            loggedIn: function () {
                return localStorage.getItem(KEY_OF_LOGGEDIN) === &apos;true&apos;;
            }
        }

        // to: 要进入目录的路由对象
        // from: 要离开的路由对象
        // next: function, 用该方法来resolve这个钩子
        router.beforeEach((to, from, next) =&gt; {
            if (to.matched.some(record =&gt; record.meta.requiresAuth)) {
                if (!auth.loggedIn()) {
                    next({
                        path: &apos;/login&apos;,
                        query: {redirect: to.fullPath},
                    });
                } else if (auth.requiresAlterPassword()){
                    next({
                        path: &apos;/firstLogin&apos;
                    });
                } else {
                    next();
                }
            } else {
                next();
            }
        });


    2、meta 定义路由的时候可以配置meta字段

        可以通过它来设置不需要判断登录的路由，在beforeEach的时候进行处理

        {
            path: &apos;/firstLogin&apos;,
            name: &apos;firstLogin&apos;,
            meta: {
                requiresAuth: false
            },
            component: (resolve) =&gt; require([&apos;../views/firstLogin.vue&apos;], resolve),
        }

九、路由对象

    1、$route.path: 当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;

    2、$route.params: 获取动态路由的参数

    3、$route.query:  URL 查询参数, 例如，对于路径 /foo?user=1，则有 $route.query.user == 1

    4、$route.hash: 路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。

    5、$route.matched: 

    6、$route.name: 路由的名称

十、路由嵌套

    const User = {
      template: `
        &lt;div class=&quot;user&quot;&gt;
          &lt;h2&gt;User {{ $route.params.id }}&lt;/h2&gt;
          &lt;router-view&gt;&lt;/router-view&gt;        // 这里嵌套一个路由
        &lt;/div&gt;
      `
    }

    const router = new VueRouter({
        routes: [
            { path: &apos;/user/:id&apos;, component: User,
                children: [
                {
                    // 当 /user/:id/profile 匹配成功，
                    // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中
                    path: &apos;profile&apos;,
                    component: UserProfile
                },
                {
                    // 当 /user/:id/posts 匹配成功
                    // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中
                    path: &apos;posts&apos;,
                    component: UserPosts
                }
                ]
            }
        ]
    })
</code></pre><h4 id="表单校验插件-vue-validator"><a href="#表单校验插件-vue-validator" class="headerlink" title="表单校验插件 vue-validator"></a>表单校验插件 vue-validator</h4><h4 id="vue-resource-ajax插件"><a href="#vue-resource-ajax插件" class="headerlink" title="vue-resource ajax插件"></a>vue-resource ajax插件</h4><pre><code>一、它提供了两种方式来处理HTTP请求: 

    使用Vue.http或this.$http

    使用Vue.resource或this.$resource


二、特点: 支持拦截器

    拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。

    拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。


三、使用方式: 

    1、拦截器  使用inteceptor

    Vue.http.interceptors.push((request, next) =&gt; {

        // 请求发送前的处理逻辑
        next((response) =&gt; {
            // 请求发送后的处理逻辑
            // 根据请求的状态，response参数会返回给successCallback或errorCallback
            return response
        })
    })


四、请求类型

    get(url, [options])
    head(url, [options])
    delete(url, [options])
    jsonp(url, [options])
    post(url, [body], [options])
    put(url, [body], [options])
    patch(url, [body], [options])

    &lt;script&gt;

        var demo = new Vue({
            el: &apos;#app&apos;,
            data: {
                gridColumns: [&apos;customerId&apos;, &apos;companyName&apos;, &apos;contactName&apos;, &apos;phone&apos;],
                gridData: [],
                apiUrl: &apos;http://211.149.193.19:8080/api/customers&apos;
            },
            ready: function() {
                this.getCustomers();
            },
            methods: {
                getCustomers: function() {

                    // get请求
                    // then方法只提供了successCallback，而省略了errorCallback。
                    // catch方法用于捕捉程序的异常，catch方法和errorCallback是不同的，errorCallback只在响应失败时调用，而catch则是在整个请求到响应过程中，只要程序出错了就会被调用。

                    this.$http.get(this.apiUrl)
                        .then((response) =&gt; {

                            // Vue实例方法，设置gridData属性赋值，并触发视图更新
                            this.$set(&apos;gridData&apos;, response.data)
                        })
                        .catch(function(response) {
                            console.log(response)
                        })
                }
            }
        })

    &lt;/script&gt;

5、options对象

    发送请求时的options选项对象包含以下属性: 

    参数             类型                                描述
    url            string            请求的URL

    method        string            请求的HTTP方法，例如: &apos;GET&apos;, &apos;POST&apos;或其他HTTP方法

    body        Object             FormData string    request body

    params        Object            请求的URL参数对象

    headers        Object            request header

    timeout        number            单位为毫秒的请求超时时间 (0 表示无超时时间)

    before        function(request)    请求发送前的处理函数，类似于jQuery的beforeSend函数

    progress     function(event)      ProgressEvent回调处理函数

    credientials    boolean          表示跨域请求时是否需要使用凭证

    emulateHTTP        boolean          发送PUT, PATCH, DELETE请求时以HTTP POST的方式发送，并设置请求头的X-HTTP-Method-Override

    emulateJSON        boolean          将request body以application/x-www-form-urlencoded content type发送
</code></pre><p>| <a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/</a><br>| <a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh-cn/</a><br>| <a href="https://github.com/dai-siki/vue-image-crop-upload" target="_blank" rel="noopener">https://github.com/dai-siki/vue-image-crop-upload</a>   头像上传组件<br>| <a href="http://www.cnblogs.com/pandabunny/p/5417938.html" target="_blank" rel="noopener">http://www.cnblogs.com/pandabunny/p/5417938.html</a>     // vue引用jquery<br>| <a href="http://router.vuejs.org/zh-cn/installation.html" target="_blank" rel="noopener">http://router.vuejs.org/zh-cn/installation.html</a>     // 路由插件<br>| <a href="http://yuche.github.io/vue-strap/" target="_blank" rel="noopener">http://yuche.github.io/vue-strap/</a>                    // vueStrap<br>| <a href="http://bootstrap-table.wenzhixin.net.cn/zh-cn/" target="_blank" rel="noopener">http://bootstrap-table.wenzhixin.net.cn/zh-cn/</a>    // bootstrap Table<br>|<br>| <a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">https://github.com/PanJiaChen/vue-element-admin</a><br>| <a href="https://github.com/opendigg/awesome-github-vue?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">https://github.com/opendigg/awesome-github-vue?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a>      // vue项目汇总</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/22/VueJS之-“组件篇“（二）/">VueJS 之 “组件篇“（二）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/22/VueJS之-“组件篇“（二）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-22T06:02:01.000Z" itemprop="datePublished">2016-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 涉及知识点:<br>| 1、全局组件、局部组件<br>| 2、数据传递（props、组件通信、slot）<br>| 3、props、sync双向绑定、once单次绑定<br>| 4、组件之间通信，$dispatch() 派发事件、 $broadcast() 广播事件，事件向下传导给所有后代<br>| 4、slot 内容分发<br>| 组件是Vue的最强大功能之一，组件可以扩展html元素，封装可复用代码</p>
<h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><pre><code>全局组件在任何组件内都可以调用，无需引用或通过component加载

main.js

    // 定义一个全局的组件
    var myComponent = Vue.extend({
        template: &apos;&lt;div&gt; 组件已经渲染出来 &lt;/div&gt;&apos;
    })

    // 全局注册
    Vue.component(&apos;crm-component&apos;, myComponent);

    new Vue({
        ...
    }}


main.vue 子组件

    &lt;templte&gt;
        &lt;div class=&quot;welcome&quot;&gt;
            &lt;h1&gt;视图列表页面&lt;/h1&gt;
            &lt;crm-component&gt;&lt;/crm-component&gt;            &lt;!-- 直接调用 --&gt;
        &lt;/div&gt;
    &lt;/template&gt;
</code></pre><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h4><pre><code>必须使用components对象来引用组件

&lt;div id=&quot;appA&quot;&gt;
    &lt;component-parent&gt;&lt;/component-parent&gt;
&lt;/div&gt;

&lt;script&gt;
    var vmA = new Vue({
        el: &quot;#appA&quot;,
        components: {        // 局部的写法
            &apos;crm-component&apos;: {
                 template: &apos;&lt;div&gt;这里component&lt;/div&gt;&apos;
            }
        }
    })
&lt;/script&gt;

注意: &lt;component-parent&gt; 自定义元素以“-”分割

    &apos;crm-component&apos;: {        // 这里定义的组件名可以是以“-”分割，也可以驼峰方式 crmComponent
         template: &apos;&lt;div&gt;这里component&lt;/div&gt;&apos;
    }
</code></pre><p>————— 父与子组件之间的数据传递 —————</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><pre><code>父组件将数据传给子组件通过props，子组件通过自定义事件$on、$emit来挂参数传递给父组件.

2.0版本之后 props为单向数据流，父组件属性变化，将传给子组件

一、props字面量

    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 这里的两个属性值通过props传到组件中 --&gt;
        &lt;component-parent my-name=&quot;siguang&quot; my-age=&apos;33&apos;&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var componentCrm = Vue.extend({
            props: [&apos;myName&apos;, &apos;myAge&apos;],
            template: &apos;&lt;h2&gt;{{ myName }} {{ myAge }}&lt;/h2&gt;&apos;
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: componentCrm
            }
        })
    &lt;/script&gt;

    注意: my-name=&quot;siguang&quot; 自定义属性以“-”分割

         props: [&apos;myName&apos;, &apos;myAge&apos;]        // props 定义的必须以驼峰形势


二、props动态值

    parent.vue:

        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- 通过父组件传到子组件中 --&gt;
            &lt;child-component :user-name=&quot;uname&quot;&gt;&lt;/child-component&gt;
        &lt;/div&gt;

        &lt;script&gt;
            import childComponent from &apos;childComponent.vue&apos;;

            export default{
                data(): {
                    return{
                        uname: &apos;siguang&apos;
                    }
                },
                components:{
                    childComponent
                }
            }
        &lt;/script&gt;


    childComponent.vue:

        &lt;div&gt;
            {{userName}}        &lt;!-- siguang --&gt;
        &lt;/div&gt;

        &lt;script&gt;
            export default{
                propos: [&apos;userName&apos;],
                data(){
                    return {

                    }
                }
            }
        &lt;/script&gt;


三、once 将渲染的结果缓存

    不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来

    &lt;div id=&quot;app&quot;&gt;
        &lt;component-parent&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;

        var childrenComponent = Vue.extend({
            template: &apos;&lt;div v-once&gt;&apos;+
                &apos;&lt;h3&gt;这里是子组件的内容: {{ myMsg }}&lt;/3&gt;&apos;+
                &apos;&lt;p&gt;这里输入不会影响父组件: &lt;input type=&quot;text&quot; v-model=&quot;myMsg&quot; /&gt;&lt;/p&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            data: function(){
                return {
                    myMsg: &apos;&apos;
                }
            },
            props: [&apos;myMsg&apos;]
        })

        var parentComponent = Vue.extend({
            template: &apos;&lt;div v-once&gt;&apos;+
                &apos;&lt;p&gt;&lt;input text=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;/p&gt;&apos;+
                &apos;&lt;p&gt;父组件的值 {{ msg }}&lt;/p&gt;&apos;+
                &apos;&lt;/div&gt;&apos;+
                &apos;&lt;childen-component v-bind:my-msg.once=&quot;msg&quot;&gt;&lt;/childen-component&gt;&apos;,
            data: function(){
                return {
                    msg: &apos;这里值只传给子组件一次&apos;
                }
            },
            components: {
                &apos;childen-component&apos;: childrenComponent
            }
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: parentComponent
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="组件之间通信"><a href="#组件之间通信" class="headerlink" title="组件之间通信"></a>组件之间通信</h4><pre><code>props是父向子组件传递数据，子向父组件传递可以通过自定义事件来完成，从而现实组件的数据双向绑定

$on(eventName) 监听事件    、$emit(eventName) 触发事件

一、子向父组件发消息

    parent.vue: 

        &lt;template&gt;
            &lt;div class=&quot;login&quot;&gt;
                &lt;div class=&quot;parent-box&quot;&gt;
                    &lt;p&gt;显示子组件数据: {{ childrenText }}&lt;/p&gt;
                &lt;/div&gt;

                &lt;children-component ref=&quot;childrenRef&quot; v-on:showChildrenVal=&quot;childrenVal&quot;&gt;&lt;/children-component&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            import ChildrenComponent from &apos;./children.vue&apos;
            export default{
                data(){
                    return {
                        childrenText: &apos;&apos;
                    }
                },
                methods:{
                    childrenVal(val){
                        this.childrenText = val;
                    }
                },
                components:{
                    ChildrenComponent
                }
            }
        &lt;/script&gt;

    children.vue:

        &lt;template&gt;
            &lt;div class=&quot;children&quot; style=&quot;padding-top: 50px; border-top: 1px #ccc solid&quot;&gt;
                &lt;p&gt;&lt;input type=&quot;text&quot; v-model=&quot;childrenInp&quot; id=&quot;&quot;&gt;&lt;/p&gt;
                &lt;p&gt;&lt;input type=&quot;button&quot; @click=&quot;showChildrenVal&quot; value=&quot;提交到父组件中&quot;&gt;&lt;/p&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            export default{
                data(){
                    return {
                        childrenInp: &apos;&apos;
                    }
                },
                methods:{
                    showChildrenVal(){
                        this.$emit(&quot;showChildrenVal&quot;, this.childrenInp);
                    }
                }
            }
        &lt;/script&gt;


二、父向子发消息

    parent.vue:

        &lt;template&gt;
            &lt;div class=&quot;login&quot;&gt;
                &lt;div class=&quot;parent-box&quot;&gt;
                    &lt;p&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;inputParent&quot; &gt;&lt;br&gt;&lt;/p&gt;
                    &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;值传给父组件&quot; @click=&quot;sendChildren&quot;&gt;&lt;br&gt;&lt;/p&gt;
                    &lt;p&gt;显示子组件数据: {{ childrenText }}&lt;/p&gt;
                &lt;/div&gt;

                &lt;children-component ref=&quot;childrenRef&quot;&gt;&lt;/children-component&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            import ChildrenComponent from &apos;./children.vue&apos;
            export default{
                data(){
                    return {
                        inputParent: &apos;&apos;,
                        childrenText: &apos;&apos;
                    }
                },
                methods:{
                    sendChildren(){
                        debugger;
                        this.$refs.childrenRef.$emit(&apos;showText&apos;, this.inputParent);        // 也可以用props
                    }
                },
                components:{
                    ChildrenComponent
                }
            }
        &lt;/script&gt;


    children.vue:

        &lt;template&gt;
            &lt;div class=&quot;children&quot; style=&quot;padding-top: 50px; border-top: 1px #ccc solid&quot;&gt;
                这里是父组件传递的值: {{transmitVal}}
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            export default{
                created(){
                    this.$on(&apos;showText&apos;, function(val){
                        this.transmitVal = val;
                    })
                },
                data(){
                    return {
                        transmitVal: &apos;&apos;
                    }
                }
            }
        &lt;/script&gt;


三、v-ref 直接访问到组件

    &lt;div id=&quot;app&quot;&gt;
        &lt;span ref=&quot;msg&quot;&gt; hello &lt;/span&gt;
        &lt;span ref=&quot;other-msg&quot;&gt; world &lt;/span&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                someProp: &apos;idName&apos;,
                otherProp: &apos;prop&apos;
            }
        })

        console.log(vm.$refs.msg.textContent);        // hello
        console.log(vm.$refs.otherMsg.textContent);    // world
    &lt;/script&gt;



以下是1.* 版本
1、$broadcast 广播事件 父组件发消息给所有子组件

    &lt;div id=&quot;app&quot;&gt;
        &lt;component-parent&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // 子组件接收消息
        var childrenComponent = Vue.extend({
            template: &apos;&lt;div style=&quot;border: 1px #42b983 solid;padding: 10px; margin-top:10px;&quot;&gt;&apos;+
                &apos;&lt;h3&gt;显示父组件广播的消息: {{ showMessage }}&lt;/h3&gt;&lt;/div&gt;&apos;,
            data: function(){
                return {
                    showMessage: &apos;&apos;
                }
            },
            events: {
                messageEvent: function(val){        // messageEvent 接收
                    this.showMessage = val;
                }
            }
        })

        // 父组件广播消息
        var parentComponent = Vue.extend({
            template: &apos;&lt;div&gt;这里是父组件: &apos;+
                &apos;&lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;&lt;input type=&quot;button&quot; @click=&quot;sendMessage&quot; value=&quot;通知&quot; /&gt;&apos;+
                &apos;&lt;children-component&gt;&lt;/children-component&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            components: {
                &apos;children-component&apos;: childrenComponent
            },
            data: function(){
                return {
                    message: &apos;&apos;
                }
            },
            methods: {
                sendMessage: function(){
                    this.$broadcast(&apos;messageEvent&apos;, this.message);        // 定义事件名为messageEenent， 将message值广告给所有子组件
                }
            }
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: parentComponent
            }
        })
    &lt;/script&gt;


2、$dispatch: 派发事件 子组件向上传消息给父组件

    &lt;div id=&quot;app&quot;&gt;
        &lt;component-parent&gt;&lt;/component-parent&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // 子组件 派发消息
        var childrenComponent = Vue.extend({
            template: &apos;&lt;div style=&quot;border: 1px #42b983 solid;padding: 10px; margin-top:10px;&quot;&gt;&apos;+
                &apos;&lt;h3&gt;显示父组件广播的消息: {{ showMessage }}&lt;/h3&gt;&apos;+
                &apos;&lt;input type=&quot;text&quot; v-model=&quot;showMessage&quot; /&gt;&lt;input type=&quot;button&quot; @click=&quot;sendMessage&quot; value=&quot;向父组件派发消息&quot; /&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            data: function(){
                return {
                    showMessage: &apos;&apos;
                }
            },
            methods: {
                sendMessage: function(){
                    this.$dispatch(&apos;messageEvent&apos;, this.showMessage);        
                }
            }
        })

        // 父组件
        var parentComponent = Vue.extend({
            template: &apos;&lt;div&gt;收到了子组件的派发消息: {{ message }}&apos;+
                &apos;&lt;children-component&gt;&lt;/children-component&gt;&apos;+
                &apos;&lt;/div&gt;&apos;,
            components: {
                &apos;children-component&apos;: childrenComponent
            },
            data: function(){
                return {
                    message: &apos;&apos;
                }
            },
            events: {
                messageEvent: function(val){
                    this.message = val;
                }
            }
        })

        var vm = new Vue({
            el: &apos;#app&apos;,
            components: {
                &apos;component-parent&apos;: parentComponent
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="slot-分发内容"><a href="#slot-分发内容" class="headerlink" title="slot 分发内容"></a>slot 分发内容</h4><pre><code>parent.vue:

    &lt;template&gt;
        &lt;div class=&quot;login&quot;&gt;
            &lt;children-component&gt;
                &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;

                &lt;div class=&quot;tag&quot;&gt;
                    这里是没有定义slot名称走的默认的slot
                    &lt;div class=&quot;tag-til&quot;&gt;标题&lt;/div&gt;
                    &lt;div class=&quot;tag-content&quot;&gt;内容部分&lt;/div&gt;
                &lt;/div&gt;
            &lt;/children-component&gt;
        &lt;/div&gt;
    &lt;/template&gt;

children.vue:

    &lt;template&gt;
        &lt;div class=&quot;children&quot;&gt;
            &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;

            &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
    &lt;/template&gt;
</code></pre><h4 id="vueify-开发外部独立"><a href="#vueify-开发外部独立" class="headerlink" title="vueify 开发外部独立"></a>vueify 开发外部独立</h4><pre><code>使用.vue格式的文件定义组件，一个.vue就是一个组件

一、.vue组件包括3部分: 

    &lt;style&gt;&lt;/style&gt; 定义组件样式

    &lt;template&gt;&lt;/template&gt; 定义组件模板

    &lt;script&gt;&lt;/script&gt; 定义组件选项，如data, methods等


二、在定义组件的选项时，data和el选项必须使用函数

    &lt;script&gt;
        export default {
            data(){                // 数据，相当于 data: function(){}
                return {
                    msg: &quot;hello Vue&quot;
                }
            }
        }
    &lt;/script&gt;

Example: 

    App.vue:
        &lt;style&gt;
            h1 { color: #cc33ff; font-size: 30px;}
        &lt;/style&gt;

        &lt;template&gt;
            &lt;div class=&quot;box&quot;&gt;
                &lt;h1&gt;{{message}}&lt;/h1&gt;
                &lt;message&gt;&lt;/message&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;

            import message from &apos;./message.vue&apos;

            export default {
                data(){                // 数据
                    return {
                        msg: &quot;hello Vue&quot;
                    }
                },
                components: {
                    message         // 这里ES6的简写，message: message
                },
                methods:{
                    showMessage(){
                        console.log(this.msg);
                    }
                }
            }
        &lt;/script&gt;

    HTML: 
        &lt;div id=&quot;app&quot;&gt;
        &lt;app&gt;&lt;/app&gt;

    main.js:

        // ES6导入模块
        import Vue form &apos;vue&apos;
        import App form &apos;App.vue&apos;

        // 可以使用CMD模式
        /*
            var vue = require(&apos;vue&apos;);
            var app = reuqire(&apos;App.vue&apos;)
        */

        new Vue({
            el:&apos;#app&apos;,
            components: { App }
        })

https://github.com/vuejs/vueify
</code></pre><h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><pre><code>Vue.component(&apos;async-webpack-example&apos;, function (resolve) {
    // 这个特殊的 require 语法告诉 webpack
    // 自动将编译后的代码分割成不同的块，
    // 这些块将通过 Ajax 请求自动下载。
    require([&apos;./my-async-component&apos;], resolve)
})
</code></pre><h4 id="组件化的css"><a href="#组件化的css" class="headerlink" title="组件化的css"></a>组件化的css</h4><pre><code>可以通过scoped属性来控制样式是否是只在当前组件下使用

&lt;style&gt;
    /* 全局下的样式 */
&lt;/style&gt;

&lt;style scoped&gt;
    /* 当前组件下使用的样式 */
&lt;/style&gt;
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/10/22/VueJS之-基础篇（一）/">VueJS 之 “基础篇“（一）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/22/VueJS之-基础篇（一）/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-22T03:06:51.000Z" itemprop="datePublished">2016-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Vue/">Vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| style与class<br>| computed、directive、filter<br>| watch 侦听Data数据的变化<br>| 生命周期: beforeCreate、create、beforeMount、mounted、beforeUpdate、updated、destroyed<br>| this.$refs、$el、$data、$watch<br>| v-bind缩写:、v-on缩写@</p>
<h4 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h4><pre><code>一、Vue的MVVM实现的原理？

    ViewModel是Vue.js的核心，Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素

    DOM Listeners 和 Data Bindings看作两个工具，它们是实现双向绑定的关键。

    从view层来看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；

    从Model层来看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。

二、Vue使用

    1）页面加载vue.js文件  &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;

    2）npm下载vue包, npm install vue --save-dev
</code></pre><h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
    {{ message }}
&lt;/div&gt;

new Vue({
    el: &apos;#app&apos;,
    data: {
        message: &apos;hello world&apos;
    }
})
</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><pre><code>一、构造器

    1、每个构造器都是通过创建一个Vue的实例启动的

        var vm = new Vue({
            // ...    
        })

    2、扩展构造器

        通过扩展构造器可以创建可复用的组件构造器

        var MyComponent = Vue.extend({
            // 扩展选项
        })


二、生命周期

    1、beforeCreate(): 实例初始化，数据观测(data observer)和事件（event/watcher）配置之前被调用

    2、create(): 实例创建完后被调用，完成了数据观测(data observer)和事件（event/watcher）回调，但还挂载还没开始$el属性不可见

    3、beforeMount(): 在挂载开始之前调用，render()函数被调用

    4、mounted(): el被创建的vm.$el替换，挂载到实例上调用钩子

    5、beforeUpdate(): 数据更新时调用，在虚拟DOM重新渲染

    6、updated(): 数据更改导致虚拟DOM重新渲染

    7、destroyed(): 卸载组件

    &lt;script&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                message: &apos;siguang&apos;
            },
            methods: {
                showMessage: function(){
                    console.log(this.message);
                },
                deleteVue: function(){
                    vm.$destroy();          // 消毁Vue实例
                }
            },

            // new Vue后执行开始
            beforeCreate: function(){
                console.log(&apos;beforeCreate&apos;);
            },

            // Vue实例创建被调用
            create: function(){
                console.log(&apos;create&apos;);
            },


            mounted: function(){
                console.log(&apos;mounted&apos;);
            },

            // 数据更新后执行的回调
            beforeUpdate: function(){    
                console.log(&apos;beforeUpdate&apos;);     
            },
            updated: function(){    
                console.log(&apos;updated&apos;);     
            },

            // 消毁时触发
            destroyed: function(){
                console.log(&apos;destroyed&apos;);
            }

        });
    &lt;/script&gt;
</code></pre><h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><pre><code>1、文本绑定:  &lt;p&gt;{{ data.name }}&lt;/p&gt;    与 &lt;p v-text=&quot;data.name&quot;&gt;&lt;/p&gt; 相同

2、html绑定:  &lt;p v-html=&quot;data.strHtml&quot;&gt;&lt;/p&gt;

3、绑定的值可以html中: 

    &lt;div id=&quot;item-{{id}}&quot;&gt;&lt;/div&gt;

    &lt;div :id=&quot;userId&quot;&gt;&lt;/div&gt;

4、表达式:  {{ dat.num == 1 }}、 {{ num ? 'yes' : 'no' }}、 {{if(ok) {return message} }}

5、过滤器:  {{ message | capitalize }}

    连续过滤器:  {{ message | filterA | filterB }}
</code></pre><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><pre><code>指令: 以 v- 开头

    &lt;div v-if=&quot;greeting == 1&quot;&gt;&lt;/div&gt;

    带参数: &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;

1、v-if、v-else-if条件渲染: 

    &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;A&lt;/div&gt;
    &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;B&lt;/div&gt;
    &lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;C&lt;/div&gt;
    &lt;div v-else&gt;Not A/B/C&lt;/div&gt;

2、v-show: 显示还是隐藏元素，用的display

3、v-for: 循环数据来渲染列表

    $index: 索引        $key: 

    * 数组/数组对象循环: 

        &lt;li v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;{{ item.message }}&lt;/li&gt;

        或者:
        &lt;li v-for=&quot;(val, index) in objList&quot; :key=&quot;index&quot;&gt;
            {{index}}. {{key}} : {{val.type}}
           &lt;/li&gt;

    * 对象循环: index下标    key对象的key   val对象属性值

        &lt;li v-for=&quot;(val, index) in objList&quot; :key=&quot;index&quot;&gt;
            {{index}}. {{key}} : {{val.type}}
           &lt;/li&gt;

    * filterBy()、orderBy()过滤器

    **** 注意在使用2.2.0以上版本时 ****
    @key是必要属性否则就会报警告

        1）&lt;el-row class=&quot;pt20 w50&quot; v-for=&quot;method in payMethods&quot; :key=&quot;method.label&quot;&gt;        // 数据

        2）&lt;el-option
                v-for=&quot;(item,index) in payMethods&quot;
                :key=&quot;index&quot;
                :label=&quot;item.label&quot;
                :value=&quot;item.value&quot;&gt;
            &lt;/el-option&gt;


4、v-model: 绑定值，这也是MVVM的关键点

    可以对文本表单、单选框 、多选框、下拉菜单进行绑定值

    参数特性:

        1）lazy: 不是输入时就进行同步而是在change的时候才对数据进行同步

            &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; lazy /&gt; {{msg}}

        2）number: 将用户输入的转成Number型，如果返回NaN那就返回原值

        3）debounce: 设置一个最小延时，否则如果输入是ajax请求，每次敲击都会去请求

            &lt;input type=&quot;text&quot; debounce=&quot;500&quot; v-model=&quot;msg&quot;&gt;        // 按完键500毫秒后在进行

    获取checkbox值:

        &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt;

        // 当选中时
        vm.toggle === vm.a

        // 当没有选中时
        vm.toggle === vm.b


5、v-bind: 绑定到HTML元素上，v-bind:class=&quot;active&quot;

    v-bind缩写: &quot;:&quot; &lt;a :href=&apos;url&apos;&gt;&lt;/a&gt;


6、v-on: 用于监听DOM事件 v-on:click=&quot;doSomeThing&quot;

    v-on缩写: &quot;@&quot; &lt;div @click=&quot;doSomeing&quot;&gt;&lt;/div&gt;


7、v-ref: 访问子组件

    2.0后 v-el和v-ref合成了一个 ref属性，组件实例中通过 $refs 来调用 

    &lt;div ref=&quot;box&quot;&gt;xxxx&lt;/div&gt;
    &lt;el-button type=&quot;primary&quot; slot=&quot;append&quot; @click=&quot;getRefs&quot;&gt;发送&lt;/el-button&gt;

    {
        methods:{
            getRefs(){
                console.log(this.$refs.box.innerHTML);
            }
        }
    }

    如果绑定一个元素使用 :ref=&apos;item&apos;
    &lt;p v-for=&quot;item in items&quot; :ref=&quot;item&quot;&gt;&lt;/p&gt;


8、v-pre: 跳过这个元素和它的子元素的编译过程，这样加快了编译的速度

    &lt;div v-pre&gt;{{ 这里不用框架来编译 }}&lt;/div&gt;

9、v-cloak:

10、v-once: 只渲染元素和组件一次，之后的渲染都会跳过次元素

    &lt;span v-once&gt;xxxxx&lt;/span&gt;
</code></pre><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><pre><code>过滤器，对绑定值进行处理

1、内置过滤器

    1）uppercase: 字母转成大写

    2）lowercase: 字母转成小写

    3）capitalize: 首字母转成大写

    4）filterBy: 过滤内容

    5）limitBy: 过滤数据从开始到指定位置结束的内容

    6）orderBy: 过滤排序

    7）currency: 货币过滤

    8）debounce: 延迟过滤


2、自定义过滤器和带参数

    &lt;span v-text=&quot;message | reverse &apos;addText&apos; &quot;&gt;&lt;/span&gt;

    // 创建自己定义过滤器 value值 addText参数
    Vue.filter(&apos;reverse&apos;, function(value, addText){
        return value.split(&apos;&apos;).remove().join() + addText:
    })


2、双向过滤器

    模型的值显示在视图之前转换它

    &lt;input v-mode=&quot;money | formatMoney&quot;&gt;
    &lt;div&gt;{{ money | formatMoney }}&lt;/div&gt;

    Vue.filter(&apos;formatMoney&apos;, {

        // model -&gt; vlew过程  在更新&lt;input&gt; 元素之初化值
        read: function(val){
            return &apos;$&apos; + val.toFixed(2);
        },

        // vlew -&gt; model过程 在写回数据之前格式化值
        write: function(val){
            var number = +val.replace(/[^\d.]/g, &apos;&apos;);
            return isNaN(number) ? 0 : parseFloat(number.toFixed(2));
        }
    })


3、动态参数

    参数用空格格开

    &lt;input type=&quot;text&quot; v-model=&quot;userInput&quot;&gt;
    &lt;span&gt;{{msg | concat userInput}}&lt;/span&gt;

    Vue.filter(&apos;concat&apos;, function (value, input) {
        // `input` === `this.userInput`
        return value + input;
    })


4、filterBy过滤器

    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;过滤数据里包含 蛋糕 字符 &lt;/div&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | filterBy &apos;蛋糕&apos; &quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top: 30px&quot; &gt;过滤出输入的字符&lt;/div&gt;
        &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;searchKey&quot; /&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | filterBy searchKey in &apos;name&apos;&quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                searchKey: &apos;&apos;,
                users:[
                    {
                        name: &apos;外卖&apos;,
                        tag: 1
                    },
                    {
                        name: &apos;鲜花&apos;,
                        tag: 5
                    },
                    {
                        name: &apos;蛋糕&apos;,
                        tag: 4
                    },
                    {
                        name: &apos;水果&apos;,
                        tag: 2
                    },
                    {
                        name: &apos;茶点&apos;,
                        tag: 3
                    }
                ]
            }
        })
    &lt;/script&gt;

5、orderBy排序

    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;searchKey&quot; /&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;user in users | orderBy &apos;tag&apos;&quot;&gt;{{ user.name }}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                searchKey: &apos;&apos;,
                users:[
                    {
                        name: &apos;外卖&apos;,
                        tag: 1
                    },
                    {
                        name: &apos;咖啡&apos;,
                        tag: 5
                    },
                    {
                        name: &apos;餐厅订座&apos;,
                        tag: 4
                    },
                    {
                        name: &apos;蛋糕&apos;,
                        tag: 2
                    },
                    {
                        name: &apos;票务&apos;,
                        tag: 3
                    }
                ]
            }
        })
    &lt;/script&gt;
</code></pre><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><pre><code>一、钩子函数

    el：指令所绑定的元素，可以用来直接操作 DOM 。
    binding：一个对象，包含以下属性：
    name：指令名，不包括 v- 前缀。
    value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。
    oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
    expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。
    arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。
    modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
    vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
    oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

2、对象字面量

    &lt;div v-demoA=&quot;{ color: &apos;white&apos;, text: &apos;hello&apos;}&quot;&gt;&lt;/div&gt;

    Vue.directive(&apos;demoA&apos;, function(el, value){
        console.log(value.color);
        console.log(value.text);
    })


3、元素指令，相当于angular的E指令

    Vue.elementDirective(&apos;my-directive&apos;, {
        bind: function(){
            // 操作this.el
        }
    })

    &lt;my-directive&gt;&lt;/my-directive&gt;            // 不能这么写&lt;div v-my-directive&gt;&lt;/div&gt;

4、高级选项

    params: 自动提取绑定元素的这些特性.

    &lt;div v-example a=&quot;hi&quot;&gt;&lt;/div&gt;
    Vue.directive(&apos;example&apos;, {
        params: [&apos;a&apos;],
        bind: function () {
            console.log(this.params.a);         // -&gt; &quot;hi&quot;
        }
    })
</code></pre><h4 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h4><pre><code>计算属性就是当依赖属性发生变化时，属性的值会自动更新，相关的DOM也会同步更新

二、计算属性的getter

    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;user_inof={{ userInfo }}&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;
        var vm = new Vue({
            el: &apos;#app&apos;,
            data: {
                &quot;user_name&quot;: &quot;lulu&quot;,
                &quot;user_age&quot;: &quot;20&quot;
            },
            computed: {
                // 一个计算属性getter
                userInfo: function(){
                    return &apos;姓名: &apos;+ this.user_name +&apos; 年龄: &apos;+ this.user_age;
                }
            }
        })
    &lt;/script&gt;


二、计算属性的setter

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            &quot;user_name&quot;: &quot;lulu&quot;,
            &quot;user_age&quot;: &quot;20&quot;
        },
        computed: {
            userInfo: function(){
                get: function(){
                    return &apos;姓名: &apos;+ this.user_name +&apos; 年龄: &apos;+ this.user_age;
                },
                set: function(newValue){        // 这里当
                    this.userInfo = newValue;
                }
            }
        }
    })
</code></pre><h4 id="watch-侦听数据变化"><a href="#watch-侦听数据变化" class="headerlink" title="watch 侦听数据变化"></a>watch 侦听数据变化</h4><pre><code>watch 侦听data下指定数据的变化 

&lt;script&gt;

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            message: &apos;siguang&apos;
        },
        methods: {
            showMessage: function(){
                console.log(this.message);
            }
        },
        watch:{
            message: function(newValue){
                return newValue + 1;        // 如果message变化值加1
            }
        }
    });

    console.log(vm.message);        // siguang
    vm.showMessage();

    // 写在实例化下侦听数据变化
    // vm.$watch(&apos;message&apos;, function(newVal, oldVal){
    //    console.log(newVal, oldVal);
    //    this.message = newVal.replace(/s|g/g, &apos;*&apos;);
    // })

&lt;/script&gt;
</code></pre><h4 id="class和style的绑定"><a href="#class和style的绑定" class="headerlink" title="class和style的绑定"></a>class和style的绑定</h4><pre><code>1、class

    // 对象
    &lt;div :class=&quot;{ &apos;active&apos;: isActive }&quot;&gt;&lt;/div&gt;

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            isActive: true
        }
    })

    // 数组
    &lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;        // 三元 &lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;
    data: {
        activeClass: &apos;active&apos;,
        errorClass: &apos;text-danger&apos;
    }    


2、style

    &lt;div :style=&quot;[crm, hk]&quot;&gt; 或 &lt;div :style=&quot;{color: activeColor, fontSize: fontSize+&apos;px&apos;}&quot;&gt;

    var vm = new Vue({
        el: &apos;#app&apos;,
        data: {
            activeColor: &apos;red&apos;,
            fontSize: 30,
            crm: {
                color: &apos;#000&apos;,
                fontSize: &apos;16px&apos;
            },
            hk: {
                color: &apos;#fff&apos;,
                fontSize: &apos;18px&apos;
            }
        }
    })
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>1、@click

    &lt;div @click=&quot;say&quot;&gt;&lt;/div&gt;
    &lt;div @click=&quot;say(&apos;hi&apos;)&quot;&gt;&lt;/div&gt;
    &lt;div @click=&quot;content + 1&quot;&gt;&lt;/div&gt;


    &lt;!-- 阻止单击事件冒泡 --&gt;
    &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

    &lt;!-- 提交事件不再重载页面 --&gt;
    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

    &lt;!-- 修饰符可以串联  --&gt;
    &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

    &lt;!-- 只有修饰符 --&gt;
    &lt;form v-on:submit.prevent&gt;&lt;/form&gt;

    &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;
    &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

    &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;
    &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;

2、按键别名

    .enter、.tab、.delete (捕获 “删除” 和 “退格” 键)、.esc、.space、.up、.down、.left、.right、.ctrl、.alt、.shift、.meta

3、once: 只处理一次点击  &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;

4、修饰符 &lt;input v-on:keyup.13=&quot;submit&quot;&gt;
</code></pre><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><pre><code>Vue在底层将模板编译成虚拟DOM渲染函数，也可以不用模板直接写render函数，可选JSX语法
</code></pre><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><pre><code>1、v-bind 内联字符串连接

    data(){
        return {
            addString: &apos;加入内容&apos;
        }
    }

    1.x版本 写法  &lt;div attr=&quot;xxxx{{addString}}&quot;&gt;

    2.x版本 写法  &lt;div v-bind=&quot;&apos;xxxx&apos;+ addString&quot;&gt;


2、checkbox动态创建绑定

    // v-model=&quot;item.check&quot; 绑定的值要相同

    &lt;p v-for=&quot;item in checkList&quot;&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;cb&quot; v-model=&quot;item.check&quot; /&gt; {{item.name}}
    &lt;/p&gt;

    data(){
        return{
            checkList:[
                {check: false, name: &apos;aa&apos;},
                {check: false, name: &apos;bb&apos;},
                {check: false, name: &apos;cc&apos;}
            ]
        }
    }

3、vue使用jxs语法

    new Vue({
        el: &apos;#demo&apos;,
        render (h) {
            return (    // 使用这种jsx语法
                &lt;AnchoredHeading level={1}&gt;
                    &lt;span&gt;Hello&lt;/span&gt; world!
                &lt;/AnchoredHeading&gt;
            )
        }
    })

    需要安装插件

    $ npm install babel-plugin-syntax-jsx babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props babel-preset-en   --save-dev

    .babelrc:
        {
            &quot;presets&quot;: [&quot;env&quot;],
            &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]
        }

    https://github.com/vuejs/babel-plugin-transform-vue-jsx


4、vue键盘事件不起作用

    @keyup.enter.native=&quot;login&quot;   如果不加.native是不起作用有
</code></pre><p>| 参考资料<br>|<br>| <a href="http://www.jianshu.com/p/95b2caf7e0da" target="_blank" rel="noopener">http://www.jianshu.com/p/95b2caf7e0da</a>              // vue-cli<br>| <a href="http://cn.vuejs.org/guide/" target="_blank" rel="noopener">http://cn.vuejs.org/guide/</a>                        // Vue中文官网<br>| <a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a>                        // github<br>| <a href="http://vuefe.cn/guide/installation.html" target="_blank" rel="noopener">http://vuefe.cn/guide/installation.html</a>            // 2.0<br>| <a href="http://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">http://router.vuejs.org/zh-cn/</a>                    // vue-router2.0<br>| <a href="https://github.com/vuejs" target="_blank" rel="noopener">https://github.com/vuejs</a>                             // Vue组件列表<br>| <a href="http://www.cnblogs.com/dh-dh/p/5606596.html" target="_blank" rel="noopener">http://www.cnblogs.com/dh-dh/p/5606596.html</a>        // binding原理，vue的数据<br>| <a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">https://github.com/vuejs/awesome-vue#libraries--plugins</a><br>| <a href="http://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">http://vuex.vuejs.org/zh-cn/</a>                         // Vuex 2.0文档<br>| <a href="https://github.com/vuejs/vuex/blob/1.0/docs/zh-cn/intro.md" target="_blank" rel="noopener">https://github.com/vuejs/vuex/blob/1.0/docs/zh-cn/intro.md</a><br>| <a href="http://www.cnblogs.com/keepfool/category/845804.html" target="_blank" rel="noopener">http://www.cnblogs.com/keepfool/category/845804.html</a><br>| <a href="http://www.jianshu.com/p/f8e21d87a572" target="_blank" rel="noopener">http://www.jianshu.com/p/f8e21d87a572</a><br>| <a href="https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91</a>      // Vue代码规范</p>

        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
