<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Tag: 设计模式 | 大排档</title>
    <meta name="author" content="siguang(厨子)" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP详解/">HTTP详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock数据/">mock数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端优化/">前端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端插件类/">前端插件类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端构建工具/">前端构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务端开发/">服务端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板引擎/">模板引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器内核/">浏览器内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经济学/">经济学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金融/">金融</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/atom.xml">订阅</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://siguang1983.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="siguang" style="box-shadow: 3px 3px 4px rgba(0,0,0, .2);">
                </a>
            </div>
            
            <div class="author-name">Siguang(厨子)</div>
            <div class="author-work">Front-end development</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">BeiJing, China</span>
            </div>
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-github"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-circle-more"></i></a>
                    <a class="thread-item" href="https://github.com/siguang1983" target="_blank"><i class="icon-twitter"></i></a>
                </div>
            </div>
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2016/12/19/javascript设计模式/">设计模式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/12/19/javascript设计模式/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-12-19T02:44:28.000Z" itemprop="datePublished">2016-12-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/设计模式/">设计模式</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>| 面向对象(类型判断、封装、多态、闭包、高阶函数)<br>| 单例模式 - 命名空间、只被实例化一次<br>| 工厂模式 - 加工在输厂的过程<br>| 外观模式 - 将复杂的接口统一，用于低层兼容<br>| 适配器模式 - 将一个接口转化为另一个接口<br>| 代理模式 - 一个对象不能直接访问另一个对象时，使用代理对象<br>| 装饰者模式 - 不改变原有对象的，并对其进行拓展<br>| 桥接模式 - 提取公用的方法，并通过桥接来进行连接<br>| 享元模式 -<br>| 观察者模式 -<br>| 状态模式 -<br>| 访问者模式 -<br>|<br>| 组合模式<br>| 策略模式 - 将一组算法封装起来，使其可以相互之间替换<br>| 中介者模式</p>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><pre><code>只能将带有duckSinging()方法的对象加入到 choir 数组中

&lt;script&gt;

    // 方法一
    var duck = {
        duckSinging: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 方法二
    var chicken = {
        chicken: function(){
            console.log(&apos;嘎嘎嘎&apos;);
        }
    }

    // 存储带有duckSinging()方法的对象
    var choir = [];

    var joinChoir = function(animal){
        if(animal &amp;&amp; typeof animal.duckSinging == &apos;function&apos;){        // 只能加入带有duckSinging()方法的对象
            choir.push(animal);
            console.log(&apos;恭喜入合唱团&apos;);
            console.log(&apos;合唱团已有成员数量&apos;, choir.length);
        }
    }

    joinChoir(duck);
    joinChoir(chicken);

&lt;/script&gt;
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>封装: 目的是将信息隐藏, 其它语言通过private、public、protected来处理访问权限

js没有这些关键字通过变量的作用域来实现封装

&lt;script&gt;
    var Book = funtcion(id, bookname, price){
        // 私有属性
        var name = 1;

        // 私有方法
        function checkId(){ }

        // 公有属性
        this.id = id;
        this.bookname = bookname;

        // 公有方法
        this.copy = function(){}

        // 特权方法
        this.getName() = function{ return name }
    }

    // 在原型 (prototype) 来添加属性和方法，有两种方式
    // 1、为原型一一添加属性和方法
    // 2、将一个对象赋给原型

    Book.prototype.display = function(){
        // 展示这本书
    }

    Book.prototype = {            // 这种方法会将prototype下的constructor被覆盖掉
        display: function(){
            // 展示这本书
        }
    }
&lt;/script&gt;

&lt;script&gt;
    // 闭包实现 1
    var Book = (function(){
        // 静态私有变量
        var bookNum = 0;

        // 静态私有方法
        function checkBook(name){}

        // 返回构造函数
        return function(newId, newName, newPrice){
            var name, price;
            function checkId(name){}
        }
    });

    Book.prototype = {
        isJSBook: false,
        display: function(){}
    }


    // 闭包实现 2
    var Book = (function(){

        // 私有变量
        var bookNum = 0;

        // 私有方法
        function checkBook(name){ }

        // 创建类
        function _book(newId, newName, newPrice){}
        _book.prototype = {}

        return _book
    })();
&lt;/script&gt;
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code>一、类式继承

    将父类的实例赋给子类的原形，类式继承的原因: 类的原型对象作用就是为类的原型添加公有方法，但不能直接访问这些属性和方法，必须通过原型prototype来访问

    &lt;script&gt;

        // 父类
        function Parent(){
            this.name = &apos;siguang&apos;
        }

        Parent.prototype.say = function(){ 
            console.log(this.name);
        }

        // 子类                
        function Childer(){}

        Childer.prototype = new Parent();   // 类式继承

        // 上一步执行后prototype的constructor会指向Parent，因为constructor指向还是在Paremt类上
        Childer.prototype.constructor = Childer;

        Childer.prototype.getSubValue = function(){
            console.log(&apos;getSubValue&apos;)
        }

        // 实例
        var oParent = new Parent();
        var oChilder = new Childer();

        oParent.say();                // siguang
        oChilder.say();                // siguang
        console.log(oChilder.name); // siguang
        oChilder.name = &apos;haha&apos;;
        oChilder.say();                // haha
        oChilder.getSubValue();        // getSubValue
    &lt;/script&gt;


二、构造函数式继承

    /*
    * 构造函数继承
    * 继承非prototype下的属性和方法
    */
    &lt;script&gt;
        // 父类继承
        function SuperClass(id){
            this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;];
            this.id = id;
            this.showId = function(){
                console.log(this.id);
            }
        }
        SuperClass.prototype.showBooks = function(){
            console.log(this.books);
        }

        // 声明子类
        function SubClass(id){
            // 继承父类所有公用属性和方法（this下的内容），但不继承prototype下的属性和方法
            SuperClass.call(this, id);
        }

        // SubClass.prototype.constructor = SubClass;

        var sub1 = new SubClass(10);
        var sub2 = new SubClass(20);

        sub1.books.push(&apos;设计模式&apos;);    
        console.log(sub1.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;设计模式&apos;]
        console.log(sub1.id);            // 10
        // sub1.showBooks();            // 报错，不
        sub1.showId();                    // 10

        console.log(sub2.books);        // [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]
        console.log(sub2.id);            // 20
    &lt;/script&gt;


总结: 类似继承与构造函数式继承的区别

    1、类似继承: ChildreClass.prototype = new ParentClass();

        继承父类的公用属性和方法（this.的内容）和 prototype下的属性和方法, 需要改变constructor的名字

    2、构造函数式继承: ParentClass.call(this);

        只能继承公用属性和就去，不能继承父类prototype下的属性和方法, 不需要改变constructor的名字


三、原型继承

    通过一个继承方法，创建一个过渡对象，将继承的父对象赋给过渡对象的原型，在返回过渡对象的实例

    &lt;script&gt;
        var Parent = function(){
            this.blod = 20;
            this.level = 1;
        }
        Parent.prototype.getBlod = function(){
            console.log(this.blod, this.level);
        }

        Object.create = Object.create || function(obj){
            var F = function(){};        // 声明一个过渡对象
            F.prototype = obj;            // 过渡对象的原型继承父对象
            return new F();                // 返回过渡对象的一个实例，该实例的原型继承了父对象
        }

        var oParent = new Parent();
        var oChilde = Object.create(oParent);

        oChilde.blod = 30;    // 如果clone不设置blod属性，会到prototype的指向中找，最终会在oParent中找到属性
        oChilde.getBlod();    // 30 1

        oParent.getBlod();    // 20 1
    &lt;/script&gt;


四、寄生式继承

    就是将原型继承在二次封装，并返回一个对象

    &lt;script&gt;

        // 寄生式继承
        // 声明基对象
        var book = {
            name: &apos;js book&apos;,
            alikeBook: [&apos;css book&apos;, &apos;html book&apos;]
        }

        function createBook(obj){
            // 通过原型继承方式创建新对象
            var o = new inhreitObject(obj);
            // 拓展新对象
            o.getName = function(){
                console.log(this.name);
            }

            // 返回拓展新对象
            return o;
        }

        function inhreitObject(obj){
            var F = function(){};
            F.prototype = obj;
            return new F();
        }


        var oCreateBook = createBook(book);
        oCreateBook.getName();            // &apos;js book&apos;

    &lt;/script&gt;


五、多继承

    只适用于对象，不适用构造函数，继承某一个类，和继承多个类

    &lt;script&gt;

        // 单继承 属性复制
        // 这种是浅复制，象jquery等框架实现了深度复制
        var extend = function(target, source){
            // 遍历源对象中的属性
            for(var property in source){
                // 将源对象中的属性复制到目标对象中
                target[property] = source[property];
            }

            // 返回目标对象
            return target;
        }


        var book = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }
        var anotherBook = {
            color: &apos;blue&apos;
        }

        extend(anotherBook, book);
        console.log(anotherBook.name);
        console.log(anotherBook.alike);
        console.log(book, anotherBook);



        // 多继承 多个对象继承 属性复制
        var mix = function(){
            var i = 1,                    // 从第二个参数起为被继承的对象
                len = arguments.length,    // 获取参数长度
                target = arguments[0],    // 第一个对象为目标对象
                arg;                    // 缓存参数对象

            // 遍历被继承的对象
            for(; i&lt;len; i++){
                // 缓存当前对象
                arg = arguments[i];
                // 遍历被继承对象中的属性
                for(var property in arg){
                    // 将被继承对象中的属性复制到目标对象中
                    target[property] = arg[property];
                }
            }
            return target;
        }


        var book1 = {
            name: &apos;javascript 设计模式&apos;,
            alike: [&apos;css&apos;, &apos;html&apos;, &apos;javascript&apos;],
            type: {
                name: &apos;计算机&apos;,
                money: 20
            }
        }

        var book2 = {
            tag: &apos;书&apos;
        }

        var book3 = {
            detail: &apos;产品优势&apos;
        }

        var newBook = mix(book1, book2, book3);

    &lt;/script&gt;
</code></pre><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><pre><code>多态: 就是调用同一对象，通过参数发出不同指令，执行不同的结果

&lt;script&gt;

    var googleMap = {
        show: function(){
            console.log(&apos;开始渲染谷歌地图&apos;);
        }
    }

    var baiduMap = {
        show: function(){
            console.log(&apos;开始渲染百度地图&apos;);
        }
    }

    // 渲染地图
    var renderMap =  function(map){

        // 如果对象下有show方法就执行
        if(map.show instanceof Function){        
            map.show();
        }

        // 另一个判断类型模式
        // if(map &amp;&amp; typeof map.show == &apos;function&apos;){
        //     map.show();
        // }
    }

    renderMap(googleMap);
    renderMap(baiduMap);

&lt;/script&gt;
</code></pre><h4 id="闭包、高阶函数"><a href="#闭包、高阶函数" class="headerlink" title="闭包、高阶函数"></a>闭包、高阶函数</h4><pre><code>高阶函数至少满足以下条件之一

一、函数可以作为参数被传递

    &lt;script&gt;
        var getUserInfo = function(userId, callback){
            $.ajax(&apos;http://xx.com/user?uid=&apos;+userId, function(data){
                if(typeof callback == &apos;function&apos;){
                    callback();
                }
            })
        }
    &lt;/script&gt;

二、函数可以作为返回值输出

    &lt;script&gt;

        // 函数作为返回值输出
        var isType = function(type){
            return function(obj){
                return Object.prototype.toString.call(obj) === &apos;[object &apos;+ type +&apos;]&apos;
            }
        } 

        var str = &quot;sdfsdf&quot;
        var isString = isType(&apos;String&apos;);
        console.log(isString(str));        // true
    &lt;/script&gt;
</code></pre><h4 id="全局变量的解决方法"><a href="#全局变量的解决方法" class="headerlink" title="全局变量的解决方法"></a>全局变量的解决方法</h4><pre><code>避免全局函数: 1、对象方法   2、函数对象    3、构造函数

&lt;script&gt;

    // 都是全局变量
    function checkName(){
        // 验证姓名
    }

    function checkEmail(){
        // 验证邮箱
    }

    function checkPassword(){
        // 验证密码
    }

    /*
    * 方法一 对象收编全局变量
    */
    var ChceckObject = {
        checkName: function(){
            // 验证姓名
        },
        checkEmail: function(){
            // 验证邮箱
        },
        checkPassword: function(){
            // 验证密码
        }
    }


    /*
    * 方法二 函数对象
    */
    var CheckObject = function(){
        return {
            checkName: function(){
                // 验证姓名
            },
            checkEmail: function(){
                // 验证邮箱
            },
            checkPassword: function(){
                // 验证密码
            }
        }
    }

    // 调用
    var oCheck = CheckObject();
    oCheck.checkName();


    /*
    * 方法三 构造函数写法
    */
    var CheckObject = function(){
        this.checkName = function(){
            // 验证姓名
        }
        this.checkEmail = function(){
            // 验证邮箱
        }
        this.checkPassword = function(){
            // 验证密码
        }
    }

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 创建型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><pre><code>单例模式: 又被称为单体模式，只允许实例化一次的对象类

全局变量 var a = {};    属于单例对象, 不属于单例模式

jquery就是一个很大的单例,js载入时被初始化一次

    (function(){
        var jquery = (function(){})();
        window.jQuery = window.$ = jQuery;
    })(window);


一、最简单的单例就是一个对象

    var app = {
        util: {},
        tool: {},
        ajax: {}
    }


二、私有变量的单例模式，减少全局变量方法

    1、使用命名空间

        var MyApp = {};

        MyApp.namespace = function(name){
            var parts = name.split(&apos;.&apos;);
            var current = MyApp;
            for(var i in parts){
                if(!current[parts[i]]){
                    current[parts[i]] = {}
                }
                current = current[parts[i]];
            }
        }

        MyApp.namespace(&apos;event&apos;);
        MyApp.namespace(&apos;dom.style&apos;);


    2、使用闭包封装私有变量

        var user = (function(){
            var _name = &apos;sven&apos;,
                _age = 30;

            return {
                getUserInfo: function(){
                    return _name +&apos;-&apos;+ _age;
                }
            }
        })();


三、惰性单例模式

    &lt;script&gt;

        // 惰性单例模式  只有在需要的时候才会创建
        var createLoginLayer = (function() {
            var div;
            return function() {
                if (!div) {
                    div = document.createElement(&apos;div&apos;);
                    div.className = &apos;dialog&apos;;
                    div.innerHTML = &apos;我是登录窗口&apos;;
                    div.style.display = &apos;none&apos;;
                    document.body.appendChild(div);
                }

                return div
            }
        })();

        var oLoginBtn = document.querySelector(&apos;#loginBtn&apos;);
        oLoginBtn.onclick = function(){
            var oLayer = createLoginLayer();
            oLayer.style.display = &apos;block&apos;;
        }

    &lt;/script&gt;
</code></pre><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><pre><code>工厂模式: 将不同的参数传入到工厂方法中，进行加工后，然后在返回新的产品

// 创建一个工厂函数，并将结果返回
function createPerson(name, age, sex){
    var createObject = {};

    // 加工
    createObject = {    
        name: name,
        age: age,
        sex: sex,
        showInfo: function(){
            console.log(&apos;姓名:&apos;+ this.name +&quot;  年龄:&quot; + this.age);
        }
    }

    // 返回成品
    return createObject;
}

var person = createPerson(&apos;siguang&apos;, 30, &apos;男&apos;);
person.showInfo();
</code></pre><h4 id="建造者模式-builder"><a href="#建造者模式-builder" class="headerlink" title="建造者模式 builder"></a>建造者模式 builder</h4><pre><code>将一个复杂对象的构建层与表示层相互分离
</code></pre><h4 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h4><pre><code>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性及方法

&lt;script&gt;

    // 定义一个基本的图片轮播对象
    var LoopImages = function(imgArr, container){
        this.imgArr = imgArr;
        this.container = container;
    }
    LoopImages.prototype = {
        // 创建
        createImage: function(){
            console.log(&apos;loopImage createImage function&apos;);
        },
        // 切换方法
        changeImage: function(){
            console.log(&apos;LoopImage changeImage function&apos;);
        }
    }

    // 定义一个上下滑动的效果
    var SliderLoopImage = function(imgArr, container){
        LoopImages.call(this, imgArr, container);
    }
    SliderLoopImage.prototype = new LoopImages();            // 就是类似继承，并将要改变的方法重写

    // 重写切换方法
    SliderLoopImage.prototype.changeImage = function(){
        console.log(&apos;SlideLoopImg changeImage function&apos;);
    }

    var oSlider = new SliderLoopImage([&apos;1.jpg&apos;, &apos;2.jpg&apos;], &apos;#box&apos;);
    oSlider.createImage();
    oSlider.changeImage();

&lt;/script&gt;
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 结构型模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><pre><code>外观模式: 为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易

// 外观模式实现
function addEvent(dom, type, fn){
    if(dom.addEventListener){
        dom.addEventListener(type, fn, false);
    }
    else if(dom.attachEvent){
        dom.attachEvent(&apos;on&apos;+type, fn);
    }
    else{
        dom[&apos;on&apos;+type] = fn;
    }
}

var myInpurt = document.querySelector(&apos;#myinput&apos;);

addEvent(myInpurt, &apos;click&apos;, function(){
    console.log(&apos;绑定第一个事件&apos;)
})
</code></pre><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><pre><code>适配器模式: 将一个类的接口转化成另外一个接口，使类之间的接口不兼容问题通过适配器得以解决

一、如果有jQuery框架，现在A框架与jQuery框架基本相同可以将两种框架适配

    // 定义A框架
    var A = jQuery || {};

    A.g = function(id){
        return document.getElementById(id);
    }

    A.on = function(id, type, fn){
        var dom = typeofi id === &apos;String&apos; ? A.g(id) : id;
        if(dom.addEventListener){
            dom.addEventListener(type, fn, false);
        }
        else if(dom.attachEvent){
            dom.attachEvent(&apos;on&apos;+type, fn);
        }
        else{
            dom[&apos;on&apos;+type] = fn;
        }
    }

二、jquery适配器

    window.A = A = jQuery;

三、参数适配

    function doSomeThing(obj){
        var adapter = {
            name: &apos;雨夜&apos;,
            titel: &apos;设计&apos;,
            age: 30,
            color: &apos;pink&apos;,
            size: 100,
            prize: 50
        }

        for(var key in adapter){
            adapter[key] = obj[key] || adapter[key];        // 处理如果obj没有的参数
        }
        return adapter;            // 也可以使用extend();
    }
</code></pre><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><pre><code>代理模式: 由于一个对象不能直引用另一个对象，所以需要一个代理对象来为两个对象之间起到中介作用

&lt;script&gt;
    var Flower = function(){};

    var xiaoming = {
        sendFlower: function(target){
            var flower = new Flower();
            target.receiveFlower(flower);
        }
    }

    // B代理小明去给A送花
    var B = {
        receiveFlower: function(flower){
            A.listenGoodModd(function(){        // 侦听A的心情
                A.receiveFlower(flower);
            })
        }
    }

    // A接收小明的花
    var A = {
        receiveFlower: function(flower){
            console.log(&apos;收到花&apos;+ flower);
        },
        listenGoodModd: function(fn){
            setTimeout(function(){
                fn()
            }, 10000);
        }
    }

    xiaoming.sendFlower(B);
&lt;/script&gt;
</code></pre><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><pre><code>装饿者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求

&lt;p&gt;姓名: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;username&quot; /&gt;&lt;span id=&quot;usernameError&quot;&gt;Error username xxxx&lt;/span&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;密码: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;password&quot; /&gt;&lt;span id=&quot;passwordError&quot;&gt;Error password xxxx&lt;/span&gt;&lt;/p&gt;

&lt;script&gt;

    /*
    * 装饰者模式: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求
    */

    // 点击文本框，显示提示信息，并保留原input上的事件
    var username = document.querySelector(&apos;#username&apos;);
    var password = document.querySelector(&apos;#password&apos;);

    // 基础需求，点击文本框后会加入文本内容
    username.onclick = function(){
        this.value = &apos;初始化username&apos;;
    }.bind(username);

    password.onclick = function(){
        this.value = &apos;初始化password&apos;;
    }.bind(password);


    // 新增的需求，点击后需要有提示消息，这里不破坏原有的功能
    // 装饰者方法
    var decorator = function(input, fn){
        var input = document.querySelector(input);

        // 判断事件是否已经绑定事件
        if(typeof input.onclick == &apos;function&apos;){
            // 缓存input本身的处理的事件
            var oldClickFn = input.onclick;

            // 为事件定义新的事件, 执行将新好的方法全执行
            input.onclick = function(){
                oldClickFn();
                fn();
            }
        }
        else{
            input.onclick = fn;
        }
    }

    // 调用
    decorator(&apos;#username&apos;, function(){
        document.querySelector(&quot;#usernameError&quot;).style.display = &apos;block&apos;;
    })
    decorator(&apos;#password&apos;, function(){
        document.querySelector(&quot;#passwordError&quot;).style.display = &apos;block&apos;;
    })

&lt;/script&gt;
</code></pre><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><pre><code>桥接模式: 将一个功能有共用的部分抽取出来，将实现与抽出来共用方法，通过桥接方法链接在一起，这就是桥接模式

&lt;div class=&quot;box&quot;&gt;
    &lt;span&gt;最新回答&lt;/span&gt;
    &lt;span&gt;热门回答&lt;/span&gt;
    &lt;span&gt;等待回答&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
    var box = document.querySelector(&apos;.box&apos;);
    var spans = box.getElementsByTagName(&apos;span&apos;);

    // 抽出的公用
    function changeColor(dom, color, bg){
        dom.style.color = color;
        dom.style.backgroundColor = bg;
    }

    // 桥接模式
    function bindSpan(){
        var i = 0;
        var len = spans.length;

        for(i; i&lt;len; i++){
            spans[i].onmouseover = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#ffbb96&apos;);
            }
            spans[i].onmouseout = function(){
                changeColor(this, &apos;#ad2102&apos;, &apos;#fff2e8&apos;);
            }                
        }
    }

    bindSpan();
&lt;/script&gt;
</code></pre><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><pre><code>享元模式: 运用共享技术有效地支持大量细粒的对象，避免对象间有相同内容造成多余的开销
</code></pre><p>/<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 行为型设计模式 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>观察者模式 - 又称发布订阅模式或消息机制
</code></pre><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><pre><code>状态模式 - 当一个对象内部状态发生改变时，会导致行为改变

状态模式是解决程序中臃肿的分支判断语句问题，将每个分支转化一种状态独立出来

&lt;script&gt;

    // 创建一个玛丽类
    var MarryState = function(){

        // 存储内部状态
        var _currentState = {};

        // 动作与状态方法映射
        var states = {
            jump: function(){
                console.log(&apos;jump&apos;);
            },
            move: function(){
                console.log(&apos;move&apos;);
            },
            shoot: function(){
                console.log(&apos;shoot&apos;);
            },
            squat: function(){
                console.log(&apos;squat&apos;);
            }
        };

        // 动作控制类
        var Action = {

            // 改变状态方法
            changeState: function(){
                var arg = arguments;
                _currentState = {};
                if(arg.length){
                    for(var i=0, len=arg.length; i&lt;len; i++){
                        _currentState[arg[i]] = true;
                    }
                }
                return this;
            },

            // 执行动作
            goes: function(){
                console.log(&apos;触发一次动作&apos;);
                for(var i in _currentState){
                    states[i] &amp;&amp; states[i]();       // 如果动作存在并执行
                }
                return this;
            }
        }

        return {
            change: Action.changeState,
            goes: Action.goes
        }
    }


    MarryState()
        .change(&apos;jump&apos;, &apos;shoot&apos;)
        .goes()

&lt;/script&gt;
</code></pre><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><pre><code>策略模式: 定义一系列算法，把他们封装起来，并使它们可以相互替换

策略模式由两部分组成:

    1、策略类，策略类封装了具体的算法，并负责具体的计算过程

    2、环境类，接受客户的请求，把请求委托给一个策略类

Example:

    &lt;script&gt;
        // 需求根据KPI等级返回奖金金额

        // 定义策略类
        var strategies = {
            &apos;S&apos;: function(salary){
                return salary * 4;
            },
            &apos;A&apos;: function(salary){
                return salary * 3;
            },
            &apos;B&apos;: function(salary){
                return salary * 2;
            }
        }

        // 环境类
        var calculateBonus = function(level, salary){
            return strategies[level] &amp;&amp; strategies[level](salary);
        }

        console.log(calculateBonus(&apos;B&apos;, 2000));        // 4000
        console.log(calculateBonus(&apos;S&apos;, 5000));        // 20000

    &lt;/script&gt;
</code></pre><h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><pre><code>职责链模式 - 解决请求的发送者与请求的接受者之间的耦合
</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><pre><code>命令模式 - 将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数
</code></pre><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><pre><code>迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部

&lt;script&gt;
    var isType = function(type){
        var callType =  Object.prototype.toString.call(type);

        switch(callType){
            case &apos;[object Object]&apos;:
                return &apos;object&apos;;
                break;

            case &apos;[object Array]&apos;:
                return &apos;array&apos;;
                break;

            default: 
                return false;
                break;
        }
    }

    var each = function(arr, callback){
        if(isType(arr) == &apos;object&apos;){
            for(var key in arr){
                callback.call(arr[key], key, arr[key]);
            }
        }
        else if (isType(arr) == &apos;array&apos;){
            for(var i=0; i&lt;arr.length; i++){
                callback.call(arr[i], i, arr[i]);
            }
        }
    }

    each([1, 2, 3], function(index, val){
        console.log(index, val);
    })

    each({name: &apos;siguang&apos;, age: 32, sex: &apos;男&apos;}, function(key, val){
        console.log(key, val);
    })
&lt;/script&gt;
</code></pre><h4 id="发布订阅模式模式"><a href="#发布订阅模式模式" class="headerlink" title="发布订阅模式模式"></a>发布订阅模式模式</h4><pre><code>发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变，所有依赖于它的对象都将得到通知.

js中事件模型来替代传统的发布订阅模式
</code></pre><p>| <a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html</a></p>

        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
